OSX env:

GL_VERSION          : 2.1 ATI-1.30.5
GL_VENDOR           : ATI Technologies Inc.
GL_RENDERER         : AMD Radeon HD 6750M OpenGL Engine
GL_SHADING_LANGUAGE_VERSION : 1.20
GL EXTENSIONS [135]:
 - GL_ARB_color_buffer_float
 - GL_ARB_depth_buffer_float
 - GL_ARB_depth_clamp
 - GL_ARB_depth_texture
 - GL_ARB_draw_buffers
 - GL_ARB_draw_elements_base_vertex
 - GL_ARB_draw_instanced
 - GL_ARB_fragment_program
 - GL_ARB_fragment_program_shadow
 - GL_ARB_fragment_shader
 - GL_ARB_framebuffer_object
 - GL_ARB_framebuffer_sRGB
 - GL_ARB_half_float_pixel
 - GL_ARB_half_float_vertex
 - GL_ARB_imaging
 - GL_ARB_instanced_arrays
 - GL_ARB_multisample
 - GL_ARB_multitexture
 - GL_ARB_occlusion_query
 - GL_ARB_pixel_buffer_object
 - GL_ARB_point_parameters
 - GL_ARB_point_sprite
 - GL_ARB_provoking_vertex
 - GL_ARB_seamless_cube_map
 - GL_ARB_shader_objects
 - GL_ARB_shader_texture_lod
 - GL_ARB_shading_language_100
 - GL_ARB_shadow
 - GL_ARB_shadow_ambient
 - GL_ARB_sync
 - GL_ARB_texture_border_clamp
 - GL_ARB_texture_compression
 - GL_ARB_texture_compression_rgtc
 - GL_ARB_texture_cube_map
 - GL_ARB_texture_env_add
 - GL_ARB_texture_env_combine
 - GL_ARB_texture_env_crossbar
 - GL_ARB_texture_env_dot3
 - GL_ARB_texture_float
 - GL_ARB_texture_mirrored_repeat
 - GL_ARB_texture_non_power_of_two
 - GL_ARB_texture_rectangle
 - GL_ARB_texture_rg
 - GL_ARB_transpose_matrix
 - GL_ARB_vertex_array_bgra
 - GL_ARB_vertex_blend
 - GL_ARB_vertex_buffer_object
 - GL_ARB_vertex_program
 - GL_ARB_vertex_shader
 - GL_ARB_window_pos
 - GL_EXT_abgr
 - GL_EXT_bgra
 - GL_EXT_bindable_uniform
 - GL_EXT_blend_color
 - GL_EXT_blend_equation_separate
 - GL_EXT_blend_func_separate
 - GL_EXT_blend_minmax
 - GL_EXT_blend_subtract
 - GL_EXT_clip_volume_hint
 - GL_EXT_debug_label
 - GL_EXT_debug_marker
 - GL_EXT_draw_buffers2
 - GL_EXT_draw_range_elements
 - GL_EXT_fog_coord
 - GL_EXT_framebuffer_blit
 - GL_EXT_framebuffer_multisample
 - GL_EXT_framebuffer_object
 - GL_EXT_framebuffer_sRGB
 - GL_EXT_geometry_shader4
 - GL_EXT_gpu_program_parameters
 - GL_EXT_gpu_shader4
 - GL_EXT_multi_draw_arrays
 - GL_EXT_packed_depth_stencil
 - GL_EXT_packed_float
 - GL_EXT_provoking_vertex
 - GL_EXT_rescale_normal
 - GL_EXT_secondary_color
 - GL_EXT_separate_specular_color
 - GL_EXT_shadow_funcs
 - GL_EXT_stencil_two_side
 - GL_EXT_stencil_wrap
 - GL_EXT_texture_array
 - GL_EXT_texture_compression_dxt1
 - GL_EXT_texture_compression_s3tc
 - GL_EXT_texture_env_add
 - GL_EXT_texture_filter_anisotropic
 - GL_EXT_texture_integer
 - GL_EXT_texture_lod_bias
 - GL_EXT_texture_mirror_clamp
 - GL_EXT_texture_rectangle
 - GL_EXT_texture_shared_exponent
 - GL_EXT_texture_sRGB
 - GL_EXT_texture_sRGB_decode
 - GL_EXT_timer_query
 - GL_EXT_transform_feedback
 - GL_EXT_vertex_array_bgra
 - GL_APPLE_aux_depth_stencil
 - GL_APPLE_client_storage
 - GL_APPLE_element_array
 - GL_APPLE_fence
 - GL_APPLE_float_pixels
 - GL_APPLE_flush_buffer_range
 - GL_APPLE_flush_render
 - GL_APPLE_object_purgeable
 - GL_APPLE_packed_pixels
 - GL_APPLE_pixel_buffer
 - GL_APPLE_rgb_422
 - GL_APPLE_row_bytes
 - GL_APPLE_specular_vector
 - GL_APPLE_texture_range
 - GL_APPLE_transform_hint
 - GL_APPLE_vertex_array_object
 - GL_APPLE_vertex_array_range
 - GL_APPLE_vertex_point_size
 - GL_APPLE_vertex_program_evaluators
 - GL_APPLE_ycbcr_422
 - GL_ATI_blend_equation_separate
 - GL_ATI_blend_weighted_minmax
 - GL_ATI_separate_stencil
 - GL_ATI_texture_compression_3dc
 - GL_ATI_texture_env_combine3
 - GL_ATI_texture_float
 - GL_ATI_texture_mirror_once
 - GL_IBM_rasterpos_clip
 - GL_NV_blend_square
 - GL_NV_conditional_render
 - GL_NV_depth_clamp
 - GL_NV_fog_distance
 - GL_NV_light_max_exponent
 - GL_NV_texgen_reflection
 - GL_NV_texture_barrier
 - GL_SGI_color_matrix
 - GL_SGIS_generate_mipmap
 - GL_SGIS_texture_edge_clamp
 - GL_SGIS_texture_lod

Windows (ANGLE) env:

GLFW version        : 3.0.4 Win32 EGL VisualC LoadLibrary(winmm)
GL_VERSION          : OpenGL ES 2.0 (ANGLE 2.1.a6d110e2811b)
GL_VENDOR           : Google Inc.
GL_RENDERER         : ANGLE (NVIDIA GeForce GTX 560  Direct3D11 vs_5_0 ps_5_0)
GL EXTENSIONS [36]:
ANGLE (* == DX11 only)
 - GL_OES_element_index_uint
 - GL_OES_packed_depth_stencil
 - GL_OES_get_program_binary
 - GL_OES_rgb8_rgba8
 - GL_EXT_texture_format_BGRA8888
 - GL_EXT_read_format_bgra
*- GL_NV_pixel_buffer_object
*- GL_OES_mapbuffer
*- GL_EXT_map_buffer_range
 - GL_OES_texture_half_float
 - GL_OES_texture_half_float_linear
 - GL_OES_texture_float
 - GL_OES_texture_float_linear
 - GL_EXT_texture_rg
 - GL_EXT_texture_compression_dxt1
 - GL_ANGLE_texture_compression_dxt3
 - GL_ANGLE_texture_compression_dxt5
*- GL_EXT_sRGB
 - GL_ANGLE_depth_texture
 - GL_EXT_texture_storage
 - GL_OES_texture_npot
*- GL_EXT_draw_buffers
 - GL_EXT_texture_filter_anisotropic
 - GL_EXT_occlusion_query_boolean
 - GL_NV_fence
 - GL_EXT_robustness
 - GL_EXT_blend_minmax
 - GL_ANGLE_framebuffer_blit
 - GL_ANGLE_framebuffer_multisample
 - GL_ANGLE_instanced_arrays
 - GL_ANGLE_pack_reverse_row_order
 - GL_OES_standard_derivatives
 - GL_EXT_shader_texture_lod
 - GL_EXT_frag_depth
 - GL_ANGLE_texture_usage
 - GL_ANGLE_translated_shader_source





   class mesh_t {
   public:
      class material_t {
      public:
         glm::vec4 const & diffuse_colour() const { return diffuse_colour_; }

      private:
         friend class mesh_t;
         material_t(aiScene const & scene, aiMesh const & mesh);
         glm::vec4 diffuse_colour_;
      };
      template <typename DataT>
      struct buffer_desc_t { DataT const * buffer; unsigned count; };

      std::string name() const;

      glm::mat4 const & default_transform() const { return default_transform_; }
      material_t const & material() const { return material_; }

      // TODO: expose a buffer_t or static_array_t?
      buffer_desc_t<float> vertices() const;
      buffer_desc_t<uint32_t> indices() const;
      buffer_desc_t<float> normals() const;

      buffer_desc_t<float> bone_indices() const;
      buffer_desc_t<float> bone_weights() const;

   private:
      friend class scene_t;
      friend class animation_instance_t;
      mesh_t(aiScene const & scene, aiMesh const & mesh, glm::mat4 const & default_transform);

      aiMesh const * ai_mesh_;
      glm::mat4 default_transform_;
      material_t material_;
      std::vector<uint32_t> indices_;
      std::vector<std::array<float, 4>> bone_indices_;
      std::vector<std::array<float, 4>> bone_weights_;
   };

   class animation_t {
   public:
      animation_t(animation_t const &) = delete;
      animation_t & operator=(animation_t const &) = delete;
      animation_t(animation_t && other);
      animation_t & operator=(animation_t && other);
      ~animation_t();

      std::string name() const;

   private:
      friend class scene_t;
      friend class animation_instance_t;
      animation_t(aiScene const & scene, aiAnimation const & animation);

      struct impl;
      std::unique_ptr<impl> impl_;
   };

   class animation_instance_t {
   public:
      struct mesh_instance_t {
      public:
         mesh_t mesh;
         std::vector<glm::mat4> const & bone_transforms;
         double last_update;
      };

      animation_instance_t(animation_t const & animation, double start_time = 0.);
      ~animation_instance_t();

      void advance_to(double time);

      std::vector<mesh_instance_t> const & mesh_instances() const;
   private:
      struct impl;
      std::unique_ptr<impl> impl_;
   };

   class scene_t {
   public:
      ~scene_t();

      static scene_t load_from_file(std::string const & filename);

      std::vector<std::string> animation_names() const;
      animation_t const & animation(std::string name) const;

      std::vector<mesh_t> const & meshes() const;

   private:
      scene_t(aiScene const * ai_scene);

      struct impl;
      std::unique_ptr<impl> impl_;
   };






   namespace {
      std::vector<uint32_t> get_mesh_indices(aiMesh const & m) {
         std::vector<uint32_t> indices;
         indices.reserve(m.mNumFaces * 3);
         for (auto fidx = 0U; fidx < m.mNumFaces; fidx++) {
            auto & f = m.mFaces[fidx];
            for (auto i = 0U; i < f.mNumIndices; i++) {
               indices.push_back(f.mIndices[i]);
            }
         }
         return indices;
      };

      // NOTE: material colour key macro is made up of:
      //const char* pKey,
      //unsigned int type,
      //unsigned int index,
      glm::vec4 get_mesh_material_colour(aiScene const & scene, aiMesh const & mesh, const char* ai_key, unsigned ai_type, unsigned ai_idx, glm::vec4 default_colour = glm::vec4{ 1.f, 0.f, 1.f, 1.f }) {
         aiColor4D result(default_colour.x, default_colour.y, default_colour.z, default_colour.w);
         aiGetMaterialColor(scene.mMaterials[mesh.mMaterialIndex], ai_key, ai_type, ai_idx, &result);
         return{ result.r, result.g, result.b, result.a };
      }
   }

   mesh_t::material_t::material_t(aiScene const & scene, aiMesh const & mesh)
      : diffuse_colour_(get_mesh_material_colour(scene, mesh, AI_MATKEY_COLOR_DIFFUSE)) {
   }

   mesh_t::mesh_t(aiScene const & scene, aiMesh const & mesh, glm::mat4 const & default_transform)
      : ai_mesh_{ &mesh }
      , default_transform_(default_transform)
      , material_{ scene, mesh }
      , indices_(get_mesh_indices(mesh))
      , bone_indices_(mesh.mNumVertices)
      , bone_weights_(mesh.mNumVertices)
   {
      std::vector<unsigned> vertex_bone_counts(mesh.mNumVertices);

      for (auto bone_idx = 0U; bone_idx < mesh.mNumBones; bone_idx++) {
         auto & bone = *mesh.mBones[bone_idx];
         for (auto weight_idx = 0U; weight_idx < bone.mNumWeights; weight_idx++) {
            auto & weight = bone.mWeights[weight_idx];
            auto array_idx = vertex_bone_counts[weight.mVertexId]++;
            assert(array_idx < 4 && "vertex has more than 4 bones");
            bone_indices_[weight.mVertexId][array_idx] = (float)bone_idx;
            bone_weights_[weight.mVertexId][array_idx] = weight.mWeight;
         }
      }
   }

   std::string mesh_t::name() const {
      return ai_mesh_->mName.C_Str();
   }

   mesh_t::buffer_desc_t<float> mesh_t::vertices() const {
      return{ reinterpret_cast<float*>(ai_mesh_->mVertices), ai_mesh_->mNumVertices * 3 };
   }

   mesh_t::buffer_desc_t<uint32_t> mesh_t::indices() const {
      return{ indices_.data(), indices_.size() };
   }

   mesh_t::buffer_desc_t<float> mesh_t::normals() const {
      assert(ai_mesh_->HasNormals());
      return{ reinterpret_cast<float*>(ai_mesh_->mNormals), ai_mesh_->mNumVertices * 3 };
   }

   mesh_t::buffer_desc_t<float> mesh_t::bone_indices() const {
      return{ bone_indices_.data()->data(), bone_indices_.size() * 4 };
   }

   mesh_t::buffer_desc_t<float> mesh_t::bone_weights() const {
      return{ bone_weights_.data()->data(), bone_weights_.size() * 4 };
   }
