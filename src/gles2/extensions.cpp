/**
 * This file was autogenerated by glgen (https://github.com/seshbot/glgen) on 2015-02-19
 * Command line: src/gen.py assets/gl.xml -p assets/gl-patch.xml -o build/lib/ --force --cpp --es2only
 */

#define GL_GLEXT_PROTOTYPES

#include <stdexcept>
#include <GLES2/gl2.h>
#include <GLES2/gl2ext.h>
#include <glpp/gles2/extensions.h>
#include "angle_extension_macros.h"

namespace gl {
    void active_shader_program_ext(uint_t pipeline, uint_t program) {
#if GL_EXT_separate_shader_objects    
      
      glActiveShaderProgramEXT(pipeline, program);
      
#else
      throw std::runtime_error("OpenGL command 'glActiveShaderProgramEXT' not available on this platform");
#endif
    }

    void alpha_func_qcom(alpha_function_t func, clampf_t ref) {
#if GL_QCOM_alpha_test    
      
      glAlphaFuncQCOM(static_cast<GLenum>(func), ref);
      
#else
      throw std::runtime_error("OpenGL command 'glAlphaFuncQCOM' not available on this platform");
#endif
    }

    void begin_conditional_render_nv(uint_t id, enum_t mode) {
#if GL_NV_conditional_render    
      
      glBeginConditionalRenderNV(id, mode);
      
#else
      throw std::runtime_error("OpenGL command 'glBeginConditionalRenderNV' not available on this platform");
#endif
    }

    void begin_perf_monitor_amd(uint_t monitor) {
#if GL_AMD_performance_monitor    
      
      glBeginPerfMonitorAMD(monitor);
      
#else
      throw std::runtime_error("OpenGL command 'glBeginPerfMonitorAMD' not available on this platform");
#endif
    }

    void begin_perf_query_intel(uint_t queryHandle) {
#if GL_INTEL_performance_query    
      
      glBeginPerfQueryINTEL(queryHandle);
      
#else
      throw std::runtime_error("OpenGL command 'glBeginPerfQueryINTEL' not available on this platform");
#endif
    }

    void begin_query_ext(framebuffer_target_t target, uint_t id) {
#if GL_EXT_occlusion_query_boolean || GL_EXT_disjoint_timer_query    
      
      glBeginQueryEXT(static_cast<GLenum>(target), id);
      
#else
      throw std::runtime_error("OpenGL command 'glBeginQueryEXT' not available on this platform");
#endif
    }

    void bind_program_pipeline_ext(uint_t pipeline) {
#if GL_EXT_separate_shader_objects    
      
      glBindProgramPipelineEXT(pipeline);
      
#else
      throw std::runtime_error("OpenGL command 'glBindProgramPipelineEXT' not available on this platform");
#endif
    }

    void bind_vertex_array_oes(uint_t array) {
#if GL_OES_vertex_array_object    
      
      glBindVertexArrayOES(array);
      
#else
      throw std::runtime_error("OpenGL command 'glBindVertexArrayOES' not available on this platform");
#endif
    }

    void blend_barrier_khr() {
#if GL_KHR_blend_equation_advanced    
      
      glBlendBarrierKHR();
      
#else
      throw std::runtime_error("OpenGL command 'glBlendBarrierKHR' not available on this platform");
#endif
    }

    void blend_barrier_nv() {
#if GL_NV_blend_equation_advanced    
      
      glBlendBarrierNV();
      
#else
      throw std::runtime_error("OpenGL command 'glBlendBarrierNV' not available on this platform");
#endif
    }

    void blend_equation_separatei_ext(uint_t buf, blend_equation_mode_ext_t modeRGB, blend_equation_mode_ext_t modeAlpha) {
#if GL_EXT_draw_buffers_indexed    
      
      glBlendEquationSeparateiEXT(buf, static_cast<GLenum>(modeRGB), static_cast<GLenum>(modeAlpha));
      
#else
      throw std::runtime_error("OpenGL command 'glBlendEquationSeparateiEXT' not available on this platform");
#endif
    }

    void blend_equation_separatei_oes(uint_t buf, blend_equation_mode_ext_t modeRGB, blend_equation_mode_ext_t modeAlpha) {
#if GL_OES_draw_buffers_indexed    
      
      glBlendEquationSeparateiOES(buf, static_cast<GLenum>(modeRGB), static_cast<GLenum>(modeAlpha));
      
#else
      throw std::runtime_error("OpenGL command 'glBlendEquationSeparateiOES' not available on this platform");
#endif
    }

    void blend_equationi_ext(uint_t buf, blend_equation_mode_t mode) {
#if GL_EXT_draw_buffers_indexed    
      
      glBlendEquationiEXT(buf, static_cast<GLenum>(mode));
      
#else
      throw std::runtime_error("OpenGL command 'glBlendEquationiEXT' not available on this platform");
#endif
    }

    void blend_equationi_oes(uint_t buf, blend_equation_mode_t mode) {
#if GL_OES_draw_buffers_indexed    
      
      glBlendEquationiOES(buf, static_cast<GLenum>(mode));
      
#else
      throw std::runtime_error("OpenGL command 'glBlendEquationiOES' not available on this platform");
#endif
    }

    void blend_func_separatei_ext(uint_t buf, enum_t srcRGB, enum_t dstRGB, enum_t srcAlpha, enum_t dstAlpha) {
#if GL_EXT_draw_buffers_indexed    
      
      glBlendFuncSeparateiEXT(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
      
#else
      throw std::runtime_error("OpenGL command 'glBlendFuncSeparateiEXT' not available on this platform");
#endif
    }

    void blend_func_separatei_oes(uint_t buf, enum_t srcRGB, enum_t dstRGB, enum_t srcAlpha, enum_t dstAlpha) {
#if GL_OES_draw_buffers_indexed    
      
      glBlendFuncSeparateiOES(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
      
#else
      throw std::runtime_error("OpenGL command 'glBlendFuncSeparateiOES' not available on this platform");
#endif
    }

    void blend_funci_ext(uint_t buf, enum_t src, enum_t dst) {
#if GL_EXT_draw_buffers_indexed    
      
      glBlendFunciEXT(buf, src, dst);
      
#else
      throw std::runtime_error("OpenGL command 'glBlendFunciEXT' not available on this platform");
#endif
    }

    void blend_funci_oes(uint_t buf, enum_t src, enum_t dst) {
#if GL_OES_draw_buffers_indexed    
      
      glBlendFunciOES(buf, src, dst);
      
#else
      throw std::runtime_error("OpenGL command 'glBlendFunciOES' not available on this platform");
#endif
    }

    void blend_parameteri_nv(get_pointerv_p_name_t pname, int_t value) {
#if GL_NV_blend_equation_advanced    
      
      glBlendParameteriNV(static_cast<GLenum>(pname), value);
      
#else
      throw std::runtime_error("OpenGL command 'glBlendParameteriNV' not available on this platform");
#endif
    }

    void blit_framebuffer_angle(int_t srcX0, int_t srcY0, int_t srcX1, int_t srcY1, int_t dstX0, int_t dstY0, int_t dstX1, int_t dstY1, bitmask<clear_buffer_flags_t> mask, enum_t filter) {
#if GL_ANGLE_framebuffer_blit    
      
      glBlitFramebufferANGLE(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, static_cast<GLbitfield>(mask.value), filter);
      
#else
      throw std::runtime_error("OpenGL command 'glBlitFramebufferANGLE' not available on this platform");
#endif
    }

    void blit_framebuffer_nv(int_t srcX0, int_t srcY0, int_t srcX1, int_t srcY1, int_t dstX0, int_t dstY0, int_t dstX1, int_t dstY1, bitmask<clear_buffer_flags_t> mask, enum_t filter) {
#if GL_NV_framebuffer_blit    
      
      glBlitFramebufferNV(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, static_cast<GLbitfield>(mask.value), filter);
      
#else
      throw std::runtime_error("OpenGL command 'glBlitFramebufferNV' not available on this platform");
#endif
    }

    enum_t client_wait_sync_apple(sync_t sync, bitfield_t flags, uint64_t timeout) {
#if GL_APPLE_sync    
      
      return glClientWaitSyncAPPLE(sync, flags, timeout);
      
#else
      throw std::runtime_error("OpenGL command 'glClientWaitSyncAPPLE' not available on this platform");
#endif
    }

    void color_maski_ext(uint_t index, boolean_t r, boolean_t g, boolean_t b, boolean_t a) {
#if GL_EXT_draw_buffers_indexed    
      
      glColorMaskiEXT(index, static_cast<GLboolean>(r), static_cast<GLboolean>(g), static_cast<GLboolean>(b), static_cast<GLboolean>(a));
      
#else
      throw std::runtime_error("OpenGL command 'glColorMaskiEXT' not available on this platform");
#endif
    }

    void color_maski_oes(uint_t index, boolean_t r, boolean_t g, boolean_t b, boolean_t a) {
#if GL_OES_draw_buffers_indexed    
      
      glColorMaskiOES(index, static_cast<GLboolean>(r), static_cast<GLboolean>(g), static_cast<GLboolean>(b), static_cast<GLboolean>(a));
      
#else
      throw std::runtime_error("OpenGL command 'glColorMaskiOES' not available on this platform");
#endif
    }

    void compressed_tex_image_3does(framebuffer_target_t target, int_t level, internal_format_t internalformat, sizei_t width, sizei_t height, sizei_t depth, int_t border, sizei_t imageSize, const void * data) {
#if GL_OES_texture_3D    
      
      glCompressedTexImage3DOES(static_cast<GLenum>(target), level, static_cast<GLenum>(internalformat), width, height, depth, border, imageSize, data);
      
#else
      throw std::runtime_error("OpenGL command 'glCompressedTexImage3DOES' not available on this platform");
#endif
    }

    void compressed_tex_sub_image_3does(framebuffer_target_t target, int_t level, int_t xoffset, int_t yoffset, int_t zoffset, sizei_t width, sizei_t height, sizei_t depth, pixel_format_t format, sizei_t imageSize, const void * data) {
#if GL_OES_texture_3D    
      
      glCompressedTexSubImage3DOES(static_cast<GLenum>(target), level, xoffset, yoffset, zoffset, width, height, depth, static_cast<GLenum>(format), imageSize, data);
      
#else
      throw std::runtime_error("OpenGL command 'glCompressedTexSubImage3DOES' not available on this platform");
#endif
    }

    void copy_buffer_sub_data_nv(enum_t readTarget, enum_t writeTarget, intptr_t readOffset, intptr_t writeOffset, sizeiptr_t size) {
#if GL_NV_copy_buffer    
      
      glCopyBufferSubDataNV(readTarget, writeTarget, readOffset, writeOffset, size);
      
#else
      throw std::runtime_error("OpenGL command 'glCopyBufferSubDataNV' not available on this platform");
#endif
    }

    void copy_image_sub_data_ext(uint_t srcName, enum_t srcTarget, int_t srcLevel, int_t srcX, int_t srcY, int_t srcZ, uint_t dstName, enum_t dstTarget, int_t dstLevel, int_t dstX, int_t dstY, int_t dstZ, sizei_t srcWidth, sizei_t srcHeight, sizei_t srcDepth) {
#if GL_EXT_copy_image    
      
      glCopyImageSubDataEXT(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
      
#else
      throw std::runtime_error("OpenGL command 'glCopyImageSubDataEXT' not available on this platform");
#endif
    }

    void copy_image_sub_data_oes(uint_t srcName, enum_t srcTarget, int_t srcLevel, int_t srcX, int_t srcY, int_t srcZ, uint_t dstName, enum_t dstTarget, int_t dstLevel, int_t dstX, int_t dstY, int_t dstZ, sizei_t srcWidth, sizei_t srcHeight, sizei_t srcDepth) {
#if GL_OES_copy_image    
      
      glCopyImageSubDataOES(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
      
#else
      throw std::runtime_error("OpenGL command 'glCopyImageSubDataOES' not available on this platform");
#endif
    }

    void copy_path_nv(uint_t resultPath, uint_t srcPath) {
#if GL_NV_path_rendering    
      
      glCopyPathNV(resultPath, srcPath);
      
#else
      throw std::runtime_error("OpenGL command 'glCopyPathNV' not available on this platform");
#endif
    }

    void copy_tex_sub_image_3does(framebuffer_target_t target, int_t level, int_t xoffset, int_t yoffset, int_t zoffset, int_t x, int_t y, sizei_t width, sizei_t height) {
#if GL_OES_texture_3D    
      
      glCopyTexSubImage3DOES(static_cast<GLenum>(target), level, xoffset, yoffset, zoffset, x, y, width, height);
      
#else
      throw std::runtime_error("OpenGL command 'glCopyTexSubImage3DOES' not available on this platform");
#endif
    }

    void copy_texture_levels_apple(uint_t destinationTexture, uint_t sourceTexture, int_t sourceBaseLevel, sizei_t sourceLevelCount) {
#if GL_APPLE_copy_texture_levels    
      
      glCopyTextureLevelsAPPLE(destinationTexture, sourceTexture, sourceBaseLevel, sourceLevelCount);
      
#else
      throw std::runtime_error("OpenGL command 'glCopyTextureLevelsAPPLE' not available on this platform");
#endif
    }

    void cover_fill_path_instanced_nv(sizei_t numPaths, enum_t pathNameType, const void * paths, uint_t pathBase, enum_t coverMode, enum_t transformType, const float_t * transformValues) {
#if GL_NV_path_rendering    
      
      glCoverFillPathInstancedNV(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues);
      
#else
      throw std::runtime_error("OpenGL command 'glCoverFillPathInstancedNV' not available on this platform");
#endif
    }

    void cover_fill_path_nv(uint_t path, enum_t coverMode) {
#if GL_NV_path_rendering    
      
      glCoverFillPathNV(path, coverMode);
      
#else
      throw std::runtime_error("OpenGL command 'glCoverFillPathNV' not available on this platform");
#endif
    }

    void cover_stroke_path_instanced_nv(sizei_t numPaths, enum_t pathNameType, const void * paths, uint_t pathBase, enum_t coverMode, enum_t transformType, const float_t * transformValues) {
#if GL_NV_path_rendering    
      
      glCoverStrokePathInstancedNV(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues);
      
#else
      throw std::runtime_error("OpenGL command 'glCoverStrokePathInstancedNV' not available on this platform");
#endif
    }

    void cover_stroke_path_nv(uint_t path, enum_t coverMode) {
#if GL_NV_path_rendering    
      
      glCoverStrokePathNV(path, coverMode);
      
#else
      throw std::runtime_error("OpenGL command 'glCoverStrokePathNV' not available on this platform");
#endif
    }

    void coverage_mask_nv(boolean_t mask) {
#if GL_NV_coverage_sample    
      
      glCoverageMaskNV(static_cast<GLboolean>(mask));
      
#else
      throw std::runtime_error("OpenGL command 'glCoverageMaskNV' not available on this platform");
#endif
    }

    void coverage_operation_nv(enum_t operation) {
#if GL_NV_coverage_sample    
      
      glCoverageOperationNV(operation);
      
#else
      throw std::runtime_error("OpenGL command 'glCoverageOperationNV' not available on this platform");
#endif
    }

    void create_perf_query_intel(uint_t queryId, uint_t * queryHandle) {
#if GL_INTEL_performance_query    
      
      glCreatePerfQueryINTEL(queryId, queryHandle);
      
#else
      throw std::runtime_error("OpenGL command 'glCreatePerfQueryINTEL' not available on this platform");
#endif
    }

    uint_t create_shader_programv_ext(draw_elements_type_t type, sizei_t count, const char_t ** strings) {
#if GL_EXT_separate_shader_objects    
      
      return glCreateShaderProgramvEXT(static_cast<GLenum>(type), count, strings);
      
#else
      throw std::runtime_error("OpenGL command 'glCreateShaderProgramvEXT' not available on this platform");
#endif
    }

    void debug_message_callback_khr(DEBUGPROCKHR_t callback, const void * userParam) {
#if GL_KHR_debug    
      
      glDebugMessageCallbackKHR(callback, userParam);
      
#else
      throw std::runtime_error("OpenGL command 'glDebugMessageCallbackKHR' not available on this platform");
#endif
    }

    void debug_message_control_khr(enum_t source, draw_elements_type_t type, enum_t severity, sizei_t count, const uint_t * ids, boolean_t enabled) {
#if GL_KHR_debug    
      
      glDebugMessageControlKHR(source, static_cast<GLenum>(type), severity, count, ids, static_cast<GLboolean>(enabled));
      
#else
      throw std::runtime_error("OpenGL command 'glDebugMessageControlKHR' not available on this platform");
#endif
    }

    void debug_message_insert_khr(enum_t source, draw_elements_type_t type, uint_t id, enum_t severity, sizei_t length, const char_t * buf) {
#if GL_KHR_debug    
      
      glDebugMessageInsertKHR(source, static_cast<GLenum>(type), id, severity, length, buf);
      
#else
      throw std::runtime_error("OpenGL command 'glDebugMessageInsertKHR' not available on this platform");
#endif
    }

    void delete_fences_nv(sizei_t n, const uint_t * fences) {
#if GL_NV_fence    
      
      glDeleteFencesNV(n, fences);
      
#else
      throw std::runtime_error("OpenGL command 'glDeleteFencesNV' not available on this platform");
#endif
    }

    void delete_paths_nv(uint_t path, sizei_t range) {
#if GL_NV_path_rendering    
      
      glDeletePathsNV(path, range);
      
#else
      throw std::runtime_error("OpenGL command 'glDeletePathsNV' not available on this platform");
#endif
    }

    void delete_perf_monitors_amd(sizei_t n, uint_t * monitors) {
#if GL_AMD_performance_monitor    
      
      glDeletePerfMonitorsAMD(n, monitors);
      
#else
      throw std::runtime_error("OpenGL command 'glDeletePerfMonitorsAMD' not available on this platform");
#endif
    }

    void delete_perf_query_intel(uint_t queryHandle) {
#if GL_INTEL_performance_query    
      
      glDeletePerfQueryINTEL(queryHandle);
      
#else
      throw std::runtime_error("OpenGL command 'glDeletePerfQueryINTEL' not available on this platform");
#endif
    }

    void delete_program_pipelines_ext(sizei_t n, const uint_t * pipelines) {
#if GL_EXT_separate_shader_objects    
      
      glDeleteProgramPipelinesEXT(n, pipelines);
      
#else
      throw std::runtime_error("OpenGL command 'glDeleteProgramPipelinesEXT' not available on this platform");
#endif
    }

    void delete_queries_ext(sizei_t n, const uint_t * ids) {
#if GL_EXT_occlusion_query_boolean || GL_EXT_disjoint_timer_query    
      
      glDeleteQueriesEXT(n, ids);
      
#else
      throw std::runtime_error("OpenGL command 'glDeleteQueriesEXT' not available on this platform");
#endif
    }

    void delete_sync_apple(sync_t sync) {
#if GL_APPLE_sync    
      
      glDeleteSyncAPPLE(sync);
      
#else
      throw std::runtime_error("OpenGL command 'glDeleteSyncAPPLE' not available on this platform");
#endif
    }

    void delete_vertex_arrays_oes(sizei_t n, const uint_t * arrays) {
#if GL_OES_vertex_array_object    
      
      glDeleteVertexArraysOES(n, arrays);
      
#else
      throw std::runtime_error("OpenGL command 'glDeleteVertexArraysOES' not available on this platform");
#endif
    }

    void depth_range_arrayfv_nv(uint_t first, sizei_t count, const float_t * v) {
#if GL_NV_viewport_array    
      
      glDepthRangeArrayfvNV(first, count, v);
      
#else
      throw std::runtime_error("OpenGL command 'glDepthRangeArrayfvNV' not available on this platform");
#endif
    }

    void depth_range_indexedf_nv(uint_t index, float_t n, float_t f) {
#if GL_NV_viewport_array    
      
      glDepthRangeIndexedfNV(index, n, f);
      
#else
      throw std::runtime_error("OpenGL command 'glDepthRangeIndexedfNV' not available on this platform");
#endif
    }

    void disable_driver_control_qcom(uint_t driverControl) {
#if GL_QCOM_driver_control    
      
      glDisableDriverControlQCOM(driverControl);
      
#else
      throw std::runtime_error("OpenGL command 'glDisableDriverControlQCOM' not available on this platform");
#endif
    }

    void disablei_ext(framebuffer_target_t target, uint_t index) {
#if GL_EXT_draw_buffers_indexed    
      
      glDisableiEXT(static_cast<GLenum>(target), index);
      
#else
      throw std::runtime_error("OpenGL command 'glDisableiEXT' not available on this platform");
#endif
    }

    void disablei_nv(framebuffer_target_t target, uint_t index) {
#if GL_NV_viewport_array    
      
      glDisableiNV(static_cast<GLenum>(target), index);
      
#else
      throw std::runtime_error("OpenGL command 'glDisableiNV' not available on this platform");
#endif
    }

    void disablei_oes(framebuffer_target_t target, uint_t index) {
#if GL_OES_draw_buffers_indexed    
      
      glDisableiOES(static_cast<GLenum>(target), index);
      
#else
      throw std::runtime_error("OpenGL command 'glDisableiOES' not available on this platform");
#endif
    }

    void discard_framebuffer_ext(framebuffer_target_t target, sizei_t numAttachments, const enum_t * attachments) {
#if GL_EXT_discard_framebuffer    
      
      glDiscardFramebufferEXT(static_cast<GLenum>(target), numAttachments, attachments);
      
#else
      throw std::runtime_error("OpenGL command 'glDiscardFramebufferEXT' not available on this platform");
#endif
    }

    void draw_arrays_instanced_angle(primitive_type_t mode, int_t first, sizei_t count, sizei_t primcount) {
#if GL_ANGLE_instanced_arrays    
      
      glDrawArraysInstancedANGLE(static_cast<GLenum>(mode), first, count, primcount);
      
#else
      throw std::runtime_error("OpenGL command 'glDrawArraysInstancedANGLE' not available on this platform");
#endif
    }

    void draw_arrays_instanced_base_instance_ext(primitive_type_t mode, int_t first, sizei_t count, sizei_t instancecount, uint_t baseinstance) {
#if GL_EXT_base_instance    
      
      glDrawArraysInstancedBaseInstanceEXT(static_cast<GLenum>(mode), first, count, instancecount, baseinstance);
      
#else
      throw std::runtime_error("OpenGL command 'glDrawArraysInstancedBaseInstanceEXT' not available on this platform");
#endif
    }

    void draw_arrays_instanced_ext(primitive_type_t mode, int_t start, sizei_t count, sizei_t primcount) {
#if GL_EXT_instanced_arrays || GL_EXT_draw_instanced    
      
      glDrawArraysInstancedEXT(static_cast<GLenum>(mode), start, count, primcount);
      
#else
      throw std::runtime_error("OpenGL command 'glDrawArraysInstancedEXT' not available on this platform");
#endif
    }

    void draw_arrays_instanced_nv(primitive_type_t mode, int_t first, sizei_t count, sizei_t primcount) {
#if GL_NV_draw_instanced    
      
      glDrawArraysInstancedNV(static_cast<GLenum>(mode), first, count, primcount);
      
#else
      throw std::runtime_error("OpenGL command 'glDrawArraysInstancedNV' not available on this platform");
#endif
    }

    void draw_buffers_ext(sizei_t n, const enum_t * bufs) {
#if GL_EXT_draw_buffers    
      
      glDrawBuffersEXT(n, bufs);
      
#else
      throw std::runtime_error("OpenGL command 'glDrawBuffersEXT' not available on this platform");
#endif
    }

    void draw_buffers_indexed_ext(int_t n, const enum_t * location, const int_t * indices) {
#if GL_EXT_multiview_draw_buffers    
      
      glDrawBuffersIndexedEXT(n, location, indices);
      
#else
      throw std::runtime_error("OpenGL command 'glDrawBuffersIndexedEXT' not available on this platform");
#endif
    }

    void draw_buffers_nv(sizei_t n, const enum_t * bufs) {
#if GL_NV_draw_buffers    
      
      glDrawBuffersNV(n, bufs);
      
#else
      throw std::runtime_error("OpenGL command 'glDrawBuffersNV' not available on this platform");
#endif
    }

    void draw_elements_base_vertex_ext(primitive_type_t mode, sizei_t count, draw_elements_type_t type, const void * indices, int_t basevertex) {
#if GL_EXT_draw_elements_base_vertex    
      
      glDrawElementsBaseVertexEXT(static_cast<GLenum>(mode), count, static_cast<GLenum>(type), indices, basevertex);
      
#else
      throw std::runtime_error("OpenGL command 'glDrawElementsBaseVertexEXT' not available on this platform");
#endif
    }

    void draw_elements_base_vertex_oes(primitive_type_t mode, sizei_t count, draw_elements_type_t type, const void * indices, int_t basevertex) {
#if GL_OES_draw_elements_base_vertex    
      
      glDrawElementsBaseVertexOES(static_cast<GLenum>(mode), count, static_cast<GLenum>(type), indices, basevertex);
      
#else
      throw std::runtime_error("OpenGL command 'glDrawElementsBaseVertexOES' not available on this platform");
#endif
    }

    void draw_elements_instanced_angle(primitive_type_t mode, sizei_t count, draw_elements_type_t type, const void * indices, sizei_t primcount) {
#if GL_ANGLE_instanced_arrays    
      
      glDrawElementsInstancedANGLE(static_cast<GLenum>(mode), count, static_cast<GLenum>(type), indices, primcount);
      
#else
      throw std::runtime_error("OpenGL command 'glDrawElementsInstancedANGLE' not available on this platform");
#endif
    }

    void draw_elements_instanced_base_instance_ext(primitive_type_t mode, sizei_t count, draw_elements_type_t type, const void * indices, sizei_t instancecount, uint_t baseinstance) {
#if GL_EXT_base_instance    
      
      glDrawElementsInstancedBaseInstanceEXT(static_cast<GLenum>(mode), count, static_cast<GLenum>(type), indices, instancecount, baseinstance);
      
#else
      throw std::runtime_error("OpenGL command 'glDrawElementsInstancedBaseInstanceEXT' not available on this platform");
#endif
    }

    void draw_elements_instanced_base_vertex_base_instance_ext(primitive_type_t mode, sizei_t count, draw_elements_type_t type, const void * indices, sizei_t instancecount, int_t basevertex, uint_t baseinstance) {
#if GL_EXT_base_instance    
      
      glDrawElementsInstancedBaseVertexBaseInstanceEXT(static_cast<GLenum>(mode), count, static_cast<GLenum>(type), indices, instancecount, basevertex, baseinstance);
      
#else
      throw std::runtime_error("OpenGL command 'glDrawElementsInstancedBaseVertexBaseInstanceEXT' not available on this platform");
#endif
    }

    void draw_elements_instanced_base_vertex_ext(primitive_type_t mode, sizei_t count, draw_elements_type_t type, const void * indices, sizei_t instancecount, int_t basevertex) {
#if GL_EXT_draw_elements_base_vertex    
      
      glDrawElementsInstancedBaseVertexEXT(static_cast<GLenum>(mode), count, static_cast<GLenum>(type), indices, instancecount, basevertex);
      
#else
      throw std::runtime_error("OpenGL command 'glDrawElementsInstancedBaseVertexEXT' not available on this platform");
#endif
    }

    void draw_elements_instanced_base_vertex_oes(primitive_type_t mode, sizei_t count, draw_elements_type_t type, const void * indices, sizei_t instancecount, int_t basevertex) {
#if GL_OES_draw_elements_base_vertex    
      
      glDrawElementsInstancedBaseVertexOES(static_cast<GLenum>(mode), count, static_cast<GLenum>(type), indices, instancecount, basevertex);
      
#else
      throw std::runtime_error("OpenGL command 'glDrawElementsInstancedBaseVertexOES' not available on this platform");
#endif
    }

    void draw_elements_instanced_ext(primitive_type_t mode, sizei_t count, draw_elements_type_t type, const void * indices, sizei_t primcount) {
#if GL_EXT_instanced_arrays || GL_EXT_draw_instanced    
      
      glDrawElementsInstancedEXT(static_cast<GLenum>(mode), count, static_cast<GLenum>(type), indices, primcount);
      
#else
      throw std::runtime_error("OpenGL command 'glDrawElementsInstancedEXT' not available on this platform");
#endif
    }

    void draw_elements_instanced_nv(primitive_type_t mode, sizei_t count, draw_elements_type_t type, const void * indices, sizei_t primcount) {
#if GL_NV_draw_instanced    
      
      glDrawElementsInstancedNV(static_cast<GLenum>(mode), count, static_cast<GLenum>(type), indices, primcount);
      
#else
      throw std::runtime_error("OpenGL command 'glDrawElementsInstancedNV' not available on this platform");
#endif
    }

    void draw_range_elements_base_vertex_ext(primitive_type_t mode, uint_t start, uint_t end, sizei_t count, draw_elements_type_t type, const void * indices, int_t basevertex) {
#if GL_EXT_draw_elements_base_vertex    
      
      glDrawRangeElementsBaseVertexEXT(static_cast<GLenum>(mode), start, end, count, static_cast<GLenum>(type), indices, basevertex);
      
#else
      throw std::runtime_error("OpenGL command 'glDrawRangeElementsBaseVertexEXT' not available on this platform");
#endif
    }

    void draw_range_elements_base_vertex_oes(primitive_type_t mode, uint_t start, uint_t end, sizei_t count, draw_elements_type_t type, const void * indices, int_t basevertex) {
#if GL_OES_draw_elements_base_vertex    
      
      glDrawRangeElementsBaseVertexOES(static_cast<GLenum>(mode), start, end, count, static_cast<GLenum>(type), indices, basevertex);
      
#else
      throw std::runtime_error("OpenGL command 'glDrawRangeElementsBaseVertexOES' not available on this platform");
#endif
    }

    void egl_image_target_renderbuffer_storage_oes(framebuffer_target_t target, eglImageOES_t image) {
#if GL_OES_EGL_image    
      
      glEGLImageTargetRenderbufferStorageOES(static_cast<GLenum>(target), image);
      
#else
      throw std::runtime_error("OpenGL command 'glEGLImageTargetRenderbufferStorageOES' not available on this platform");
#endif
    }

    void egl_image_target_texture_2does(framebuffer_target_t target, eglImageOES_t image) {
#if GL_OES_EGL_image    
      
      glEGLImageTargetTexture2DOES(static_cast<GLenum>(target), image);
      
#else
      throw std::runtime_error("OpenGL command 'glEGLImageTargetTexture2DOES' not available on this platform");
#endif
    }

    void enable_driver_control_qcom(uint_t driverControl) {
#if GL_QCOM_driver_control    
      
      glEnableDriverControlQCOM(driverControl);
      
#else
      throw std::runtime_error("OpenGL command 'glEnableDriverControlQCOM' not available on this platform");
#endif
    }

    void enablei_ext(framebuffer_target_t target, uint_t index) {
#if GL_EXT_draw_buffers_indexed    
      
      glEnableiEXT(static_cast<GLenum>(target), index);
      
#else
      throw std::runtime_error("OpenGL command 'glEnableiEXT' not available on this platform");
#endif
    }

    void enablei_nv(framebuffer_target_t target, uint_t index) {
#if GL_NV_viewport_array    
      
      glEnableiNV(static_cast<GLenum>(target), index);
      
#else
      throw std::runtime_error("OpenGL command 'glEnableiNV' not available on this platform");
#endif
    }

    void enablei_oes(framebuffer_target_t target, uint_t index) {
#if GL_OES_draw_buffers_indexed    
      
      glEnableiOES(static_cast<GLenum>(target), index);
      
#else
      throw std::runtime_error("OpenGL command 'glEnableiOES' not available on this platform");
#endif
    }

    void end_conditional_render_nv() {
#if GL_NV_conditional_render    
      
      glEndConditionalRenderNV();
      
#else
      throw std::runtime_error("OpenGL command 'glEndConditionalRenderNV' not available on this platform");
#endif
    }

    void end_perf_monitor_amd(uint_t monitor) {
#if GL_AMD_performance_monitor    
      
      glEndPerfMonitorAMD(monitor);
      
#else
      throw std::runtime_error("OpenGL command 'glEndPerfMonitorAMD' not available on this platform");
#endif
    }

    void end_perf_query_intel(uint_t queryHandle) {
#if GL_INTEL_performance_query    
      
      glEndPerfQueryINTEL(queryHandle);
      
#else
      throw std::runtime_error("OpenGL command 'glEndPerfQueryINTEL' not available on this platform");
#endif
    }

    void end_query_ext(framebuffer_target_t target) {
#if GL_EXT_occlusion_query_boolean || GL_EXT_disjoint_timer_query    
      
      glEndQueryEXT(static_cast<GLenum>(target));
      
#else
      throw std::runtime_error("OpenGL command 'glEndQueryEXT' not available on this platform");
#endif
    }

    void end_tiling_qcom(bitfield_t preserveMask) {
#if GL_QCOM_tiled_rendering    
      
      glEndTilingQCOM(preserveMask);
      
#else
      throw std::runtime_error("OpenGL command 'glEndTilingQCOM' not available on this platform");
#endif
    }

    void ext_get_buffer_pointerv_qcom(framebuffer_target_t target, void ** params) {
#if GL_QCOM_extended_get    
      
      glExtGetBufferPointervQCOM(static_cast<GLenum>(target), params);
      
#else
      throw std::runtime_error("OpenGL command 'glExtGetBufferPointervQCOM' not available on this platform");
#endif
    }

    void ext_get_buffers_qcom(uint_t * buffers, int_t maxBuffers, int_t * numBuffers) {
#if GL_QCOM_extended_get    
      
      glExtGetBuffersQCOM(buffers, maxBuffers, numBuffers);
      
#else
      throw std::runtime_error("OpenGL command 'glExtGetBuffersQCOM' not available on this platform");
#endif
    }

    void ext_get_framebuffers_qcom(uint_t * framebuffers, int_t maxFramebuffers, int_t * numFramebuffers) {
#if GL_QCOM_extended_get    
      
      glExtGetFramebuffersQCOM(framebuffers, maxFramebuffers, numFramebuffers);
      
#else
      throw std::runtime_error("OpenGL command 'glExtGetFramebuffersQCOM' not available on this platform");
#endif
    }

    void ext_get_program_binary_source_qcom(uint_t program, enum_t shadertype, char_t * source, int_t * length) {
#if GL_QCOM_extended_get2    
      
      glExtGetProgramBinarySourceQCOM(program, shadertype, source, length);
      
#else
      throw std::runtime_error("OpenGL command 'glExtGetProgramBinarySourceQCOM' not available on this platform");
#endif
    }

    void ext_get_programs_qcom(uint_t * programs, int_t maxPrograms, int_t * numPrograms) {
#if GL_QCOM_extended_get2    
      
      glExtGetProgramsQCOM(programs, maxPrograms, numPrograms);
      
#else
      throw std::runtime_error("OpenGL command 'glExtGetProgramsQCOM' not available on this platform");
#endif
    }

    void ext_get_renderbuffers_qcom(uint_t * renderbuffers, int_t maxRenderbuffers, int_t * numRenderbuffers) {
#if GL_QCOM_extended_get    
      
      glExtGetRenderbuffersQCOM(renderbuffers, maxRenderbuffers, numRenderbuffers);
      
#else
      throw std::runtime_error("OpenGL command 'glExtGetRenderbuffersQCOM' not available on this platform");
#endif
    }

    void ext_get_shaders_qcom(uint_t * shaders, int_t maxShaders, int_t * numShaders) {
#if GL_QCOM_extended_get2    
      
      glExtGetShadersQCOM(shaders, maxShaders, numShaders);
      
#else
      throw std::runtime_error("OpenGL command 'glExtGetShadersQCOM' not available on this platform");
#endif
    }

    void ext_get_tex_level_parameteriv_qcom(uint_t texture, enum_t face, int_t level, get_pointerv_p_name_t pname, int_t * params) {
#if GL_QCOM_extended_get    
      
      glExtGetTexLevelParameterivQCOM(texture, face, level, static_cast<GLenum>(pname), params);
      
#else
      throw std::runtime_error("OpenGL command 'glExtGetTexLevelParameterivQCOM' not available on this platform");
#endif
    }

    void ext_get_tex_sub_image_qcom(framebuffer_target_t target, int_t level, int_t xoffset, int_t yoffset, int_t zoffset, sizei_t width, sizei_t height, sizei_t depth, pixel_format_t format, draw_elements_type_t type, void * texels) {
#if GL_QCOM_extended_get    
      
      glExtGetTexSubImageQCOM(static_cast<GLenum>(target), level, xoffset, yoffset, zoffset, width, height, depth, static_cast<GLenum>(format), static_cast<GLenum>(type), texels);
      
#else
      throw std::runtime_error("OpenGL command 'glExtGetTexSubImageQCOM' not available on this platform");
#endif
    }

    void ext_get_textures_qcom(uint_t * textures, int_t maxTextures, int_t * numTextures) {
#if GL_QCOM_extended_get    
      
      glExtGetTexturesQCOM(textures, maxTextures, numTextures);
      
#else
      throw std::runtime_error("OpenGL command 'glExtGetTexturesQCOM' not available on this platform");
#endif
    }

    boolean_t ext_is_program_binary_qcom(uint_t program) {
#if GL_QCOM_extended_get2    
      
      return static_cast<boolean_t>(glExtIsProgramBinaryQCOM(program));
      
#else
      throw std::runtime_error("OpenGL command 'glExtIsProgramBinaryQCOM' not available on this platform");
#endif
    }

    void ext_tex_object_state_overridei_qcom(framebuffer_target_t target, get_pointerv_p_name_t pname, int_t param) {
#if GL_QCOM_extended_get    
      
      glExtTexObjectStateOverrideiQCOM(static_cast<GLenum>(target), static_cast<GLenum>(pname), param);
      
#else
      throw std::runtime_error("OpenGL command 'glExtTexObjectStateOverrideiQCOM' not available on this platform");
#endif
    }

    sync_t fence_sync_apple(enum_t condition, bitfield_t flags) {
#if GL_APPLE_sync    
      
      return glFenceSyncAPPLE(condition, flags);
      
#else
      throw std::runtime_error("OpenGL command 'glFenceSyncAPPLE' not available on this platform");
#endif
    }

    void finish_fence_nv(uint_t fence) {
#if GL_NV_fence    
      
      glFinishFenceNV(fence);
      
#else
      throw std::runtime_error("OpenGL command 'glFinishFenceNV' not available on this platform");
#endif
    }

    void flush_mapped_buffer_range_ext(framebuffer_target_t target, intptr_t offset, sizeiptr_t length) {
#if GL_EXT_map_buffer_range    
      
      glFlushMappedBufferRangeEXT(static_cast<GLenum>(target), offset, length);
      
#else
      throw std::runtime_error("OpenGL command 'glFlushMappedBufferRangeEXT' not available on this platform");
#endif
    }

    void framebuffer_texture_2d_multisample_ext(framebuffer_target_t target, framebuffer_attachment_t attachment, enum_t textarget, uint_t texture, int_t level, sizei_t samples) {
#if GL_EXT_multisampled_render_to_texture    
      
      glFramebufferTexture2DMultisampleEXT(static_cast<GLenum>(target), static_cast<GLenum>(attachment), textarget, texture, level, samples);
      
#else
      throw std::runtime_error("OpenGL command 'glFramebufferTexture2DMultisampleEXT' not available on this platform");
#endif
    }

    void framebuffer_texture_2d_multisample_img(framebuffer_target_t target, framebuffer_attachment_t attachment, enum_t textarget, uint_t texture, int_t level, sizei_t samples) {
#if GL_IMG_multisampled_render_to_texture    
      
      glFramebufferTexture2DMultisampleIMG(static_cast<GLenum>(target), static_cast<GLenum>(attachment), textarget, texture, level, samples);
      
#else
      throw std::runtime_error("OpenGL command 'glFramebufferTexture2DMultisampleIMG' not available on this platform");
#endif
    }

    void framebuffer_texture_3does(framebuffer_target_t target, framebuffer_attachment_t attachment, enum_t textarget, uint_t texture, int_t level, int_t zoffset) {
#if GL_OES_texture_3D    
      
      glFramebufferTexture3DOES(static_cast<GLenum>(target), static_cast<GLenum>(attachment), textarget, texture, level, zoffset);
      
#else
      throw std::runtime_error("OpenGL command 'glFramebufferTexture3DOES' not available on this platform");
#endif
    }

    void framebuffer_texture_ext(framebuffer_target_t target, framebuffer_attachment_t attachment, uint_t texture, int_t level) {
#if GL_EXT_geometry_shader    
      
      glFramebufferTextureEXT(static_cast<GLenum>(target), static_cast<GLenum>(attachment), texture, level);
      
#else
      throw std::runtime_error("OpenGL command 'glFramebufferTextureEXT' not available on this platform");
#endif
    }

    void framebuffer_texture_oes(framebuffer_target_t target, framebuffer_attachment_t attachment, uint_t texture, int_t level) {
#if GL_OES_geometry_shader    
      
      glFramebufferTextureOES(static_cast<GLenum>(target), static_cast<GLenum>(attachment), texture, level);
      
#else
      throw std::runtime_error("OpenGL command 'glFramebufferTextureOES' not available on this platform");
#endif
    }

    void gen_fences_nv(sizei_t n, uint_t * fences) {
#if GL_NV_fence    
      
      glGenFencesNV(n, fences);
      
#else
      throw std::runtime_error("OpenGL command 'glGenFencesNV' not available on this platform");
#endif
    }

    uint_t gen_paths_nv(sizei_t range) {
#if GL_NV_path_rendering    
      
      return glGenPathsNV(range);
      
#else
      throw std::runtime_error("OpenGL command 'glGenPathsNV' not available on this platform");
#endif
    }

    void gen_perf_monitors_amd(sizei_t n, uint_t * monitors) {
#if GL_AMD_performance_monitor    
      
      glGenPerfMonitorsAMD(n, monitors);
      
#else
      throw std::runtime_error("OpenGL command 'glGenPerfMonitorsAMD' not available on this platform");
#endif
    }

    void gen_program_pipelines_ext(sizei_t n, uint_t * pipelines) {
#if GL_EXT_separate_shader_objects    
      
      glGenProgramPipelinesEXT(n, pipelines);
      
#else
      throw std::runtime_error("OpenGL command 'glGenProgramPipelinesEXT' not available on this platform");
#endif
    }

    void gen_queries_ext(sizei_t n, uint_t * ids) {
#if GL_EXT_occlusion_query_boolean || GL_EXT_disjoint_timer_query    
      
      glGenQueriesEXT(n, ids);
      
#else
      throw std::runtime_error("OpenGL command 'glGenQueriesEXT' not available on this platform");
#endif
    }

    void gen_vertex_arrays_oes(sizei_t n, uint_t * arrays) {
#if GL_OES_vertex_array_object    
      
      glGenVertexArraysOES(n, arrays);
      
#else
      throw std::runtime_error("OpenGL command 'glGenVertexArraysOES' not available on this platform");
#endif
    }

    void get_buffer_pointerv_oes(framebuffer_target_t target, get_pointerv_p_name_t pname, void ** params) {
#if GL_OES_mapbuffer    
      
      glGetBufferPointervOES(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      
#else
      throw std::runtime_error("OpenGL command 'glGetBufferPointervOES' not available on this platform");
#endif
    }

    uint_t get_debug_message_log_khr(uint_t count, sizei_t bufSize, enum_t * sources, enum_t * types, uint_t * ids, enum_t * severities, sizei_t * lengths, char_t * messageLog) {
#if GL_KHR_debug    
      
      return glGetDebugMessageLogKHR(count, bufSize, sources, types, ids, severities, lengths, messageLog);
      
#else
      throw std::runtime_error("OpenGL command 'glGetDebugMessageLogKHR' not available on this platform");
#endif
    }

    void get_driver_control_string_qcom(uint_t driverControl, sizei_t bufSize, sizei_t * length, char_t * driverControlString) {
#if GL_QCOM_driver_control    
      
      glGetDriverControlStringQCOM(driverControl, bufSize, length, driverControlString);
      
#else
      throw std::runtime_error("OpenGL command 'glGetDriverControlStringQCOM' not available on this platform");
#endif
    }

    void get_driver_controls_qcom(int_t * num, sizei_t size, uint_t * driverControls) {
#if GL_QCOM_driver_control    
      
      glGetDriverControlsQCOM(num, size, driverControls);
      
#else
      throw std::runtime_error("OpenGL command 'glGetDriverControlsQCOM' not available on this platform");
#endif
    }

    void get_fenceiv_nv(uint_t fence, enum_t pname, int_t * params) {
#if GL_NV_fence    
      
      glGetFenceivNV(fence, pname, params);
      
#else
      throw std::runtime_error("OpenGL command 'glGetFenceivNV' not available on this platform");
#endif
    }

    void get_first_perf_query_id_intel(uint_t * queryId) {
#if GL_INTEL_performance_query    
      
      glGetFirstPerfQueryIdINTEL(queryId);
      
#else
      throw std::runtime_error("OpenGL command 'glGetFirstPerfQueryIdINTEL' not available on this platform");
#endif
    }

    void get_floati_v_nv(enum_t target, uint_t index, float_t * data) {
#if GL_NV_viewport_array    
      
      glGetFloati_vNV(target, index, data);
      
#else
      throw std::runtime_error("OpenGL command 'glGetFloati_vNV' not available on this platform");
#endif
    }

    enum_t get_graphics_reset_status_ext() {
#if GL_EXT_robustness    
      
      return glGetGraphicsResetStatusEXT();
      
#else
      throw std::runtime_error("OpenGL command 'glGetGraphicsResetStatusEXT' not available on this platform");
#endif
    }

    enum_t get_graphics_reset_status_khr() {
#if GL_KHR_robustness    
      
      return glGetGraphicsResetStatusKHR();
      
#else
      throw std::runtime_error("OpenGL command 'glGetGraphicsResetStatusKHR' not available on this platform");
#endif
    }

    uint64_t get_image_handle_nv(uint_t texture, int_t level, boolean_t layered, int_t layer, pixel_format_t format) {
#if GL_NV_bindless_texture    
      
      return glGetImageHandleNV(texture, level, static_cast<GLboolean>(layered), layer, static_cast<GLenum>(format));
      
#else
      throw std::runtime_error("OpenGL command 'glGetImageHandleNV' not available on this platform");
#endif
    }

    void get_integer_64v_apple(get_pointerv_p_name_t pname, int64_t * params) {
#if GL_APPLE_sync    
      
      glGetInteger64vAPPLE(static_cast<GLenum>(pname), params);
      
#else
      throw std::runtime_error("OpenGL command 'glGetInteger64vAPPLE' not available on this platform");
#endif
    }

    void get_integeri_v_ext(framebuffer_target_t target, uint_t index, int_t * data) {
#if GL_EXT_multiview_draw_buffers    
      
      glGetIntegeri_vEXT(static_cast<GLenum>(target), index, data);
      
#else
      throw std::runtime_error("OpenGL command 'glGetIntegeri_vEXT' not available on this platform");
#endif
    }

    void get_internalformat_sampleiv_nv(framebuffer_target_t target, internal_format_t internalformat, sizei_t samples, get_pointerv_p_name_t pname, sizei_t bufSize, int_t * params) {
#if GL_NV_internalformat_sample_query    
      
      glGetInternalformatSampleivNV(static_cast<GLenum>(target), static_cast<GLenum>(internalformat), samples, static_cast<GLenum>(pname), bufSize, params);
      
#else
      throw std::runtime_error("OpenGL command 'glGetInternalformatSampleivNV' not available on this platform");
#endif
    }

    void get_next_perf_query_id_intel(uint_t queryId, uint_t * nextQueryId) {
#if GL_INTEL_performance_query    
      
      glGetNextPerfQueryIdINTEL(queryId, nextQueryId);
      
#else
      throw std::runtime_error("OpenGL command 'glGetNextPerfQueryIdINTEL' not available on this platform");
#endif
    }

    void get_object_label_ext(draw_elements_type_t type, uint_t object, sizei_t bufSize, sizei_t * length, char_t * label) {
#if GL_EXT_debug_label    
      
      glGetObjectLabelEXT(static_cast<GLenum>(type), object, bufSize, length, label);
      
#else
      throw std::runtime_error("OpenGL command 'glGetObjectLabelEXT' not available on this platform");
#endif
    }

    void get_object_label_khr(enum_t identifier, uint_t name, sizei_t bufSize, sizei_t * length, char_t * label) {
#if GL_KHR_debug    
      
      glGetObjectLabelKHR(identifier, name, bufSize, length, label);
      
#else
      throw std::runtime_error("OpenGL command 'glGetObjectLabelKHR' not available on this platform");
#endif
    }

    void get_object_ptr_label_khr(const void * ptr, sizei_t bufSize, sizei_t * length, char_t * label) {
#if GL_KHR_debug    
      
      glGetObjectPtrLabelKHR(ptr, bufSize, length, label);
      
#else
      throw std::runtime_error("OpenGL command 'glGetObjectPtrLabelKHR' not available on this platform");
#endif
    }

    void get_path_commands_nv(uint_t path, ubyte_t * commands) {
#if GL_NV_path_rendering    
      
      glGetPathCommandsNV(path, commands);
      
#else
      throw std::runtime_error("OpenGL command 'glGetPathCommandsNV' not available on this platform");
#endif
    }

    void get_path_coords_nv(uint_t path, float_t * coords) {
#if GL_NV_path_rendering    
      
      glGetPathCoordsNV(path, coords);
      
#else
      throw std::runtime_error("OpenGL command 'glGetPathCoordsNV' not available on this platform");
#endif
    }

    void get_path_dash_array_nv(uint_t path, float_t * dashArray) {
#if GL_NV_path_rendering    
      
      glGetPathDashArrayNV(path, dashArray);
      
#else
      throw std::runtime_error("OpenGL command 'glGetPathDashArrayNV' not available on this platform");
#endif
    }

    float_t get_path_length_nv(uint_t path, sizei_t startSegment, sizei_t numSegments) {
#if GL_NV_path_rendering    
      
      return glGetPathLengthNV(path, startSegment, numSegments);
      
#else
      throw std::runtime_error("OpenGL command 'glGetPathLengthNV' not available on this platform");
#endif
    }

    void get_path_metric_range_nv(bitfield_t metricQueryMask, uint_t firstPathName, sizei_t numPaths, sizei_t stride, float_t * metrics) {
#if GL_NV_path_rendering    
      
      glGetPathMetricRangeNV(metricQueryMask, firstPathName, numPaths, stride, metrics);
      
#else
      throw std::runtime_error("OpenGL command 'glGetPathMetricRangeNV' not available on this platform");
#endif
    }

    void get_path_metrics_nv(bitfield_t metricQueryMask, sizei_t numPaths, enum_t pathNameType, const void * paths, uint_t pathBase, sizei_t stride, float_t * metrics) {
#if GL_NV_path_rendering    
      
      glGetPathMetricsNV(metricQueryMask, numPaths, pathNameType, paths, pathBase, stride, metrics);
      
#else
      throw std::runtime_error("OpenGL command 'glGetPathMetricsNV' not available on this platform");
#endif
    }

    void get_path_parameterfv_nv(uint_t path, enum_t pname, float_t * value) {
#if GL_NV_path_rendering    
      
      glGetPathParameterfvNV(path, pname, value);
      
#else
      throw std::runtime_error("OpenGL command 'glGetPathParameterfvNV' not available on this platform");
#endif
    }

    void get_path_parameteriv_nv(uint_t path, enum_t pname, int_t * value) {
#if GL_NV_path_rendering    
      
      glGetPathParameterivNV(path, pname, value);
      
#else
      throw std::runtime_error("OpenGL command 'glGetPathParameterivNV' not available on this platform");
#endif
    }

    void get_path_spacing_nv(enum_t pathListMode, sizei_t numPaths, enum_t pathNameType, const void * paths, uint_t pathBase, float_t advanceScale, float_t kerningScale, enum_t transformType, float_t * returnedSpacing) {
#if GL_NV_path_rendering    
      
      glGetPathSpacingNV(pathListMode, numPaths, pathNameType, paths, pathBase, advanceScale, kerningScale, transformType, returnedSpacing);
      
#else
      throw std::runtime_error("OpenGL command 'glGetPathSpacingNV' not available on this platform");
#endif
    }

    void get_perf_counter_info_intel(uint_t queryId, uint_t counterId, uint_t counterNameLength, char_t * counterName, uint_t counterDescLength, char_t * counterDesc, uint_t * counterOffset, uint_t * counterDataSize, uint_t * counterTypeEnum, uint_t * counterDataTypeEnum, uint64_t * rawCounterMaxValue) {
#if GL_INTEL_performance_query    
      
      glGetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue);
      
#else
      throw std::runtime_error("OpenGL command 'glGetPerfCounterInfoINTEL' not available on this platform");
#endif
    }

    void get_perf_monitor_counter_data_amd(uint_t monitor, get_pointerv_p_name_t pname, sizei_t dataSize, uint_t * data, int_t * bytesWritten) {
#if GL_AMD_performance_monitor    
      
      glGetPerfMonitorCounterDataAMD(monitor, static_cast<GLenum>(pname), dataSize, data, bytesWritten);
      
#else
      throw std::runtime_error("OpenGL command 'glGetPerfMonitorCounterDataAMD' not available on this platform");
#endif
    }

    void get_perf_monitor_counter_info_amd(uint_t group, uint_t counter, get_pointerv_p_name_t pname, void * data) {
#if GL_AMD_performance_monitor    
      
      glGetPerfMonitorCounterInfoAMD(group, counter, static_cast<GLenum>(pname), data);
      
#else
      throw std::runtime_error("OpenGL command 'glGetPerfMonitorCounterInfoAMD' not available on this platform");
#endif
    }

    void get_perf_monitor_counter_string_amd(uint_t group, uint_t counter, sizei_t bufSize, sizei_t * length, char_t * counterString) {
#if GL_AMD_performance_monitor    
      
      glGetPerfMonitorCounterStringAMD(group, counter, bufSize, length, counterString);
      
#else
      throw std::runtime_error("OpenGL command 'glGetPerfMonitorCounterStringAMD' not available on this platform");
#endif
    }

    void get_perf_monitor_counters_amd(uint_t group, int_t * numCounters, int_t * maxActiveCounters, sizei_t counterSize, uint_t * counters) {
#if GL_AMD_performance_monitor    
      
      glGetPerfMonitorCountersAMD(group, numCounters, maxActiveCounters, counterSize, counters);
      
#else
      throw std::runtime_error("OpenGL command 'glGetPerfMonitorCountersAMD' not available on this platform");
#endif
    }

    void get_perf_monitor_group_string_amd(uint_t group, sizei_t bufSize, sizei_t * length, char_t * groupString) {
#if GL_AMD_performance_monitor    
      
      glGetPerfMonitorGroupStringAMD(group, bufSize, length, groupString);
      
#else
      throw std::runtime_error("OpenGL command 'glGetPerfMonitorGroupStringAMD' not available on this platform");
#endif
    }

    void get_perf_monitor_groups_amd(int_t * numGroups, sizei_t groupsSize, uint_t * groups) {
#if GL_AMD_performance_monitor    
      
      glGetPerfMonitorGroupsAMD(numGroups, groupsSize, groups);
      
#else
      throw std::runtime_error("OpenGL command 'glGetPerfMonitorGroupsAMD' not available on this platform");
#endif
    }

    void get_perf_query_data_intel(uint_t queryHandle, uint_t flags, sizei_t dataSize, void * data, uint_t * bytesWritten) {
#if GL_INTEL_performance_query    
      
      glGetPerfQueryDataINTEL(queryHandle, flags, dataSize, data, bytesWritten);
      
#else
      throw std::runtime_error("OpenGL command 'glGetPerfQueryDataINTEL' not available on this platform");
#endif
    }

    void get_perf_query_id_by_name_intel(char_t * queryName, uint_t * queryId) {
#if GL_INTEL_performance_query    
      
      glGetPerfQueryIdByNameINTEL(queryName, queryId);
      
#else
      throw std::runtime_error("OpenGL command 'glGetPerfQueryIdByNameINTEL' not available on this platform");
#endif
    }

    void get_perf_query_info_intel(uint_t queryId, uint_t queryNameLength, char_t * queryName, uint_t * dataSize, uint_t * noCounters, uint_t * noInstances, uint_t * capsMask) {
#if GL_INTEL_performance_query    
      
      glGetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, dataSize, noCounters, noInstances, capsMask);
      
#else
      throw std::runtime_error("OpenGL command 'glGetPerfQueryInfoINTEL' not available on this platform");
#endif
    }

    void get_pointerv_khr(get_pointerv_p_name_t pname, void ** params) {
#if GL_KHR_debug    
      
      glGetPointervKHR(static_cast<GLenum>(pname), params);
      
#else
      throw std::runtime_error("OpenGL command 'glGetPointervKHR' not available on this platform");
#endif
    }

    void get_program_binary_oes(uint_t program, sizei_t bufSize, sizei_t * length, enum_t * binaryFormat, void * binary) {
#if GL_OES_get_program_binary    
      
      glGetProgramBinaryOES(program, bufSize, length, binaryFormat, binary);
      
#else
      throw std::runtime_error("OpenGL command 'glGetProgramBinaryOES' not available on this platform");
#endif
    }

    void get_program_pipeline_info_log_ext(uint_t pipeline, sizei_t bufSize, sizei_t * length, char_t * infoLog) {
#if GL_EXT_separate_shader_objects    
      
      glGetProgramPipelineInfoLogEXT(pipeline, bufSize, length, infoLog);
      
#else
      throw std::runtime_error("OpenGL command 'glGetProgramPipelineInfoLogEXT' not available on this platform");
#endif
    }

    void get_program_pipelineiv_ext(uint_t pipeline, get_pointerv_p_name_t pname, int_t * params) {
#if GL_EXT_separate_shader_objects    
      
      glGetProgramPipelineivEXT(pipeline, static_cast<GLenum>(pname), params);
      
#else
      throw std::runtime_error("OpenGL command 'glGetProgramPipelineivEXT' not available on this platform");
#endif
    }

    void get_program_resourcefv_nv(uint_t program, enum_t programInterface, uint_t index, sizei_t propCount, const enum_t * props, sizei_t bufSize, sizei_t * length, float_t * params) {
#if GL_NV_path_rendering    
      
      glGetProgramResourcefvNV(program, programInterface, index, propCount, props, bufSize, length, params);
      
#else
      throw std::runtime_error("OpenGL command 'glGetProgramResourcefvNV' not available on this platform");
#endif
    }

    void get_query_objecti_64v_ext(uint_t id, get_pointerv_p_name_t pname, int64_t * params) {
#if GL_EXT_disjoint_timer_query    
      
      glGetQueryObjecti64vEXT(id, static_cast<GLenum>(pname), params);
      
#else
      throw std::runtime_error("OpenGL command 'glGetQueryObjecti64vEXT' not available on this platform");
#endif
    }

    void get_query_objectiv_ext(uint_t id, get_pointerv_p_name_t pname, int_t * params) {
#if GL_EXT_disjoint_timer_query    
      
      glGetQueryObjectivEXT(id, static_cast<GLenum>(pname), params);
      
#else
      throw std::runtime_error("OpenGL command 'glGetQueryObjectivEXT' not available on this platform");
#endif
    }

    void get_query_objectui_64v_ext(uint_t id, get_pointerv_p_name_t pname, uint64_t * params) {
#if GL_EXT_disjoint_timer_query    
      
      glGetQueryObjectui64vEXT(id, static_cast<GLenum>(pname), params);
      
#else
      throw std::runtime_error("OpenGL command 'glGetQueryObjectui64vEXT' not available on this platform");
#endif
    }

    void get_query_objectuiv_ext(uint_t id, get_pointerv_p_name_t pname, uint_t * params) {
#if GL_EXT_occlusion_query_boolean || GL_EXT_disjoint_timer_query    
      
      glGetQueryObjectuivEXT(id, static_cast<GLenum>(pname), params);
      
#else
      throw std::runtime_error("OpenGL command 'glGetQueryObjectuivEXT' not available on this platform");
#endif
    }

    void get_queryiv_ext(framebuffer_target_t target, get_pointerv_p_name_t pname, int_t * params) {
#if GL_EXT_occlusion_query_boolean || GL_EXT_disjoint_timer_query    
      
      glGetQueryivEXT(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      
#else
      throw std::runtime_error("OpenGL command 'glGetQueryivEXT' not available on this platform");
#endif
    }

    void get_sampler_parameter_iiv_ext(uint_t sampler, get_pointerv_p_name_t pname, int_t * params) {
#if GL_EXT_texture_border_clamp    
      
      glGetSamplerParameterIivEXT(sampler, static_cast<GLenum>(pname), params);
      
#else
      throw std::runtime_error("OpenGL command 'glGetSamplerParameterIivEXT' not available on this platform");
#endif
    }

    void get_sampler_parameter_iiv_oes(uint_t sampler, get_pointerv_p_name_t pname, int_t * params) {
#if GL_OES_texture_border_clamp    
      
      glGetSamplerParameterIivOES(sampler, static_cast<GLenum>(pname), params);
      
#else
      throw std::runtime_error("OpenGL command 'glGetSamplerParameterIivOES' not available on this platform");
#endif
    }

    void get_sampler_parameter_iuiv_ext(uint_t sampler, get_pointerv_p_name_t pname, uint_t * params) {
#if GL_EXT_texture_border_clamp    
      
      glGetSamplerParameterIuivEXT(sampler, static_cast<GLenum>(pname), params);
      
#else
      throw std::runtime_error("OpenGL command 'glGetSamplerParameterIuivEXT' not available on this platform");
#endif
    }

    void get_sampler_parameter_iuiv_oes(uint_t sampler, get_pointerv_p_name_t pname, uint_t * params) {
#if GL_OES_texture_border_clamp    
      
      glGetSamplerParameterIuivOES(sampler, static_cast<GLenum>(pname), params);
      
#else
      throw std::runtime_error("OpenGL command 'glGetSamplerParameterIuivOES' not available on this platform");
#endif
    }

    void get_synciv_apple(sync_t sync, get_pointerv_p_name_t pname, sizei_t bufSize, sizei_t * length, int_t * values) {
#if GL_APPLE_sync    
      
      glGetSyncivAPPLE(sync, static_cast<GLenum>(pname), bufSize, length, values);
      
#else
      throw std::runtime_error("OpenGL command 'glGetSyncivAPPLE' not available on this platform");
#endif
    }

    void get_tex_parameter_iiv_ext(texture_target_t target, get_texture_parameter_t pname, int_t * params) {
#if GL_EXT_texture_border_clamp    
      
      glGetTexParameterIivEXT(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      
#else
      throw std::runtime_error("OpenGL command 'glGetTexParameterIivEXT' not available on this platform");
#endif
    }

    void get_tex_parameter_iiv_oes(texture_target_t target, get_texture_parameter_t pname, int_t * params) {
#if GL_OES_texture_border_clamp    
      
      glGetTexParameterIivOES(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      
#else
      throw std::runtime_error("OpenGL command 'glGetTexParameterIivOES' not available on this platform");
#endif
    }

    void get_tex_parameter_iuiv_ext(texture_target_t target, get_texture_parameter_t pname, uint_t * params) {
#if GL_EXT_texture_border_clamp    
      
      glGetTexParameterIuivEXT(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      
#else
      throw std::runtime_error("OpenGL command 'glGetTexParameterIuivEXT' not available on this platform");
#endif
    }

    void get_tex_parameter_iuiv_oes(texture_target_t target, get_texture_parameter_t pname, uint_t * params) {
#if GL_OES_texture_border_clamp    
      
      glGetTexParameterIuivOES(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      
#else
      throw std::runtime_error("OpenGL command 'glGetTexParameterIuivOES' not available on this platform");
#endif
    }

    uint64_t get_texture_handle_nv(uint_t texture) {
#if GL_NV_bindless_texture    
      
      return glGetTextureHandleNV(texture);
      
#else
      throw std::runtime_error("OpenGL command 'glGetTextureHandleNV' not available on this platform");
#endif
    }

    uint64_t get_texture_sampler_handle_nv(uint_t texture, uint_t sampler) {
#if GL_NV_bindless_texture    
      
      return glGetTextureSamplerHandleNV(texture, sampler);
      
#else
      throw std::runtime_error("OpenGL command 'glGetTextureSamplerHandleNV' not available on this platform");
#endif
    }

    void get_translated_shader_source_angle(uint_t shader, sizei_t bufsize, sizei_t * length, char_t * source) {
#if GL_ANGLE_translated_shader_source    
      
      glGetTranslatedShaderSourceANGLE(shader, bufsize, length, source);
      
#else
      throw std::runtime_error("OpenGL command 'glGetTranslatedShaderSourceANGLE' not available on this platform");
#endif
    }

    void getn_uniformfv_ext(uint_t program, int_t location, sizei_t bufSize, float_t * params) {
#if GL_EXT_robustness    
      
      glGetnUniformfvEXT(program, location, bufSize, params);
      
#else
      throw std::runtime_error("OpenGL command 'glGetnUniformfvEXT' not available on this platform");
#endif
    }

    void getn_uniformfv_khr(uint_t program, int_t location, sizei_t bufSize, float_t * params) {
#if GL_KHR_robustness    
      
      glGetnUniformfvKHR(program, location, bufSize, params);
      
#else
      throw std::runtime_error("OpenGL command 'glGetnUniformfvKHR' not available on this platform");
#endif
    }

    void getn_uniformiv_ext(uint_t program, int_t location, sizei_t bufSize, int_t * params) {
#if GL_EXT_robustness    
      
      glGetnUniformivEXT(program, location, bufSize, params);
      
#else
      throw std::runtime_error("OpenGL command 'glGetnUniformivEXT' not available on this platform");
#endif
    }

    void getn_uniformiv_khr(uint_t program, int_t location, sizei_t bufSize, int_t * params) {
#if GL_KHR_robustness    
      
      glGetnUniformivKHR(program, location, bufSize, params);
      
#else
      throw std::runtime_error("OpenGL command 'glGetnUniformivKHR' not available on this platform");
#endif
    }

    void getn_uniformuiv_khr(uint_t program, int_t location, sizei_t bufSize, uint_t * params) {
#if GL_KHR_robustness    
      
      glGetnUniformuivKHR(program, location, bufSize, params);
      
#else
      throw std::runtime_error("OpenGL command 'glGetnUniformuivKHR' not available on this platform");
#endif
    }

    void insert_event_marker_ext(sizei_t length, const char_t * marker) {
#if GL_EXT_debug_marker    
      
      glInsertEventMarkerEXT(length, marker);
      
#else
      throw std::runtime_error("OpenGL command 'glInsertEventMarkerEXT' not available on this platform");
#endif
    }

    void interpolate_paths_nv(uint_t resultPath, uint_t pathA, uint_t pathB, float_t weight) {
#if GL_NV_path_rendering    
      
      glInterpolatePathsNV(resultPath, pathA, pathB, weight);
      
#else
      throw std::runtime_error("OpenGL command 'glInterpolatePathsNV' not available on this platform");
#endif
    }

    boolean_t is_enabledi_ext(framebuffer_target_t target, uint_t index) {
#if GL_EXT_draw_buffers_indexed    
      
      return static_cast<boolean_t>(glIsEnablediEXT(static_cast<GLenum>(target), index));
      
#else
      throw std::runtime_error("OpenGL command 'glIsEnablediEXT' not available on this platform");
#endif
    }

    boolean_t is_enabledi_nv(framebuffer_target_t target, uint_t index) {
#if GL_NV_viewport_array    
      
      return static_cast<boolean_t>(glIsEnablediNV(static_cast<GLenum>(target), index));
      
#else
      throw std::runtime_error("OpenGL command 'glIsEnablediNV' not available on this platform");
#endif
    }

    boolean_t is_enabledi_oes(framebuffer_target_t target, uint_t index) {
#if GL_OES_draw_buffers_indexed    
      
      return static_cast<boolean_t>(glIsEnablediOES(static_cast<GLenum>(target), index));
      
#else
      throw std::runtime_error("OpenGL command 'glIsEnablediOES' not available on this platform");
#endif
    }

    boolean_t is_fence_nv(uint_t fence) {
#if GL_NV_fence    
      
      return static_cast<boolean_t>(glIsFenceNV(fence));
      
#else
      throw std::runtime_error("OpenGL command 'glIsFenceNV' not available on this platform");
#endif
    }

    boolean_t is_image_handle_resident_nv(uint64_t handle) {
#if GL_NV_bindless_texture    
      
      return static_cast<boolean_t>(glIsImageHandleResidentNV(handle));
      
#else
      throw std::runtime_error("OpenGL command 'glIsImageHandleResidentNV' not available on this platform");
#endif
    }

    boolean_t is_path_nv(uint_t path) {
#if GL_NV_path_rendering    
      
      return static_cast<boolean_t>(glIsPathNV(path));
      
#else
      throw std::runtime_error("OpenGL command 'glIsPathNV' not available on this platform");
#endif
    }

    boolean_t is_point_in_fill_path_nv(uint_t path, uint_t mask, float_t x, float_t y) {
#if GL_NV_path_rendering    
      
      return static_cast<boolean_t>(glIsPointInFillPathNV(path, mask, x, y));
      
#else
      throw std::runtime_error("OpenGL command 'glIsPointInFillPathNV' not available on this platform");
#endif
    }

    boolean_t is_point_in_stroke_path_nv(uint_t path, float_t x, float_t y) {
#if GL_NV_path_rendering    
      
      return static_cast<boolean_t>(glIsPointInStrokePathNV(path, x, y));
      
#else
      throw std::runtime_error("OpenGL command 'glIsPointInStrokePathNV' not available on this platform");
#endif
    }

    boolean_t is_program_pipeline_ext(uint_t pipeline) {
#if GL_EXT_separate_shader_objects    
      
      return static_cast<boolean_t>(glIsProgramPipelineEXT(pipeline));
      
#else
      throw std::runtime_error("OpenGL command 'glIsProgramPipelineEXT' not available on this platform");
#endif
    }

    boolean_t is_query_ext(uint_t id) {
#if GL_EXT_occlusion_query_boolean || GL_EXT_disjoint_timer_query    
      
      return static_cast<boolean_t>(glIsQueryEXT(id));
      
#else
      throw std::runtime_error("OpenGL command 'glIsQueryEXT' not available on this platform");
#endif
    }

    boolean_t is_sync_apple(sync_t sync) {
#if GL_APPLE_sync    
      
      return static_cast<boolean_t>(glIsSyncAPPLE(sync));
      
#else
      throw std::runtime_error("OpenGL command 'glIsSyncAPPLE' not available on this platform");
#endif
    }

    boolean_t is_texture_handle_resident_nv(uint64_t handle) {
#if GL_NV_bindless_texture    
      
      return static_cast<boolean_t>(glIsTextureHandleResidentNV(handle));
      
#else
      throw std::runtime_error("OpenGL command 'glIsTextureHandleResidentNV' not available on this platform");
#endif
    }

    boolean_t is_vertex_array_oes(uint_t array) {
#if GL_OES_vertex_array_object    
      
      return static_cast<boolean_t>(glIsVertexArrayOES(array));
      
#else
      throw std::runtime_error("OpenGL command 'glIsVertexArrayOES' not available on this platform");
#endif
    }

    void label_object_ext(draw_elements_type_t type, uint_t object, sizei_t length, const char_t * label) {
#if GL_EXT_debug_label    
      
      glLabelObjectEXT(static_cast<GLenum>(type), object, length, label);
      
#else
      throw std::runtime_error("OpenGL command 'glLabelObjectEXT' not available on this platform");
#endif
    }

    void make_image_handle_non_resident_nv(uint64_t handle) {
#if GL_NV_bindless_texture    
      
      glMakeImageHandleNonResidentNV(handle);
      
#else
      throw std::runtime_error("OpenGL command 'glMakeImageHandleNonResidentNV' not available on this platform");
#endif
    }

    void make_image_handle_resident_nv(uint64_t handle, enum_t access) {
#if GL_NV_bindless_texture    
      
      glMakeImageHandleResidentNV(handle, access);
      
#else
      throw std::runtime_error("OpenGL command 'glMakeImageHandleResidentNV' not available on this platform");
#endif
    }

    void make_texture_handle_non_resident_nv(uint64_t handle) {
#if GL_NV_bindless_texture    
      
      glMakeTextureHandleNonResidentNV(handle);
      
#else
      throw std::runtime_error("OpenGL command 'glMakeTextureHandleNonResidentNV' not available on this platform");
#endif
    }

    void make_texture_handle_resident_nv(uint64_t handle) {
#if GL_NV_bindless_texture    
      
      glMakeTextureHandleResidentNV(handle);
      
#else
      throw std::runtime_error("OpenGL command 'glMakeTextureHandleResidentNV' not available on this platform");
#endif
    }

    void * map_buffer_oes(framebuffer_target_t target, enum_t access) {
#if GL_OES_mapbuffer    
      
      return glMapBufferOES(static_cast<GLenum>(target), access);
      
#else
      throw std::runtime_error("OpenGL command 'glMapBufferOES' not available on this platform");
#endif
    }

    void * map_buffer_range_ext(framebuffer_target_t target, intptr_t offset, sizeiptr_t length, bitfield_t access) {
#if GL_EXT_map_buffer_range    
      
      return glMapBufferRangeEXT(static_cast<GLenum>(target), offset, length, access);
      
#else
      throw std::runtime_error("OpenGL command 'glMapBufferRangeEXT' not available on this platform");
#endif
    }

    void matrix_load_3x_2f_nv(enum_t matrixMode, const float_t * m) {
#if GL_NV_path_rendering    
      
      glMatrixLoad3x2fNV(matrixMode, m);
      
#else
      throw std::runtime_error("OpenGL command 'glMatrixLoad3x2fNV' not available on this platform");
#endif
    }

    void matrix_load_3x_3f_nv(enum_t matrixMode, const float_t * m) {
#if GL_NV_path_rendering    
      
      glMatrixLoad3x3fNV(matrixMode, m);
      
#else
      throw std::runtime_error("OpenGL command 'glMatrixLoad3x3fNV' not available on this platform");
#endif
    }

    void matrix_load_transpose_3x_3f_nv(enum_t matrixMode, const float_t * m) {
#if GL_NV_path_rendering    
      
      glMatrixLoadTranspose3x3fNV(matrixMode, m);
      
#else
      throw std::runtime_error("OpenGL command 'glMatrixLoadTranspose3x3fNV' not available on this platform");
#endif
    }

    void matrix_mult_3x_2f_nv(enum_t matrixMode, const float_t * m) {
#if GL_NV_path_rendering    
      
      glMatrixMult3x2fNV(matrixMode, m);
      
#else
      throw std::runtime_error("OpenGL command 'glMatrixMult3x2fNV' not available on this platform");
#endif
    }

    void matrix_mult_3x_3f_nv(enum_t matrixMode, const float_t * m) {
#if GL_NV_path_rendering    
      
      glMatrixMult3x3fNV(matrixMode, m);
      
#else
      throw std::runtime_error("OpenGL command 'glMatrixMult3x3fNV' not available on this platform");
#endif
    }

    void matrix_mult_transpose_3x_3f_nv(enum_t matrixMode, const float_t * m) {
#if GL_NV_path_rendering    
      
      glMatrixMultTranspose3x3fNV(matrixMode, m);
      
#else
      throw std::runtime_error("OpenGL command 'glMatrixMultTranspose3x3fNV' not available on this platform");
#endif
    }

    void min_sample_shading_oes(float_t value) {
#if GL_OES_sample_shading    
      
      glMinSampleShadingOES(value);
      
#else
      throw std::runtime_error("OpenGL command 'glMinSampleShadingOES' not available on this platform");
#endif
    }

    void multi_draw_arrays_ext(primitive_type_t mode, const int_t * first, const sizei_t * count, sizei_t primcount) {
#if GL_EXT_multi_draw_arrays    
      
      glMultiDrawArraysEXT(static_cast<GLenum>(mode), first, count, primcount);
      
#else
      throw std::runtime_error("OpenGL command 'glMultiDrawArraysEXT' not available on this platform");
#endif
    }

    void multi_draw_arrays_indirect_ext(blend_equation_mode_t mode, const void * indirect, sizei_t drawcount, sizei_t stride) {
#if GL_EXT_multi_draw_indirect    
      
      glMultiDrawArraysIndirectEXT(static_cast<GLenum>(mode), indirect, drawcount, stride);
      
#else
      throw std::runtime_error("OpenGL command 'glMultiDrawArraysIndirectEXT' not available on this platform");
#endif
    }

    void multi_draw_elements_base_vertex_ext(blend_equation_mode_t mode, const sizei_t * count, draw_elements_type_t type, const void *const* indices, sizei_t primcount, const int_t * basevertex) {
#if GL_EXT_draw_elements_base_vertex    
      
      glMultiDrawElementsBaseVertexEXT(static_cast<GLenum>(mode), count, static_cast<GLenum>(type), indices, primcount, basevertex);
      
#else
      throw std::runtime_error("OpenGL command 'glMultiDrawElementsBaseVertexEXT' not available on this platform");
#endif
    }

    void multi_draw_elements_base_vertex_oes(blend_equation_mode_t mode, const sizei_t * count, draw_elements_type_t type, const void *const* indices, sizei_t primcount, const int_t * basevertex) {
#if GL_OES_draw_elements_base_vertex    
      
      glMultiDrawElementsBaseVertexOES(static_cast<GLenum>(mode), count, static_cast<GLenum>(type), indices, primcount, basevertex);
      
#else
      throw std::runtime_error("OpenGL command 'glMultiDrawElementsBaseVertexOES' not available on this platform");
#endif
    }

    void multi_draw_elements_ext(primitive_type_t mode, const sizei_t * count, draw_elements_type_t type, const void * * indices, sizei_t primcount) {
#if GL_EXT_multi_draw_arrays    
      
      glMultiDrawElementsEXT(static_cast<GLenum>(mode), count, static_cast<GLenum>(type), indices, primcount);
      
#else
      throw std::runtime_error("OpenGL command 'glMultiDrawElementsEXT' not available on this platform");
#endif
    }

    void multi_draw_elements_indirect_ext(blend_equation_mode_t mode, draw_elements_type_t type, const void * indirect, sizei_t drawcount, sizei_t stride) {
#if GL_EXT_multi_draw_indirect    
      
      glMultiDrawElementsIndirectEXT(static_cast<GLenum>(mode), static_cast<GLenum>(type), indirect, drawcount, stride);
      
#else
      throw std::runtime_error("OpenGL command 'glMultiDrawElementsIndirectEXT' not available on this platform");
#endif
    }

    void object_label_khr(enum_t identifier, uint_t name, sizei_t length, const char_t * label) {
#if GL_KHR_debug    
      
      glObjectLabelKHR(identifier, name, length, label);
      
#else
      throw std::runtime_error("OpenGL command 'glObjectLabelKHR' not available on this platform");
#endif
    }

    void object_ptr_label_khr(const void * ptr, sizei_t length, const char_t * label) {
#if GL_KHR_debug    
      
      glObjectPtrLabelKHR(ptr, length, label);
      
#else
      throw std::runtime_error("OpenGL command 'glObjectPtrLabelKHR' not available on this platform");
#endif
    }

    void patch_parameteri_ext(get_pointerv_p_name_t pname, int_t value) {
#if GL_EXT_tessellation_shader    
      
      glPatchParameteriEXT(static_cast<GLenum>(pname), value);
      
#else
      throw std::runtime_error("OpenGL command 'glPatchParameteriEXT' not available on this platform");
#endif
    }

    void patch_parameteri_oes(get_pointerv_p_name_t pname, int_t value) {
#if GL_OES_tessellation_shader    
      
      glPatchParameteriOES(static_cast<GLenum>(pname), value);
      
#else
      throw std::runtime_error("OpenGL command 'glPatchParameteriOES' not available on this platform");
#endif
    }

    void path_commands_nv(uint_t path, sizei_t numCommands, const ubyte_t * commands, sizei_t numCoords, enum_t coordType, const void * coords) {
#if GL_NV_path_rendering    
      
      glPathCommandsNV(path, numCommands, commands, numCoords, coordType, coords);
      
#else
      throw std::runtime_error("OpenGL command 'glPathCommandsNV' not available on this platform");
#endif
    }

    void path_coords_nv(uint_t path, sizei_t numCoords, enum_t coordType, const void * coords) {
#if GL_NV_path_rendering    
      
      glPathCoordsNV(path, numCoords, coordType, coords);
      
#else
      throw std::runtime_error("OpenGL command 'glPathCoordsNV' not available on this platform");
#endif
    }

    void path_cover_depth_func_nv(depth_function_t func) {
#if GL_NV_path_rendering    
      
      glPathCoverDepthFuncNV(static_cast<GLenum>(func));
      
#else
      throw std::runtime_error("OpenGL command 'glPathCoverDepthFuncNV' not available on this platform");
#endif
    }

    void path_dash_array_nv(uint_t path, sizei_t dashCount, const float_t * dashArray) {
#if GL_NV_path_rendering    
      
      glPathDashArrayNV(path, dashCount, dashArray);
      
#else
      throw std::runtime_error("OpenGL command 'glPathDashArrayNV' not available on this platform");
#endif
    }

    enum_t path_glyph_index_array_nv(uint_t firstPathName, enum_t fontTarget, const void * fontName, bitfield_t fontStyle, uint_t firstGlyphIndex, sizei_t numGlyphs, uint_t pathParameterTemplate, float_t emScale) {
#if GL_NV_path_rendering    
      
      return glPathGlyphIndexArrayNV(firstPathName, fontTarget, fontName, fontStyle, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale);
      
#else
      throw std::runtime_error("OpenGL command 'glPathGlyphIndexArrayNV' not available on this platform");
#endif
    }

    enum_t path_glyph_index_range_nv(enum_t fontTarget, const void * fontName, bitfield_t fontStyle, uint_t pathParameterTemplate, float_t emScale, uint_t * baseAndCount) {
#if GL_NV_path_rendering    
      
      return glPathGlyphIndexRangeNV(fontTarget, fontName, fontStyle, pathParameterTemplate, emScale, baseAndCount);
      
#else
      throw std::runtime_error("OpenGL command 'glPathGlyphIndexRangeNV' not available on this platform");
#endif
    }

    void path_glyph_range_nv(uint_t firstPathName, enum_t fontTarget, const void * fontName, bitfield_t fontStyle, uint_t firstGlyph, sizei_t numGlyphs, enum_t handleMissingGlyphs, uint_t pathParameterTemplate, float_t emScale) {
#if GL_NV_path_rendering    
      
      glPathGlyphRangeNV(firstPathName, fontTarget, fontName, fontStyle, firstGlyph, numGlyphs, handleMissingGlyphs, pathParameterTemplate, emScale);
      
#else
      throw std::runtime_error("OpenGL command 'glPathGlyphRangeNV' not available on this platform");
#endif
    }

    void path_glyphs_nv(uint_t firstPathName, enum_t fontTarget, const void * fontName, bitfield_t fontStyle, sizei_t numGlyphs, enum_t type, const void * charcodes, enum_t handleMissingGlyphs, uint_t pathParameterTemplate, float_t emScale) {
#if GL_NV_path_rendering    
      
      glPathGlyphsNV(firstPathName, fontTarget, fontName, fontStyle, numGlyphs, type, charcodes, handleMissingGlyphs, pathParameterTemplate, emScale);
      
#else
      throw std::runtime_error("OpenGL command 'glPathGlyphsNV' not available on this platform");
#endif
    }

    enum_t path_memory_glyph_index_array_nv(uint_t firstPathName, enum_t fontTarget, sizeiptr_t fontSize, const void * fontData, sizei_t faceIndex, uint_t firstGlyphIndex, sizei_t numGlyphs, uint_t pathParameterTemplate, float_t emScale) {
#if GL_NV_path_rendering    
      
      return glPathMemoryGlyphIndexArrayNV(firstPathName, fontTarget, fontSize, fontData, faceIndex, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale);
      
#else
      throw std::runtime_error("OpenGL command 'glPathMemoryGlyphIndexArrayNV' not available on this platform");
#endif
    }

    void path_parameterf_nv(uint_t path, enum_t pname, float_t value) {
#if GL_NV_path_rendering    
      
      glPathParameterfNV(path, pname, value);
      
#else
      throw std::runtime_error("OpenGL command 'glPathParameterfNV' not available on this platform");
#endif
    }

    void path_parameterfv_nv(uint_t path, enum_t pname, const float_t * value) {
#if GL_NV_path_rendering    
      
      glPathParameterfvNV(path, pname, value);
      
#else
      throw std::runtime_error("OpenGL command 'glPathParameterfvNV' not available on this platform");
#endif
    }

    void path_parameteri_nv(uint_t path, enum_t pname, int_t value) {
#if GL_NV_path_rendering    
      
      glPathParameteriNV(path, pname, value);
      
#else
      throw std::runtime_error("OpenGL command 'glPathParameteriNV' not available on this platform");
#endif
    }

    void path_parameteriv_nv(uint_t path, enum_t pname, const int_t * value) {
#if GL_NV_path_rendering    
      
      glPathParameterivNV(path, pname, value);
      
#else
      throw std::runtime_error("OpenGL command 'glPathParameterivNV' not available on this platform");
#endif
    }

    void path_stencil_depth_offset_nv(float_t factor, float_t units) {
#if GL_NV_path_rendering    
      
      glPathStencilDepthOffsetNV(factor, units);
      
#else
      throw std::runtime_error("OpenGL command 'glPathStencilDepthOffsetNV' not available on this platform");
#endif
    }

    void path_stencil_func_nv(stencil_function_t func, int_t ref, uint_t mask) {
#if GL_NV_path_rendering    
      
      glPathStencilFuncNV(static_cast<GLenum>(func), ref, mask);
      
#else
      throw std::runtime_error("OpenGL command 'glPathStencilFuncNV' not available on this platform");
#endif
    }

    void path_string_nv(uint_t path, enum_t format, sizei_t length, const void * pathString) {
#if GL_NV_path_rendering    
      
      glPathStringNV(path, format, length, pathString);
      
#else
      throw std::runtime_error("OpenGL command 'glPathStringNV' not available on this platform");
#endif
    }

    void path_sub_commands_nv(uint_t path, sizei_t commandStart, sizei_t commandsToDelete, sizei_t numCommands, const ubyte_t * commands, sizei_t numCoords, enum_t coordType, const void * coords) {
#if GL_NV_path_rendering    
      
      glPathSubCommandsNV(path, commandStart, commandsToDelete, numCommands, commands, numCoords, coordType, coords);
      
#else
      throw std::runtime_error("OpenGL command 'glPathSubCommandsNV' not available on this platform");
#endif
    }

    void path_sub_coords_nv(uint_t path, sizei_t coordStart, sizei_t numCoords, enum_t coordType, const void * coords) {
#if GL_NV_path_rendering    
      
      glPathSubCoordsNV(path, coordStart, numCoords, coordType, coords);
      
#else
      throw std::runtime_error("OpenGL command 'glPathSubCoordsNV' not available on this platform");
#endif
    }

    boolean_t point_along_path_nv(uint_t path, sizei_t startSegment, sizei_t numSegments, float_t distance, float_t * x, float_t * y, float_t * tangentX, float_t * tangentY) {
#if GL_NV_path_rendering    
      
      return static_cast<boolean_t>(glPointAlongPathNV(path, startSegment, numSegments, distance, x, y, tangentX, tangentY));
      
#else
      throw std::runtime_error("OpenGL command 'glPointAlongPathNV' not available on this platform");
#endif
    }

    void pop_debug_group_khr() {
#if GL_KHR_debug    
      
      glPopDebugGroupKHR();
      
#else
      throw std::runtime_error("OpenGL command 'glPopDebugGroupKHR' not available on this platform");
#endif
    }

    void pop_group_marker_ext() {
#if GL_EXT_debug_marker    
      
      glPopGroupMarkerEXT();
      
#else
      throw std::runtime_error("OpenGL command 'glPopGroupMarkerEXT' not available on this platform");
#endif
    }

    void primitive_bounding_box_ext(float_t minX, float_t minY, float_t minZ, float_t minW, float_t maxX, float_t maxY, float_t maxZ, float_t maxW) {
#if GL_EXT_primitive_bounding_box    
      
      glPrimitiveBoundingBoxEXT(minX, minY, minZ, minW, maxX, maxY, maxZ, maxW);
      
#else
      throw std::runtime_error("OpenGL command 'glPrimitiveBoundingBoxEXT' not available on this platform");
#endif
    }

    void primitive_bounding_box_oes(float_t minX, float_t minY, float_t minZ, float_t minW, float_t maxX, float_t maxY, float_t maxZ, float_t maxW) {
#if GL_OES_primitive_bounding_box    
      
      glPrimitiveBoundingBoxOES(minX, minY, minZ, minW, maxX, maxY, maxZ, maxW);
      
#else
      throw std::runtime_error("OpenGL command 'glPrimitiveBoundingBoxOES' not available on this platform");
#endif
    }

    void program_binary_oes(uint_t program, enum_t binaryFormat, const void * binary, int_t length) {
#if GL_OES_get_program_binary    
      
      glProgramBinaryOES(program, binaryFormat, binary, length);
      
#else
      throw std::runtime_error("OpenGL command 'glProgramBinaryOES' not available on this platform");
#endif
    }

    void program_parameteri_ext(uint_t program, enum_t pname, int_t value) {
#if GL_EXT_separate_shader_objects    
      
      glProgramParameteriEXT(program, pname, value);
      
#else
      throw std::runtime_error("OpenGL command 'glProgramParameteriEXT' not available on this platform");
#endif
    }

    void program_path_fragment_input_gen_nv(uint_t program, int_t location, enum_t genMode, int_t components, const float_t * coeffs) {
#if GL_NV_path_rendering    
      
      glProgramPathFragmentInputGenNV(program, location, genMode, components, coeffs);
      
#else
      throw std::runtime_error("OpenGL command 'glProgramPathFragmentInputGenNV' not available on this platform");
#endif
    }

    void program_uniform_1f_ext(uint_t program, int_t location, float_t v0) {
#if GL_EXT_separate_shader_objects    
      
      glProgramUniform1fEXT(program, location, v0);
      
#else
      throw std::runtime_error("OpenGL command 'glProgramUniform1fEXT' not available on this platform");
#endif
    }

    void program_uniform_1fv_ext(uint_t program, int_t location, sizei_t count, const float_t * value) {
#if GL_EXT_separate_shader_objects    
      
      glProgramUniform1fvEXT(program, location, count, value);
      
#else
      throw std::runtime_error("OpenGL command 'glProgramUniform1fvEXT' not available on this platform");
#endif
    }

    void program_uniform_1i_ext(uint_t program, int_t location, int_t v0) {
#if GL_EXT_separate_shader_objects    
      
      glProgramUniform1iEXT(program, location, v0);
      
#else
      throw std::runtime_error("OpenGL command 'glProgramUniform1iEXT' not available on this platform");
#endif
    }

    void program_uniform_1iv_ext(uint_t program, int_t location, sizei_t count, const int_t * value) {
#if GL_EXT_separate_shader_objects    
      
      glProgramUniform1ivEXT(program, location, count, value);
      
#else
      throw std::runtime_error("OpenGL command 'glProgramUniform1ivEXT' not available on this platform");
#endif
    }

    void program_uniform_1ui_ext(uint_t program, int_t location, uint_t v0) {
#if GL_EXT_separate_shader_objects    
      
      glProgramUniform1uiEXT(program, location, v0);
      
#else
      throw std::runtime_error("OpenGL command 'glProgramUniform1uiEXT' not available on this platform");
#endif
    }

    void program_uniform_1uiv_ext(uint_t program, int_t location, sizei_t count, const uint_t * value) {
#if GL_EXT_separate_shader_objects    
      
      glProgramUniform1uivEXT(program, location, count, value);
      
#else
      throw std::runtime_error("OpenGL command 'glProgramUniform1uivEXT' not available on this platform");
#endif
    }

    void program_uniform_2f_ext(uint_t program, int_t location, float_t v0, float_t v1) {
#if GL_EXT_separate_shader_objects    
      
      glProgramUniform2fEXT(program, location, v0, v1);
      
#else
      throw std::runtime_error("OpenGL command 'glProgramUniform2fEXT' not available on this platform");
#endif
    }

    void program_uniform_2fv_ext(uint_t program, int_t location, sizei_t count, const float_t * value) {
#if GL_EXT_separate_shader_objects    
      
      glProgramUniform2fvEXT(program, location, count, value);
      
#else
      throw std::runtime_error("OpenGL command 'glProgramUniform2fvEXT' not available on this platform");
#endif
    }

    void program_uniform_2i_ext(uint_t program, int_t location, int_t v0, int_t v1) {
#if GL_EXT_separate_shader_objects    
      
      glProgramUniform2iEXT(program, location, v0, v1);
      
#else
      throw std::runtime_error("OpenGL command 'glProgramUniform2iEXT' not available on this platform");
#endif
    }

    void program_uniform_2iv_ext(uint_t program, int_t location, sizei_t count, const int_t * value) {
#if GL_EXT_separate_shader_objects    
      
      glProgramUniform2ivEXT(program, location, count, value);
      
#else
      throw std::runtime_error("OpenGL command 'glProgramUniform2ivEXT' not available on this platform");
#endif
    }

    void program_uniform_2ui_ext(uint_t program, int_t location, uint_t v0, uint_t v1) {
#if GL_EXT_separate_shader_objects    
      
      glProgramUniform2uiEXT(program, location, v0, v1);
      
#else
      throw std::runtime_error("OpenGL command 'glProgramUniform2uiEXT' not available on this platform");
#endif
    }

    void program_uniform_2uiv_ext(uint_t program, int_t location, sizei_t count, const uint_t * value) {
#if GL_EXT_separate_shader_objects    
      
      glProgramUniform2uivEXT(program, location, count, value);
      
#else
      throw std::runtime_error("OpenGL command 'glProgramUniform2uivEXT' not available on this platform");
#endif
    }

    void program_uniform_3f_ext(uint_t program, int_t location, float_t v0, float_t v1, float_t v2) {
#if GL_EXT_separate_shader_objects    
      
      glProgramUniform3fEXT(program, location, v0, v1, v2);
      
#else
      throw std::runtime_error("OpenGL command 'glProgramUniform3fEXT' not available on this platform");
#endif
    }

    void program_uniform_3fv_ext(uint_t program, int_t location, sizei_t count, const float_t * value) {
#if GL_EXT_separate_shader_objects    
      
      glProgramUniform3fvEXT(program, location, count, value);
      
#else
      throw std::runtime_error("OpenGL command 'glProgramUniform3fvEXT' not available on this platform");
#endif
    }

    void program_uniform_3i_ext(uint_t program, int_t location, int_t v0, int_t v1, int_t v2) {
#if GL_EXT_separate_shader_objects    
      
      glProgramUniform3iEXT(program, location, v0, v1, v2);
      
#else
      throw std::runtime_error("OpenGL command 'glProgramUniform3iEXT' not available on this platform");
#endif
    }

    void program_uniform_3iv_ext(uint_t program, int_t location, sizei_t count, const int_t * value) {
#if GL_EXT_separate_shader_objects    
      
      glProgramUniform3ivEXT(program, location, count, value);
      
#else
      throw std::runtime_error("OpenGL command 'glProgramUniform3ivEXT' not available on this platform");
#endif
    }

    void program_uniform_3ui_ext(uint_t program, int_t location, uint_t v0, uint_t v1, uint_t v2) {
#if GL_EXT_separate_shader_objects    
      
      glProgramUniform3uiEXT(program, location, v0, v1, v2);
      
#else
      throw std::runtime_error("OpenGL command 'glProgramUniform3uiEXT' not available on this platform");
#endif
    }

    void program_uniform_3uiv_ext(uint_t program, int_t location, sizei_t count, const uint_t * value) {
#if GL_EXT_separate_shader_objects    
      
      glProgramUniform3uivEXT(program, location, count, value);
      
#else
      throw std::runtime_error("OpenGL command 'glProgramUniform3uivEXT' not available on this platform");
#endif
    }

    void program_uniform_4f_ext(uint_t program, int_t location, float_t v0, float_t v1, float_t v2, float_t v3) {
#if GL_EXT_separate_shader_objects    
      
      glProgramUniform4fEXT(program, location, v0, v1, v2, v3);
      
#else
      throw std::runtime_error("OpenGL command 'glProgramUniform4fEXT' not available on this platform");
#endif
    }

    void program_uniform_4fv_ext(uint_t program, int_t location, sizei_t count, const float_t * value) {
#if GL_EXT_separate_shader_objects    
      
      glProgramUniform4fvEXT(program, location, count, value);
      
#else
      throw std::runtime_error("OpenGL command 'glProgramUniform4fvEXT' not available on this platform");
#endif
    }

    void program_uniform_4i_ext(uint_t program, int_t location, int_t v0, int_t v1, int_t v2, int_t v3) {
#if GL_EXT_separate_shader_objects    
      
      glProgramUniform4iEXT(program, location, v0, v1, v2, v3);
      
#else
      throw std::runtime_error("OpenGL command 'glProgramUniform4iEXT' not available on this platform");
#endif
    }

    void program_uniform_4iv_ext(uint_t program, int_t location, sizei_t count, const int_t * value) {
#if GL_EXT_separate_shader_objects    
      
      glProgramUniform4ivEXT(program, location, count, value);
      
#else
      throw std::runtime_error("OpenGL command 'glProgramUniform4ivEXT' not available on this platform");
#endif
    }

    void program_uniform_4ui_ext(uint_t program, int_t location, uint_t v0, uint_t v1, uint_t v2, uint_t v3) {
#if GL_EXT_separate_shader_objects    
      
      glProgramUniform4uiEXT(program, location, v0, v1, v2, v3);
      
#else
      throw std::runtime_error("OpenGL command 'glProgramUniform4uiEXT' not available on this platform");
#endif
    }

    void program_uniform_4uiv_ext(uint_t program, int_t location, sizei_t count, const uint_t * value) {
#if GL_EXT_separate_shader_objects    
      
      glProgramUniform4uivEXT(program, location, count, value);
      
#else
      throw std::runtime_error("OpenGL command 'glProgramUniform4uivEXT' not available on this platform");
#endif
    }

    void program_uniform_handleui_64nv(uint_t program, int_t location, uint64_t value) {
#if GL_NV_bindless_texture    
      
      glProgramUniformHandleui64NV(program, location, value);
      
#else
      throw std::runtime_error("OpenGL command 'glProgramUniformHandleui64NV' not available on this platform");
#endif
    }

    void program_uniform_handleui_64v_nv(uint_t program, int_t location, sizei_t count, const uint64_t * values) {
#if GL_NV_bindless_texture    
      
      glProgramUniformHandleui64vNV(program, location, count, values);
      
#else
      throw std::runtime_error("OpenGL command 'glProgramUniformHandleui64vNV' not available on this platform");
#endif
    }

    void program_uniform_matrix_2fv_ext(uint_t program, int_t location, sizei_t count, boolean_t transpose, const float_t * value) {
#if GL_EXT_separate_shader_objects    
      
      glProgramUniformMatrix2fvEXT(program, location, count, static_cast<GLboolean>(transpose), value);
      
#else
      throw std::runtime_error("OpenGL command 'glProgramUniformMatrix2fvEXT' not available on this platform");
#endif
    }

    void program_uniform_matrix_2x_3fv_ext(uint_t program, int_t location, sizei_t count, boolean_t transpose, const float_t * value) {
#if GL_EXT_separate_shader_objects    
      
      glProgramUniformMatrix2x3fvEXT(program, location, count, static_cast<GLboolean>(transpose), value);
      
#else
      throw std::runtime_error("OpenGL command 'glProgramUniformMatrix2x3fvEXT' not available on this platform");
#endif
    }

    void program_uniform_matrix_2x_4fv_ext(uint_t program, int_t location, sizei_t count, boolean_t transpose, const float_t * value) {
#if GL_EXT_separate_shader_objects    
      
      glProgramUniformMatrix2x4fvEXT(program, location, count, static_cast<GLboolean>(transpose), value);
      
#else
      throw std::runtime_error("OpenGL command 'glProgramUniformMatrix2x4fvEXT' not available on this platform");
#endif
    }

    void program_uniform_matrix_3fv_ext(uint_t program, int_t location, sizei_t count, boolean_t transpose, const float_t * value) {
#if GL_EXT_separate_shader_objects    
      
      glProgramUniformMatrix3fvEXT(program, location, count, static_cast<GLboolean>(transpose), value);
      
#else
      throw std::runtime_error("OpenGL command 'glProgramUniformMatrix3fvEXT' not available on this platform");
#endif
    }

    void program_uniform_matrix_3x_2fv_ext(uint_t program, int_t location, sizei_t count, boolean_t transpose, const float_t * value) {
#if GL_EXT_separate_shader_objects    
      
      glProgramUniformMatrix3x2fvEXT(program, location, count, static_cast<GLboolean>(transpose), value);
      
#else
      throw std::runtime_error("OpenGL command 'glProgramUniformMatrix3x2fvEXT' not available on this platform");
#endif
    }

    void program_uniform_matrix_3x_4fv_ext(uint_t program, int_t location, sizei_t count, boolean_t transpose, const float_t * value) {
#if GL_EXT_separate_shader_objects    
      
      glProgramUniformMatrix3x4fvEXT(program, location, count, static_cast<GLboolean>(transpose), value);
      
#else
      throw std::runtime_error("OpenGL command 'glProgramUniformMatrix3x4fvEXT' not available on this platform");
#endif
    }

    void program_uniform_matrix_4fv_ext(uint_t program, int_t location, sizei_t count, boolean_t transpose, const float_t * value) {
#if GL_EXT_separate_shader_objects    
      
      glProgramUniformMatrix4fvEXT(program, location, count, static_cast<GLboolean>(transpose), value);
      
#else
      throw std::runtime_error("OpenGL command 'glProgramUniformMatrix4fvEXT' not available on this platform");
#endif
    }

    void program_uniform_matrix_4x_2fv_ext(uint_t program, int_t location, sizei_t count, boolean_t transpose, const float_t * value) {
#if GL_EXT_separate_shader_objects    
      
      glProgramUniformMatrix4x2fvEXT(program, location, count, static_cast<GLboolean>(transpose), value);
      
#else
      throw std::runtime_error("OpenGL command 'glProgramUniformMatrix4x2fvEXT' not available on this platform");
#endif
    }

    void program_uniform_matrix_4x_3fv_ext(uint_t program, int_t location, sizei_t count, boolean_t transpose, const float_t * value) {
#if GL_EXT_separate_shader_objects    
      
      glProgramUniformMatrix4x3fvEXT(program, location, count, static_cast<GLboolean>(transpose), value);
      
#else
      throw std::runtime_error("OpenGL command 'glProgramUniformMatrix4x3fvEXT' not available on this platform");
#endif
    }

    void push_debug_group_khr(enum_t source, uint_t id, sizei_t length, const char_t * message) {
#if GL_KHR_debug    
      
      glPushDebugGroupKHR(source, id, length, message);
      
#else
      throw std::runtime_error("OpenGL command 'glPushDebugGroupKHR' not available on this platform");
#endif
    }

    void push_group_marker_ext(sizei_t length, const char_t * marker) {
#if GL_EXT_debug_marker    
      
      glPushGroupMarkerEXT(length, marker);
      
#else
      throw std::runtime_error("OpenGL command 'glPushGroupMarkerEXT' not available on this platform");
#endif
    }

    void query_counter_ext(uint_t id, framebuffer_target_t target) {
#if GL_EXT_disjoint_timer_query    
      
      glQueryCounterEXT(id, static_cast<GLenum>(target));
      
#else
      throw std::runtime_error("OpenGL command 'glQueryCounterEXT' not available on this platform");
#endif
    }

    void read_buffer_indexed_ext(enum_t src, int_t index) {
#if GL_EXT_multiview_draw_buffers    
      
      glReadBufferIndexedEXT(src, index);
      
#else
      throw std::runtime_error("OpenGL command 'glReadBufferIndexedEXT' not available on this platform");
#endif
    }

    void read_buffer_nv(blend_equation_mode_t mode) {
#if GL_NV_read_buffer    
      
      glReadBufferNV(static_cast<GLenum>(mode));
      
#else
      throw std::runtime_error("OpenGL command 'glReadBufferNV' not available on this platform");
#endif
    }

    void readn_pixels_ext(int_t x, int_t y, sizei_t width, sizei_t height, pixel_format_t format, draw_elements_type_t type, sizei_t bufSize, void * data) {
#if GL_EXT_robustness    
      
      glReadnPixelsEXT(x, y, width, height, static_cast<GLenum>(format), static_cast<GLenum>(type), bufSize, data);
      
#else
      throw std::runtime_error("OpenGL command 'glReadnPixelsEXT' not available on this platform");
#endif
    }

    void readn_pixels_khr(int_t x, int_t y, sizei_t width, sizei_t height, pixel_format_t format, pixel_type_t type, sizei_t bufSize, void * data) {
#if GL_KHR_robustness    
      
      glReadnPixelsKHR(x, y, width, height, static_cast<GLenum>(format), static_cast<GLenum>(type), bufSize, data);
      
#else
      throw std::runtime_error("OpenGL command 'glReadnPixelsKHR' not available on this platform");
#endif
    }

    void renderbuffer_storage_multisample_angle(framebuffer_target_t target, sizei_t samples, internal_format_t internalformat, sizei_t width, sizei_t height) {
#if GL_ANGLE_framebuffer_multisample    
      
      glRenderbufferStorageMultisampleANGLE(static_cast<GLenum>(target), samples, static_cast<GLenum>(internalformat), width, height);
      
#else
      throw std::runtime_error("OpenGL command 'glRenderbufferStorageMultisampleANGLE' not available on this platform");
#endif
    }

    void renderbuffer_storage_multisample_apple(framebuffer_target_t target, sizei_t samples, internal_format_t internalformat, sizei_t width, sizei_t height) {
#if GL_APPLE_framebuffer_multisample    
      
      glRenderbufferStorageMultisampleAPPLE(static_cast<GLenum>(target), samples, static_cast<GLenum>(internalformat), width, height);
      
#else
      throw std::runtime_error("OpenGL command 'glRenderbufferStorageMultisampleAPPLE' not available on this platform");
#endif
    }

    void renderbuffer_storage_multisample_ext(framebuffer_target_t target, sizei_t samples, internal_format_t internalformat, sizei_t width, sizei_t height) {
#if GL_EXT_multisampled_render_to_texture    
      
      glRenderbufferStorageMultisampleEXT(static_cast<GLenum>(target), samples, static_cast<GLenum>(internalformat), width, height);
      
#else
      throw std::runtime_error("OpenGL command 'glRenderbufferStorageMultisampleEXT' not available on this platform");
#endif
    }

    void renderbuffer_storage_multisample_img(framebuffer_target_t target, sizei_t samples, internal_format_t internalformat, sizei_t width, sizei_t height) {
#if GL_IMG_multisampled_render_to_texture    
      
      glRenderbufferStorageMultisampleIMG(static_cast<GLenum>(target), samples, static_cast<GLenum>(internalformat), width, height);
      
#else
      throw std::runtime_error("OpenGL command 'glRenderbufferStorageMultisampleIMG' not available on this platform");
#endif
    }

    void renderbuffer_storage_multisample_nv(framebuffer_target_t target, sizei_t samples, internal_format_t internalformat, sizei_t width, sizei_t height) {
#if GL_NV_framebuffer_multisample    
      
      glRenderbufferStorageMultisampleNV(static_cast<GLenum>(target), samples, static_cast<GLenum>(internalformat), width, height);
      
#else
      throw std::runtime_error("OpenGL command 'glRenderbufferStorageMultisampleNV' not available on this platform");
#endif
    }

    void resolve_multisample_framebuffer_apple() {
#if GL_APPLE_framebuffer_multisample    
      
      glResolveMultisampleFramebufferAPPLE();
      
#else
      throw std::runtime_error("OpenGL command 'glResolveMultisampleFramebufferAPPLE' not available on this platform");
#endif
    }

    void sampler_parameter_iiv_ext(uint_t sampler, get_pointerv_p_name_t pname, const int_t * param) {
#if GL_EXT_texture_border_clamp    
      
      glSamplerParameterIivEXT(sampler, static_cast<GLenum>(pname), param);
      
#else
      throw std::runtime_error("OpenGL command 'glSamplerParameterIivEXT' not available on this platform");
#endif
    }

    void sampler_parameter_iiv_oes(uint_t sampler, get_pointerv_p_name_t pname, const int_t * param) {
#if GL_OES_texture_border_clamp    
      
      glSamplerParameterIivOES(sampler, static_cast<GLenum>(pname), param);
      
#else
      throw std::runtime_error("OpenGL command 'glSamplerParameterIivOES' not available on this platform");
#endif
    }

    void sampler_parameter_iuiv_ext(uint_t sampler, get_pointerv_p_name_t pname, const uint_t * param) {
#if GL_EXT_texture_border_clamp    
      
      glSamplerParameterIuivEXT(sampler, static_cast<GLenum>(pname), param);
      
#else
      throw std::runtime_error("OpenGL command 'glSamplerParameterIuivEXT' not available on this platform");
#endif
    }

    void sampler_parameter_iuiv_oes(uint_t sampler, get_pointerv_p_name_t pname, const uint_t * param) {
#if GL_OES_texture_border_clamp    
      
      glSamplerParameterIuivOES(sampler, static_cast<GLenum>(pname), param);
      
#else
      throw std::runtime_error("OpenGL command 'glSamplerParameterIuivOES' not available on this platform");
#endif
    }

    void scissor_arrayv_nv(uint_t first, sizei_t count, const int_t * v) {
#if GL_NV_viewport_array    
      
      glScissorArrayvNV(first, count, v);
      
#else
      throw std::runtime_error("OpenGL command 'glScissorArrayvNV' not available on this platform");
#endif
    }

    void scissor_indexed_nv(uint_t index, int_t left, int_t bottom, sizei_t width, sizei_t height) {
#if GL_NV_viewport_array    
      
      glScissorIndexedNV(index, left, bottom, width, height);
      
#else
      throw std::runtime_error("OpenGL command 'glScissorIndexedNV' not available on this platform");
#endif
    }

    void scissor_indexedv_nv(uint_t index, const int_t * v) {
#if GL_NV_viewport_array    
      
      glScissorIndexedvNV(index, v);
      
#else
      throw std::runtime_error("OpenGL command 'glScissorIndexedvNV' not available on this platform");
#endif
    }

    void select_perf_monitor_counters_amd(uint_t monitor, boolean_t enable, uint_t group, int_t numCounters, uint_t * counterList) {
#if GL_AMD_performance_monitor    
      
      glSelectPerfMonitorCountersAMD(monitor, static_cast<GLboolean>(enable), group, numCounters, counterList);
      
#else
      throw std::runtime_error("OpenGL command 'glSelectPerfMonitorCountersAMD' not available on this platform");
#endif
    }

    void set_fence_nv(uint_t fence, enum_t condition) {
#if GL_NV_fence    
      
      glSetFenceNV(fence, condition);
      
#else
      throw std::runtime_error("OpenGL command 'glSetFenceNV' not available on this platform");
#endif
    }

    void start_tiling_qcom(uint_t x, uint_t y, uint_t width, uint_t height, bitfield_t preserveMask) {
#if GL_QCOM_tiled_rendering    
      
      glStartTilingQCOM(x, y, width, height, preserveMask);
      
#else
      throw std::runtime_error("OpenGL command 'glStartTilingQCOM' not available on this platform");
#endif
    }

    void stencil_fill_path_instanced_nv(sizei_t numPaths, enum_t pathNameType, const void * paths, uint_t pathBase, enum_t fillMode, uint_t mask, enum_t transformType, const float_t * transformValues) {
#if GL_NV_path_rendering    
      
      glStencilFillPathInstancedNV(numPaths, pathNameType, paths, pathBase, fillMode, mask, transformType, transformValues);
      
#else
      throw std::runtime_error("OpenGL command 'glStencilFillPathInstancedNV' not available on this platform");
#endif
    }

    void stencil_fill_path_nv(uint_t path, enum_t fillMode, uint_t mask) {
#if GL_NV_path_rendering    
      
      glStencilFillPathNV(path, fillMode, mask);
      
#else
      throw std::runtime_error("OpenGL command 'glStencilFillPathNV' not available on this platform");
#endif
    }

    void stencil_stroke_path_instanced_nv(sizei_t numPaths, enum_t pathNameType, const void * paths, uint_t pathBase, int_t reference, uint_t mask, enum_t transformType, const float_t * transformValues) {
#if GL_NV_path_rendering    
      
      glStencilStrokePathInstancedNV(numPaths, pathNameType, paths, pathBase, reference, mask, transformType, transformValues);
      
#else
      throw std::runtime_error("OpenGL command 'glStencilStrokePathInstancedNV' not available on this platform");
#endif
    }

    void stencil_stroke_path_nv(uint_t path, int_t reference, uint_t mask) {
#if GL_NV_path_rendering    
      
      glStencilStrokePathNV(path, reference, mask);
      
#else
      throw std::runtime_error("OpenGL command 'glStencilStrokePathNV' not available on this platform");
#endif
    }

    void stencil_then_cover_fill_path_instanced_nv(sizei_t numPaths, enum_t pathNameType, const void * paths, uint_t pathBase, enum_t fillMode, uint_t mask, enum_t coverMode, enum_t transformType, const float_t * transformValues) {
#if GL_NV_path_rendering    
      
      glStencilThenCoverFillPathInstancedNV(numPaths, pathNameType, paths, pathBase, fillMode, mask, coverMode, transformType, transformValues);
      
#else
      throw std::runtime_error("OpenGL command 'glStencilThenCoverFillPathInstancedNV' not available on this platform");
#endif
    }

    void stencil_then_cover_fill_path_nv(uint_t path, enum_t fillMode, uint_t mask, enum_t coverMode) {
#if GL_NV_path_rendering    
      
      glStencilThenCoverFillPathNV(path, fillMode, mask, coverMode);
      
#else
      throw std::runtime_error("OpenGL command 'glStencilThenCoverFillPathNV' not available on this platform");
#endif
    }

    void stencil_then_cover_stroke_path_instanced_nv(sizei_t numPaths, enum_t pathNameType, const void * paths, uint_t pathBase, int_t reference, uint_t mask, enum_t coverMode, enum_t transformType, const float_t * transformValues) {
#if GL_NV_path_rendering    
      
      glStencilThenCoverStrokePathInstancedNV(numPaths, pathNameType, paths, pathBase, reference, mask, coverMode, transformType, transformValues);
      
#else
      throw std::runtime_error("OpenGL command 'glStencilThenCoverStrokePathInstancedNV' not available on this platform");
#endif
    }

    void stencil_then_cover_stroke_path_nv(uint_t path, int_t reference, uint_t mask, enum_t coverMode) {
#if GL_NV_path_rendering    
      
      glStencilThenCoverStrokePathNV(path, reference, mask, coverMode);
      
#else
      throw std::runtime_error("OpenGL command 'glStencilThenCoverStrokePathNV' not available on this platform");
#endif
    }

    boolean_t test_fence_nv(uint_t fence) {
#if GL_NV_fence    
      
      return static_cast<boolean_t>(glTestFenceNV(fence));
      
#else
      throw std::runtime_error("OpenGL command 'glTestFenceNV' not available on this platform");
#endif
    }

    void tex_buffer_ext(texture_target_t target, internal_format_t internalformat, uint_t buffer) {
#if GL_EXT_texture_buffer    
      
      glTexBufferEXT(static_cast<GLenum>(target), static_cast<GLenum>(internalformat), buffer);
      
#else
      throw std::runtime_error("OpenGL command 'glTexBufferEXT' not available on this platform");
#endif
    }

    void tex_buffer_oes(texture_target_t target, internal_format_t internalformat, uint_t buffer) {
#if GL_OES_texture_buffer    
      
      glTexBufferOES(static_cast<GLenum>(target), static_cast<GLenum>(internalformat), buffer);
      
#else
      throw std::runtime_error("OpenGL command 'glTexBufferOES' not available on this platform");
#endif
    }

    void tex_buffer_range_ext(framebuffer_target_t target, internal_format_t internalformat, uint_t buffer, intptr_t offset, sizeiptr_t size) {
#if GL_EXT_texture_buffer    
      
      glTexBufferRangeEXT(static_cast<GLenum>(target), static_cast<GLenum>(internalformat), buffer, offset, size);
      
#else
      throw std::runtime_error("OpenGL command 'glTexBufferRangeEXT' not available on this platform");
#endif
    }

    void tex_buffer_range_oes(framebuffer_target_t target, internal_format_t internalformat, uint_t buffer, intptr_t offset, sizeiptr_t size) {
#if GL_OES_texture_buffer    
      
      glTexBufferRangeOES(static_cast<GLenum>(target), static_cast<GLenum>(internalformat), buffer, offset, size);
      
#else
      throw std::runtime_error("OpenGL command 'glTexBufferRangeOES' not available on this platform");
#endif
    }

    void tex_image_3does(framebuffer_target_t target, int_t level, internal_format_t internalformat, sizei_t width, sizei_t height, sizei_t depth, int_t border, pixel_format_t format, draw_elements_type_t type, const void * pixels) {
#if GL_OES_texture_3D    
      
      glTexImage3DOES(static_cast<GLenum>(target), level, static_cast<GLenum>(internalformat), width, height, depth, border, static_cast<GLenum>(format), static_cast<GLenum>(type), pixels);
      
#else
      throw std::runtime_error("OpenGL command 'glTexImage3DOES' not available on this platform");
#endif
    }

    void tex_parameter_iiv_ext(texture_target_t target, texture_parameter_name_t pname, const int_t * params) {
#if GL_EXT_texture_border_clamp    
      
      glTexParameterIivEXT(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      
#else
      throw std::runtime_error("OpenGL command 'glTexParameterIivEXT' not available on this platform");
#endif
    }

    void tex_parameter_iiv_oes(texture_target_t target, texture_parameter_name_t pname, const int_t * params) {
#if GL_OES_texture_border_clamp    
      
      glTexParameterIivOES(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      
#else
      throw std::runtime_error("OpenGL command 'glTexParameterIivOES' not available on this platform");
#endif
    }

    void tex_parameter_iuiv_ext(texture_target_t target, texture_parameter_name_t pname, const uint_t * params) {
#if GL_EXT_texture_border_clamp    
      
      glTexParameterIuivEXT(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      
#else
      throw std::runtime_error("OpenGL command 'glTexParameterIuivEXT' not available on this platform");
#endif
    }

    void tex_parameter_iuiv_oes(texture_target_t target, texture_parameter_name_t pname, const uint_t * params) {
#if GL_OES_texture_border_clamp    
      
      glTexParameterIuivOES(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      
#else
      throw std::runtime_error("OpenGL command 'glTexParameterIuivOES' not available on this platform");
#endif
    }

    void tex_storage_1dext(framebuffer_target_t target, sizei_t levels, internal_format_t internalformat, sizei_t width) {
#if GL_EXT_texture_storage    
      
      glTexStorage1DEXT(static_cast<GLenum>(target), levels, static_cast<GLenum>(internalformat), width);
      
#else
      throw std::runtime_error("OpenGL command 'glTexStorage1DEXT' not available on this platform");
#endif
    }

    void tex_storage_2dext(framebuffer_target_t target, sizei_t levels, internal_format_t internalformat, sizei_t width, sizei_t height) {
#if GL_EXT_texture_storage    
      
      glTexStorage2DEXT(static_cast<GLenum>(target), levels, static_cast<GLenum>(internalformat), width, height);
      
#else
      throw std::runtime_error("OpenGL command 'glTexStorage2DEXT' not available on this platform");
#endif
    }

    void tex_storage_3dext(framebuffer_target_t target, sizei_t levels, internal_format_t internalformat, sizei_t width, sizei_t height, sizei_t depth) {
#if GL_EXT_texture_storage    
      
      glTexStorage3DEXT(static_cast<GLenum>(target), levels, static_cast<GLenum>(internalformat), width, height, depth);
      
#else
      throw std::runtime_error("OpenGL command 'glTexStorage3DEXT' not available on this platform");
#endif
    }

    void tex_storage_3d_multisample_oes(framebuffer_target_t target, sizei_t samples, internal_format_t internalformat, sizei_t width, sizei_t height, sizei_t depth, boolean_t fixedsamplelocations) {
#if GL_OES_texture_storage_multisample_2d_array    
      
      glTexStorage3DMultisampleOES(static_cast<GLenum>(target), samples, static_cast<GLenum>(internalformat), width, height, depth, static_cast<GLboolean>(fixedsamplelocations));
      
#else
      throw std::runtime_error("OpenGL command 'glTexStorage3DMultisampleOES' not available on this platform");
#endif
    }

    void tex_sub_image_3does(framebuffer_target_t target, int_t level, int_t xoffset, int_t yoffset, int_t zoffset, sizei_t width, sizei_t height, sizei_t depth, pixel_format_t format, draw_elements_type_t type, const void * pixels) {
#if GL_OES_texture_3D    
      
      glTexSubImage3DOES(static_cast<GLenum>(target), level, xoffset, yoffset, zoffset, width, height, depth, static_cast<GLenum>(format), static_cast<GLenum>(type), pixels);
      
#else
      throw std::runtime_error("OpenGL command 'glTexSubImage3DOES' not available on this platform");
#endif
    }

    void texture_storage_1dext(uint_t texture, framebuffer_target_t target, sizei_t levels, internal_format_t internalformat, sizei_t width) {
#if GL_EXT_texture_storage    
      
      glTextureStorage1DEXT(texture, static_cast<GLenum>(target), levels, static_cast<GLenum>(internalformat), width);
      
#else
      throw std::runtime_error("OpenGL command 'glTextureStorage1DEXT' not available on this platform");
#endif
    }

    void texture_storage_2dext(uint_t texture, framebuffer_target_t target, sizei_t levels, internal_format_t internalformat, sizei_t width, sizei_t height) {
#if GL_EXT_texture_storage    
      
      glTextureStorage2DEXT(texture, static_cast<GLenum>(target), levels, static_cast<GLenum>(internalformat), width, height);
      
#else
      throw std::runtime_error("OpenGL command 'glTextureStorage2DEXT' not available on this platform");
#endif
    }

    void texture_storage_3dext(uint_t texture, framebuffer_target_t target, sizei_t levels, internal_format_t internalformat, sizei_t width, sizei_t height, sizei_t depth) {
#if GL_EXT_texture_storage    
      
      glTextureStorage3DEXT(texture, static_cast<GLenum>(target), levels, static_cast<GLenum>(internalformat), width, height, depth);
      
#else
      throw std::runtime_error("OpenGL command 'glTextureStorage3DEXT' not available on this platform");
#endif
    }

    void texture_view_ext(uint_t texture, framebuffer_target_t target, uint_t origtexture, internal_format_t internalformat, uint_t minlevel, uint_t numlevels, uint_t minlayer, uint_t numlayers) {
#if GL_EXT_texture_view    
      
      glTextureViewEXT(texture, static_cast<GLenum>(target), origtexture, static_cast<GLenum>(internalformat), minlevel, numlevels, minlayer, numlayers);
      
#else
      throw std::runtime_error("OpenGL command 'glTextureViewEXT' not available on this platform");
#endif
    }

    void texture_view_oes(uint_t texture, framebuffer_target_t target, uint_t origtexture, internal_format_t internalformat, uint_t minlevel, uint_t numlevels, uint_t minlayer, uint_t numlayers) {
#if GL_OES_texture_view    
      
      glTextureViewOES(texture, static_cast<GLenum>(target), origtexture, static_cast<GLenum>(internalformat), minlevel, numlevels, minlayer, numlayers);
      
#else
      throw std::runtime_error("OpenGL command 'glTextureViewOES' not available on this platform");
#endif
    }

    void transform_path_nv(uint_t resultPath, uint_t srcPath, enum_t transformType, const float_t * transformValues) {
#if GL_NV_path_rendering    
      
      glTransformPathNV(resultPath, srcPath, transformType, transformValues);
      
#else
      throw std::runtime_error("OpenGL command 'glTransformPathNV' not available on this platform");
#endif
    }

    void uniform_handleui_64nv(int_t location, uint64_t value) {
#if GL_NV_bindless_texture    
      
      glUniformHandleui64NV(location, value);
      
#else
      throw std::runtime_error("OpenGL command 'glUniformHandleui64NV' not available on this platform");
#endif
    }

    void uniform_handleui_64v_nv(int_t location, sizei_t count, const uint64_t * value) {
#if GL_NV_bindless_texture    
      
      glUniformHandleui64vNV(location, count, value);
      
#else
      throw std::runtime_error("OpenGL command 'glUniformHandleui64vNV' not available on this platform");
#endif
    }

    void uniform_matrix_2x_3fv_nv(int_t location, sizei_t count, boolean_t transpose, const float_t * value) {
#if GL_NV_non_square_matrices    
      
      glUniformMatrix2x3fvNV(location, count, static_cast<GLboolean>(transpose), value);
      
#else
      throw std::runtime_error("OpenGL command 'glUniformMatrix2x3fvNV' not available on this platform");
#endif
    }

    void uniform_matrix_2x_4fv_nv(int_t location, sizei_t count, boolean_t transpose, const float_t * value) {
#if GL_NV_non_square_matrices    
      
      glUniformMatrix2x4fvNV(location, count, static_cast<GLboolean>(transpose), value);
      
#else
      throw std::runtime_error("OpenGL command 'glUniformMatrix2x4fvNV' not available on this platform");
#endif
    }

    void uniform_matrix_3x_2fv_nv(int_t location, sizei_t count, boolean_t transpose, const float_t * value) {
#if GL_NV_non_square_matrices    
      
      glUniformMatrix3x2fvNV(location, count, static_cast<GLboolean>(transpose), value);
      
#else
      throw std::runtime_error("OpenGL command 'glUniformMatrix3x2fvNV' not available on this platform");
#endif
    }

    void uniform_matrix_3x_4fv_nv(int_t location, sizei_t count, boolean_t transpose, const float_t * value) {
#if GL_NV_non_square_matrices    
      
      glUniformMatrix3x4fvNV(location, count, static_cast<GLboolean>(transpose), value);
      
#else
      throw std::runtime_error("OpenGL command 'glUniformMatrix3x4fvNV' not available on this platform");
#endif
    }

    void uniform_matrix_4x_2fv_nv(int_t location, sizei_t count, boolean_t transpose, const float_t * value) {
#if GL_NV_non_square_matrices    
      
      glUniformMatrix4x2fvNV(location, count, static_cast<GLboolean>(transpose), value);
      
#else
      throw std::runtime_error("OpenGL command 'glUniformMatrix4x2fvNV' not available on this platform");
#endif
    }

    void uniform_matrix_4x_3fv_nv(int_t location, sizei_t count, boolean_t transpose, const float_t * value) {
#if GL_NV_non_square_matrices    
      
      glUniformMatrix4x3fvNV(location, count, static_cast<GLboolean>(transpose), value);
      
#else
      throw std::runtime_error("OpenGL command 'glUniformMatrix4x3fvNV' not available on this platform");
#endif
    }

    boolean_t unmap_buffer_oes(framebuffer_target_t target) {
#if GL_OES_mapbuffer    
      
      return static_cast<boolean_t>(glUnmapBufferOES(static_cast<GLenum>(target)));
      
#else
      throw std::runtime_error("OpenGL command 'glUnmapBufferOES' not available on this platform");
#endif
    }

    void use_program_stages_ext(uint_t pipeline, bitmask<use_program_stage_flags_t> stages, uint_t program) {
#if GL_EXT_separate_shader_objects    
      
      glUseProgramStagesEXT(pipeline, static_cast<GLbitfield>(stages.value), program);
      
#else
      throw std::runtime_error("OpenGL command 'glUseProgramStagesEXT' not available on this platform");
#endif
    }

    void validate_program_pipeline_ext(uint_t pipeline) {
#if GL_EXT_separate_shader_objects    
      
      glValidateProgramPipelineEXT(pipeline);
      
#else
      throw std::runtime_error("OpenGL command 'glValidateProgramPipelineEXT' not available on this platform");
#endif
    }

    void vertex_attrib_divisor_angle(uint_t index, uint_t divisor) {
#if GL_ANGLE_instanced_arrays    
      
      glVertexAttribDivisorANGLE(index, divisor);
      
#else
      throw std::runtime_error("OpenGL command 'glVertexAttribDivisorANGLE' not available on this platform");
#endif
    }

    void vertex_attrib_divisor_ext(uint_t index, uint_t divisor) {
#if GL_EXT_instanced_arrays    
      
      glVertexAttribDivisorEXT(index, divisor);
      
#else
      throw std::runtime_error("OpenGL command 'glVertexAttribDivisorEXT' not available on this platform");
#endif
    }

    void vertex_attrib_divisor_nv(uint_t index, uint_t divisor) {
#if GL_NV_instanced_arrays    
      
      glVertexAttribDivisorNV(index, divisor);
      
#else
      throw std::runtime_error("OpenGL command 'glVertexAttribDivisorNV' not available on this platform");
#endif
    }

    void viewport_arrayv_nv(uint_t first, sizei_t count, const float_t * v) {
#if GL_NV_viewport_array    
      
      glViewportArrayvNV(first, count, v);
      
#else
      throw std::runtime_error("OpenGL command 'glViewportArrayvNV' not available on this platform");
#endif
    }

    void viewport_indexedf_nv(uint_t index, float_t x, float_t y, float_t w, float_t h) {
#if GL_NV_viewport_array    
      
      glViewportIndexedfNV(index, x, y, w, h);
      
#else
      throw std::runtime_error("OpenGL command 'glViewportIndexedfNV' not available on this platform");
#endif
    }

    void viewport_indexedfv_nv(uint_t index, const float_t * v) {
#if GL_NV_viewport_array    
      
      glViewportIndexedfvNV(index, v);
      
#else
      throw std::runtime_error("OpenGL command 'glViewportIndexedfvNV' not available on this platform");
#endif
    }

    void wait_sync_apple(sync_t sync, bitfield_t flags, uint64_t timeout) {
#if GL_APPLE_sync    
      
      glWaitSyncAPPLE(sync, flags, timeout);
      
#else
      throw std::runtime_error("OpenGL command 'glWaitSyncAPPLE' not available on this platform");
#endif
    }

    void weight_paths_nv(uint_t resultPath, sizei_t numPaths, const uint_t * paths, const float_t * weights) {
#if GL_NV_path_rendering    
      
      glWeightPathsNV(resultPath, numPaths, paths, weights);
      
#else
      throw std::runtime_error("OpenGL command 'glWeightPathsNV' not available on this platform");
#endif
    }

}
