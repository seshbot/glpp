/**
 * This file was autogenerated by glgen (https://github.com/seshbot/glgen) on 2015-03-10
 * Command line: src/gen.py assets/gl.xml -p assets/gl-patch.xml -o ../glpp/ --includesubdir include/glpp --sourcesubdir src --namespace gles2 --force --cpp --es2only --synth
 */

#include <glad/glad.h>
#include <stdexcept>
#include <glpp/gles2/extensions.h>


namespace gles2 {
    void active_shader_program_ext(gl::uint_t pipeline, gl::uint_t program) {
      if ( GLAD_GL_EXT_separate_shader_objects ) {
        glActiveShaderProgramEXT(pipeline, program);
      }
      else {
        throw std::runtime_error("OpenGL command 'glActiveShaderProgramEXT' not available on this platform (extensions: GL_EXT_separate_shader_objects)");
      }
    }

    void alpha_func_qcom(alpha_function_t func, gl::clampf_t ref) {
      if ( GLAD_GL_QCOM_alpha_test ) {
        glAlphaFuncQCOM(static_cast<GLenum>(func), ref);
      }
      else {
        throw std::runtime_error("OpenGL command 'glAlphaFuncQCOM' not available on this platform (extensions: GL_QCOM_alpha_test)");
      }
    }

    void begin_conditional_render_nv(gl::uint_t id, gl::enum_t mode) {
      if ( GLAD_GL_NV_conditional_render ) {
        glBeginConditionalRenderNV(id, mode);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBeginConditionalRenderNV' not available on this platform (extensions: GL_NV_conditional_render)");
      }
    }

    void begin_perf_monitor_amd(gl::uint_t monitor) {
      if ( GLAD_GL_AMD_performance_monitor ) {
        glBeginPerfMonitorAMD(monitor);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBeginPerfMonitorAMD' not available on this platform (extensions: GL_AMD_performance_monitor)");
      }
    }

    void begin_perf_query_intel(gl::uint_t queryHandle) {
      if ( GLAD_GL_INTEL_performance_query ) {
        glBeginPerfQueryINTEL(queryHandle);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBeginPerfQueryINTEL' not available on this platform (extensions: GL_INTEL_performance_query)");
      }
    }

    void begin_query_ext(gl::enum_t target, gl::uint_t id) {
      if ( GLAD_GL_EXT_disjoint_timer_query || GLAD_GL_EXT_occlusion_query_boolean ) {
        glBeginQueryEXT(target, id);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBeginQueryEXT' not available on this platform (extensions: GL_EXT_disjoint_timer_query, GL_EXT_occlusion_query_boolean)");
      }
    }

    void bind_program_pipeline_ext(gl::uint_t pipeline) {
      if ( GLAD_GL_EXT_separate_shader_objects ) {
        glBindProgramPipelineEXT(pipeline);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBindProgramPipelineEXT' not available on this platform (extensions: GL_EXT_separate_shader_objects)");
      }
    }

    void bind_vertex_array_oes(gl::uint_t array) {
      if ( GLAD_GL_OES_vertex_array_object ) {
        glBindVertexArrayOES(array);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBindVertexArrayOES' not available on this platform (extensions: GL_OES_vertex_array_object)");
      }
    }

    void blend_barrier_khr() {
      if ( GLAD_GL_KHR_blend_equation_advanced ) {
        glBlendBarrierKHR();
      }
      else {
        throw std::runtime_error("OpenGL command 'glBlendBarrierKHR' not available on this platform (extensions: GL_KHR_blend_equation_advanced)");
      }
    }

    void blend_barrier_nv() {
      if ( GLAD_GL_NV_blend_equation_advanced ) {
        glBlendBarrierNV();
      }
      else {
        throw std::runtime_error("OpenGL command 'glBlendBarrierNV' not available on this platform (extensions: GL_NV_blend_equation_advanced)");
      }
    }

    void blend_equation_separatei_ext(gl::uint_t buf, gl::enum_t modeRGB, gl::enum_t modeAlpha) {
      if ( GLAD_GL_EXT_draw_buffers_indexed ) {
        glBlendEquationSeparateiEXT(buf, modeRGB, modeAlpha);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBlendEquationSeparateiEXT' not available on this platform (extensions: GL_EXT_draw_buffers_indexed)");
      }
    }

    void blend_equation_separatei_oes(gl::uint_t buf, gl::enum_t modeRGB, gl::enum_t modeAlpha) {
      if ( GLAD_GL_OES_draw_buffers_indexed ) {
        glBlendEquationSeparateiOES(buf, modeRGB, modeAlpha);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBlendEquationSeparateiOES' not available on this platform (extensions: GL_OES_draw_buffers_indexed)");
      }
    }

    void blend_equationi_ext(gl::uint_t buf, gl::enum_t mode) {
      if ( GLAD_GL_EXT_draw_buffers_indexed ) {
        glBlendEquationiEXT(buf, mode);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBlendEquationiEXT' not available on this platform (extensions: GL_EXT_draw_buffers_indexed)");
      }
    }

    void blend_equationi_oes(gl::uint_t buf, gl::enum_t mode) {
      if ( GLAD_GL_OES_draw_buffers_indexed ) {
        glBlendEquationiOES(buf, mode);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBlendEquationiOES' not available on this platform (extensions: GL_OES_draw_buffers_indexed)");
      }
    }

    void blend_func_separatei_ext(gl::uint_t buf, gl::enum_t srcRGB, gl::enum_t dstRGB, gl::enum_t srcAlpha, gl::enum_t dstAlpha) {
      if ( GLAD_GL_EXT_draw_buffers_indexed ) {
        glBlendFuncSeparateiEXT(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBlendFuncSeparateiEXT' not available on this platform (extensions: GL_EXT_draw_buffers_indexed)");
      }
    }

    void blend_func_separatei_oes(gl::uint_t buf, gl::enum_t srcRGB, gl::enum_t dstRGB, gl::enum_t srcAlpha, gl::enum_t dstAlpha) {
      if ( GLAD_GL_OES_draw_buffers_indexed ) {
        glBlendFuncSeparateiOES(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBlendFuncSeparateiOES' not available on this platform (extensions: GL_OES_draw_buffers_indexed)");
      }
    }

    void blend_funci_ext(gl::uint_t buf, gl::enum_t src, gl::enum_t dst) {
      if ( GLAD_GL_EXT_draw_buffers_indexed ) {
        glBlendFunciEXT(buf, src, dst);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBlendFunciEXT' not available on this platform (extensions: GL_EXT_draw_buffers_indexed)");
      }
    }

    void blend_funci_oes(gl::uint_t buf, gl::enum_t src, gl::enum_t dst) {
      if ( GLAD_GL_OES_draw_buffers_indexed ) {
        glBlendFunciOES(buf, src, dst);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBlendFunciOES' not available on this platform (extensions: GL_OES_draw_buffers_indexed)");
      }
    }

    void blend_parameteri_nv(gl::enum_t pname, gl::int_t value) {
      if ( GLAD_GL_NV_blend_equation_advanced ) {
        glBlendParameteriNV(pname, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBlendParameteriNV' not available on this platform (extensions: GL_NV_blend_equation_advanced)");
      }
    }

    void blit_framebuffer_angle(gl::int_t srcX0, gl::int_t srcY0, gl::int_t srcX1, gl::int_t srcY1, gl::int_t dstX0, gl::int_t dstY0, gl::int_t dstX1, gl::int_t dstY1, gl::bitmask<clear_buffer_flags_t> mask, gl::enum_t filter) {
      if ( GLAD_GL_ANGLE_framebuffer_blit ) {
        glBlitFramebufferANGLE(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, static_cast<GLbitfield>(mask.value), filter);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBlitFramebufferANGLE' not available on this platform (extensions: GL_ANGLE_framebuffer_blit)");
      }
    }

    void blit_framebuffer_nv(gl::int_t srcX0, gl::int_t srcY0, gl::int_t srcX1, gl::int_t srcY1, gl::int_t dstX0, gl::int_t dstY0, gl::int_t dstX1, gl::int_t dstY1, gl::bitmask<clear_buffer_flags_t> mask, gl::enum_t filter) {
      if ( GLAD_GL_NV_framebuffer_blit ) {
        glBlitFramebufferNV(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, static_cast<GLbitfield>(mask.value), filter);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBlitFramebufferNV' not available on this platform (extensions: GL_NV_framebuffer_blit)");
      }
    }

    gl::enum_t client_wait_sync_apple(gl::sync_t sync, gl::bitfield_t flags, gl::uint64_t timeout) {
      if ( GLAD_GL_APPLE_sync ) {
        return glClientWaitSyncAPPLE(sync, flags, timeout);
      }
      else {
        throw std::runtime_error("OpenGL command 'glClientWaitSyncAPPLE' not available on this platform (extensions: GL_APPLE_sync)");
      }
    }

    void color_maski_ext(gl::uint_t index, gl::boolean_t r, gl::boolean_t g, gl::boolean_t b, gl::boolean_t a) {
      if ( GLAD_GL_EXT_draw_buffers_indexed ) {
        glColorMaskiEXT(index, r, g, b, a);
      }
      else {
        throw std::runtime_error("OpenGL command 'glColorMaskiEXT' not available on this platform (extensions: GL_EXT_draw_buffers_indexed)");
      }
    }

    void color_maski_oes(gl::uint_t index, gl::boolean_t r, gl::boolean_t g, gl::boolean_t b, gl::boolean_t a) {
      if ( GLAD_GL_OES_draw_buffers_indexed ) {
        glColorMaskiOES(index, r, g, b, a);
      }
      else {
        throw std::runtime_error("OpenGL command 'glColorMaskiOES' not available on this platform (extensions: GL_OES_draw_buffers_indexed)");
      }
    }

    void compressed_tex_image_3does(texture_target_t target, gl::int_t level, gl::enum_t internalformat, gl::sizei_t width, gl::sizei_t height, gl::sizei_t depth, gl::int_t border, gl::sizei_t imageSize, const  void * data) {
      if ( GLAD_GL_OES_texture_3D ) {
        glCompressedTexImage3DOES(static_cast<GLenum>(target), level, internalformat, width, height, depth, border, imageSize, data);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCompressedTexImage3DOES' not available on this platform (extensions: GL_OES_texture_3D)");
      }
    }

    void compressed_tex_sub_image_3does(texture_target_t target, gl::int_t level, gl::int_t xoffset, gl::int_t yoffset, gl::int_t zoffset, gl::sizei_t width, gl::sizei_t height, gl::sizei_t depth, pixel_format_t format, gl::sizei_t imageSize, const  void * data) {
      if ( GLAD_GL_OES_texture_3D ) {
        glCompressedTexSubImage3DOES(static_cast<GLenum>(target), level, xoffset, yoffset, zoffset, width, height, depth, static_cast<GLenum>(format), imageSize, data);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCompressedTexSubImage3DOES' not available on this platform (extensions: GL_OES_texture_3D)");
      }
    }

    void copy_buffer_sub_data_nv(gl::enum_t readTarget, gl::enum_t writeTarget, gl::intptr_t readOffset, gl::intptr_t writeOffset, gl::sizeiptr_t size) {
      if ( GLAD_GL_NV_copy_buffer ) {
        glCopyBufferSubDataNV(readTarget, writeTarget, readOffset, writeOffset, size);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCopyBufferSubDataNV' not available on this platform (extensions: GL_NV_copy_buffer)");
      }
    }

    void copy_image_sub_data_ext(gl::uint_t srcName, gl::enum_t srcTarget, gl::int_t srcLevel, gl::int_t srcX, gl::int_t srcY, gl::int_t srcZ, gl::uint_t dstName, gl::enum_t dstTarget, gl::int_t dstLevel, gl::int_t dstX, gl::int_t dstY, gl::int_t dstZ, gl::sizei_t srcWidth, gl::sizei_t srcHeight, gl::sizei_t srcDepth) {
      if ( GLAD_GL_EXT_copy_image ) {
        glCopyImageSubDataEXT(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCopyImageSubDataEXT' not available on this platform (extensions: GL_EXT_copy_image)");
      }
    }

    void copy_image_sub_data_oes(gl::uint_t srcName, gl::enum_t srcTarget, gl::int_t srcLevel, gl::int_t srcX, gl::int_t srcY, gl::int_t srcZ, gl::uint_t dstName, gl::enum_t dstTarget, gl::int_t dstLevel, gl::int_t dstX, gl::int_t dstY, gl::int_t dstZ, gl::sizei_t srcWidth, gl::sizei_t srcHeight, gl::sizei_t srcDepth) {
      if ( GLAD_GL_OES_copy_image ) {
        glCopyImageSubDataOES(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCopyImageSubDataOES' not available on this platform (extensions: GL_OES_copy_image)");
      }
    }

    void copy_path_nv(gl::uint_t resultPath, gl::uint_t srcPath) {
      if ( GLAD_GL_NV_path_rendering ) {
        glCopyPathNV(resultPath, srcPath);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCopyPathNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void copy_tex_sub_image_3does(texture_target_t target, gl::int_t level, gl::int_t xoffset, gl::int_t yoffset, gl::int_t zoffset, gl::int_t x, gl::int_t y, gl::sizei_t width, gl::sizei_t height) {
      if ( GLAD_GL_OES_texture_3D ) {
        glCopyTexSubImage3DOES(static_cast<GLenum>(target), level, xoffset, yoffset, zoffset, x, y, width, height);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCopyTexSubImage3DOES' not available on this platform (extensions: GL_OES_texture_3D)");
      }
    }

    void copy_texture_levels_apple(gl::uint_t destinationTexture, gl::uint_t sourceTexture, gl::int_t sourceBaseLevel, gl::sizei_t sourceLevelCount) {
      if ( GLAD_GL_APPLE_copy_texture_levels ) {
        glCopyTextureLevelsAPPLE(destinationTexture, sourceTexture, sourceBaseLevel, sourceLevelCount);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCopyTextureLevelsAPPLE' not available on this platform (extensions: GL_APPLE_copy_texture_levels)");
      }
    }

    void cover_fill_path_instanced_nv(gl::sizei_t numPaths, gl::enum_t pathNameType, const  void * paths, gl::uint_t pathBase, gl::enum_t coverMode, gl::enum_t transformType, const  gl::float_t * transformValues) {
      if ( GLAD_GL_NV_path_rendering ) {
        glCoverFillPathInstancedNV(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCoverFillPathInstancedNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void cover_fill_path_nv(gl::uint_t path, gl::enum_t coverMode) {
      if ( GLAD_GL_NV_path_rendering ) {
        glCoverFillPathNV(path, coverMode);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCoverFillPathNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void cover_stroke_path_instanced_nv(gl::sizei_t numPaths, gl::enum_t pathNameType, const  void * paths, gl::uint_t pathBase, gl::enum_t coverMode, gl::enum_t transformType, const  gl::float_t * transformValues) {
      if ( GLAD_GL_NV_path_rendering ) {
        glCoverStrokePathInstancedNV(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCoverStrokePathInstancedNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void cover_stroke_path_nv(gl::uint_t path, gl::enum_t coverMode) {
      if ( GLAD_GL_NV_path_rendering ) {
        glCoverStrokePathNV(path, coverMode);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCoverStrokePathNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void coverage_mask_nv(gl::boolean_t mask) {
      if ( GLAD_GL_NV_coverage_sample ) {
        glCoverageMaskNV(mask);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCoverageMaskNV' not available on this platform (extensions: GL_NV_coverage_sample)");
      }
    }

    void coverage_operation_nv(gl::enum_t operation) {
      if ( GLAD_GL_NV_coverage_sample ) {
        glCoverageOperationNV(operation);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCoverageOperationNV' not available on this platform (extensions: GL_NV_coverage_sample)");
      }
    }

    void create_perf_query_intel(gl::uint_t queryId, gl::uint_t * queryHandle) {
      if ( GLAD_GL_INTEL_performance_query ) {
        glCreatePerfQueryINTEL(queryId, queryHandle);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCreatePerfQueryINTEL' not available on this platform (extensions: GL_INTEL_performance_query)");
      }
    }

    gl::uint_t create_shader_programv_ext(gl::enum_t type, gl::sizei_t count, const  gl::char_t ** strings) {
      if ( GLAD_GL_EXT_separate_shader_objects ) {
        return glCreateShaderProgramvEXT(type, count, strings);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCreateShaderProgramvEXT' not available on this platform (extensions: GL_EXT_separate_shader_objects)");
      }
    }

    void debug_message_callback_khr(gl::DEBUGPROCKHR_t callback, const  void * userParam) {
      if ( GLAD_GL_KHR_debug ) {
        glDebugMessageCallbackKHR(callback, userParam);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDebugMessageCallbackKHR' not available on this platform (extensions: GL_KHR_debug)");
      }
    }

    void debug_message_control_khr(gl::enum_t source, gl::enum_t type, gl::enum_t severity, gl::sizei_t count, const  gl::uint_t * ids, gl::boolean_t enabled) {
      if ( GLAD_GL_KHR_debug ) {
        glDebugMessageControlKHR(source, type, severity, count, ids, enabled);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDebugMessageControlKHR' not available on this platform (extensions: GL_KHR_debug)");
      }
    }

    void debug_message_insert_khr(gl::enum_t source, gl::enum_t type, gl::uint_t id, gl::enum_t severity, gl::sizei_t length, const  gl::char_t * buf) {
      if ( GLAD_GL_KHR_debug ) {
        glDebugMessageInsertKHR(source, type, id, severity, length, buf);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDebugMessageInsertKHR' not available on this platform (extensions: GL_KHR_debug)");
      }
    }

    void delete_fences_nv(gl::sizei_t n, const  gl::uint_t * fences) {
      if ( GLAD_GL_NV_fence ) {
        glDeleteFencesNV(n, fences);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDeleteFencesNV' not available on this platform (extensions: GL_NV_fence)");
      }
    }

    void delete_paths_nv(gl::uint_t path, gl::sizei_t range) {
      if ( GLAD_GL_NV_path_rendering ) {
        glDeletePathsNV(path, range);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDeletePathsNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void delete_perf_monitors_amd(gl::sizei_t n, gl::uint_t * monitors) {
      if ( GLAD_GL_AMD_performance_monitor ) {
        glDeletePerfMonitorsAMD(n, monitors);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDeletePerfMonitorsAMD' not available on this platform (extensions: GL_AMD_performance_monitor)");
      }
    }

    void delete_perf_query_intel(gl::uint_t queryHandle) {
      if ( GLAD_GL_INTEL_performance_query ) {
        glDeletePerfQueryINTEL(queryHandle);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDeletePerfQueryINTEL' not available on this platform (extensions: GL_INTEL_performance_query)");
      }
    }

    void delete_program_pipelines_ext(gl::sizei_t n, const  gl::uint_t * pipelines) {
      if ( GLAD_GL_EXT_separate_shader_objects ) {
        glDeleteProgramPipelinesEXT(n, pipelines);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDeleteProgramPipelinesEXT' not available on this platform (extensions: GL_EXT_separate_shader_objects)");
      }
    }

    void delete_queries_ext(gl::sizei_t n, const  gl::uint_t * ids) {
      if ( GLAD_GL_EXT_disjoint_timer_query || GLAD_GL_EXT_occlusion_query_boolean ) {
        glDeleteQueriesEXT(n, ids);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDeleteQueriesEXT' not available on this platform (extensions: GL_EXT_disjoint_timer_query, GL_EXT_occlusion_query_boolean)");
      }
    }

    void delete_sync_apple(gl::sync_t sync) {
      if ( GLAD_GL_APPLE_sync ) {
        glDeleteSyncAPPLE(sync);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDeleteSyncAPPLE' not available on this platform (extensions: GL_APPLE_sync)");
      }
    }

    void delete_vertex_arrays_oes(gl::sizei_t n, const  gl::uint_t * arrays) {
      if ( GLAD_GL_OES_vertex_array_object ) {
        glDeleteVertexArraysOES(n, arrays);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDeleteVertexArraysOES' not available on this platform (extensions: GL_OES_vertex_array_object)");
      }
    }

    void depth_range_arrayfv_nv(gl::uint_t first, gl::sizei_t count, const  gl::float_t * v) {
      if ( GLAD_GL_NV_viewport_array ) {
        glDepthRangeArrayfvNV(first, count, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDepthRangeArrayfvNV' not available on this platform (extensions: GL_NV_viewport_array)");
      }
    }

    void depth_range_indexedf_nv(gl::uint_t index, gl::float_t n, gl::float_t f) {
      if ( GLAD_GL_NV_viewport_array ) {
        glDepthRangeIndexedfNV(index, n, f);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDepthRangeIndexedfNV' not available on this platform (extensions: GL_NV_viewport_array)");
      }
    }

    void disable_driver_control_qcom(gl::uint_t driverControl) {
      if ( GLAD_GL_QCOM_driver_control ) {
        glDisableDriverControlQCOM(driverControl);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDisableDriverControlQCOM' not available on this platform (extensions: GL_QCOM_driver_control)");
      }
    }

    void disablei_ext(gl::enum_t target, gl::uint_t index) {
      if ( GLAD_GL_EXT_draw_buffers_indexed ) {
        glDisableiEXT(target, index);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDisableiEXT' not available on this platform (extensions: GL_EXT_draw_buffers_indexed)");
      }
    }

    void disablei_nv(gl::enum_t target, gl::uint_t index) {
      if ( GLAD_GL_NV_viewport_array ) {
        glDisableiNV(target, index);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDisableiNV' not available on this platform (extensions: GL_NV_viewport_array)");
      }
    }

    void disablei_oes(gl::enum_t target, gl::uint_t index) {
      if ( GLAD_GL_OES_draw_buffers_indexed ) {
        glDisableiOES(target, index);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDisableiOES' not available on this platform (extensions: GL_OES_draw_buffers_indexed)");
      }
    }

    void discard_framebuffer_ext(gl::enum_t target, gl::sizei_t numAttachments, const  gl::enum_t * attachments) {
      if ( GLAD_GL_EXT_discard_framebuffer ) {
        glDiscardFramebufferEXT(target, numAttachments, attachments);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDiscardFramebufferEXT' not available on this platform (extensions: GL_EXT_discard_framebuffer)");
      }
    }

    void draw_arrays_instanced_angle(primitive_type_t mode, gl::int_t first, gl::sizei_t count, gl::sizei_t primcount) {
      if ( GLAD_GL_ANGLE_instanced_arrays ) {
        glDrawArraysInstancedANGLE(static_cast<GLenum>(mode), first, count, primcount);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDrawArraysInstancedANGLE' not available on this platform (extensions: GL_ANGLE_instanced_arrays)");
      }
    }

    void draw_arrays_instanced_base_instance_ext(primitive_type_t mode, gl::int_t first, gl::sizei_t count, gl::sizei_t instancecount, gl::uint_t baseinstance) {
      if ( GLAD_GL_EXT_base_instance ) {
        glDrawArraysInstancedBaseInstanceEXT(static_cast<GLenum>(mode), first, count, instancecount, baseinstance);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDrawArraysInstancedBaseInstanceEXT' not available on this platform (extensions: GL_EXT_base_instance)");
      }
    }

    void draw_arrays_instanced_ext(primitive_type_t mode, gl::int_t start, gl::sizei_t count, gl::sizei_t primcount) {
      if ( GLAD_GL_EXT_draw_instanced || GLAD_GL_EXT_instanced_arrays ) {
        glDrawArraysInstancedEXT(static_cast<GLenum>(mode), start, count, primcount);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDrawArraysInstancedEXT' not available on this platform (extensions: GL_EXT_draw_instanced, GL_EXT_instanced_arrays)");
      }
    }

    void draw_arrays_instanced_nv(primitive_type_t mode, gl::int_t first, gl::sizei_t count, gl::sizei_t primcount) {
      if ( GLAD_GL_NV_draw_instanced ) {
        glDrawArraysInstancedNV(static_cast<GLenum>(mode), first, count, primcount);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDrawArraysInstancedNV' not available on this platform (extensions: GL_NV_draw_instanced)");
      }
    }

    void draw_buffers_ext(gl::sizei_t n, const  gl::enum_t * bufs) {
      if ( GLAD_GL_EXT_draw_buffers ) {
        glDrawBuffersEXT(n, bufs);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDrawBuffersEXT' not available on this platform (extensions: GL_EXT_draw_buffers)");
      }
    }

    void draw_buffers_indexed_ext(gl::int_t n, const  gl::enum_t * location, const  gl::int_t * indices) {
      if ( GLAD_GL_EXT_multiview_draw_buffers ) {
        glDrawBuffersIndexedEXT(n, location, indices);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDrawBuffersIndexedEXT' not available on this platform (extensions: GL_EXT_multiview_draw_buffers)");
      }
    }

    void draw_buffers_nv(gl::sizei_t n, const  gl::enum_t * bufs) {
      if ( GLAD_GL_NV_draw_buffers ) {
        glDrawBuffersNV(n, bufs);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDrawBuffersNV' not available on this platform (extensions: GL_NV_draw_buffers)");
      }
    }

    void draw_elements_base_vertex_ext(primitive_type_t mode, gl::sizei_t count, draw_elements_type_t type, const  void * indices, gl::int_t basevertex) {
      if ( GLAD_GL_EXT_draw_elements_base_vertex ) {
        glDrawElementsBaseVertexEXT(static_cast<GLenum>(mode), count, static_cast<GLenum>(type), indices, basevertex);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDrawElementsBaseVertexEXT' not available on this platform (extensions: GL_EXT_draw_elements_base_vertex)");
      }
    }

    void draw_elements_base_vertex_oes(primitive_type_t mode, gl::sizei_t count, draw_elements_type_t type, const  void * indices, gl::int_t basevertex) {
      if ( GLAD_GL_OES_draw_elements_base_vertex ) {
        glDrawElementsBaseVertexOES(static_cast<GLenum>(mode), count, static_cast<GLenum>(type), indices, basevertex);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDrawElementsBaseVertexOES' not available on this platform (extensions: GL_OES_draw_elements_base_vertex)");
      }
    }

    void draw_elements_instanced_angle(primitive_type_t mode, gl::sizei_t count, draw_elements_type_t type, const  void * indices, gl::sizei_t primcount) {
      if ( GLAD_GL_ANGLE_instanced_arrays ) {
        glDrawElementsInstancedANGLE(static_cast<GLenum>(mode), count, static_cast<GLenum>(type), indices, primcount);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDrawElementsInstancedANGLE' not available on this platform (extensions: GL_ANGLE_instanced_arrays)");
      }
    }

    void draw_elements_instanced_base_instance_ext(primitive_type_t mode, gl::sizei_t count, gl::enum_t type, const  void * indices, gl::sizei_t instancecount, gl::uint_t baseinstance) {
      if ( GLAD_GL_EXT_base_instance ) {
        glDrawElementsInstancedBaseInstanceEXT(static_cast<GLenum>(mode), count, type, indices, instancecount, baseinstance);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDrawElementsInstancedBaseInstanceEXT' not available on this platform (extensions: GL_EXT_base_instance)");
      }
    }

    void draw_elements_instanced_base_vertex_base_instance_ext(primitive_type_t mode, gl::sizei_t count, gl::enum_t type, const  void * indices, gl::sizei_t instancecount, gl::int_t basevertex, gl::uint_t baseinstance) {
      if ( GLAD_GL_EXT_base_instance ) {
        glDrawElementsInstancedBaseVertexBaseInstanceEXT(static_cast<GLenum>(mode), count, type, indices, instancecount, basevertex, baseinstance);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDrawElementsInstancedBaseVertexBaseInstanceEXT' not available on this platform (extensions: GL_EXT_base_instance)");
      }
    }

    void draw_elements_instanced_base_vertex_ext(primitive_type_t mode, gl::sizei_t count, draw_elements_type_t type, const  void * indices, gl::sizei_t instancecount, gl::int_t basevertex) {
      if ( GLAD_GL_EXT_draw_elements_base_vertex ) {
        glDrawElementsInstancedBaseVertexEXT(static_cast<GLenum>(mode), count, static_cast<GLenum>(type), indices, instancecount, basevertex);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDrawElementsInstancedBaseVertexEXT' not available on this platform (extensions: GL_EXT_draw_elements_base_vertex)");
      }
    }

    void draw_elements_instanced_base_vertex_oes(primitive_type_t mode, gl::sizei_t count, draw_elements_type_t type, const  void * indices, gl::sizei_t instancecount, gl::int_t basevertex) {
      if ( GLAD_GL_OES_draw_elements_base_vertex ) {
        glDrawElementsInstancedBaseVertexOES(static_cast<GLenum>(mode), count, static_cast<GLenum>(type), indices, instancecount, basevertex);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDrawElementsInstancedBaseVertexOES' not available on this platform (extensions: GL_OES_draw_elements_base_vertex)");
      }
    }

    void draw_elements_instanced_ext(primitive_type_t mode, gl::sizei_t count, draw_elements_type_t type, const  void * indices, gl::sizei_t primcount) {
      if ( GLAD_GL_EXT_draw_instanced || GLAD_GL_EXT_instanced_arrays ) {
        glDrawElementsInstancedEXT(static_cast<GLenum>(mode), count, static_cast<GLenum>(type), indices, primcount);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDrawElementsInstancedEXT' not available on this platform (extensions: GL_EXT_draw_instanced, GL_EXT_instanced_arrays)");
      }
    }

    void draw_elements_instanced_nv(primitive_type_t mode, gl::sizei_t count, draw_elements_type_t type, const  void * indices, gl::sizei_t primcount) {
      if ( GLAD_GL_NV_draw_instanced ) {
        glDrawElementsInstancedNV(static_cast<GLenum>(mode), count, static_cast<GLenum>(type), indices, primcount);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDrawElementsInstancedNV' not available on this platform (extensions: GL_NV_draw_instanced)");
      }
    }

    void draw_range_elements_base_vertex_ext(primitive_type_t mode, gl::uint_t start, gl::uint_t end, gl::sizei_t count, draw_elements_type_t type, const  void * indices, gl::int_t basevertex) {
      if ( GLAD_GL_EXT_draw_elements_base_vertex ) {
        glDrawRangeElementsBaseVertexEXT(static_cast<GLenum>(mode), start, end, count, static_cast<GLenum>(type), indices, basevertex);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDrawRangeElementsBaseVertexEXT' not available on this platform (extensions: GL_EXT_draw_elements_base_vertex)");
      }
    }

    void draw_range_elements_base_vertex_oes(primitive_type_t mode, gl::uint_t start, gl::uint_t end, gl::sizei_t count, draw_elements_type_t type, const  void * indices, gl::int_t basevertex) {
      if ( GLAD_GL_OES_draw_elements_base_vertex ) {
        glDrawRangeElementsBaseVertexOES(static_cast<GLenum>(mode), start, end, count, static_cast<GLenum>(type), indices, basevertex);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDrawRangeElementsBaseVertexOES' not available on this platform (extensions: GL_OES_draw_elements_base_vertex)");
      }
    }

    void egl_image_target_renderbuffer_storage_oes(gl::enum_t target, gl::eglImageOES_t image) {
      if ( GLAD_GL_OES_EGL_image ) {
        glEGLImageTargetRenderbufferStorageOES(target, image);
      }
      else {
        throw std::runtime_error("OpenGL command 'glEGLImageTargetRenderbufferStorageOES' not available on this platform (extensions: GL_OES_EGL_image)");
      }
    }

    void egl_image_target_texture_2does(gl::enum_t target, gl::eglImageOES_t image) {
      if ( GLAD_GL_OES_EGL_image ) {
        glEGLImageTargetTexture2DOES(target, image);
      }
      else {
        throw std::runtime_error("OpenGL command 'glEGLImageTargetTexture2DOES' not available on this platform (extensions: GL_OES_EGL_image)");
      }
    }

    void enable_driver_control_qcom(gl::uint_t driverControl) {
      if ( GLAD_GL_QCOM_driver_control ) {
        glEnableDriverControlQCOM(driverControl);
      }
      else {
        throw std::runtime_error("OpenGL command 'glEnableDriverControlQCOM' not available on this platform (extensions: GL_QCOM_driver_control)");
      }
    }

    void enablei_ext(gl::enum_t target, gl::uint_t index) {
      if ( GLAD_GL_EXT_draw_buffers_indexed ) {
        glEnableiEXT(target, index);
      }
      else {
        throw std::runtime_error("OpenGL command 'glEnableiEXT' not available on this platform (extensions: GL_EXT_draw_buffers_indexed)");
      }
    }

    void enablei_nv(gl::enum_t target, gl::uint_t index) {
      if ( GLAD_GL_NV_viewport_array ) {
        glEnableiNV(target, index);
      }
      else {
        throw std::runtime_error("OpenGL command 'glEnableiNV' not available on this platform (extensions: GL_NV_viewport_array)");
      }
    }

    void enablei_oes(gl::enum_t target, gl::uint_t index) {
      if ( GLAD_GL_OES_draw_buffers_indexed ) {
        glEnableiOES(target, index);
      }
      else {
        throw std::runtime_error("OpenGL command 'glEnableiOES' not available on this platform (extensions: GL_OES_draw_buffers_indexed)");
      }
    }

    void end_conditional_render_nv() {
      if ( GLAD_GL_NV_conditional_render ) {
        glEndConditionalRenderNV();
      }
      else {
        throw std::runtime_error("OpenGL command 'glEndConditionalRenderNV' not available on this platform (extensions: GL_NV_conditional_render)");
      }
    }

    void end_perf_monitor_amd(gl::uint_t monitor) {
      if ( GLAD_GL_AMD_performance_monitor ) {
        glEndPerfMonitorAMD(monitor);
      }
      else {
        throw std::runtime_error("OpenGL command 'glEndPerfMonitorAMD' not available on this platform (extensions: GL_AMD_performance_monitor)");
      }
    }

    void end_perf_query_intel(gl::uint_t queryHandle) {
      if ( GLAD_GL_INTEL_performance_query ) {
        glEndPerfQueryINTEL(queryHandle);
      }
      else {
        throw std::runtime_error("OpenGL command 'glEndPerfQueryINTEL' not available on this platform (extensions: GL_INTEL_performance_query)");
      }
    }

    void end_query_ext(gl::enum_t target) {
      if ( GLAD_GL_EXT_disjoint_timer_query || GLAD_GL_EXT_occlusion_query_boolean ) {
        glEndQueryEXT(target);
      }
      else {
        throw std::runtime_error("OpenGL command 'glEndQueryEXT' not available on this platform (extensions: GL_EXT_disjoint_timer_query, GL_EXT_occlusion_query_boolean)");
      }
    }

    void end_tiling_qcom(gl::bitfield_t preserveMask) {
      if ( GLAD_GL_QCOM_tiled_rendering ) {
        glEndTilingQCOM(preserveMask);
      }
      else {
        throw std::runtime_error("OpenGL command 'glEndTilingQCOM' not available on this platform (extensions: GL_QCOM_tiled_rendering)");
      }
    }

    void ext_get_buffer_pointerv_qcom(gl::enum_t target, void ** params) {
      if ( GLAD_GL_QCOM_extended_get ) {
        glExtGetBufferPointervQCOM(target, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glExtGetBufferPointervQCOM' not available on this platform (extensions: GL_QCOM_extended_get)");
      }
    }

    void ext_get_buffers_qcom(gl::uint_t * buffers, gl::int_t maxBuffers, gl::int_t * numBuffers) {
      if ( GLAD_GL_QCOM_extended_get ) {
        glExtGetBuffersQCOM(buffers, maxBuffers, numBuffers);
      }
      else {
        throw std::runtime_error("OpenGL command 'glExtGetBuffersQCOM' not available on this platform (extensions: GL_QCOM_extended_get)");
      }
    }

    void ext_get_framebuffers_qcom(gl::uint_t * framebuffers, gl::int_t maxFramebuffers, gl::int_t * numFramebuffers) {
      if ( GLAD_GL_QCOM_extended_get ) {
        glExtGetFramebuffersQCOM(framebuffers, maxFramebuffers, numFramebuffers);
      }
      else {
        throw std::runtime_error("OpenGL command 'glExtGetFramebuffersQCOM' not available on this platform (extensions: GL_QCOM_extended_get)");
      }
    }

    void ext_get_program_binary_source_qcom(gl::uint_t program, gl::enum_t shadertype, gl::char_t * source, gl::int_t * length) {
      if ( GLAD_GL_QCOM_extended_get2 ) {
        glExtGetProgramBinarySourceQCOM(program, shadertype, source, length);
      }
      else {
        throw std::runtime_error("OpenGL command 'glExtGetProgramBinarySourceQCOM' not available on this platform (extensions: GL_QCOM_extended_get2)");
      }
    }

    void ext_get_programs_qcom(gl::uint_t * programs, gl::int_t maxPrograms, gl::int_t * numPrograms) {
      if ( GLAD_GL_QCOM_extended_get2 ) {
        glExtGetProgramsQCOM(programs, maxPrograms, numPrograms);
      }
      else {
        throw std::runtime_error("OpenGL command 'glExtGetProgramsQCOM' not available on this platform (extensions: GL_QCOM_extended_get2)");
      }
    }

    void ext_get_renderbuffers_qcom(gl::uint_t * renderbuffers, gl::int_t maxRenderbuffers, gl::int_t * numRenderbuffers) {
      if ( GLAD_GL_QCOM_extended_get ) {
        glExtGetRenderbuffersQCOM(renderbuffers, maxRenderbuffers, numRenderbuffers);
      }
      else {
        throw std::runtime_error("OpenGL command 'glExtGetRenderbuffersQCOM' not available on this platform (extensions: GL_QCOM_extended_get)");
      }
    }

    void ext_get_shaders_qcom(gl::uint_t * shaders, gl::int_t maxShaders, gl::int_t * numShaders) {
      if ( GLAD_GL_QCOM_extended_get2 ) {
        glExtGetShadersQCOM(shaders, maxShaders, numShaders);
      }
      else {
        throw std::runtime_error("OpenGL command 'glExtGetShadersQCOM' not available on this platform (extensions: GL_QCOM_extended_get2)");
      }
    }

    void ext_get_tex_level_parameteriv_qcom(gl::uint_t texture, gl::enum_t face, gl::int_t level, gl::enum_t pname, gl::int_t * params) {
      if ( GLAD_GL_QCOM_extended_get ) {
        glExtGetTexLevelParameterivQCOM(texture, face, level, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glExtGetTexLevelParameterivQCOM' not available on this platform (extensions: GL_QCOM_extended_get)");
      }
    }

    void ext_get_tex_sub_image_qcom(gl::enum_t target, gl::int_t level, gl::int_t xoffset, gl::int_t yoffset, gl::int_t zoffset, gl::sizei_t width, gl::sizei_t height, gl::sizei_t depth, gl::enum_t format, gl::enum_t type, void * texels) {
      if ( GLAD_GL_QCOM_extended_get ) {
        glExtGetTexSubImageQCOM(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, texels);
      }
      else {
        throw std::runtime_error("OpenGL command 'glExtGetTexSubImageQCOM' not available on this platform (extensions: GL_QCOM_extended_get)");
      }
    }

    void ext_get_textures_qcom(gl::uint_t * textures, gl::int_t maxTextures, gl::int_t * numTextures) {
      if ( GLAD_GL_QCOM_extended_get ) {
        glExtGetTexturesQCOM(textures, maxTextures, numTextures);
      }
      else {
        throw std::runtime_error("OpenGL command 'glExtGetTexturesQCOM' not available on this platform (extensions: GL_QCOM_extended_get)");
      }
    }

    gl::boolean_t ext_is_program_binary_qcom(gl::uint_t program) {
      if ( GLAD_GL_QCOM_extended_get2 ) {
        return glExtIsProgramBinaryQCOM(program);
      }
      else {
        throw std::runtime_error("OpenGL command 'glExtIsProgramBinaryQCOM' not available on this platform (extensions: GL_QCOM_extended_get2)");
      }
    }

    void ext_tex_object_state_overridei_qcom(gl::enum_t target, gl::enum_t pname, gl::int_t param) {
      if ( GLAD_GL_QCOM_extended_get ) {
        glExtTexObjectStateOverrideiQCOM(target, pname, param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glExtTexObjectStateOverrideiQCOM' not available on this platform (extensions: GL_QCOM_extended_get)");
      }
    }

    gl::sync_t fence_sync_apple(gl::enum_t condition, gl::bitfield_t flags) {
      if ( GLAD_GL_APPLE_sync ) {
        return glFenceSyncAPPLE(condition, flags);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFenceSyncAPPLE' not available on this platform (extensions: GL_APPLE_sync)");
      }
    }

    void finish_fence_nv(gl::uint_t fence) {
      if ( GLAD_GL_NV_fence ) {
        glFinishFenceNV(fence);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFinishFenceNV' not available on this platform (extensions: GL_NV_fence)");
      }
    }

    void flush_mapped_buffer_range_ext(buffer_target_arb_t target, gl::intptr_t offset, gl::sizeiptr_t length) {
      if ( GLAD_GL_EXT_map_buffer_range ) {
        glFlushMappedBufferRangeEXT(static_cast<GLenum>(target), offset, length);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFlushMappedBufferRangeEXT' not available on this platform (extensions: GL_EXT_map_buffer_range)");
      }
    }

    void framebuffer_texture_2d_multisample_ext(gl::enum_t target, gl::enum_t attachment, gl::enum_t textarget, gl::uint_t texture, gl::int_t level, gl::sizei_t samples) {
      if ( GLAD_GL_EXT_multisampled_render_to_texture ) {
        glFramebufferTexture2DMultisampleEXT(target, attachment, textarget, texture, level, samples);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFramebufferTexture2DMultisampleEXT' not available on this platform (extensions: GL_EXT_multisampled_render_to_texture)");
      }
    }

    void framebuffer_texture_2d_multisample_img(gl::enum_t target, gl::enum_t attachment, gl::enum_t textarget, gl::uint_t texture, gl::int_t level, gl::sizei_t samples) {
      if ( GLAD_GL_IMG_multisampled_render_to_texture ) {
        glFramebufferTexture2DMultisampleIMG(target, attachment, textarget, texture, level, samples);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFramebufferTexture2DMultisampleIMG' not available on this platform (extensions: GL_IMG_multisampled_render_to_texture)");
      }
    }

    void framebuffer_texture_3does(framebuffer_target_t target, framebuffer_attachment_t attachment, gl::enum_t textarget, gl::uint_t texture, gl::int_t level, gl::int_t zoffset) {
      if ( GLAD_GL_OES_texture_3D ) {
        glFramebufferTexture3DOES(static_cast<GLenum>(target), static_cast<GLenum>(attachment), textarget, texture, level, zoffset);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFramebufferTexture3DOES' not available on this platform (extensions: GL_OES_texture_3D)");
      }
    }

    void framebuffer_texture_ext(framebuffer_target_t target, framebuffer_attachment_t attachment, gl::uint_t texture, gl::int_t level) {
      if ( GLAD_GL_EXT_geometry_shader ) {
        glFramebufferTextureEXT(static_cast<GLenum>(target), static_cast<GLenum>(attachment), texture, level);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFramebufferTextureEXT' not available on this platform (extensions: GL_EXT_geometry_shader)");
      }
    }

    void framebuffer_texture_oes(framebuffer_target_t target, framebuffer_attachment_t attachment, gl::uint_t texture, gl::int_t level) {
      if ( GLAD_GL_OES_geometry_shader ) {
        glFramebufferTextureOES(static_cast<GLenum>(target), static_cast<GLenum>(attachment), texture, level);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFramebufferTextureOES' not available on this platform (extensions: GL_OES_geometry_shader)");
      }
    }

    void gen_fences_nv(gl::sizei_t n, gl::uint_t * fences) {
      if ( GLAD_GL_NV_fence ) {
        glGenFencesNV(n, fences);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGenFencesNV' not available on this platform (extensions: GL_NV_fence)");
      }
    }

    gl::uint_t gen_paths_nv(gl::sizei_t range) {
      if ( GLAD_GL_NV_path_rendering ) {
        return glGenPathsNV(range);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGenPathsNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void gen_perf_monitors_amd(gl::sizei_t n, gl::uint_t * monitors) {
      if ( GLAD_GL_AMD_performance_monitor ) {
        glGenPerfMonitorsAMD(n, monitors);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGenPerfMonitorsAMD' not available on this platform (extensions: GL_AMD_performance_monitor)");
      }
    }

    void gen_program_pipelines_ext(gl::sizei_t n, gl::uint_t * pipelines) {
      if ( GLAD_GL_EXT_separate_shader_objects ) {
        glGenProgramPipelinesEXT(n, pipelines);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGenProgramPipelinesEXT' not available on this platform (extensions: GL_EXT_separate_shader_objects)");
      }
    }

    void gen_queries_ext(gl::sizei_t n, gl::uint_t * ids) {
      if ( GLAD_GL_EXT_disjoint_timer_query || GLAD_GL_EXT_occlusion_query_boolean ) {
        glGenQueriesEXT(n, ids);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGenQueriesEXT' not available on this platform (extensions: GL_EXT_disjoint_timer_query, GL_EXT_occlusion_query_boolean)");
      }
    }

    void gen_vertex_arrays_oes(gl::sizei_t n, gl::uint_t * arrays) {
      if ( GLAD_GL_OES_vertex_array_object ) {
        glGenVertexArraysOES(n, arrays);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGenVertexArraysOES' not available on this platform (extensions: GL_OES_vertex_array_object)");
      }
    }

    void get_buffer_pointerv_oes(buffer_target_arb_t target, gl::enum_t pname, void ** params) {
      if ( GLAD_GL_OES_mapbuffer ) {
        glGetBufferPointervOES(static_cast<GLenum>(target), pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetBufferPointervOES' not available on this platform (extensions: GL_OES_mapbuffer)");
      }
    }

    gl::uint_t get_debug_message_log_khr(gl::uint_t count, gl::sizei_t bufSize, gl::enum_t * sources, gl::enum_t * types, gl::uint_t * ids, gl::enum_t * severities, gl::sizei_t * lengths, gl::char_t * messageLog) {
      if ( GLAD_GL_KHR_debug ) {
        return glGetDebugMessageLogKHR(count, bufSize, sources, types, ids, severities, lengths, messageLog);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetDebugMessageLogKHR' not available on this platform (extensions: GL_KHR_debug)");
      }
    }

    void get_driver_control_string_qcom(gl::uint_t driverControl, gl::sizei_t bufSize, gl::sizei_t * length, gl::char_t * driverControlString) {
      if ( GLAD_GL_QCOM_driver_control ) {
        glGetDriverControlStringQCOM(driverControl, bufSize, length, driverControlString);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetDriverControlStringQCOM' not available on this platform (extensions: GL_QCOM_driver_control)");
      }
    }

    void get_driver_controls_qcom(gl::int_t * num, gl::sizei_t size, gl::uint_t * driverControls) {
      if ( GLAD_GL_QCOM_driver_control ) {
        glGetDriverControlsQCOM(num, size, driverControls);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetDriverControlsQCOM' not available on this platform (extensions: GL_QCOM_driver_control)");
      }
    }

    void get_fenceiv_nv(gl::uint_t fence, gl::enum_t pname, gl::int_t * params) {
      if ( GLAD_GL_NV_fence ) {
        glGetFenceivNV(fence, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetFenceivNV' not available on this platform (extensions: GL_NV_fence)");
      }
    }

    void get_first_perf_query_id_intel(gl::uint_t * queryId) {
      if ( GLAD_GL_INTEL_performance_query ) {
        glGetFirstPerfQueryIdINTEL(queryId);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetFirstPerfQueryIdINTEL' not available on this platform (extensions: GL_INTEL_performance_query)");
      }
    }

    void get_floati_v_nv(gl::enum_t target, gl::uint_t index, gl::float_t * data) {
      if ( GLAD_GL_NV_viewport_array ) {
        glGetFloati_vNV(target, index, data);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetFloati_vNV' not available on this platform (extensions: GL_NV_viewport_array)");
      }
    }

    gl::enum_t get_graphics_reset_status_ext() {
      if ( GLAD_GL_EXT_robustness ) {
        return glGetGraphicsResetStatusEXT();
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetGraphicsResetStatusEXT' not available on this platform (extensions: GL_EXT_robustness)");
      }
    }

    gl::enum_t get_graphics_reset_status_khr() {
      if ( GLAD_GL_KHR_robustness ) {
        return glGetGraphicsResetStatusKHR();
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetGraphicsResetStatusKHR' not available on this platform (extensions: GL_KHR_robustness)");
      }
    }

    gl::uint64_t get_image_handle_nv(gl::uint_t texture, gl::int_t level, gl::boolean_t layered, gl::int_t layer, gl::enum_t format) {
      if ( GLAD_GL_NV_bindless_texture ) {
        return glGetImageHandleNV(texture, level, layered, layer, format);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetImageHandleNV' not available on this platform (extensions: GL_NV_bindless_texture)");
      }
    }

    void get_integer_64v_apple(gl::enum_t pname, gl::int64_t * params) {
      if ( GLAD_GL_APPLE_sync ) {
        glGetInteger64vAPPLE(pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetInteger64vAPPLE' not available on this platform (extensions: GL_APPLE_sync)");
      }
    }

    void get_integeri_v_ext(gl::enum_t target, gl::uint_t index, gl::int_t * data) {
      if ( GLAD_GL_EXT_multiview_draw_buffers ) {
        glGetIntegeri_vEXT(target, index, data);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetIntegeri_vEXT' not available on this platform (extensions: GL_EXT_multiview_draw_buffers)");
      }
    }

    void get_internalformat_sampleiv_nv(gl::enum_t target, gl::enum_t internalformat, gl::sizei_t samples, gl::enum_t pname, gl::sizei_t bufSize, gl::int_t * params) {
      if ( GLAD_GL_NV_internalformat_sample_query ) {
        glGetInternalformatSampleivNV(target, internalformat, samples, pname, bufSize, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetInternalformatSampleivNV' not available on this platform (extensions: GL_NV_internalformat_sample_query)");
      }
    }

    void get_next_perf_query_id_intel(gl::uint_t queryId, gl::uint_t * nextQueryId) {
      if ( GLAD_GL_INTEL_performance_query ) {
        glGetNextPerfQueryIdINTEL(queryId, nextQueryId);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetNextPerfQueryIdINTEL' not available on this platform (extensions: GL_INTEL_performance_query)");
      }
    }

    void get_object_label_ext(gl::enum_t type, gl::uint_t object, gl::sizei_t bufSize, gl::sizei_t * length, gl::char_t * label) {
      if ( GLAD_GL_EXT_debug_label ) {
        glGetObjectLabelEXT(type, object, bufSize, length, label);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetObjectLabelEXT' not available on this platform (extensions: GL_EXT_debug_label)");
      }
    }

    void get_object_label_khr(gl::enum_t identifier, gl::uint_t name, gl::sizei_t bufSize, gl::sizei_t * length, gl::char_t * label) {
      if ( GLAD_GL_KHR_debug ) {
        glGetObjectLabelKHR(identifier, name, bufSize, length, label);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetObjectLabelKHR' not available on this platform (extensions: GL_KHR_debug)");
      }
    }

    void get_object_ptr_label_khr(const  void * ptr, gl::sizei_t bufSize, gl::sizei_t * length, gl::char_t * label) {
      if ( GLAD_GL_KHR_debug ) {
        glGetObjectPtrLabelKHR(ptr, bufSize, length, label);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetObjectPtrLabelKHR' not available on this platform (extensions: GL_KHR_debug)");
      }
    }

    void get_path_commands_nv(gl::uint_t path, gl::ubyte_t * commands) {
      if ( GLAD_GL_NV_path_rendering ) {
        glGetPathCommandsNV(path, commands);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetPathCommandsNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void get_path_coords_nv(gl::uint_t path, gl::float_t * coords) {
      if ( GLAD_GL_NV_path_rendering ) {
        glGetPathCoordsNV(path, coords);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetPathCoordsNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void get_path_dash_array_nv(gl::uint_t path, gl::float_t * dashArray) {
      if ( GLAD_GL_NV_path_rendering ) {
        glGetPathDashArrayNV(path, dashArray);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetPathDashArrayNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    gl::float_t get_path_length_nv(gl::uint_t path, gl::sizei_t startSegment, gl::sizei_t numSegments) {
      if ( GLAD_GL_NV_path_rendering ) {
        return glGetPathLengthNV(path, startSegment, numSegments);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetPathLengthNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void get_path_metric_range_nv(gl::bitfield_t metricQueryMask, gl::uint_t firstPathName, gl::sizei_t numPaths, gl::sizei_t stride, gl::float_t * metrics) {
      if ( GLAD_GL_NV_path_rendering ) {
        glGetPathMetricRangeNV(metricQueryMask, firstPathName, numPaths, stride, metrics);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetPathMetricRangeNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void get_path_metrics_nv(gl::bitfield_t metricQueryMask, gl::sizei_t numPaths, gl::enum_t pathNameType, const  void * paths, gl::uint_t pathBase, gl::sizei_t stride, gl::float_t * metrics) {
      if ( GLAD_GL_NV_path_rendering ) {
        glGetPathMetricsNV(metricQueryMask, numPaths, pathNameType, paths, pathBase, stride, metrics);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetPathMetricsNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void get_path_parameterfv_nv(gl::uint_t path, gl::enum_t pname, gl::float_t * value) {
      if ( GLAD_GL_NV_path_rendering ) {
        glGetPathParameterfvNV(path, pname, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetPathParameterfvNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void get_path_parameteriv_nv(gl::uint_t path, gl::enum_t pname, gl::int_t * value) {
      if ( GLAD_GL_NV_path_rendering ) {
        glGetPathParameterivNV(path, pname, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetPathParameterivNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void get_path_spacing_nv(gl::enum_t pathListMode, gl::sizei_t numPaths, gl::enum_t pathNameType, const  void * paths, gl::uint_t pathBase, gl::float_t advanceScale, gl::float_t kerningScale, gl::enum_t transformType, gl::float_t * returnedSpacing) {
      if ( GLAD_GL_NV_path_rendering ) {
        glGetPathSpacingNV(pathListMode, numPaths, pathNameType, paths, pathBase, advanceScale, kerningScale, transformType, returnedSpacing);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetPathSpacingNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void get_perf_counter_info_intel(gl::uint_t queryId, gl::uint_t counterId, gl::uint_t counterNameLength, gl::char_t * counterName, gl::uint_t counterDescLength, gl::char_t * counterDesc, gl::uint_t * counterOffset, gl::uint_t * counterDataSize, gl::uint_t * counterTypeEnum, gl::uint_t * counterDataTypeEnum, gl::uint64_t * rawCounterMaxValue) {
      if ( GLAD_GL_INTEL_performance_query ) {
        glGetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetPerfCounterInfoINTEL' not available on this platform (extensions: GL_INTEL_performance_query)");
      }
    }

    void get_perf_monitor_counter_data_amd(gl::uint_t monitor, gl::enum_t pname, gl::sizei_t dataSize, gl::uint_t * data, gl::int_t * bytesWritten) {
      if ( GLAD_GL_AMD_performance_monitor ) {
        glGetPerfMonitorCounterDataAMD(monitor, pname, dataSize, data, bytesWritten);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetPerfMonitorCounterDataAMD' not available on this platform (extensions: GL_AMD_performance_monitor)");
      }
    }

    void get_perf_monitor_counter_info_amd(gl::uint_t group, gl::uint_t counter, gl::enum_t pname, void * data) {
      if ( GLAD_GL_AMD_performance_monitor ) {
        glGetPerfMonitorCounterInfoAMD(group, counter, pname, data);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetPerfMonitorCounterInfoAMD' not available on this platform (extensions: GL_AMD_performance_monitor)");
      }
    }

    void get_perf_monitor_counter_string_amd(gl::uint_t group, gl::uint_t counter, gl::sizei_t bufSize, gl::sizei_t * length, gl::char_t * counterString) {
      if ( GLAD_GL_AMD_performance_monitor ) {
        glGetPerfMonitorCounterStringAMD(group, counter, bufSize, length, counterString);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetPerfMonitorCounterStringAMD' not available on this platform (extensions: GL_AMD_performance_monitor)");
      }
    }

    void get_perf_monitor_counters_amd(gl::uint_t group, gl::int_t * numCounters, gl::int_t * maxActiveCounters, gl::sizei_t counterSize, gl::uint_t * counters) {
      if ( GLAD_GL_AMD_performance_monitor ) {
        glGetPerfMonitorCountersAMD(group, numCounters, maxActiveCounters, counterSize, counters);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetPerfMonitorCountersAMD' not available on this platform (extensions: GL_AMD_performance_monitor)");
      }
    }

    void get_perf_monitor_group_string_amd(gl::uint_t group, gl::sizei_t bufSize, gl::sizei_t * length, gl::char_t * groupString) {
      if ( GLAD_GL_AMD_performance_monitor ) {
        glGetPerfMonitorGroupStringAMD(group, bufSize, length, groupString);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetPerfMonitorGroupStringAMD' not available on this platform (extensions: GL_AMD_performance_monitor)");
      }
    }

    void get_perf_monitor_groups_amd(gl::int_t * numGroups, gl::sizei_t groupsSize, gl::uint_t * groups) {
      if ( GLAD_GL_AMD_performance_monitor ) {
        glGetPerfMonitorGroupsAMD(numGroups, groupsSize, groups);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetPerfMonitorGroupsAMD' not available on this platform (extensions: GL_AMD_performance_monitor)");
      }
    }

    void get_perf_query_data_intel(gl::uint_t queryHandle, gl::uint_t flags, gl::sizei_t dataSize, void * data, gl::uint_t * bytesWritten) {
      if ( GLAD_GL_INTEL_performance_query ) {
        glGetPerfQueryDataINTEL(queryHandle, flags, dataSize, data, bytesWritten);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetPerfQueryDataINTEL' not available on this platform (extensions: GL_INTEL_performance_query)");
      }
    }

    void get_perf_query_id_by_name_intel(gl::char_t * queryName, gl::uint_t * queryId) {
      if ( GLAD_GL_INTEL_performance_query ) {
        glGetPerfQueryIdByNameINTEL(queryName, queryId);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetPerfQueryIdByNameINTEL' not available on this platform (extensions: GL_INTEL_performance_query)");
      }
    }

    void get_perf_query_info_intel(gl::uint_t queryId, gl::uint_t queryNameLength, gl::char_t * queryName, gl::uint_t * dataSize, gl::uint_t * noCounters, gl::uint_t * noInstances, gl::uint_t * capsMask) {
      if ( GLAD_GL_INTEL_performance_query ) {
        glGetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, dataSize, noCounters, noInstances, capsMask);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetPerfQueryInfoINTEL' not available on this platform (extensions: GL_INTEL_performance_query)");
      }
    }

    void get_pointerv_khr(get_pointerv_p_name_t pname, void ** params) {
      if ( GLAD_GL_KHR_debug ) {
        glGetPointervKHR(static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetPointervKHR' not available on this platform (extensions: GL_KHR_debug)");
      }
    }

    void get_program_binary_oes(gl::uint_t program, gl::sizei_t bufSize, gl::sizei_t * length, gl::enum_t * binaryFormat, void * binary) {
      if ( GLAD_GL_OES_get_program_binary ) {
        glGetProgramBinaryOES(program, bufSize, length, binaryFormat, binary);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetProgramBinaryOES' not available on this platform (extensions: GL_OES_get_program_binary)");
      }
    }

    void get_program_pipeline_info_log_ext(gl::uint_t pipeline, gl::sizei_t bufSize, gl::sizei_t * length, gl::char_t * infoLog) {
      if ( GLAD_GL_EXT_separate_shader_objects ) {
        glGetProgramPipelineInfoLogEXT(pipeline, bufSize, length, infoLog);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetProgramPipelineInfoLogEXT' not available on this platform (extensions: GL_EXT_separate_shader_objects)");
      }
    }

    void get_program_pipelineiv_ext(gl::uint_t pipeline, gl::enum_t pname, gl::int_t * params) {
      if ( GLAD_GL_EXT_separate_shader_objects ) {
        glGetProgramPipelineivEXT(pipeline, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetProgramPipelineivEXT' not available on this platform (extensions: GL_EXT_separate_shader_objects)");
      }
    }

    void get_program_resourcefv_nv(gl::uint_t program, gl::enum_t programInterface, gl::uint_t index, gl::sizei_t propCount, const  gl::enum_t * props, gl::sizei_t bufSize, gl::sizei_t * length, gl::float_t * params) {
      if ( GLAD_GL_NV_path_rendering ) {
        glGetProgramResourcefvNV(program, programInterface, index, propCount, props, bufSize, length, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetProgramResourcefvNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void get_query_objecti_64v_ext(gl::uint_t id, gl::enum_t pname, gl::int64_t * params) {
      if ( GLAD_GL_EXT_disjoint_timer_query ) {
        glGetQueryObjecti64vEXT(id, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetQueryObjecti64vEXT' not available on this platform (extensions: GL_EXT_disjoint_timer_query)");
      }
    }

    void get_query_objectiv_ext(gl::uint_t id, gl::enum_t pname, gl::int_t * params) {
      if ( GLAD_GL_EXT_disjoint_timer_query ) {
        glGetQueryObjectivEXT(id, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetQueryObjectivEXT' not available on this platform (extensions: GL_EXT_disjoint_timer_query)");
      }
    }

    void get_query_objectui_64v_ext(gl::uint_t id, gl::enum_t pname, gl::uint64_t * params) {
      if ( GLAD_GL_EXT_disjoint_timer_query ) {
        glGetQueryObjectui64vEXT(id, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetQueryObjectui64vEXT' not available on this platform (extensions: GL_EXT_disjoint_timer_query)");
      }
    }

    void get_query_objectuiv_ext(gl::uint_t id, gl::enum_t pname, gl::uint_t * params) {
      if ( GLAD_GL_EXT_disjoint_timer_query || GLAD_GL_EXT_occlusion_query_boolean ) {
        glGetQueryObjectuivEXT(id, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetQueryObjectuivEXT' not available on this platform (extensions: GL_EXT_disjoint_timer_query, GL_EXT_occlusion_query_boolean)");
      }
    }

    void get_queryiv_ext(gl::enum_t target, gl::enum_t pname, gl::int_t * params) {
      if ( GLAD_GL_EXT_disjoint_timer_query || GLAD_GL_EXT_occlusion_query_boolean ) {
        glGetQueryivEXT(target, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetQueryivEXT' not available on this platform (extensions: GL_EXT_disjoint_timer_query, GL_EXT_occlusion_query_boolean)");
      }
    }

    void get_sampler_parameter_iiv_ext(gl::uint_t sampler, gl::enum_t pname, gl::int_t * params) {
      if ( GLAD_GL_EXT_texture_border_clamp ) {
        glGetSamplerParameterIivEXT(sampler, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetSamplerParameterIivEXT' not available on this platform (extensions: GL_EXT_texture_border_clamp)");
      }
    }

    void get_sampler_parameter_iiv_oes(gl::uint_t sampler, gl::enum_t pname, gl::int_t * params) {
      if ( GLAD_GL_OES_texture_border_clamp ) {
        glGetSamplerParameterIivOES(sampler, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetSamplerParameterIivOES' not available on this platform (extensions: GL_OES_texture_border_clamp)");
      }
    }

    void get_sampler_parameter_iuiv_ext(gl::uint_t sampler, gl::enum_t pname, gl::uint_t * params) {
      if ( GLAD_GL_EXT_texture_border_clamp ) {
        glGetSamplerParameterIuivEXT(sampler, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetSamplerParameterIuivEXT' not available on this platform (extensions: GL_EXT_texture_border_clamp)");
      }
    }

    void get_sampler_parameter_iuiv_oes(gl::uint_t sampler, gl::enum_t pname, gl::uint_t * params) {
      if ( GLAD_GL_OES_texture_border_clamp ) {
        glGetSamplerParameterIuivOES(sampler, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetSamplerParameterIuivOES' not available on this platform (extensions: GL_OES_texture_border_clamp)");
      }
    }

    void get_synciv_apple(gl::sync_t sync, gl::enum_t pname, gl::sizei_t bufSize, gl::sizei_t * length, gl::int_t * values) {
      if ( GLAD_GL_APPLE_sync ) {
        glGetSyncivAPPLE(sync, pname, bufSize, length, values);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetSyncivAPPLE' not available on this platform (extensions: GL_APPLE_sync)");
      }
    }

    void get_tex_parameter_iiv_ext(texture_target_t target, get_texture_parameter_t pname, gl::int_t * params) {
      if ( GLAD_GL_EXT_texture_border_clamp ) {
        glGetTexParameterIivEXT(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetTexParameterIivEXT' not available on this platform (extensions: GL_EXT_texture_border_clamp)");
      }
    }

    void get_tex_parameter_iiv_oes(texture_target_t target, get_texture_parameter_t pname, gl::int_t * params) {
      if ( GLAD_GL_OES_texture_border_clamp ) {
        glGetTexParameterIivOES(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetTexParameterIivOES' not available on this platform (extensions: GL_OES_texture_border_clamp)");
      }
    }

    void get_tex_parameter_iuiv_ext(texture_target_t target, get_texture_parameter_t pname, gl::uint_t * params) {
      if ( GLAD_GL_EXT_texture_border_clamp ) {
        glGetTexParameterIuivEXT(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetTexParameterIuivEXT' not available on this platform (extensions: GL_EXT_texture_border_clamp)");
      }
    }

    void get_tex_parameter_iuiv_oes(texture_target_t target, get_texture_parameter_t pname, gl::uint_t * params) {
      if ( GLAD_GL_OES_texture_border_clamp ) {
        glGetTexParameterIuivOES(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetTexParameterIuivOES' not available on this platform (extensions: GL_OES_texture_border_clamp)");
      }
    }

    gl::uint64_t get_texture_handle_nv(gl::uint_t texture) {
      if ( GLAD_GL_NV_bindless_texture ) {
        return glGetTextureHandleNV(texture);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetTextureHandleNV' not available on this platform (extensions: GL_NV_bindless_texture)");
      }
    }

    gl::uint64_t get_texture_sampler_handle_nv(gl::uint_t texture, gl::uint_t sampler) {
      if ( GLAD_GL_NV_bindless_texture ) {
        return glGetTextureSamplerHandleNV(texture, sampler);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetTextureSamplerHandleNV' not available on this platform (extensions: GL_NV_bindless_texture)");
      }
    }

    void get_translated_shader_source_angle(gl::uint_t shader, gl::sizei_t bufsize, gl::sizei_t * length, gl::char_t * source) {
      if ( GLAD_GL_ANGLE_translated_shader_source ) {
        glGetTranslatedShaderSourceANGLE(shader, bufsize, length, source);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetTranslatedShaderSourceANGLE' not available on this platform (extensions: GL_ANGLE_translated_shader_source)");
      }
    }

    void getn_uniformfv_ext(gl::uint_t program, gl::int_t location, gl::sizei_t bufSize, gl::float_t * params) {
      if ( GLAD_GL_EXT_robustness ) {
        glGetnUniformfvEXT(program, location, bufSize, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetnUniformfvEXT' not available on this platform (extensions: GL_EXT_robustness)");
      }
    }

    void getn_uniformfv_khr(gl::uint_t program, gl::int_t location, gl::sizei_t bufSize, gl::float_t * params) {
      if ( GLAD_GL_KHR_robustness ) {
        glGetnUniformfvKHR(program, location, bufSize, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetnUniformfvKHR' not available on this platform (extensions: GL_KHR_robustness)");
      }
    }

    void getn_uniformiv_ext(gl::uint_t program, gl::int_t location, gl::sizei_t bufSize, gl::int_t * params) {
      if ( GLAD_GL_EXT_robustness ) {
        glGetnUniformivEXT(program, location, bufSize, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetnUniformivEXT' not available on this platform (extensions: GL_EXT_robustness)");
      }
    }

    void getn_uniformiv_khr(gl::uint_t program, gl::int_t location, gl::sizei_t bufSize, gl::int_t * params) {
      if ( GLAD_GL_KHR_robustness ) {
        glGetnUniformivKHR(program, location, bufSize, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetnUniformivKHR' not available on this platform (extensions: GL_KHR_robustness)");
      }
    }

    void getn_uniformuiv_khr(gl::uint_t program, gl::int_t location, gl::sizei_t bufSize, gl::uint_t * params) {
      if ( GLAD_GL_KHR_robustness ) {
        glGetnUniformuivKHR(program, location, bufSize, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetnUniformuivKHR' not available on this platform (extensions: GL_KHR_robustness)");
      }
    }

    void insert_event_marker_ext(gl::sizei_t length, const  gl::char_t * marker) {
      if ( GLAD_GL_EXT_debug_marker ) {
        glInsertEventMarkerEXT(length, marker);
      }
      else {
        throw std::runtime_error("OpenGL command 'glInsertEventMarkerEXT' not available on this platform (extensions: GL_EXT_debug_marker)");
      }
    }

    void interpolate_paths_nv(gl::uint_t resultPath, gl::uint_t pathA, gl::uint_t pathB, gl::float_t weight) {
      if ( GLAD_GL_NV_path_rendering ) {
        glInterpolatePathsNV(resultPath, pathA, pathB, weight);
      }
      else {
        throw std::runtime_error("OpenGL command 'glInterpolatePathsNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    gl::boolean_t is_enabledi_ext(gl::enum_t target, gl::uint_t index) {
      if ( GLAD_GL_EXT_draw_buffers_indexed ) {
        return glIsEnablediEXT(target, index);
      }
      else {
        throw std::runtime_error("OpenGL command 'glIsEnablediEXT' not available on this platform (extensions: GL_EXT_draw_buffers_indexed)");
      }
    }

    gl::boolean_t is_enabledi_nv(gl::enum_t target, gl::uint_t index) {
      if ( GLAD_GL_NV_viewport_array ) {
        return glIsEnablediNV(target, index);
      }
      else {
        throw std::runtime_error("OpenGL command 'glIsEnablediNV' not available on this platform (extensions: GL_NV_viewport_array)");
      }
    }

    gl::boolean_t is_enabledi_oes(gl::enum_t target, gl::uint_t index) {
      if ( GLAD_GL_OES_draw_buffers_indexed ) {
        return glIsEnablediOES(target, index);
      }
      else {
        throw std::runtime_error("OpenGL command 'glIsEnablediOES' not available on this platform (extensions: GL_OES_draw_buffers_indexed)");
      }
    }

    gl::boolean_t is_fence_nv(gl::uint_t fence) {
      if ( GLAD_GL_NV_fence ) {
        return glIsFenceNV(fence);
      }
      else {
        throw std::runtime_error("OpenGL command 'glIsFenceNV' not available on this platform (extensions: GL_NV_fence)");
      }
    }

    gl::boolean_t is_image_handle_resident_nv(gl::uint64_t handle) {
      if ( GLAD_GL_NV_bindless_texture ) {
        return glIsImageHandleResidentNV(handle);
      }
      else {
        throw std::runtime_error("OpenGL command 'glIsImageHandleResidentNV' not available on this platform (extensions: GL_NV_bindless_texture)");
      }
    }

    gl::boolean_t is_path_nv(gl::uint_t path) {
      if ( GLAD_GL_NV_path_rendering ) {
        return glIsPathNV(path);
      }
      else {
        throw std::runtime_error("OpenGL command 'glIsPathNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    gl::boolean_t is_point_in_fill_path_nv(gl::uint_t path, gl::uint_t mask, gl::float_t x, gl::float_t y) {
      if ( GLAD_GL_NV_path_rendering ) {
        return glIsPointInFillPathNV(path, mask, x, y);
      }
      else {
        throw std::runtime_error("OpenGL command 'glIsPointInFillPathNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    gl::boolean_t is_point_in_stroke_path_nv(gl::uint_t path, gl::float_t x, gl::float_t y) {
      if ( GLAD_GL_NV_path_rendering ) {
        return glIsPointInStrokePathNV(path, x, y);
      }
      else {
        throw std::runtime_error("OpenGL command 'glIsPointInStrokePathNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    gl::boolean_t is_program_pipeline_ext(gl::uint_t pipeline) {
      if ( GLAD_GL_EXT_separate_shader_objects ) {
        return glIsProgramPipelineEXT(pipeline);
      }
      else {
        throw std::runtime_error("OpenGL command 'glIsProgramPipelineEXT' not available on this platform (extensions: GL_EXT_separate_shader_objects)");
      }
    }

    gl::boolean_t is_query_ext(gl::uint_t id) {
      if ( GLAD_GL_EXT_disjoint_timer_query || GLAD_GL_EXT_occlusion_query_boolean ) {
        return glIsQueryEXT(id);
      }
      else {
        throw std::runtime_error("OpenGL command 'glIsQueryEXT' not available on this platform (extensions: GL_EXT_disjoint_timer_query, GL_EXT_occlusion_query_boolean)");
      }
    }

    gl::boolean_t is_sync_apple(gl::sync_t sync) {
      if ( GLAD_GL_APPLE_sync ) {
        return glIsSyncAPPLE(sync);
      }
      else {
        throw std::runtime_error("OpenGL command 'glIsSyncAPPLE' not available on this platform (extensions: GL_APPLE_sync)");
      }
    }

    gl::boolean_t is_texture_handle_resident_nv(gl::uint64_t handle) {
      if ( GLAD_GL_NV_bindless_texture ) {
        return glIsTextureHandleResidentNV(handle);
      }
      else {
        throw std::runtime_error("OpenGL command 'glIsTextureHandleResidentNV' not available on this platform (extensions: GL_NV_bindless_texture)");
      }
    }

    gl::boolean_t is_vertex_array_oes(gl::uint_t array) {
      if ( GLAD_GL_OES_vertex_array_object ) {
        return glIsVertexArrayOES(array);
      }
      else {
        throw std::runtime_error("OpenGL command 'glIsVertexArrayOES' not available on this platform (extensions: GL_OES_vertex_array_object)");
      }
    }

    void label_object_ext(gl::enum_t type, gl::uint_t object, gl::sizei_t length, const  gl::char_t * label) {
      if ( GLAD_GL_EXT_debug_label ) {
        glLabelObjectEXT(type, object, length, label);
      }
      else {
        throw std::runtime_error("OpenGL command 'glLabelObjectEXT' not available on this platform (extensions: GL_EXT_debug_label)");
      }
    }

    void make_image_handle_non_resident_nv(gl::uint64_t handle) {
      if ( GLAD_GL_NV_bindless_texture ) {
        glMakeImageHandleNonResidentNV(handle);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMakeImageHandleNonResidentNV' not available on this platform (extensions: GL_NV_bindless_texture)");
      }
    }

    void make_image_handle_resident_nv(gl::uint64_t handle, gl::enum_t access) {
      if ( GLAD_GL_NV_bindless_texture ) {
        glMakeImageHandleResidentNV(handle, access);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMakeImageHandleResidentNV' not available on this platform (extensions: GL_NV_bindless_texture)");
      }
    }

    void make_texture_handle_non_resident_nv(gl::uint64_t handle) {
      if ( GLAD_GL_NV_bindless_texture ) {
        glMakeTextureHandleNonResidentNV(handle);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMakeTextureHandleNonResidentNV' not available on this platform (extensions: GL_NV_bindless_texture)");
      }
    }

    void make_texture_handle_resident_nv(gl::uint64_t handle) {
      if ( GLAD_GL_NV_bindless_texture ) {
        glMakeTextureHandleResidentNV(handle);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMakeTextureHandleResidentNV' not available on this platform (extensions: GL_NV_bindless_texture)");
      }
    }

    void * map_buffer_oes(buffer_target_arb_t target, gl::enum_t access) {
      if ( GLAD_GL_OES_mapbuffer ) {
        return glMapBufferOES(static_cast<GLenum>(target), access);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMapBufferOES' not available on this platform (extensions: GL_OES_mapbuffer)");
      }
    }

    void * map_buffer_range_ext(buffer_target_arb_t target, gl::intptr_t offset, gl::sizeiptr_t length, gl::bitfield_t access) {
      if ( GLAD_GL_EXT_map_buffer_range ) {
        return glMapBufferRangeEXT(static_cast<GLenum>(target), offset, length, access);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMapBufferRangeEXT' not available on this platform (extensions: GL_EXT_map_buffer_range)");
      }
    }

    void matrix_load_3x_2f_nv(gl::enum_t matrixMode, const  gl::float_t * m) {
      if ( GLAD_GL_NV_path_rendering ) {
        glMatrixLoad3x2fNV(matrixMode, m);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMatrixLoad3x2fNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void matrix_load_3x_3f_nv(gl::enum_t matrixMode, const  gl::float_t * m) {
      if ( GLAD_GL_NV_path_rendering ) {
        glMatrixLoad3x3fNV(matrixMode, m);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMatrixLoad3x3fNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void matrix_load_transpose_3x_3f_nv(gl::enum_t matrixMode, const  gl::float_t * m) {
      if ( GLAD_GL_NV_path_rendering ) {
        glMatrixLoadTranspose3x3fNV(matrixMode, m);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMatrixLoadTranspose3x3fNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void matrix_mult_3x_2f_nv(gl::enum_t matrixMode, const  gl::float_t * m) {
      if ( GLAD_GL_NV_path_rendering ) {
        glMatrixMult3x2fNV(matrixMode, m);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMatrixMult3x2fNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void matrix_mult_3x_3f_nv(gl::enum_t matrixMode, const  gl::float_t * m) {
      if ( GLAD_GL_NV_path_rendering ) {
        glMatrixMult3x3fNV(matrixMode, m);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMatrixMult3x3fNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void matrix_mult_transpose_3x_3f_nv(gl::enum_t matrixMode, const  gl::float_t * m) {
      if ( GLAD_GL_NV_path_rendering ) {
        glMatrixMultTranspose3x3fNV(matrixMode, m);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMatrixMultTranspose3x3fNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void min_sample_shading_oes(gl::float_t value) {
      if ( GLAD_GL_OES_sample_shading ) {
        glMinSampleShadingOES(value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMinSampleShadingOES' not available on this platform (extensions: GL_OES_sample_shading)");
      }
    }

    void multi_draw_arrays_ext(primitive_type_t mode, const  gl::int_t * first, const  gl::sizei_t * count, gl::sizei_t primcount) {
      if ( GLAD_GL_EXT_multi_draw_arrays ) {
        glMultiDrawArraysEXT(static_cast<GLenum>(mode), first, count, primcount);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiDrawArraysEXT' not available on this platform (extensions: GL_EXT_multi_draw_arrays)");
      }
    }

    void multi_draw_arrays_indirect_ext(gl::enum_t mode, const  void * indirect, gl::sizei_t drawcount, gl::sizei_t stride) {
      if ( GLAD_GL_EXT_multi_draw_indirect ) {
        glMultiDrawArraysIndirectEXT(mode, indirect, drawcount, stride);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiDrawArraysIndirectEXT' not available on this platform (extensions: GL_EXT_multi_draw_indirect)");
      }
    }

    void multi_draw_elements_base_vertex_ext(gl::enum_t mode, const  gl::sizei_t * count, draw_elements_type_t type, const  void ** indices, gl::sizei_t primcount, const  gl::int_t * basevertex) {
      if ( GLAD_GL_EXT_draw_elements_base_vertex ) {
        glMultiDrawElementsBaseVertexEXT(mode, count, static_cast<GLenum>(type), indices, primcount, basevertex);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiDrawElementsBaseVertexEXT' not available on this platform (extensions: GL_EXT_draw_elements_base_vertex)");
      }
    }

    void multi_draw_elements_base_vertex_oes(gl::enum_t mode, const  gl::sizei_t * count, draw_elements_type_t type, const  void ** indices, gl::sizei_t primcount, const  gl::int_t * basevertex) {
      if ( GLAD_GL_OES_draw_elements_base_vertex ) {
        glMultiDrawElementsBaseVertexOES(mode, count, static_cast<GLenum>(type), indices, primcount, basevertex);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiDrawElementsBaseVertexOES' not available on this platform (extensions: GL_OES_draw_elements_base_vertex)");
      }
    }

    void multi_draw_elements_ext(primitive_type_t mode, const  gl::sizei_t * count, draw_elements_type_t type, const  void * * indices, gl::sizei_t primcount) {
      if ( GLAD_GL_EXT_multi_draw_arrays ) {
        glMultiDrawElementsEXT(static_cast<GLenum>(mode), count, static_cast<GLenum>(type), indices, primcount);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiDrawElementsEXT' not available on this platform (extensions: GL_EXT_multi_draw_arrays)");
      }
    }

    void multi_draw_elements_indirect_ext(gl::enum_t mode, gl::enum_t type, const  void * indirect, gl::sizei_t drawcount, gl::sizei_t stride) {
      if ( GLAD_GL_EXT_multi_draw_indirect ) {
        glMultiDrawElementsIndirectEXT(mode, type, indirect, drawcount, stride);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiDrawElementsIndirectEXT' not available on this platform (extensions: GL_EXT_multi_draw_indirect)");
      }
    }

    void object_label_khr(gl::enum_t identifier, gl::uint_t name, gl::sizei_t length, const  gl::char_t * label) {
      if ( GLAD_GL_KHR_debug ) {
        glObjectLabelKHR(identifier, name, length, label);
      }
      else {
        throw std::runtime_error("OpenGL command 'glObjectLabelKHR' not available on this platform (extensions: GL_KHR_debug)");
      }
    }

    void object_ptr_label_khr(const  void * ptr, gl::sizei_t length, const  gl::char_t * label) {
      if ( GLAD_GL_KHR_debug ) {
        glObjectPtrLabelKHR(ptr, length, label);
      }
      else {
        throw std::runtime_error("OpenGL command 'glObjectPtrLabelKHR' not available on this platform (extensions: GL_KHR_debug)");
      }
    }

    void patch_parameteri_ext(gl::enum_t pname, gl::int_t value) {
      if ( GLAD_GL_EXT_tessellation_shader ) {
        glPatchParameteriEXT(pname, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPatchParameteriEXT' not available on this platform (extensions: GL_EXT_tessellation_shader)");
      }
    }

    void patch_parameteri_oes(gl::enum_t pname, gl::int_t value) {
      if ( GLAD_GL_OES_tessellation_shader ) {
        glPatchParameteriOES(pname, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPatchParameteriOES' not available on this platform (extensions: GL_OES_tessellation_shader)");
      }
    }

    void path_commands_nv(gl::uint_t path, gl::sizei_t numCommands, const  gl::ubyte_t * commands, gl::sizei_t numCoords, gl::enum_t coordType, const  void * coords) {
      if ( GLAD_GL_NV_path_rendering ) {
        glPathCommandsNV(path, numCommands, commands, numCoords, coordType, coords);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPathCommandsNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void path_coords_nv(gl::uint_t path, gl::sizei_t numCoords, gl::enum_t coordType, const  void * coords) {
      if ( GLAD_GL_NV_path_rendering ) {
        glPathCoordsNV(path, numCoords, coordType, coords);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPathCoordsNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void path_cover_depth_func_nv(depth_function_t func) {
      if ( GLAD_GL_NV_path_rendering ) {
        glPathCoverDepthFuncNV(static_cast<GLenum>(func));
      }
      else {
        throw std::runtime_error("OpenGL command 'glPathCoverDepthFuncNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void path_dash_array_nv(gl::uint_t path, gl::sizei_t dashCount, const  gl::float_t * dashArray) {
      if ( GLAD_GL_NV_path_rendering ) {
        glPathDashArrayNV(path, dashCount, dashArray);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPathDashArrayNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    gl::enum_t path_glyph_index_array_nv(gl::uint_t firstPathName, gl::enum_t fontTarget, const  void * fontName, gl::bitfield_t fontStyle, gl::uint_t firstGlyphIndex, gl::sizei_t numGlyphs, gl::uint_t pathParameterTemplate, gl::float_t emScale) {
      if ( GLAD_GL_NV_path_rendering ) {
        return glPathGlyphIndexArrayNV(firstPathName, fontTarget, fontName, fontStyle, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPathGlyphIndexArrayNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    gl::enum_t path_glyph_index_range_nv(gl::enum_t fontTarget, const  void * fontName, gl::bitfield_t fontStyle, gl::uint_t pathParameterTemplate, gl::float_t emScale, gl::uint_t * baseAndCount) {
      if ( GLAD_GL_NV_path_rendering ) {
        return glPathGlyphIndexRangeNV(fontTarget, fontName, fontStyle, pathParameterTemplate, emScale, baseAndCount);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPathGlyphIndexRangeNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void path_glyph_range_nv(gl::uint_t firstPathName, gl::enum_t fontTarget, const  void * fontName, gl::bitfield_t fontStyle, gl::uint_t firstGlyph, gl::sizei_t numGlyphs, gl::enum_t handleMissingGlyphs, gl::uint_t pathParameterTemplate, gl::float_t emScale) {
      if ( GLAD_GL_NV_path_rendering ) {
        glPathGlyphRangeNV(firstPathName, fontTarget, fontName, fontStyle, firstGlyph, numGlyphs, handleMissingGlyphs, pathParameterTemplate, emScale);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPathGlyphRangeNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void path_glyphs_nv(gl::uint_t firstPathName, gl::enum_t fontTarget, const  void * fontName, gl::bitfield_t fontStyle, gl::sizei_t numGlyphs, gl::enum_t type, const  void * charcodes, gl::enum_t handleMissingGlyphs, gl::uint_t pathParameterTemplate, gl::float_t emScale) {
      if ( GLAD_GL_NV_path_rendering ) {
        glPathGlyphsNV(firstPathName, fontTarget, fontName, fontStyle, numGlyphs, type, charcodes, handleMissingGlyphs, pathParameterTemplate, emScale);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPathGlyphsNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    gl::enum_t path_memory_glyph_index_array_nv(gl::uint_t firstPathName, gl::enum_t fontTarget, gl::sizeiptr_t fontSize, const  void * fontData, gl::sizei_t faceIndex, gl::uint_t firstGlyphIndex, gl::sizei_t numGlyphs, gl::uint_t pathParameterTemplate, gl::float_t emScale) {
      if ( GLAD_GL_NV_path_rendering ) {
        return glPathMemoryGlyphIndexArrayNV(firstPathName, fontTarget, fontSize, fontData, faceIndex, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPathMemoryGlyphIndexArrayNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void path_parameterf_nv(gl::uint_t path, gl::enum_t pname, gl::float_t value) {
      if ( GLAD_GL_NV_path_rendering ) {
        glPathParameterfNV(path, pname, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPathParameterfNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void path_parameterfv_nv(gl::uint_t path, gl::enum_t pname, const  gl::float_t * value) {
      if ( GLAD_GL_NV_path_rendering ) {
        glPathParameterfvNV(path, pname, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPathParameterfvNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void path_parameteri_nv(gl::uint_t path, gl::enum_t pname, gl::int_t value) {
      if ( GLAD_GL_NV_path_rendering ) {
        glPathParameteriNV(path, pname, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPathParameteriNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void path_parameteriv_nv(gl::uint_t path, gl::enum_t pname, const  gl::int_t * value) {
      if ( GLAD_GL_NV_path_rendering ) {
        glPathParameterivNV(path, pname, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPathParameterivNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void path_stencil_depth_offset_nv(gl::float_t factor, gl::float_t units) {
      if ( GLAD_GL_NV_path_rendering ) {
        glPathStencilDepthOffsetNV(factor, units);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPathStencilDepthOffsetNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void path_stencil_func_nv(stencil_function_t func, gl::int_t ref, gl::uint_t mask) {
      if ( GLAD_GL_NV_path_rendering ) {
        glPathStencilFuncNV(static_cast<GLenum>(func), ref, mask);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPathStencilFuncNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void path_string_nv(gl::uint_t path, gl::enum_t format, gl::sizei_t length, const  void * pathString) {
      if ( GLAD_GL_NV_path_rendering ) {
        glPathStringNV(path, format, length, pathString);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPathStringNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void path_sub_commands_nv(gl::uint_t path, gl::sizei_t commandStart, gl::sizei_t commandsToDelete, gl::sizei_t numCommands, const  gl::ubyte_t * commands, gl::sizei_t numCoords, gl::enum_t coordType, const  void * coords) {
      if ( GLAD_GL_NV_path_rendering ) {
        glPathSubCommandsNV(path, commandStart, commandsToDelete, numCommands, commands, numCoords, coordType, coords);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPathSubCommandsNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void path_sub_coords_nv(gl::uint_t path, gl::sizei_t coordStart, gl::sizei_t numCoords, gl::enum_t coordType, const  void * coords) {
      if ( GLAD_GL_NV_path_rendering ) {
        glPathSubCoordsNV(path, coordStart, numCoords, coordType, coords);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPathSubCoordsNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    gl::boolean_t point_along_path_nv(gl::uint_t path, gl::sizei_t startSegment, gl::sizei_t numSegments, gl::float_t distance, gl::float_t * x, gl::float_t * y, gl::float_t * tangentX, gl::float_t * tangentY) {
      if ( GLAD_GL_NV_path_rendering ) {
        return glPointAlongPathNV(path, startSegment, numSegments, distance, x, y, tangentX, tangentY);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPointAlongPathNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void pop_debug_group_khr() {
      if ( GLAD_GL_KHR_debug ) {
        glPopDebugGroupKHR();
      }
      else {
        throw std::runtime_error("OpenGL command 'glPopDebugGroupKHR' not available on this platform (extensions: GL_KHR_debug)");
      }
    }

    void pop_group_marker_ext() {
      if ( GLAD_GL_EXT_debug_marker ) {
        glPopGroupMarkerEXT();
      }
      else {
        throw std::runtime_error("OpenGL command 'glPopGroupMarkerEXT' not available on this platform (extensions: GL_EXT_debug_marker)");
      }
    }

    void primitive_bounding_box_ext(gl::float_t minX, gl::float_t minY, gl::float_t minZ, gl::float_t minW, gl::float_t maxX, gl::float_t maxY, gl::float_t maxZ, gl::float_t maxW) {
      if ( GLAD_GL_EXT_primitive_bounding_box ) {
        glPrimitiveBoundingBoxEXT(minX, minY, minZ, minW, maxX, maxY, maxZ, maxW);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPrimitiveBoundingBoxEXT' not available on this platform (extensions: GL_EXT_primitive_bounding_box)");
      }
    }

    void primitive_bounding_box_oes(gl::float_t minX, gl::float_t minY, gl::float_t minZ, gl::float_t minW, gl::float_t maxX, gl::float_t maxY, gl::float_t maxZ, gl::float_t maxW) {
      if ( GLAD_GL_OES_primitive_bounding_box ) {
        glPrimitiveBoundingBoxOES(minX, minY, minZ, minW, maxX, maxY, maxZ, maxW);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPrimitiveBoundingBoxOES' not available on this platform (extensions: GL_OES_primitive_bounding_box)");
      }
    }

    void program_binary_oes(gl::uint_t program, gl::enum_t binaryFormat, const  void * binary, gl::int_t length) {
      if ( GLAD_GL_OES_get_program_binary ) {
        glProgramBinaryOES(program, binaryFormat, binary, length);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramBinaryOES' not available on this platform (extensions: GL_OES_get_program_binary)");
      }
    }

    void program_parameteri_ext(gl::uint_t program, gl::enum_t pname, gl::int_t value) {
      if ( GLAD_GL_EXT_separate_shader_objects ) {
        glProgramParameteriEXT(program, pname, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramParameteriEXT' not available on this platform (extensions: GL_EXT_separate_shader_objects)");
      }
    }

    void program_path_fragment_input_gen_nv(gl::uint_t program, gl::int_t location, gl::enum_t genMode, gl::int_t components, const  gl::float_t * coeffs) {
      if ( GLAD_GL_NV_path_rendering ) {
        glProgramPathFragmentInputGenNV(program, location, genMode, components, coeffs);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramPathFragmentInputGenNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void program_uniform_1f_ext(gl::uint_t program, gl::int_t location, gl::float_t v0) {
      if ( GLAD_GL_EXT_separate_shader_objects ) {
        glProgramUniform1fEXT(program, location, v0);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform1fEXT' not available on this platform (extensions: GL_EXT_separate_shader_objects)");
      }
    }

    void program_uniform_1fv_ext(gl::uint_t program, gl::int_t location, gl::sizei_t count, const  gl::float_t * value) {
      if ( GLAD_GL_EXT_separate_shader_objects ) {
        glProgramUniform1fvEXT(program, location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform1fvEXT' not available on this platform (extensions: GL_EXT_separate_shader_objects)");
      }
    }

    void program_uniform_1i_ext(gl::uint_t program, gl::int_t location, gl::int_t v0) {
      if ( GLAD_GL_EXT_separate_shader_objects ) {
        glProgramUniform1iEXT(program, location, v0);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform1iEXT' not available on this platform (extensions: GL_EXT_separate_shader_objects)");
      }
    }

    void program_uniform_1iv_ext(gl::uint_t program, gl::int_t location, gl::sizei_t count, const  gl::int_t * value) {
      if ( GLAD_GL_EXT_separate_shader_objects ) {
        glProgramUniform1ivEXT(program, location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform1ivEXT' not available on this platform (extensions: GL_EXT_separate_shader_objects)");
      }
    }

    void program_uniform_1ui_ext(gl::uint_t program, gl::int_t location, gl::uint_t v0) {
      if ( GLAD_GL_EXT_separate_shader_objects ) {
        glProgramUniform1uiEXT(program, location, v0);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform1uiEXT' not available on this platform (extensions: GL_EXT_separate_shader_objects)");
      }
    }

    void program_uniform_1uiv_ext(gl::uint_t program, gl::int_t location, gl::sizei_t count, const  gl::uint_t * value) {
      if ( GLAD_GL_EXT_separate_shader_objects ) {
        glProgramUniform1uivEXT(program, location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform1uivEXT' not available on this platform (extensions: GL_EXT_separate_shader_objects)");
      }
    }

    void program_uniform_2f_ext(gl::uint_t program, gl::int_t location, gl::float_t v0, gl::float_t v1) {
      if ( GLAD_GL_EXT_separate_shader_objects ) {
        glProgramUniform2fEXT(program, location, v0, v1);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform2fEXT' not available on this platform (extensions: GL_EXT_separate_shader_objects)");
      }
    }

    void program_uniform_2fv_ext(gl::uint_t program, gl::int_t location, gl::sizei_t count, const  gl::float_t * value) {
      if ( GLAD_GL_EXT_separate_shader_objects ) {
        glProgramUniform2fvEXT(program, location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform2fvEXT' not available on this platform (extensions: GL_EXT_separate_shader_objects)");
      }
    }

    void program_uniform_2i_ext(gl::uint_t program, gl::int_t location, gl::int_t v0, gl::int_t v1) {
      if ( GLAD_GL_EXT_separate_shader_objects ) {
        glProgramUniform2iEXT(program, location, v0, v1);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform2iEXT' not available on this platform (extensions: GL_EXT_separate_shader_objects)");
      }
    }

    void program_uniform_2iv_ext(gl::uint_t program, gl::int_t location, gl::sizei_t count, const  gl::int_t * value) {
      if ( GLAD_GL_EXT_separate_shader_objects ) {
        glProgramUniform2ivEXT(program, location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform2ivEXT' not available on this platform (extensions: GL_EXT_separate_shader_objects)");
      }
    }

    void program_uniform_2ui_ext(gl::uint_t program, gl::int_t location, gl::uint_t v0, gl::uint_t v1) {
      if ( GLAD_GL_EXT_separate_shader_objects ) {
        glProgramUniform2uiEXT(program, location, v0, v1);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform2uiEXT' not available on this platform (extensions: GL_EXT_separate_shader_objects)");
      }
    }

    void program_uniform_2uiv_ext(gl::uint_t program, gl::int_t location, gl::sizei_t count, const  gl::uint_t * value) {
      if ( GLAD_GL_EXT_separate_shader_objects ) {
        glProgramUniform2uivEXT(program, location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform2uivEXT' not available on this platform (extensions: GL_EXT_separate_shader_objects)");
      }
    }

    void program_uniform_3f_ext(gl::uint_t program, gl::int_t location, gl::float_t v0, gl::float_t v1, gl::float_t v2) {
      if ( GLAD_GL_EXT_separate_shader_objects ) {
        glProgramUniform3fEXT(program, location, v0, v1, v2);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform3fEXT' not available on this platform (extensions: GL_EXT_separate_shader_objects)");
      }
    }

    void program_uniform_3fv_ext(gl::uint_t program, gl::int_t location, gl::sizei_t count, const  gl::float_t * value) {
      if ( GLAD_GL_EXT_separate_shader_objects ) {
        glProgramUniform3fvEXT(program, location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform3fvEXT' not available on this platform (extensions: GL_EXT_separate_shader_objects)");
      }
    }

    void program_uniform_3i_ext(gl::uint_t program, gl::int_t location, gl::int_t v0, gl::int_t v1, gl::int_t v2) {
      if ( GLAD_GL_EXT_separate_shader_objects ) {
        glProgramUniform3iEXT(program, location, v0, v1, v2);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform3iEXT' not available on this platform (extensions: GL_EXT_separate_shader_objects)");
      }
    }

    void program_uniform_3iv_ext(gl::uint_t program, gl::int_t location, gl::sizei_t count, const  gl::int_t * value) {
      if ( GLAD_GL_EXT_separate_shader_objects ) {
        glProgramUniform3ivEXT(program, location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform3ivEXT' not available on this platform (extensions: GL_EXT_separate_shader_objects)");
      }
    }

    void program_uniform_3ui_ext(gl::uint_t program, gl::int_t location, gl::uint_t v0, gl::uint_t v1, gl::uint_t v2) {
      if ( GLAD_GL_EXT_separate_shader_objects ) {
        glProgramUniform3uiEXT(program, location, v0, v1, v2);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform3uiEXT' not available on this platform (extensions: GL_EXT_separate_shader_objects)");
      }
    }

    void program_uniform_3uiv_ext(gl::uint_t program, gl::int_t location, gl::sizei_t count, const  gl::uint_t * value) {
      if ( GLAD_GL_EXT_separate_shader_objects ) {
        glProgramUniform3uivEXT(program, location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform3uivEXT' not available on this platform (extensions: GL_EXT_separate_shader_objects)");
      }
    }

    void program_uniform_4f_ext(gl::uint_t program, gl::int_t location, gl::float_t v0, gl::float_t v1, gl::float_t v2, gl::float_t v3) {
      if ( GLAD_GL_EXT_separate_shader_objects ) {
        glProgramUniform4fEXT(program, location, v0, v1, v2, v3);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform4fEXT' not available on this platform (extensions: GL_EXT_separate_shader_objects)");
      }
    }

    void program_uniform_4fv_ext(gl::uint_t program, gl::int_t location, gl::sizei_t count, const  gl::float_t * value) {
      if ( GLAD_GL_EXT_separate_shader_objects ) {
        glProgramUniform4fvEXT(program, location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform4fvEXT' not available on this platform (extensions: GL_EXT_separate_shader_objects)");
      }
    }

    void program_uniform_4i_ext(gl::uint_t program, gl::int_t location, gl::int_t v0, gl::int_t v1, gl::int_t v2, gl::int_t v3) {
      if ( GLAD_GL_EXT_separate_shader_objects ) {
        glProgramUniform4iEXT(program, location, v0, v1, v2, v3);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform4iEXT' not available on this platform (extensions: GL_EXT_separate_shader_objects)");
      }
    }

    void program_uniform_4iv_ext(gl::uint_t program, gl::int_t location, gl::sizei_t count, const  gl::int_t * value) {
      if ( GLAD_GL_EXT_separate_shader_objects ) {
        glProgramUniform4ivEXT(program, location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform4ivEXT' not available on this platform (extensions: GL_EXT_separate_shader_objects)");
      }
    }

    void program_uniform_4ui_ext(gl::uint_t program, gl::int_t location, gl::uint_t v0, gl::uint_t v1, gl::uint_t v2, gl::uint_t v3) {
      if ( GLAD_GL_EXT_separate_shader_objects ) {
        glProgramUniform4uiEXT(program, location, v0, v1, v2, v3);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform4uiEXT' not available on this platform (extensions: GL_EXT_separate_shader_objects)");
      }
    }

    void program_uniform_4uiv_ext(gl::uint_t program, gl::int_t location, gl::sizei_t count, const  gl::uint_t * value) {
      if ( GLAD_GL_EXT_separate_shader_objects ) {
        glProgramUniform4uivEXT(program, location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform4uivEXT' not available on this platform (extensions: GL_EXT_separate_shader_objects)");
      }
    }

    void program_uniform_handleui_64nv(gl::uint_t program, gl::int_t location, gl::uint64_t value) {
      if ( GLAD_GL_NV_bindless_texture ) {
        glProgramUniformHandleui64NV(program, location, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniformHandleui64NV' not available on this platform (extensions: GL_NV_bindless_texture)");
      }
    }

    void program_uniform_handleui_64v_nv(gl::uint_t program, gl::int_t location, gl::sizei_t count, const  gl::uint64_t * values) {
      if ( GLAD_GL_NV_bindless_texture ) {
        glProgramUniformHandleui64vNV(program, location, count, values);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniformHandleui64vNV' not available on this platform (extensions: GL_NV_bindless_texture)");
      }
    }

    void program_uniform_matrix_2fv_ext(gl::uint_t program, gl::int_t location, gl::sizei_t count, gl::boolean_t transpose, const  gl::float_t * value) {
      if ( GLAD_GL_EXT_separate_shader_objects ) {
        glProgramUniformMatrix2fvEXT(program, location, count, transpose, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniformMatrix2fvEXT' not available on this platform (extensions: GL_EXT_separate_shader_objects)");
      }
    }

    void program_uniform_matrix_2x_3fv_ext(gl::uint_t program, gl::int_t location, gl::sizei_t count, gl::boolean_t transpose, const  gl::float_t * value) {
      if ( GLAD_GL_EXT_separate_shader_objects ) {
        glProgramUniformMatrix2x3fvEXT(program, location, count, transpose, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniformMatrix2x3fvEXT' not available on this platform (extensions: GL_EXT_separate_shader_objects)");
      }
    }

    void program_uniform_matrix_2x_4fv_ext(gl::uint_t program, gl::int_t location, gl::sizei_t count, gl::boolean_t transpose, const  gl::float_t * value) {
      if ( GLAD_GL_EXT_separate_shader_objects ) {
        glProgramUniformMatrix2x4fvEXT(program, location, count, transpose, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniformMatrix2x4fvEXT' not available on this platform (extensions: GL_EXT_separate_shader_objects)");
      }
    }

    void program_uniform_matrix_3fv_ext(gl::uint_t program, gl::int_t location, gl::sizei_t count, gl::boolean_t transpose, const  gl::float_t * value) {
      if ( GLAD_GL_EXT_separate_shader_objects ) {
        glProgramUniformMatrix3fvEXT(program, location, count, transpose, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniformMatrix3fvEXT' not available on this platform (extensions: GL_EXT_separate_shader_objects)");
      }
    }

    void program_uniform_matrix_3x_2fv_ext(gl::uint_t program, gl::int_t location, gl::sizei_t count, gl::boolean_t transpose, const  gl::float_t * value) {
      if ( GLAD_GL_EXT_separate_shader_objects ) {
        glProgramUniformMatrix3x2fvEXT(program, location, count, transpose, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniformMatrix3x2fvEXT' not available on this platform (extensions: GL_EXT_separate_shader_objects)");
      }
    }

    void program_uniform_matrix_3x_4fv_ext(gl::uint_t program, gl::int_t location, gl::sizei_t count, gl::boolean_t transpose, const  gl::float_t * value) {
      if ( GLAD_GL_EXT_separate_shader_objects ) {
        glProgramUniformMatrix3x4fvEXT(program, location, count, transpose, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniformMatrix3x4fvEXT' not available on this platform (extensions: GL_EXT_separate_shader_objects)");
      }
    }

    void program_uniform_matrix_4fv_ext(gl::uint_t program, gl::int_t location, gl::sizei_t count, gl::boolean_t transpose, const  gl::float_t * value) {
      if ( GLAD_GL_EXT_separate_shader_objects ) {
        glProgramUniformMatrix4fvEXT(program, location, count, transpose, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniformMatrix4fvEXT' not available on this platform (extensions: GL_EXT_separate_shader_objects)");
      }
    }

    void program_uniform_matrix_4x_2fv_ext(gl::uint_t program, gl::int_t location, gl::sizei_t count, gl::boolean_t transpose, const  gl::float_t * value) {
      if ( GLAD_GL_EXT_separate_shader_objects ) {
        glProgramUniformMatrix4x2fvEXT(program, location, count, transpose, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniformMatrix4x2fvEXT' not available on this platform (extensions: GL_EXT_separate_shader_objects)");
      }
    }

    void program_uniform_matrix_4x_3fv_ext(gl::uint_t program, gl::int_t location, gl::sizei_t count, gl::boolean_t transpose, const  gl::float_t * value) {
      if ( GLAD_GL_EXT_separate_shader_objects ) {
        glProgramUniformMatrix4x3fvEXT(program, location, count, transpose, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniformMatrix4x3fvEXT' not available on this platform (extensions: GL_EXT_separate_shader_objects)");
      }
    }

    void push_debug_group_khr(gl::enum_t source, gl::uint_t id, gl::sizei_t length, const  gl::char_t * message) {
      if ( GLAD_GL_KHR_debug ) {
        glPushDebugGroupKHR(source, id, length, message);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPushDebugGroupKHR' not available on this platform (extensions: GL_KHR_debug)");
      }
    }

    void push_group_marker_ext(gl::sizei_t length, const  gl::char_t * marker) {
      if ( GLAD_GL_EXT_debug_marker ) {
        glPushGroupMarkerEXT(length, marker);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPushGroupMarkerEXT' not available on this platform (extensions: GL_EXT_debug_marker)");
      }
    }

    void query_counter_ext(gl::uint_t id, gl::enum_t target) {
      if ( GLAD_GL_EXT_disjoint_timer_query ) {
        glQueryCounterEXT(id, target);
      }
      else {
        throw std::runtime_error("OpenGL command 'glQueryCounterEXT' not available on this platform (extensions: GL_EXT_disjoint_timer_query)");
      }
    }

    void read_buffer_indexed_ext(gl::enum_t src, gl::int_t index) {
      if ( GLAD_GL_EXT_multiview_draw_buffers ) {
        glReadBufferIndexedEXT(src, index);
      }
      else {
        throw std::runtime_error("OpenGL command 'glReadBufferIndexedEXT' not available on this platform (extensions: GL_EXT_multiview_draw_buffers)");
      }
    }

    void read_buffer_nv(gl::enum_t mode) {
      if ( GLAD_GL_NV_read_buffer ) {
        glReadBufferNV(mode);
      }
      else {
        throw std::runtime_error("OpenGL command 'glReadBufferNV' not available on this platform (extensions: GL_NV_read_buffer)");
      }
    }

    void readn_pixels_ext(gl::int_t x, gl::int_t y, gl::sizei_t width, gl::sizei_t height, gl::enum_t format, gl::enum_t type, gl::sizei_t bufSize, void * data) {
      if ( GLAD_GL_EXT_robustness ) {
        glReadnPixelsEXT(x, y, width, height, format, type, bufSize, data);
      }
      else {
        throw std::runtime_error("OpenGL command 'glReadnPixelsEXT' not available on this platform (extensions: GL_EXT_robustness)");
      }
    }

    void readn_pixels_khr(gl::int_t x, gl::int_t y, gl::sizei_t width, gl::sizei_t height, pixel_format_t format, pixel_type_t type, gl::sizei_t bufSize, void * data) {
      if ( GLAD_GL_KHR_robustness ) {
        glReadnPixelsKHR(x, y, width, height, static_cast<GLenum>(format), static_cast<GLenum>(type), bufSize, data);
      }
      else {
        throw std::runtime_error("OpenGL command 'glReadnPixelsKHR' not available on this platform (extensions: GL_KHR_robustness)");
      }
    }

    void renderbuffer_storage_multisample_angle(renderbuffer_target_t target, gl::sizei_t samples, internal_format_t internalformat, gl::sizei_t width, gl::sizei_t height) {
      if ( GLAD_GL_ANGLE_framebuffer_multisample ) {
        glRenderbufferStorageMultisampleANGLE(static_cast<GLenum>(target), samples, static_cast<GLenum>(internalformat), width, height);
      }
      else {
        throw std::runtime_error("OpenGL command 'glRenderbufferStorageMultisampleANGLE' not available on this platform (extensions: GL_ANGLE_framebuffer_multisample)");
      }
    }

    void renderbuffer_storage_multisample_apple(renderbuffer_target_t target, gl::sizei_t samples, internal_format_t internalformat, gl::sizei_t width, gl::sizei_t height) {
      if ( GLAD_GL_APPLE_framebuffer_multisample ) {
        glRenderbufferStorageMultisampleAPPLE(static_cast<GLenum>(target), samples, static_cast<GLenum>(internalformat), width, height);
      }
      else {
        throw std::runtime_error("OpenGL command 'glRenderbufferStorageMultisampleAPPLE' not available on this platform (extensions: GL_APPLE_framebuffer_multisample)");
      }
    }

    void renderbuffer_storage_multisample_ext(renderbuffer_target_t target, gl::sizei_t samples, internal_format_t internalformat, gl::sizei_t width, gl::sizei_t height) {
      if ( GLAD_GL_EXT_multisampled_render_to_texture ) {
        glRenderbufferStorageMultisampleEXT(static_cast<GLenum>(target), samples, static_cast<GLenum>(internalformat), width, height);
      }
      else {
        throw std::runtime_error("OpenGL command 'glRenderbufferStorageMultisampleEXT' not available on this platform (extensions: GL_EXT_multisampled_render_to_texture)");
      }
    }

    void renderbuffer_storage_multisample_img(gl::enum_t target, gl::sizei_t samples, gl::enum_t internalformat, gl::sizei_t width, gl::sizei_t height) {
      if ( GLAD_GL_IMG_multisampled_render_to_texture ) {
        glRenderbufferStorageMultisampleIMG(target, samples, internalformat, width, height);
      }
      else {
        throw std::runtime_error("OpenGL command 'glRenderbufferStorageMultisampleIMG' not available on this platform (extensions: GL_IMG_multisampled_render_to_texture)");
      }
    }

    void renderbuffer_storage_multisample_nv(renderbuffer_target_t target, gl::sizei_t samples, internal_format_t internalformat, gl::sizei_t width, gl::sizei_t height) {
      if ( GLAD_GL_NV_framebuffer_multisample ) {
        glRenderbufferStorageMultisampleNV(static_cast<GLenum>(target), samples, static_cast<GLenum>(internalformat), width, height);
      }
      else {
        throw std::runtime_error("OpenGL command 'glRenderbufferStorageMultisampleNV' not available on this platform (extensions: GL_NV_framebuffer_multisample)");
      }
    }

    void resolve_multisample_framebuffer_apple() {
      if ( GLAD_GL_APPLE_framebuffer_multisample ) {
        glResolveMultisampleFramebufferAPPLE();
      }
      else {
        throw std::runtime_error("OpenGL command 'glResolveMultisampleFramebufferAPPLE' not available on this platform (extensions: GL_APPLE_framebuffer_multisample)");
      }
    }

    void sampler_parameter_iiv_ext(gl::uint_t sampler, gl::enum_t pname, const  gl::int_t * param) {
      if ( GLAD_GL_EXT_texture_border_clamp ) {
        glSamplerParameterIivEXT(sampler, pname, param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSamplerParameterIivEXT' not available on this platform (extensions: GL_EXT_texture_border_clamp)");
      }
    }

    void sampler_parameter_iiv_oes(gl::uint_t sampler, gl::enum_t pname, const  gl::int_t * param) {
      if ( GLAD_GL_OES_texture_border_clamp ) {
        glSamplerParameterIivOES(sampler, pname, param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSamplerParameterIivOES' not available on this platform (extensions: GL_OES_texture_border_clamp)");
      }
    }

    void sampler_parameter_iuiv_ext(gl::uint_t sampler, gl::enum_t pname, const  gl::uint_t * param) {
      if ( GLAD_GL_EXT_texture_border_clamp ) {
        glSamplerParameterIuivEXT(sampler, pname, param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSamplerParameterIuivEXT' not available on this platform (extensions: GL_EXT_texture_border_clamp)");
      }
    }

    void sampler_parameter_iuiv_oes(gl::uint_t sampler, gl::enum_t pname, const  gl::uint_t * param) {
      if ( GLAD_GL_OES_texture_border_clamp ) {
        glSamplerParameterIuivOES(sampler, pname, param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSamplerParameterIuivOES' not available on this platform (extensions: GL_OES_texture_border_clamp)");
      }
    }

    void scissor_arrayv_nv(gl::uint_t first, gl::sizei_t count, const  gl::int_t * v) {
      if ( GLAD_GL_NV_viewport_array ) {
        glScissorArrayvNV(first, count, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glScissorArrayvNV' not available on this platform (extensions: GL_NV_viewport_array)");
      }
    }

    void scissor_indexed_nv(gl::uint_t index, gl::int_t left, gl::int_t bottom, gl::sizei_t width, gl::sizei_t height) {
      if ( GLAD_GL_NV_viewport_array ) {
        glScissorIndexedNV(index, left, bottom, width, height);
      }
      else {
        throw std::runtime_error("OpenGL command 'glScissorIndexedNV' not available on this platform (extensions: GL_NV_viewport_array)");
      }
    }

    void scissor_indexedv_nv(gl::uint_t index, const  gl::int_t * v) {
      if ( GLAD_GL_NV_viewport_array ) {
        glScissorIndexedvNV(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glScissorIndexedvNV' not available on this platform (extensions: GL_NV_viewport_array)");
      }
    }

    void select_perf_monitor_counters_amd(gl::uint_t monitor, gl::boolean_t enable, gl::uint_t group, gl::int_t numCounters, gl::uint_t * counterList) {
      if ( GLAD_GL_AMD_performance_monitor ) {
        glSelectPerfMonitorCountersAMD(monitor, enable, group, numCounters, counterList);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSelectPerfMonitorCountersAMD' not available on this platform (extensions: GL_AMD_performance_monitor)");
      }
    }

    void set_fence_nv(gl::uint_t fence, gl::enum_t condition) {
      if ( GLAD_GL_NV_fence ) {
        glSetFenceNV(fence, condition);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSetFenceNV' not available on this platform (extensions: GL_NV_fence)");
      }
    }

    void start_tiling_qcom(gl::uint_t x, gl::uint_t y, gl::uint_t width, gl::uint_t height, gl::bitfield_t preserveMask) {
      if ( GLAD_GL_QCOM_tiled_rendering ) {
        glStartTilingQCOM(x, y, width, height, preserveMask);
      }
      else {
        throw std::runtime_error("OpenGL command 'glStartTilingQCOM' not available on this platform (extensions: GL_QCOM_tiled_rendering)");
      }
    }

    void stencil_fill_path_instanced_nv(gl::sizei_t numPaths, gl::enum_t pathNameType, const  void * paths, gl::uint_t pathBase, gl::enum_t fillMode, gl::uint_t mask, gl::enum_t transformType, const  gl::float_t * transformValues) {
      if ( GLAD_GL_NV_path_rendering ) {
        glStencilFillPathInstancedNV(numPaths, pathNameType, paths, pathBase, fillMode, mask, transformType, transformValues);
      }
      else {
        throw std::runtime_error("OpenGL command 'glStencilFillPathInstancedNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void stencil_fill_path_nv(gl::uint_t path, gl::enum_t fillMode, gl::uint_t mask) {
      if ( GLAD_GL_NV_path_rendering ) {
        glStencilFillPathNV(path, fillMode, mask);
      }
      else {
        throw std::runtime_error("OpenGL command 'glStencilFillPathNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void stencil_stroke_path_instanced_nv(gl::sizei_t numPaths, gl::enum_t pathNameType, const  void * paths, gl::uint_t pathBase, gl::int_t reference, gl::uint_t mask, gl::enum_t transformType, const  gl::float_t * transformValues) {
      if ( GLAD_GL_NV_path_rendering ) {
        glStencilStrokePathInstancedNV(numPaths, pathNameType, paths, pathBase, reference, mask, transformType, transformValues);
      }
      else {
        throw std::runtime_error("OpenGL command 'glStencilStrokePathInstancedNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void stencil_stroke_path_nv(gl::uint_t path, gl::int_t reference, gl::uint_t mask) {
      if ( GLAD_GL_NV_path_rendering ) {
        glStencilStrokePathNV(path, reference, mask);
      }
      else {
        throw std::runtime_error("OpenGL command 'glStencilStrokePathNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void stencil_then_cover_fill_path_instanced_nv(gl::sizei_t numPaths, gl::enum_t pathNameType, const  void * paths, gl::uint_t pathBase, gl::enum_t fillMode, gl::uint_t mask, gl::enum_t coverMode, gl::enum_t transformType, const  gl::float_t * transformValues) {
      if ( GLAD_GL_NV_path_rendering ) {
        glStencilThenCoverFillPathInstancedNV(numPaths, pathNameType, paths, pathBase, fillMode, mask, coverMode, transformType, transformValues);
      }
      else {
        throw std::runtime_error("OpenGL command 'glStencilThenCoverFillPathInstancedNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void stencil_then_cover_fill_path_nv(gl::uint_t path, gl::enum_t fillMode, gl::uint_t mask, gl::enum_t coverMode) {
      if ( GLAD_GL_NV_path_rendering ) {
        glStencilThenCoverFillPathNV(path, fillMode, mask, coverMode);
      }
      else {
        throw std::runtime_error("OpenGL command 'glStencilThenCoverFillPathNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void stencil_then_cover_stroke_path_instanced_nv(gl::sizei_t numPaths, gl::enum_t pathNameType, const  void * paths, gl::uint_t pathBase, gl::int_t reference, gl::uint_t mask, gl::enum_t coverMode, gl::enum_t transformType, const  gl::float_t * transformValues) {
      if ( GLAD_GL_NV_path_rendering ) {
        glStencilThenCoverStrokePathInstancedNV(numPaths, pathNameType, paths, pathBase, reference, mask, coverMode, transformType, transformValues);
      }
      else {
        throw std::runtime_error("OpenGL command 'glStencilThenCoverStrokePathInstancedNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void stencil_then_cover_stroke_path_nv(gl::uint_t path, gl::int_t reference, gl::uint_t mask, gl::enum_t coverMode) {
      if ( GLAD_GL_NV_path_rendering ) {
        glStencilThenCoverStrokePathNV(path, reference, mask, coverMode);
      }
      else {
        throw std::runtime_error("OpenGL command 'glStencilThenCoverStrokePathNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    gl::boolean_t test_fence_nv(gl::uint_t fence) {
      if ( GLAD_GL_NV_fence ) {
        return glTestFenceNV(fence);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTestFenceNV' not available on this platform (extensions: GL_NV_fence)");
      }
    }

    void tex_buffer_ext(texture_target_t target, gl::enum_t internalformat, gl::uint_t buffer) {
      if ( GLAD_GL_EXT_texture_buffer ) {
        glTexBufferEXT(static_cast<GLenum>(target), internalformat, buffer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexBufferEXT' not available on this platform (extensions: GL_EXT_texture_buffer)");
      }
    }

    void tex_buffer_oes(texture_target_t target, gl::enum_t internalformat, gl::uint_t buffer) {
      if ( GLAD_GL_OES_texture_buffer ) {
        glTexBufferOES(static_cast<GLenum>(target), internalformat, buffer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexBufferOES' not available on this platform (extensions: GL_OES_texture_buffer)");
      }
    }

    void tex_buffer_range_ext(gl::enum_t target, gl::enum_t internalformat, gl::uint_t buffer, gl::intptr_t offset, gl::sizeiptr_t size) {
      if ( GLAD_GL_EXT_texture_buffer ) {
        glTexBufferRangeEXT(target, internalformat, buffer, offset, size);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexBufferRangeEXT' not available on this platform (extensions: GL_EXT_texture_buffer)");
      }
    }

    void tex_buffer_range_oes(gl::enum_t target, gl::enum_t internalformat, gl::uint_t buffer, gl::intptr_t offset, gl::sizeiptr_t size) {
      if ( GLAD_GL_OES_texture_buffer ) {
        glTexBufferRangeOES(target, internalformat, buffer, offset, size);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexBufferRangeOES' not available on this platform (extensions: GL_OES_texture_buffer)");
      }
    }

    void tex_image_3does(texture_target_t target, gl::int_t level, gl::enum_t internalformat, gl::sizei_t width, gl::sizei_t height, gl::sizei_t depth, gl::int_t border, pixel_format_t format, pixel_type_t type, const  void * pixels) {
      if ( GLAD_GL_OES_texture_3D ) {
        glTexImage3DOES(static_cast<GLenum>(target), level, internalformat, width, height, depth, border, static_cast<GLenum>(format), static_cast<GLenum>(type), pixels);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexImage3DOES' not available on this platform (extensions: GL_OES_texture_3D)");
      }
    }

    void tex_parameter_iiv_ext(texture_target_t target, texture_parameter_name_t pname, const  gl::int_t * params) {
      if ( GLAD_GL_EXT_texture_border_clamp ) {
        glTexParameterIivEXT(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexParameterIivEXT' not available on this platform (extensions: GL_EXT_texture_border_clamp)");
      }
    }

    void tex_parameter_iiv_oes(texture_target_t target, texture_parameter_name_t pname, const  gl::int_t * params) {
      if ( GLAD_GL_OES_texture_border_clamp ) {
        glTexParameterIivOES(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexParameterIivOES' not available on this platform (extensions: GL_OES_texture_border_clamp)");
      }
    }

    void tex_parameter_iuiv_ext(texture_target_t target, texture_parameter_name_t pname, const  gl::uint_t * params) {
      if ( GLAD_GL_EXT_texture_border_clamp ) {
        glTexParameterIuivEXT(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexParameterIuivEXT' not available on this platform (extensions: GL_EXT_texture_border_clamp)");
      }
    }

    void tex_parameter_iuiv_oes(texture_target_t target, texture_parameter_name_t pname, const  gl::uint_t * params) {
      if ( GLAD_GL_OES_texture_border_clamp ) {
        glTexParameterIuivOES(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexParameterIuivOES' not available on this platform (extensions: GL_OES_texture_border_clamp)");
      }
    }

    void tex_storage_1dext(gl::enum_t target, gl::sizei_t levels, gl::enum_t internalformat, gl::sizei_t width) {
      if ( GLAD_GL_EXT_texture_storage ) {
        glTexStorage1DEXT(target, levels, internalformat, width);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexStorage1DEXT' not available on this platform (extensions: GL_EXT_texture_storage)");
      }
    }

    void tex_storage_2dext(gl::enum_t target, gl::sizei_t levels, gl::enum_t internalformat, gl::sizei_t width, gl::sizei_t height) {
      if ( GLAD_GL_EXT_texture_storage ) {
        glTexStorage2DEXT(target, levels, internalformat, width, height);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexStorage2DEXT' not available on this platform (extensions: GL_EXT_texture_storage)");
      }
    }

    void tex_storage_3dext(gl::enum_t target, gl::sizei_t levels, gl::enum_t internalformat, gl::sizei_t width, gl::sizei_t height, gl::sizei_t depth) {
      if ( GLAD_GL_EXT_texture_storage ) {
        glTexStorage3DEXT(target, levels, internalformat, width, height, depth);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexStorage3DEXT' not available on this platform (extensions: GL_EXT_texture_storage)");
      }
    }

    void tex_storage_3d_multisample_oes(gl::enum_t target, gl::sizei_t samples, gl::enum_t internalformat, gl::sizei_t width, gl::sizei_t height, gl::sizei_t depth, gl::boolean_t fixedsamplelocations) {
      if ( GLAD_GL_OES_texture_storage_multisample_2d_array ) {
        glTexStorage3DMultisampleOES(target, samples, internalformat, width, height, depth, fixedsamplelocations);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexStorage3DMultisampleOES' not available on this platform (extensions: GL_OES_texture_storage_multisample_2d_array)");
      }
    }

    void tex_sub_image_3does(texture_target_t target, gl::int_t level, gl::int_t xoffset, gl::int_t yoffset, gl::int_t zoffset, gl::sizei_t width, gl::sizei_t height, gl::sizei_t depth, pixel_format_t format, pixel_type_t type, const  void * pixels) {
      if ( GLAD_GL_OES_texture_3D ) {
        glTexSubImage3DOES(static_cast<GLenum>(target), level, xoffset, yoffset, zoffset, width, height, depth, static_cast<GLenum>(format), static_cast<GLenum>(type), pixels);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexSubImage3DOES' not available on this platform (extensions: GL_OES_texture_3D)");
      }
    }

    void texture_storage_1dext(gl::uint_t texture, gl::enum_t target, gl::sizei_t levels, gl::enum_t internalformat, gl::sizei_t width) {
      if ( GLAD_GL_EXT_texture_storage ) {
        glTextureStorage1DEXT(texture, target, levels, internalformat, width);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTextureStorage1DEXT' not available on this platform (extensions: GL_EXT_texture_storage)");
      }
    }

    void texture_storage_2dext(gl::uint_t texture, gl::enum_t target, gl::sizei_t levels, gl::enum_t internalformat, gl::sizei_t width, gl::sizei_t height) {
      if ( GLAD_GL_EXT_texture_storage ) {
        glTextureStorage2DEXT(texture, target, levels, internalformat, width, height);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTextureStorage2DEXT' not available on this platform (extensions: GL_EXT_texture_storage)");
      }
    }

    void texture_storage_3dext(gl::uint_t texture, gl::enum_t target, gl::sizei_t levels, gl::enum_t internalformat, gl::sizei_t width, gl::sizei_t height, gl::sizei_t depth) {
      if ( GLAD_GL_EXT_texture_storage ) {
        glTextureStorage3DEXT(texture, target, levels, internalformat, width, height, depth);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTextureStorage3DEXT' not available on this platform (extensions: GL_EXT_texture_storage)");
      }
    }

    void texture_view_ext(gl::uint_t texture, gl::enum_t target, gl::uint_t origtexture, gl::enum_t internalformat, gl::uint_t minlevel, gl::uint_t numlevels, gl::uint_t minlayer, gl::uint_t numlayers) {
      if ( GLAD_GL_EXT_texture_view ) {
        glTextureViewEXT(texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTextureViewEXT' not available on this platform (extensions: GL_EXT_texture_view)");
      }
    }

    void texture_view_oes(gl::uint_t texture, gl::enum_t target, gl::uint_t origtexture, gl::enum_t internalformat, gl::uint_t minlevel, gl::uint_t numlevels, gl::uint_t minlayer, gl::uint_t numlayers) {
      if ( GLAD_GL_OES_texture_view ) {
        glTextureViewOES(texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTextureViewOES' not available on this platform (extensions: GL_OES_texture_view)");
      }
    }

    void transform_path_nv(gl::uint_t resultPath, gl::uint_t srcPath, gl::enum_t transformType, const  gl::float_t * transformValues) {
      if ( GLAD_GL_NV_path_rendering ) {
        glTransformPathNV(resultPath, srcPath, transformType, transformValues);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTransformPathNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void uniform_handleui_64nv(gl::int_t location, gl::uint64_t value) {
      if ( GLAD_GL_NV_bindless_texture ) {
        glUniformHandleui64NV(location, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniformHandleui64NV' not available on this platform (extensions: GL_NV_bindless_texture)");
      }
    }

    void uniform_handleui_64v_nv(gl::int_t location, gl::sizei_t count, const  gl::uint64_t * value) {
      if ( GLAD_GL_NV_bindless_texture ) {
        glUniformHandleui64vNV(location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniformHandleui64vNV' not available on this platform (extensions: GL_NV_bindless_texture)");
      }
    }

    void uniform_matrix_2x_3fv_nv(gl::int_t location, gl::sizei_t count, gl::boolean_t transpose, const  gl::float_t * value) {
      if ( GLAD_GL_NV_non_square_matrices ) {
        glUniformMatrix2x3fvNV(location, count, transpose, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniformMatrix2x3fvNV' not available on this platform (extensions: GL_NV_non_square_matrices)");
      }
    }

    void uniform_matrix_2x_4fv_nv(gl::int_t location, gl::sizei_t count, gl::boolean_t transpose, const  gl::float_t * value) {
      if ( GLAD_GL_NV_non_square_matrices ) {
        glUniformMatrix2x4fvNV(location, count, transpose, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniformMatrix2x4fvNV' not available on this platform (extensions: GL_NV_non_square_matrices)");
      }
    }

    void uniform_matrix_3x_2fv_nv(gl::int_t location, gl::sizei_t count, gl::boolean_t transpose, const  gl::float_t * value) {
      if ( GLAD_GL_NV_non_square_matrices ) {
        glUniformMatrix3x2fvNV(location, count, transpose, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniformMatrix3x2fvNV' not available on this platform (extensions: GL_NV_non_square_matrices)");
      }
    }

    void uniform_matrix_3x_4fv_nv(gl::int_t location, gl::sizei_t count, gl::boolean_t transpose, const  gl::float_t * value) {
      if ( GLAD_GL_NV_non_square_matrices ) {
        glUniformMatrix3x4fvNV(location, count, transpose, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniformMatrix3x4fvNV' not available on this platform (extensions: GL_NV_non_square_matrices)");
      }
    }

    void uniform_matrix_4x_2fv_nv(gl::int_t location, gl::sizei_t count, gl::boolean_t transpose, const  gl::float_t * value) {
      if ( GLAD_GL_NV_non_square_matrices ) {
        glUniformMatrix4x2fvNV(location, count, transpose, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniformMatrix4x2fvNV' not available on this platform (extensions: GL_NV_non_square_matrices)");
      }
    }

    void uniform_matrix_4x_3fv_nv(gl::int_t location, gl::sizei_t count, gl::boolean_t transpose, const  gl::float_t * value) {
      if ( GLAD_GL_NV_non_square_matrices ) {
        glUniformMatrix4x3fvNV(location, count, transpose, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniformMatrix4x3fvNV' not available on this platform (extensions: GL_NV_non_square_matrices)");
      }
    }

    gl::boolean_t unmap_buffer_oes(buffer_target_arb_t target) {
      if ( GLAD_GL_OES_mapbuffer ) {
        return glUnmapBufferOES(static_cast<GLenum>(target));
      }
      else {
        throw std::runtime_error("OpenGL command 'glUnmapBufferOES' not available on this platform (extensions: GL_OES_mapbuffer)");
      }
    }

    void use_program_stages_ext(gl::uint_t pipeline, gl::bitmask<use_program_stage_flags_t> stages, gl::uint_t program) {
      if ( GLAD_GL_EXT_separate_shader_objects ) {
        glUseProgramStagesEXT(pipeline, static_cast<GLbitfield>(stages.value), program);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUseProgramStagesEXT' not available on this platform (extensions: GL_EXT_separate_shader_objects)");
      }
    }

    void validate_program_pipeline_ext(gl::uint_t pipeline) {
      if ( GLAD_GL_EXT_separate_shader_objects ) {
        glValidateProgramPipelineEXT(pipeline);
      }
      else {
        throw std::runtime_error("OpenGL command 'glValidateProgramPipelineEXT' not available on this platform (extensions: GL_EXT_separate_shader_objects)");
      }
    }

    void vertex_attrib_divisor_angle(gl::uint_t index, gl::uint_t divisor) {
      if ( GLAD_GL_ANGLE_instanced_arrays ) {
        glVertexAttribDivisorANGLE(index, divisor);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribDivisorANGLE' not available on this platform (extensions: GL_ANGLE_instanced_arrays)");
      }
    }

    void vertex_attrib_divisor_ext(gl::uint_t index, gl::uint_t divisor) {
      if ( GLAD_GL_EXT_instanced_arrays ) {
        glVertexAttribDivisorEXT(index, divisor);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribDivisorEXT' not available on this platform (extensions: GL_EXT_instanced_arrays)");
      }
    }

    void vertex_attrib_divisor_nv(gl::uint_t index, gl::uint_t divisor) {
      if ( GLAD_GL_NV_instanced_arrays ) {
        glVertexAttribDivisorNV(index, divisor);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribDivisorNV' not available on this platform (extensions: GL_NV_instanced_arrays)");
      }
    }

    void viewport_arrayv_nv(gl::uint_t first, gl::sizei_t count, const  gl::float_t * v) {
      if ( GLAD_GL_NV_viewport_array ) {
        glViewportArrayvNV(first, count, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glViewportArrayvNV' not available on this platform (extensions: GL_NV_viewport_array)");
      }
    }

    void viewport_indexedf_nv(gl::uint_t index, gl::float_t x, gl::float_t y, gl::float_t w, gl::float_t h) {
      if ( GLAD_GL_NV_viewport_array ) {
        glViewportIndexedfNV(index, x, y, w, h);
      }
      else {
        throw std::runtime_error("OpenGL command 'glViewportIndexedfNV' not available on this platform (extensions: GL_NV_viewport_array)");
      }
    }

    void viewport_indexedfv_nv(gl::uint_t index, const  gl::float_t * v) {
      if ( GLAD_GL_NV_viewport_array ) {
        glViewportIndexedfvNV(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glViewportIndexedfvNV' not available on this platform (extensions: GL_NV_viewport_array)");
      }
    }

    void wait_sync_apple(gl::sync_t sync, gl::bitfield_t flags, gl::uint64_t timeout) {
      if ( GLAD_GL_APPLE_sync ) {
        glWaitSyncAPPLE(sync, flags, timeout);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWaitSyncAPPLE' not available on this platform (extensions: GL_APPLE_sync)");
      }
    }

    void weight_paths_nv(gl::uint_t resultPath, gl::sizei_t numPaths, const  gl::uint_t * paths, const  gl::float_t * weights) {
      if ( GLAD_GL_NV_path_rendering ) {
        glWeightPathsNV(resultPath, numPaths, paths, weights);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWeightPathsNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

}
