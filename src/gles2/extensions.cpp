/**
 * This file was autogenerated by glgen (https://github.com/seshbot/glgen) on 2015-02-27
 * Command line: src/gen.py assets/gl.xml -p assets/gl-patch.xml -o ../glpp/ --includesubdir include/glpp --sourcesubdir src --namespace gles2 --force --cpp --es2only
 */

#include <stdexcept>
#include <GLES2/gl2.h>
#include <GLES2/gl2ext.h>
#include <glpp/gles2/extensions.h>
#include "angle_extension_macros.h"

namespace gles2 {
    void active_shader_program_ext(gl::uint_t pipeline, gl::uint_t program) {
#if GL_EXT_separate_shader_objects    
      
      glActiveShaderProgramEXT(pipeline, program);
      
#else
      throw std::runtime_error("OpenGL command 'glActiveShaderProgramEXT' not available on this platform");
#endif
    }

    void alpha_func_qcom(alpha_function_t func, gl::clampf_t ref) {
#if GL_QCOM_alpha_test    
      
      glAlphaFuncQCOM(static_cast<GLenum>(func), ref);
      
#else
      throw std::runtime_error("OpenGL command 'glAlphaFuncQCOM' not available on this platform");
#endif
    }

    void begin_conditional_render_nv(gl::uint_t id, gl::enum_t mode) {
#if GL_NV_conditional_render    
      
      glBeginConditionalRenderNV(id, mode);
      
#else
      throw std::runtime_error("OpenGL command 'glBeginConditionalRenderNV' not available on this platform");
#endif
    }

    void begin_perf_monitor_amd(gl::uint_t monitor) {
#if GL_AMD_performance_monitor    
      
      glBeginPerfMonitorAMD(monitor);
      
#else
      throw std::runtime_error("OpenGL command 'glBeginPerfMonitorAMD' not available on this platform");
#endif
    }

    void begin_perf_query_intel(gl::uint_t queryHandle) {
#if GL_INTEL_performance_query    
      
      glBeginPerfQueryINTEL(queryHandle);
      
#else
      throw std::runtime_error("OpenGL command 'glBeginPerfQueryINTEL' not available on this platform");
#endif
    }

    void begin_query_ext(gl::enum_t target, gl::uint_t id) {
#if GL_EXT_disjoint_timer_query || GL_EXT_occlusion_query_boolean    
      
      glBeginQueryEXT(target, id);
      
#else
      throw std::runtime_error("OpenGL command 'glBeginQueryEXT' not available on this platform");
#endif
    }

    void bind_program_pipeline_ext(gl::uint_t pipeline) {
#if GL_EXT_separate_shader_objects    
      
      glBindProgramPipelineEXT(pipeline);
      
#else
      throw std::runtime_error("OpenGL command 'glBindProgramPipelineEXT' not available on this platform");
#endif
    }

    void bind_vertex_array_oes(gl::uint_t array) {
#if GL_OES_vertex_array_object    
      
      glBindVertexArrayOES(array);
      
#else
      throw std::runtime_error("OpenGL command 'glBindVertexArrayOES' not available on this platform");
#endif
    }

    void blend_barrier_khr() {
#if GL_KHR_blend_equation_advanced    
      
      glBlendBarrierKHR();
      
#else
      throw std::runtime_error("OpenGL command 'glBlendBarrierKHR' not available on this platform");
#endif
    }

    void blend_barrier_nv() {
#if GL_NV_blend_equation_advanced    
      
      glBlendBarrierNV();
      
#else
      throw std::runtime_error("OpenGL command 'glBlendBarrierNV' not available on this platform");
#endif
    }

    void blend_equation_separatei_ext(gl::uint_t buf, gl::enum_t modeRGB, gl::enum_t modeAlpha) {
#if GL_EXT_draw_buffers_indexed    
      
      glBlendEquationSeparateiEXT(buf, modeRGB, modeAlpha);
      
#else
      throw std::runtime_error("OpenGL command 'glBlendEquationSeparateiEXT' not available on this platform");
#endif
    }

    void blend_equation_separatei_oes(gl::uint_t buf, gl::enum_t modeRGB, gl::enum_t modeAlpha) {
#if GL_OES_draw_buffers_indexed    
      
      glBlendEquationSeparateiOES(buf, modeRGB, modeAlpha);
      
#else
      throw std::runtime_error("OpenGL command 'glBlendEquationSeparateiOES' not available on this platform");
#endif
    }

    void blend_equationi_ext(gl::uint_t buf, gl::enum_t mode) {
#if GL_EXT_draw_buffers_indexed    
      
      glBlendEquationiEXT(buf, mode);
      
#else
      throw std::runtime_error("OpenGL command 'glBlendEquationiEXT' not available on this platform");
#endif
    }

    void blend_equationi_oes(gl::uint_t buf, gl::enum_t mode) {
#if GL_OES_draw_buffers_indexed    
      
      glBlendEquationiOES(buf, mode);
      
#else
      throw std::runtime_error("OpenGL command 'glBlendEquationiOES' not available on this platform");
#endif
    }

    void blend_func_separatei_ext(gl::uint_t buf, gl::enum_t srcRGB, gl::enum_t dstRGB, gl::enum_t srcAlpha, gl::enum_t dstAlpha) {
#if GL_EXT_draw_buffers_indexed    
      
      glBlendFuncSeparateiEXT(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
      
#else
      throw std::runtime_error("OpenGL command 'glBlendFuncSeparateiEXT' not available on this platform");
#endif
    }

    void blend_func_separatei_oes(gl::uint_t buf, gl::enum_t srcRGB, gl::enum_t dstRGB, gl::enum_t srcAlpha, gl::enum_t dstAlpha) {
#if GL_OES_draw_buffers_indexed    
      
      glBlendFuncSeparateiOES(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
      
#else
      throw std::runtime_error("OpenGL command 'glBlendFuncSeparateiOES' not available on this platform");
#endif
    }

    void blend_funci_ext(gl::uint_t buf, gl::enum_t src, gl::enum_t dst) {
#if GL_EXT_draw_buffers_indexed    
      
      glBlendFunciEXT(buf, src, dst);
      
#else
      throw std::runtime_error("OpenGL command 'glBlendFunciEXT' not available on this platform");
#endif
    }

    void blend_funci_oes(gl::uint_t buf, gl::enum_t src, gl::enum_t dst) {
#if GL_OES_draw_buffers_indexed    
      
      glBlendFunciOES(buf, src, dst);
      
#else
      throw std::runtime_error("OpenGL command 'glBlendFunciOES' not available on this platform");
#endif
    }

    void blend_parameteri_nv(gl::enum_t pname, gl::int_t value) {
#if GL_NV_blend_equation_advanced    
      
      glBlendParameteriNV(pname, value);
      
#else
      throw std::runtime_error("OpenGL command 'glBlendParameteriNV' not available on this platform");
#endif
    }

    void blit_framebuffer_angle(gl::int_t srcX0, gl::int_t srcY0, gl::int_t srcX1, gl::int_t srcY1, gl::int_t dstX0, gl::int_t dstY0, gl::int_t dstX1, gl::int_t dstY1, gl::bitmask<clear_buffer_flags_t> mask, gl::enum_t filter) {
#if GL_ANGLE_framebuffer_blit    
      
      glBlitFramebufferANGLE(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, static_cast<GLbitfield>(mask.value), filter);
      
#else
      throw std::runtime_error("OpenGL command 'glBlitFramebufferANGLE' not available on this platform");
#endif
    }

    void blit_framebuffer_nv(gl::int_t srcX0, gl::int_t srcY0, gl::int_t srcX1, gl::int_t srcY1, gl::int_t dstX0, gl::int_t dstY0, gl::int_t dstX1, gl::int_t dstY1, gl::bitmask<clear_buffer_flags_t> mask, gl::enum_t filter) {
#if GL_NV_framebuffer_blit    
      
      glBlitFramebufferNV(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, static_cast<GLbitfield>(mask.value), filter);
      
#else
      throw std::runtime_error("OpenGL command 'glBlitFramebufferNV' not available on this platform");
#endif
    }

    gl::enum_t client_wait_sync_apple(gl::sync_t sync, gl::bitfield_t flags, gl::uint64_t timeout) {
#if GL_APPLE_sync    
      
      return glClientWaitSyncAPPLE(sync, flags, timeout);
      
#else
      throw std::runtime_error("OpenGL command 'glClientWaitSyncAPPLE' not available on this platform");
#endif
    }

    void color_maski_ext(gl::uint_t index, boolean_t r, boolean_t g, boolean_t b, boolean_t a) {
#if GL_EXT_draw_buffers_indexed    
      
      glColorMaskiEXT(index, static_cast<GLboolean>(r), static_cast<GLboolean>(g), static_cast<GLboolean>(b), static_cast<GLboolean>(a));
      
#else
      throw std::runtime_error("OpenGL command 'glColorMaskiEXT' not available on this platform");
#endif
    }

    void color_maski_oes(gl::uint_t index, boolean_t r, boolean_t g, boolean_t b, boolean_t a) {
#if GL_OES_draw_buffers_indexed    
      
      glColorMaskiOES(index, static_cast<GLboolean>(r), static_cast<GLboolean>(g), static_cast<GLboolean>(b), static_cast<GLboolean>(a));
      
#else
      throw std::runtime_error("OpenGL command 'glColorMaskiOES' not available on this platform");
#endif
    }

    void compressed_tex_image_3does(texture_target_t target, gl::int_t level, gl::enum_t internalformat, gl::sizei_t width, gl::sizei_t height, gl::sizei_t depth, gl::int_t border, gl::sizei_t imageSize, const void * data) {
#if GL_OES_texture_3D    
      
      glCompressedTexImage3DOES(static_cast<GLenum>(target), level, internalformat, width, height, depth, border, imageSize, data);
      
#else
      throw std::runtime_error("OpenGL command 'glCompressedTexImage3DOES' not available on this platform");
#endif
    }

    void compressed_tex_sub_image_3does(texture_target_t target, gl::int_t level, gl::int_t xoffset, gl::int_t yoffset, gl::int_t zoffset, gl::sizei_t width, gl::sizei_t height, gl::sizei_t depth, pixel_format_t format, gl::sizei_t imageSize, const void * data) {
#if GL_OES_texture_3D    
      
      glCompressedTexSubImage3DOES(static_cast<GLenum>(target), level, xoffset, yoffset, zoffset, width, height, depth, static_cast<GLenum>(format), imageSize, data);
      
#else
      throw std::runtime_error("OpenGL command 'glCompressedTexSubImage3DOES' not available on this platform");
#endif
    }

    void copy_buffer_sub_data_nv(gl::enum_t readTarget, gl::enum_t writeTarget, gl::intptr_t readOffset, gl::intptr_t writeOffset, gl::sizeiptr_t size) {
#if GL_NV_copy_buffer    
      
      glCopyBufferSubDataNV(readTarget, writeTarget, readOffset, writeOffset, size);
      
#else
      throw std::runtime_error("OpenGL command 'glCopyBufferSubDataNV' not available on this platform");
#endif
    }

    void copy_image_sub_data_ext(gl::uint_t srcName, gl::enum_t srcTarget, gl::int_t srcLevel, gl::int_t srcX, gl::int_t srcY, gl::int_t srcZ, gl::uint_t dstName, gl::enum_t dstTarget, gl::int_t dstLevel, gl::int_t dstX, gl::int_t dstY, gl::int_t dstZ, gl::sizei_t srcWidth, gl::sizei_t srcHeight, gl::sizei_t srcDepth) {
#if GL_EXT_copy_image    
      
      glCopyImageSubDataEXT(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
      
#else
      throw std::runtime_error("OpenGL command 'glCopyImageSubDataEXT' not available on this platform");
#endif
    }

    void copy_image_sub_data_oes(gl::uint_t srcName, gl::enum_t srcTarget, gl::int_t srcLevel, gl::int_t srcX, gl::int_t srcY, gl::int_t srcZ, gl::uint_t dstName, gl::enum_t dstTarget, gl::int_t dstLevel, gl::int_t dstX, gl::int_t dstY, gl::int_t dstZ, gl::sizei_t srcWidth, gl::sizei_t srcHeight, gl::sizei_t srcDepth) {
#if GL_OES_copy_image    
      
      glCopyImageSubDataOES(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
      
#else
      throw std::runtime_error("OpenGL command 'glCopyImageSubDataOES' not available on this platform");
#endif
    }

    void copy_path_nv(gl::uint_t resultPath, gl::uint_t srcPath) {
#if GL_NV_path_rendering    
      
      glCopyPathNV(resultPath, srcPath);
      
#else
      throw std::runtime_error("OpenGL command 'glCopyPathNV' not available on this platform");
#endif
    }

    void copy_tex_sub_image_3does(texture_target_t target, gl::int_t level, gl::int_t xoffset, gl::int_t yoffset, gl::int_t zoffset, gl::int_t x, gl::int_t y, gl::sizei_t width, gl::sizei_t height) {
#if GL_OES_texture_3D    
      
      glCopyTexSubImage3DOES(static_cast<GLenum>(target), level, xoffset, yoffset, zoffset, x, y, width, height);
      
#else
      throw std::runtime_error("OpenGL command 'glCopyTexSubImage3DOES' not available on this platform");
#endif
    }

    void copy_texture_levels_apple(gl::uint_t destinationTexture, gl::uint_t sourceTexture, gl::int_t sourceBaseLevel, gl::sizei_t sourceLevelCount) {
#if GL_APPLE_copy_texture_levels    
      
      glCopyTextureLevelsAPPLE(destinationTexture, sourceTexture, sourceBaseLevel, sourceLevelCount);
      
#else
      throw std::runtime_error("OpenGL command 'glCopyTextureLevelsAPPLE' not available on this platform");
#endif
    }

    void cover_fill_path_instanced_nv(gl::sizei_t numPaths, gl::enum_t pathNameType, const void * paths, gl::uint_t pathBase, gl::enum_t coverMode, gl::enum_t transformType, const gl::float_t * transformValues) {
#if GL_NV_path_rendering    
      
      glCoverFillPathInstancedNV(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues);
      
#else
      throw std::runtime_error("OpenGL command 'glCoverFillPathInstancedNV' not available on this platform");
#endif
    }

    void cover_fill_path_nv(gl::uint_t path, gl::enum_t coverMode) {
#if GL_NV_path_rendering    
      
      glCoverFillPathNV(path, coverMode);
      
#else
      throw std::runtime_error("OpenGL command 'glCoverFillPathNV' not available on this platform");
#endif
    }

    void cover_stroke_path_instanced_nv(gl::sizei_t numPaths, gl::enum_t pathNameType, const void * paths, gl::uint_t pathBase, gl::enum_t coverMode, gl::enum_t transformType, const gl::float_t * transformValues) {
#if GL_NV_path_rendering    
      
      glCoverStrokePathInstancedNV(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues);
      
#else
      throw std::runtime_error("OpenGL command 'glCoverStrokePathInstancedNV' not available on this platform");
#endif
    }

    void cover_stroke_path_nv(gl::uint_t path, gl::enum_t coverMode) {
#if GL_NV_path_rendering    
      
      glCoverStrokePathNV(path, coverMode);
      
#else
      throw std::runtime_error("OpenGL command 'glCoverStrokePathNV' not available on this platform");
#endif
    }

    void coverage_mask_nv(boolean_t mask) {
#if GL_NV_coverage_sample    
      
      glCoverageMaskNV(static_cast<GLboolean>(mask));
      
#else
      throw std::runtime_error("OpenGL command 'glCoverageMaskNV' not available on this platform");
#endif
    }

    void coverage_operation_nv(gl::enum_t operation) {
#if GL_NV_coverage_sample    
      
      glCoverageOperationNV(operation);
      
#else
      throw std::runtime_error("OpenGL command 'glCoverageOperationNV' not available on this platform");
#endif
    }

    void create_perf_query_intel(gl::uint_t queryId, gl::uint_t * queryHandle) {
#if GL_INTEL_performance_query    
      
      glCreatePerfQueryINTEL(queryId, queryHandle);
      
#else
      throw std::runtime_error("OpenGL command 'glCreatePerfQueryINTEL' not available on this platform");
#endif
    }

    gl::uint_t create_shader_programv_ext(gl::enum_t type, gl::sizei_t count, const gl::char_t ** strings) {
#if GL_EXT_separate_shader_objects    
      
      return glCreateShaderProgramvEXT(type, count, strings);
      
#else
      throw std::runtime_error("OpenGL command 'glCreateShaderProgramvEXT' not available on this platform");
#endif
    }

    void debug_message_callback_khr(gl::DEBUGPROCKHR_t callback, const void * userParam) {
#if GL_KHR_debug    
      
      glDebugMessageCallbackKHR(callback, userParam);
      
#else
      throw std::runtime_error("OpenGL command 'glDebugMessageCallbackKHR' not available on this platform");
#endif
    }

    void debug_message_control_khr(gl::enum_t source, gl::enum_t type, gl::enum_t severity, gl::sizei_t count, const gl::uint_t * ids, boolean_t enabled) {
#if GL_KHR_debug    
      
      glDebugMessageControlKHR(source, type, severity, count, ids, static_cast<GLboolean>(enabled));
      
#else
      throw std::runtime_error("OpenGL command 'glDebugMessageControlKHR' not available on this platform");
#endif
    }

    void debug_message_insert_khr(gl::enum_t source, gl::enum_t type, gl::uint_t id, gl::enum_t severity, gl::sizei_t length, const gl::char_t * buf) {
#if GL_KHR_debug    
      
      glDebugMessageInsertKHR(source, type, id, severity, length, buf);
      
#else
      throw std::runtime_error("OpenGL command 'glDebugMessageInsertKHR' not available on this platform");
#endif
    }

    void delete_fences_nv(gl::sizei_t n, const gl::uint_t * fences) {
#if GL_NV_fence    
      
      glDeleteFencesNV(n, fences);
      
#else
      throw std::runtime_error("OpenGL command 'glDeleteFencesNV' not available on this platform");
#endif
    }

    void delete_paths_nv(gl::uint_t path, gl::sizei_t range) {
#if GL_NV_path_rendering    
      
      glDeletePathsNV(path, range);
      
#else
      throw std::runtime_error("OpenGL command 'glDeletePathsNV' not available on this platform");
#endif
    }

    void delete_perf_monitors_amd(gl::sizei_t n, gl::uint_t * monitors) {
#if GL_AMD_performance_monitor    
      
      glDeletePerfMonitorsAMD(n, monitors);
      
#else
      throw std::runtime_error("OpenGL command 'glDeletePerfMonitorsAMD' not available on this platform");
#endif
    }

    void delete_perf_query_intel(gl::uint_t queryHandle) {
#if GL_INTEL_performance_query    
      
      glDeletePerfQueryINTEL(queryHandle);
      
#else
      throw std::runtime_error("OpenGL command 'glDeletePerfQueryINTEL' not available on this platform");
#endif
    }

    void delete_program_pipelines_ext(gl::sizei_t n, const gl::uint_t * pipelines) {
#if GL_EXT_separate_shader_objects    
      
      glDeleteProgramPipelinesEXT(n, pipelines);
      
#else
      throw std::runtime_error("OpenGL command 'glDeleteProgramPipelinesEXT' not available on this platform");
#endif
    }

    void delete_queries_ext(gl::sizei_t n, const gl::uint_t * ids) {
#if GL_EXT_disjoint_timer_query || GL_EXT_occlusion_query_boolean    
      
      glDeleteQueriesEXT(n, ids);
      
#else
      throw std::runtime_error("OpenGL command 'glDeleteQueriesEXT' not available on this platform");
#endif
    }

    void delete_sync_apple(gl::sync_t sync) {
#if GL_APPLE_sync    
      
      glDeleteSyncAPPLE(sync);
      
#else
      throw std::runtime_error("OpenGL command 'glDeleteSyncAPPLE' not available on this platform");
#endif
    }

    void delete_vertex_arrays_oes(gl::sizei_t n, const gl::uint_t * arrays) {
#if GL_OES_vertex_array_object    
      
      glDeleteVertexArraysOES(n, arrays);
      
#else
      throw std::runtime_error("OpenGL command 'glDeleteVertexArraysOES' not available on this platform");
#endif
    }

    void depth_range_arrayfv_nv(gl::uint_t first, gl::sizei_t count, const gl::float_t * v) {
#if GL_NV_viewport_array    
      
      glDepthRangeArrayfvNV(first, count, v);
      
#else
      throw std::runtime_error("OpenGL command 'glDepthRangeArrayfvNV' not available on this platform");
#endif
    }

    void depth_range_indexedf_nv(gl::uint_t index, gl::float_t n, gl::float_t f) {
#if GL_NV_viewport_array    
      
      glDepthRangeIndexedfNV(index, n, f);
      
#else
      throw std::runtime_error("OpenGL command 'glDepthRangeIndexedfNV' not available on this platform");
#endif
    }

    void disable_driver_control_qcom(gl::uint_t driverControl) {
#if GL_QCOM_driver_control    
      
      glDisableDriverControlQCOM(driverControl);
      
#else
      throw std::runtime_error("OpenGL command 'glDisableDriverControlQCOM' not available on this platform");
#endif
    }

    void disablei_ext(gl::enum_t target, gl::uint_t index) {
#if GL_EXT_draw_buffers_indexed    
      
      glDisableiEXT(target, index);
      
#else
      throw std::runtime_error("OpenGL command 'glDisableiEXT' not available on this platform");
#endif
    }

    void disablei_nv(gl::enum_t target, gl::uint_t index) {
#if GL_NV_viewport_array    
      
      glDisableiNV(target, index);
      
#else
      throw std::runtime_error("OpenGL command 'glDisableiNV' not available on this platform");
#endif
    }

    void disablei_oes(gl::enum_t target, gl::uint_t index) {
#if GL_OES_draw_buffers_indexed    
      
      glDisableiOES(target, index);
      
#else
      throw std::runtime_error("OpenGL command 'glDisableiOES' not available on this platform");
#endif
    }

    void discard_framebuffer_ext(gl::enum_t target, gl::sizei_t numAttachments, const gl::enum_t * attachments) {
#if GL_EXT_discard_framebuffer    
      
      glDiscardFramebufferEXT(target, numAttachments, attachments);
      
#else
      throw std::runtime_error("OpenGL command 'glDiscardFramebufferEXT' not available on this platform");
#endif
    }

    void draw_arrays_instanced_angle(primitive_type_t mode, gl::int_t first, gl::sizei_t count, gl::sizei_t primcount) {
#if GL_ANGLE_instanced_arrays    
      
      glDrawArraysInstancedANGLE(static_cast<GLenum>(mode), first, count, primcount);
      
#else
      throw std::runtime_error("OpenGL command 'glDrawArraysInstancedANGLE' not available on this platform");
#endif
    }

    void draw_arrays_instanced_base_instance_ext(primitive_type_t mode, gl::int_t first, gl::sizei_t count, gl::sizei_t instancecount, gl::uint_t baseinstance) {
#if GL_EXT_base_instance    
      
      glDrawArraysInstancedBaseInstanceEXT(static_cast<GLenum>(mode), first, count, instancecount, baseinstance);
      
#else
      throw std::runtime_error("OpenGL command 'glDrawArraysInstancedBaseInstanceEXT' not available on this platform");
#endif
    }

    void draw_arrays_instanced_ext(primitive_type_t mode, gl::int_t start, gl::sizei_t count, gl::sizei_t primcount) {
#if GL_EXT_instanced_arrays || GL_EXT_draw_instanced    
      
      glDrawArraysInstancedEXT(static_cast<GLenum>(mode), start, count, primcount);
      
#else
      throw std::runtime_error("OpenGL command 'glDrawArraysInstancedEXT' not available on this platform");
#endif
    }

    void draw_arrays_instanced_nv(primitive_type_t mode, gl::int_t first, gl::sizei_t count, gl::sizei_t primcount) {
#if GL_NV_draw_instanced    
      
      glDrawArraysInstancedNV(static_cast<GLenum>(mode), first, count, primcount);
      
#else
      throw std::runtime_error("OpenGL command 'glDrawArraysInstancedNV' not available on this platform");
#endif
    }

    void draw_buffers_ext(gl::sizei_t n, const gl::enum_t * bufs) {
#if GL_EXT_draw_buffers    
      
      glDrawBuffersEXT(n, bufs);
      
#else
      throw std::runtime_error("OpenGL command 'glDrawBuffersEXT' not available on this platform");
#endif
    }

    void draw_buffers_indexed_ext(gl::int_t n, const gl::enum_t * location, const gl::int_t * indices) {
#if GL_EXT_multiview_draw_buffers    
      
      glDrawBuffersIndexedEXT(n, location, indices);
      
#else
      throw std::runtime_error("OpenGL command 'glDrawBuffersIndexedEXT' not available on this platform");
#endif
    }

    void draw_buffers_nv(gl::sizei_t n, const gl::enum_t * bufs) {
#if GL_NV_draw_buffers    
      
      glDrawBuffersNV(n, bufs);
      
#else
      throw std::runtime_error("OpenGL command 'glDrawBuffersNV' not available on this platform");
#endif
    }

    void draw_elements_base_vertex_ext(primitive_type_t mode, gl::sizei_t count, draw_elements_type_t type, const void * indices, gl::int_t basevertex) {
#if GL_EXT_draw_elements_base_vertex    
      
      glDrawElementsBaseVertexEXT(static_cast<GLenum>(mode), count, static_cast<GLenum>(type), indices, basevertex);
      
#else
      throw std::runtime_error("OpenGL command 'glDrawElementsBaseVertexEXT' not available on this platform");
#endif
    }

    void draw_elements_base_vertex_oes(primitive_type_t mode, gl::sizei_t count, draw_elements_type_t type, const void * indices, gl::int_t basevertex) {
#if GL_OES_draw_elements_base_vertex    
      
      glDrawElementsBaseVertexOES(static_cast<GLenum>(mode), count, static_cast<GLenum>(type), indices, basevertex);
      
#else
      throw std::runtime_error("OpenGL command 'glDrawElementsBaseVertexOES' not available on this platform");
#endif
    }

    void draw_elements_instanced_angle(primitive_type_t mode, gl::sizei_t count, draw_elements_type_t type, const void * indices, gl::sizei_t primcount) {
#if GL_ANGLE_instanced_arrays    
      
      glDrawElementsInstancedANGLE(static_cast<GLenum>(mode), count, static_cast<GLenum>(type), indices, primcount);
      
#else
      throw std::runtime_error("OpenGL command 'glDrawElementsInstancedANGLE' not available on this platform");
#endif
    }

    void draw_elements_instanced_base_instance_ext(primitive_type_t mode, gl::sizei_t count, gl::enum_t type, const void * indices, gl::sizei_t instancecount, gl::uint_t baseinstance) {
#if GL_EXT_base_instance    
      
      glDrawElementsInstancedBaseInstanceEXT(static_cast<GLenum>(mode), count, type, indices, instancecount, baseinstance);
      
#else
      throw std::runtime_error("OpenGL command 'glDrawElementsInstancedBaseInstanceEXT' not available on this platform");
#endif
    }

    void draw_elements_instanced_base_vertex_base_instance_ext(primitive_type_t mode, gl::sizei_t count, gl::enum_t type, const void * indices, gl::sizei_t instancecount, gl::int_t basevertex, gl::uint_t baseinstance) {
#if GL_EXT_base_instance    
      
      glDrawElementsInstancedBaseVertexBaseInstanceEXT(static_cast<GLenum>(mode), count, type, indices, instancecount, basevertex, baseinstance);
      
#else
      throw std::runtime_error("OpenGL command 'glDrawElementsInstancedBaseVertexBaseInstanceEXT' not available on this platform");
#endif
    }

    void draw_elements_instanced_base_vertex_ext(primitive_type_t mode, gl::sizei_t count, draw_elements_type_t type, const void * indices, gl::sizei_t instancecount, gl::int_t basevertex) {
#if GL_EXT_draw_elements_base_vertex    
      
      glDrawElementsInstancedBaseVertexEXT(static_cast<GLenum>(mode), count, static_cast<GLenum>(type), indices, instancecount, basevertex);
      
#else
      throw std::runtime_error("OpenGL command 'glDrawElementsInstancedBaseVertexEXT' not available on this platform");
#endif
    }

    void draw_elements_instanced_base_vertex_oes(primitive_type_t mode, gl::sizei_t count, draw_elements_type_t type, const void * indices, gl::sizei_t instancecount, gl::int_t basevertex) {
#if GL_OES_draw_elements_base_vertex    
      
      glDrawElementsInstancedBaseVertexOES(static_cast<GLenum>(mode), count, static_cast<GLenum>(type), indices, instancecount, basevertex);
      
#else
      throw std::runtime_error("OpenGL command 'glDrawElementsInstancedBaseVertexOES' not available on this platform");
#endif
    }

    void draw_elements_instanced_ext(primitive_type_t mode, gl::sizei_t count, draw_elements_type_t type, const void * indices, gl::sizei_t primcount) {
#if GL_EXT_instanced_arrays || GL_EXT_draw_instanced    
      
      glDrawElementsInstancedEXT(static_cast<GLenum>(mode), count, static_cast<GLenum>(type), indices, primcount);
      
#else
      throw std::runtime_error("OpenGL command 'glDrawElementsInstancedEXT' not available on this platform");
#endif
    }

    void draw_elements_instanced_nv(primitive_type_t mode, gl::sizei_t count, draw_elements_type_t type, const void * indices, gl::sizei_t primcount) {
#if GL_NV_draw_instanced    
      
      glDrawElementsInstancedNV(static_cast<GLenum>(mode), count, static_cast<GLenum>(type), indices, primcount);
      
#else
      throw std::runtime_error("OpenGL command 'glDrawElementsInstancedNV' not available on this platform");
#endif
    }

    void draw_range_elements_base_vertex_ext(primitive_type_t mode, gl::uint_t start, gl::uint_t end, gl::sizei_t count, draw_elements_type_t type, const void * indices, gl::int_t basevertex) {
#if GL_EXT_draw_elements_base_vertex    
      
      glDrawRangeElementsBaseVertexEXT(static_cast<GLenum>(mode), start, end, count, static_cast<GLenum>(type), indices, basevertex);
      
#else
      throw std::runtime_error("OpenGL command 'glDrawRangeElementsBaseVertexEXT' not available on this platform");
#endif
    }

    void draw_range_elements_base_vertex_oes(primitive_type_t mode, gl::uint_t start, gl::uint_t end, gl::sizei_t count, draw_elements_type_t type, const void * indices, gl::int_t basevertex) {
#if GL_OES_draw_elements_base_vertex    
      
      glDrawRangeElementsBaseVertexOES(static_cast<GLenum>(mode), start, end, count, static_cast<GLenum>(type), indices, basevertex);
      
#else
      throw std::runtime_error("OpenGL command 'glDrawRangeElementsBaseVertexOES' not available on this platform");
#endif
    }

    void egl_image_target_renderbuffer_storage_oes(gl::enum_t target, gl::eglImageOES_t image) {
#if GL_OES_EGL_image    
      
      glEGLImageTargetRenderbufferStorageOES(target, image);
      
#else
      throw std::runtime_error("OpenGL command 'glEGLImageTargetRenderbufferStorageOES' not available on this platform");
#endif
    }

    void egl_image_target_texture_2does(gl::enum_t target, gl::eglImageOES_t image) {
#if GL_OES_EGL_image    
      
      glEGLImageTargetTexture2DOES(target, image);
      
#else
      throw std::runtime_error("OpenGL command 'glEGLImageTargetTexture2DOES' not available on this platform");
#endif
    }

    void enable_driver_control_qcom(gl::uint_t driverControl) {
#if GL_QCOM_driver_control    
      
      glEnableDriverControlQCOM(driverControl);
      
#else
      throw std::runtime_error("OpenGL command 'glEnableDriverControlQCOM' not available on this platform");
#endif
    }

    void enablei_ext(gl::enum_t target, gl::uint_t index) {
#if GL_EXT_draw_buffers_indexed    
      
      glEnableiEXT(target, index);
      
#else
      throw std::runtime_error("OpenGL command 'glEnableiEXT' not available on this platform");
#endif
    }

    void enablei_nv(gl::enum_t target, gl::uint_t index) {
#if GL_NV_viewport_array    
      
      glEnableiNV(target, index);
      
#else
      throw std::runtime_error("OpenGL command 'glEnableiNV' not available on this platform");
#endif
    }

    void enablei_oes(gl::enum_t target, gl::uint_t index) {
#if GL_OES_draw_buffers_indexed    
      
      glEnableiOES(target, index);
      
#else
      throw std::runtime_error("OpenGL command 'glEnableiOES' not available on this platform");
#endif
    }

    void end_conditional_render_nv() {
#if GL_NV_conditional_render    
      
      glEndConditionalRenderNV();
      
#else
      throw std::runtime_error("OpenGL command 'glEndConditionalRenderNV' not available on this platform");
#endif
    }

    void end_perf_monitor_amd(gl::uint_t monitor) {
#if GL_AMD_performance_monitor    
      
      glEndPerfMonitorAMD(monitor);
      
#else
      throw std::runtime_error("OpenGL command 'glEndPerfMonitorAMD' not available on this platform");
#endif
    }

    void end_perf_query_intel(gl::uint_t queryHandle) {
#if GL_INTEL_performance_query    
      
      glEndPerfQueryINTEL(queryHandle);
      
#else
      throw std::runtime_error("OpenGL command 'glEndPerfQueryINTEL' not available on this platform");
#endif
    }

    void end_query_ext(gl::enum_t target) {
#if GL_EXT_disjoint_timer_query || GL_EXT_occlusion_query_boolean    
      
      glEndQueryEXT(target);
      
#else
      throw std::runtime_error("OpenGL command 'glEndQueryEXT' not available on this platform");
#endif
    }

    void end_tiling_qcom(gl::bitfield_t preserveMask) {
#if GL_QCOM_tiled_rendering    
      
      glEndTilingQCOM(preserveMask);
      
#else
      throw std::runtime_error("OpenGL command 'glEndTilingQCOM' not available on this platform");
#endif
    }

    void ext_get_buffer_pointerv_qcom(gl::enum_t target, void ** params) {
#if GL_QCOM_extended_get    
      
      glExtGetBufferPointervQCOM(target, params);
      
#else
      throw std::runtime_error("OpenGL command 'glExtGetBufferPointervQCOM' not available on this platform");
#endif
    }

    void ext_get_buffers_qcom(gl::uint_t * buffers, gl::int_t maxBuffers, gl::int_t * numBuffers) {
#if GL_QCOM_extended_get    
      
      glExtGetBuffersQCOM(buffers, maxBuffers, numBuffers);
      
#else
      throw std::runtime_error("OpenGL command 'glExtGetBuffersQCOM' not available on this platform");
#endif
    }

    void ext_get_framebuffers_qcom(gl::uint_t * framebuffers, gl::int_t maxFramebuffers, gl::int_t * numFramebuffers) {
#if GL_QCOM_extended_get    
      
      glExtGetFramebuffersQCOM(framebuffers, maxFramebuffers, numFramebuffers);
      
#else
      throw std::runtime_error("OpenGL command 'glExtGetFramebuffersQCOM' not available on this platform");
#endif
    }

    void ext_get_program_binary_source_qcom(gl::uint_t program, gl::enum_t shadertype, gl::char_t * source, gl::int_t * length) {
#if GL_QCOM_extended_get2    
      
      glExtGetProgramBinarySourceQCOM(program, shadertype, source, length);
      
#else
      throw std::runtime_error("OpenGL command 'glExtGetProgramBinarySourceQCOM' not available on this platform");
#endif
    }

    void ext_get_programs_qcom(gl::uint_t * programs, gl::int_t maxPrograms, gl::int_t * numPrograms) {
#if GL_QCOM_extended_get2    
      
      glExtGetProgramsQCOM(programs, maxPrograms, numPrograms);
      
#else
      throw std::runtime_error("OpenGL command 'glExtGetProgramsQCOM' not available on this platform");
#endif
    }

    void ext_get_renderbuffers_qcom(gl::uint_t * renderbuffers, gl::int_t maxRenderbuffers, gl::int_t * numRenderbuffers) {
#if GL_QCOM_extended_get    
      
      glExtGetRenderbuffersQCOM(renderbuffers, maxRenderbuffers, numRenderbuffers);
      
#else
      throw std::runtime_error("OpenGL command 'glExtGetRenderbuffersQCOM' not available on this platform");
#endif
    }

    void ext_get_shaders_qcom(gl::uint_t * shaders, gl::int_t maxShaders, gl::int_t * numShaders) {
#if GL_QCOM_extended_get2    
      
      glExtGetShadersQCOM(shaders, maxShaders, numShaders);
      
#else
      throw std::runtime_error("OpenGL command 'glExtGetShadersQCOM' not available on this platform");
#endif
    }

    void ext_get_tex_level_parameteriv_qcom(gl::uint_t texture, gl::enum_t face, gl::int_t level, gl::enum_t pname, gl::int_t * params) {
#if GL_QCOM_extended_get    
      
      glExtGetTexLevelParameterivQCOM(texture, face, level, pname, params);
      
#else
      throw std::runtime_error("OpenGL command 'glExtGetTexLevelParameterivQCOM' not available on this platform");
#endif
    }

    void ext_get_tex_sub_image_qcom(gl::enum_t target, gl::int_t level, gl::int_t xoffset, gl::int_t yoffset, gl::int_t zoffset, gl::sizei_t width, gl::sizei_t height, gl::sizei_t depth, gl::enum_t format, gl::enum_t type, void * texels) {
#if GL_QCOM_extended_get    
      
      glExtGetTexSubImageQCOM(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, texels);
      
#else
      throw std::runtime_error("OpenGL command 'glExtGetTexSubImageQCOM' not available on this platform");
#endif
    }

    void ext_get_textures_qcom(gl::uint_t * textures, gl::int_t maxTextures, gl::int_t * numTextures) {
#if GL_QCOM_extended_get    
      
      glExtGetTexturesQCOM(textures, maxTextures, numTextures);
      
#else
      throw std::runtime_error("OpenGL command 'glExtGetTexturesQCOM' not available on this platform");
#endif
    }

    boolean_t ext_is_program_binary_qcom(gl::uint_t program) {
#if GL_QCOM_extended_get2    
      
      return static_cast<boolean_t>(glExtIsProgramBinaryQCOM(program));
      
#else
      throw std::runtime_error("OpenGL command 'glExtIsProgramBinaryQCOM' not available on this platform");
#endif
    }

    void ext_tex_object_state_overridei_qcom(gl::enum_t target, gl::enum_t pname, gl::int_t param) {
#if GL_QCOM_extended_get    
      
      glExtTexObjectStateOverrideiQCOM(target, pname, param);
      
#else
      throw std::runtime_error("OpenGL command 'glExtTexObjectStateOverrideiQCOM' not available on this platform");
#endif
    }

    gl::sync_t fence_sync_apple(gl::enum_t condition, gl::bitfield_t flags) {
#if GL_APPLE_sync    
      
      return glFenceSyncAPPLE(condition, flags);
      
#else
      throw std::runtime_error("OpenGL command 'glFenceSyncAPPLE' not available on this platform");
#endif
    }

    void finish_fence_nv(gl::uint_t fence) {
#if GL_NV_fence    
      
      glFinishFenceNV(fence);
      
#else
      throw std::runtime_error("OpenGL command 'glFinishFenceNV' not available on this platform");
#endif
    }

    void flush_mapped_buffer_range_ext(buffer_target_arb_t target, gl::intptr_t offset, gl::sizeiptr_t length) {
#if GL_EXT_map_buffer_range    
      
      glFlushMappedBufferRangeEXT(static_cast<GLenum>(target), offset, length);
      
#else
      throw std::runtime_error("OpenGL command 'glFlushMappedBufferRangeEXT' not available on this platform");
#endif
    }

    void framebuffer_texture_2d_multisample_ext(gl::enum_t target, gl::enum_t attachment, gl::enum_t textarget, gl::uint_t texture, gl::int_t level, gl::sizei_t samples) {
#if GL_EXT_multisampled_render_to_texture    
      
      glFramebufferTexture2DMultisampleEXT(target, attachment, textarget, texture, level, samples);
      
#else
      throw std::runtime_error("OpenGL command 'glFramebufferTexture2DMultisampleEXT' not available on this platform");
#endif
    }

    void framebuffer_texture_2d_multisample_img(gl::enum_t target, gl::enum_t attachment, gl::enum_t textarget, gl::uint_t texture, gl::int_t level, gl::sizei_t samples) {
#if GL_IMG_multisampled_render_to_texture    
      
      glFramebufferTexture2DMultisampleIMG(target, attachment, textarget, texture, level, samples);
      
#else
      throw std::runtime_error("OpenGL command 'glFramebufferTexture2DMultisampleIMG' not available on this platform");
#endif
    }

    void framebuffer_texture_3does(framebuffer_target_t target, framebuffer_attachment_t attachment, gl::enum_t textarget, gl::uint_t texture, gl::int_t level, gl::int_t zoffset) {
#if GL_OES_texture_3D    
      
      glFramebufferTexture3DOES(static_cast<GLenum>(target), static_cast<GLenum>(attachment), textarget, texture, level, zoffset);
      
#else
      throw std::runtime_error("OpenGL command 'glFramebufferTexture3DOES' not available on this platform");
#endif
    }

    void framebuffer_texture_ext(framebuffer_target_t target, framebuffer_attachment_t attachment, gl::uint_t texture, gl::int_t level) {
#if GL_EXT_geometry_shader    
      
      glFramebufferTextureEXT(static_cast<GLenum>(target), static_cast<GLenum>(attachment), texture, level);
      
#else
      throw std::runtime_error("OpenGL command 'glFramebufferTextureEXT' not available on this platform");
#endif
    }

    void framebuffer_texture_oes(framebuffer_target_t target, framebuffer_attachment_t attachment, gl::uint_t texture, gl::int_t level) {
#if GL_OES_geometry_shader    
      
      glFramebufferTextureOES(static_cast<GLenum>(target), static_cast<GLenum>(attachment), texture, level);
      
#else
      throw std::runtime_error("OpenGL command 'glFramebufferTextureOES' not available on this platform");
#endif
    }

    void gen_fences_nv(gl::sizei_t n, gl::uint_t * fences) {
#if GL_NV_fence    
      
      glGenFencesNV(n, fences);
      
#else
      throw std::runtime_error("OpenGL command 'glGenFencesNV' not available on this platform");
#endif
    }

    gl::uint_t gen_paths_nv(gl::sizei_t range) {
#if GL_NV_path_rendering    
      
      return glGenPathsNV(range);
      
#else
      throw std::runtime_error("OpenGL command 'glGenPathsNV' not available on this platform");
#endif
    }

    void gen_perf_monitors_amd(gl::sizei_t n, gl::uint_t * monitors) {
#if GL_AMD_performance_monitor    
      
      glGenPerfMonitorsAMD(n, monitors);
      
#else
      throw std::runtime_error("OpenGL command 'glGenPerfMonitorsAMD' not available on this platform");
#endif
    }

    void gen_program_pipelines_ext(gl::sizei_t n, gl::uint_t * pipelines) {
#if GL_EXT_separate_shader_objects    
      
      glGenProgramPipelinesEXT(n, pipelines);
      
#else
      throw std::runtime_error("OpenGL command 'glGenProgramPipelinesEXT' not available on this platform");
#endif
    }

    void gen_queries_ext(gl::sizei_t n, gl::uint_t * ids) {
#if GL_EXT_disjoint_timer_query || GL_EXT_occlusion_query_boolean    
      
      glGenQueriesEXT(n, ids);
      
#else
      throw std::runtime_error("OpenGL command 'glGenQueriesEXT' not available on this platform");
#endif
    }

    void gen_vertex_arrays_oes(gl::sizei_t n, gl::uint_t * arrays) {
#if GL_OES_vertex_array_object    
      
      glGenVertexArraysOES(n, arrays);
      
#else
      throw std::runtime_error("OpenGL command 'glGenVertexArraysOES' not available on this platform");
#endif
    }

    void get_buffer_pointerv_oes(buffer_target_arb_t target, gl::enum_t pname, void ** params) {
#if GL_OES_mapbuffer    
      
      glGetBufferPointervOES(static_cast<GLenum>(target), pname, params);
      
#else
      throw std::runtime_error("OpenGL command 'glGetBufferPointervOES' not available on this platform");
#endif
    }

    gl::uint_t get_debug_message_log_khr(gl::uint_t count, gl::sizei_t bufSize, gl::enum_t * sources, gl::enum_t * types, gl::uint_t * ids, gl::enum_t * severities, gl::sizei_t * lengths, gl::char_t * messageLog) {
#if GL_KHR_debug    
      
      return glGetDebugMessageLogKHR(count, bufSize, sources, types, ids, severities, lengths, messageLog);
      
#else
      throw std::runtime_error("OpenGL command 'glGetDebugMessageLogKHR' not available on this platform");
#endif
    }

    void get_driver_control_string_qcom(gl::uint_t driverControl, gl::sizei_t bufSize, gl::sizei_t * length, gl::char_t * driverControlString) {
#if GL_QCOM_driver_control    
      
      glGetDriverControlStringQCOM(driverControl, bufSize, length, driverControlString);
      
#else
      throw std::runtime_error("OpenGL command 'glGetDriverControlStringQCOM' not available on this platform");
#endif
    }

    void get_driver_controls_qcom(gl::int_t * num, gl::sizei_t size, gl::uint_t * driverControls) {
#if GL_QCOM_driver_control    
      
      glGetDriverControlsQCOM(num, size, driverControls);
      
#else
      throw std::runtime_error("OpenGL command 'glGetDriverControlsQCOM' not available on this platform");
#endif
    }

    void get_fenceiv_nv(gl::uint_t fence, gl::enum_t pname, gl::int_t * params) {
#if GL_NV_fence    
      
      glGetFenceivNV(fence, pname, params);
      
#else
      throw std::runtime_error("OpenGL command 'glGetFenceivNV' not available on this platform");
#endif
    }

    void get_first_perf_query_id_intel(gl::uint_t * queryId) {
#if GL_INTEL_performance_query    
      
      glGetFirstPerfQueryIdINTEL(queryId);
      
#else
      throw std::runtime_error("OpenGL command 'glGetFirstPerfQueryIdINTEL' not available on this platform");
#endif
    }

    void get_floati_v_nv(gl::enum_t target, gl::uint_t index, gl::float_t * data) {
#if GL_NV_viewport_array    
      
      glGetFloati_vNV(target, index, data);
      
#else
      throw std::runtime_error("OpenGL command 'glGetFloati_vNV' not available on this platform");
#endif
    }

    gl::enum_t get_graphics_reset_status_ext() {
#if GL_EXT_robustness    
      
      return glGetGraphicsResetStatusEXT();
      
#else
      throw std::runtime_error("OpenGL command 'glGetGraphicsResetStatusEXT' not available on this platform");
#endif
    }

    gl::enum_t get_graphics_reset_status_khr() {
#if GL_KHR_robustness    
      
      return glGetGraphicsResetStatusKHR();
      
#else
      throw std::runtime_error("OpenGL command 'glGetGraphicsResetStatusKHR' not available on this platform");
#endif
    }

    gl::uint64_t get_image_handle_nv(gl::uint_t texture, gl::int_t level, boolean_t layered, gl::int_t layer, gl::enum_t format) {
#if GL_NV_bindless_texture    
      
      return glGetImageHandleNV(texture, level, static_cast<GLboolean>(layered), layer, format);
      
#else
      throw std::runtime_error("OpenGL command 'glGetImageHandleNV' not available on this platform");
#endif
    }

    void get_integer_64v_apple(gl::enum_t pname, gl::int64_t * params) {
#if GL_APPLE_sync    
      
      glGetInteger64vAPPLE(pname, params);
      
#else
      throw std::runtime_error("OpenGL command 'glGetInteger64vAPPLE' not available on this platform");
#endif
    }

    void get_integeri_v_ext(gl::enum_t target, gl::uint_t index, gl::int_t * data) {
#if GL_EXT_multiview_draw_buffers    
      
      glGetIntegeri_vEXT(target, index, data);
      
#else
      throw std::runtime_error("OpenGL command 'glGetIntegeri_vEXT' not available on this platform");
#endif
    }

    void get_internalformat_sampleiv_nv(gl::enum_t target, gl::enum_t internalformat, gl::sizei_t samples, gl::enum_t pname, gl::sizei_t bufSize, gl::int_t * params) {
#if GL_NV_internalformat_sample_query    
      
      glGetInternalformatSampleivNV(target, internalformat, samples, pname, bufSize, params);
      
#else
      throw std::runtime_error("OpenGL command 'glGetInternalformatSampleivNV' not available on this platform");
#endif
    }

    void get_next_perf_query_id_intel(gl::uint_t queryId, gl::uint_t * nextQueryId) {
#if GL_INTEL_performance_query    
      
      glGetNextPerfQueryIdINTEL(queryId, nextQueryId);
      
#else
      throw std::runtime_error("OpenGL command 'glGetNextPerfQueryIdINTEL' not available on this platform");
#endif
    }

    void get_object_label_ext(gl::enum_t type, gl::uint_t object, gl::sizei_t bufSize, gl::sizei_t * length, gl::char_t * label) {
#if GL_EXT_debug_label    
      
      glGetObjectLabelEXT(type, object, bufSize, length, label);
      
#else
      throw std::runtime_error("OpenGL command 'glGetObjectLabelEXT' not available on this platform");
#endif
    }

    void get_object_label_khr(gl::enum_t identifier, gl::uint_t name, gl::sizei_t bufSize, gl::sizei_t * length, gl::char_t * label) {
#if GL_KHR_debug    
      
      glGetObjectLabelKHR(identifier, name, bufSize, length, label);
      
#else
      throw std::runtime_error("OpenGL command 'glGetObjectLabelKHR' not available on this platform");
#endif
    }

    void get_object_ptr_label_khr(const void * ptr, gl::sizei_t bufSize, gl::sizei_t * length, gl::char_t * label) {
#if GL_KHR_debug    
      
      glGetObjectPtrLabelKHR(ptr, bufSize, length, label);
      
#else
      throw std::runtime_error("OpenGL command 'glGetObjectPtrLabelKHR' not available on this platform");
#endif
    }

    void get_path_commands_nv(gl::uint_t path, gl::ubyte_t * commands) {
#if GL_NV_path_rendering    
      
      glGetPathCommandsNV(path, commands);
      
#else
      throw std::runtime_error("OpenGL command 'glGetPathCommandsNV' not available on this platform");
#endif
    }

    void get_path_coords_nv(gl::uint_t path, gl::float_t * coords) {
#if GL_NV_path_rendering    
      
      glGetPathCoordsNV(path, coords);
      
#else
      throw std::runtime_error("OpenGL command 'glGetPathCoordsNV' not available on this platform");
#endif
    }

    void get_path_dash_array_nv(gl::uint_t path, gl::float_t * dashArray) {
#if GL_NV_path_rendering    
      
      glGetPathDashArrayNV(path, dashArray);
      
#else
      throw std::runtime_error("OpenGL command 'glGetPathDashArrayNV' not available on this platform");
#endif
    }

    gl::float_t get_path_length_nv(gl::uint_t path, gl::sizei_t startSegment, gl::sizei_t numSegments) {
#if GL_NV_path_rendering    
      
      return glGetPathLengthNV(path, startSegment, numSegments);
      
#else
      throw std::runtime_error("OpenGL command 'glGetPathLengthNV' not available on this platform");
#endif
    }

    void get_path_metric_range_nv(gl::bitfield_t metricQueryMask, gl::uint_t firstPathName, gl::sizei_t numPaths, gl::sizei_t stride, gl::float_t * metrics) {
#if GL_NV_path_rendering    
      
      glGetPathMetricRangeNV(metricQueryMask, firstPathName, numPaths, stride, metrics);
      
#else
      throw std::runtime_error("OpenGL command 'glGetPathMetricRangeNV' not available on this platform");
#endif
    }

    void get_path_metrics_nv(gl::bitfield_t metricQueryMask, gl::sizei_t numPaths, gl::enum_t pathNameType, const void * paths, gl::uint_t pathBase, gl::sizei_t stride, gl::float_t * metrics) {
#if GL_NV_path_rendering    
      
      glGetPathMetricsNV(metricQueryMask, numPaths, pathNameType, paths, pathBase, stride, metrics);
      
#else
      throw std::runtime_error("OpenGL command 'glGetPathMetricsNV' not available on this platform");
#endif
    }

    void get_path_parameterfv_nv(gl::uint_t path, gl::enum_t pname, gl::float_t * value) {
#if GL_NV_path_rendering    
      
      glGetPathParameterfvNV(path, pname, value);
      
#else
      throw std::runtime_error("OpenGL command 'glGetPathParameterfvNV' not available on this platform");
#endif
    }

    void get_path_parameteriv_nv(gl::uint_t path, gl::enum_t pname, gl::int_t * value) {
#if GL_NV_path_rendering    
      
      glGetPathParameterivNV(path, pname, value);
      
#else
      throw std::runtime_error("OpenGL command 'glGetPathParameterivNV' not available on this platform");
#endif
    }

    void get_path_spacing_nv(gl::enum_t pathListMode, gl::sizei_t numPaths, gl::enum_t pathNameType, const void * paths, gl::uint_t pathBase, gl::float_t advanceScale, gl::float_t kerningScale, gl::enum_t transformType, gl::float_t * returnedSpacing) {
#if GL_NV_path_rendering    
      
      glGetPathSpacingNV(pathListMode, numPaths, pathNameType, paths, pathBase, advanceScale, kerningScale, transformType, returnedSpacing);
      
#else
      throw std::runtime_error("OpenGL command 'glGetPathSpacingNV' not available on this platform");
#endif
    }

    void get_perf_counter_info_intel(gl::uint_t queryId, gl::uint_t counterId, gl::uint_t counterNameLength, gl::char_t * counterName, gl::uint_t counterDescLength, gl::char_t * counterDesc, gl::uint_t * counterOffset, gl::uint_t * counterDataSize, gl::uint_t * counterTypeEnum, gl::uint_t * counterDataTypeEnum, gl::uint64_t * rawCounterMaxValue) {
#if GL_INTEL_performance_query    
      
      glGetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue);
      
#else
      throw std::runtime_error("OpenGL command 'glGetPerfCounterInfoINTEL' not available on this platform");
#endif
    }

    void get_perf_monitor_counter_data_amd(gl::uint_t monitor, gl::enum_t pname, gl::sizei_t dataSize, gl::uint_t * data, gl::int_t * bytesWritten) {
#if GL_AMD_performance_monitor    
      
      glGetPerfMonitorCounterDataAMD(monitor, pname, dataSize, data, bytesWritten);
      
#else
      throw std::runtime_error("OpenGL command 'glGetPerfMonitorCounterDataAMD' not available on this platform");
#endif
    }

    void get_perf_monitor_counter_info_amd(gl::uint_t group, gl::uint_t counter, gl::enum_t pname, void * data) {
#if GL_AMD_performance_monitor    
      
      glGetPerfMonitorCounterInfoAMD(group, counter, pname, data);
      
#else
      throw std::runtime_error("OpenGL command 'glGetPerfMonitorCounterInfoAMD' not available on this platform");
#endif
    }

    void get_perf_monitor_counter_string_amd(gl::uint_t group, gl::uint_t counter, gl::sizei_t bufSize, gl::sizei_t * length, gl::char_t * counterString) {
#if GL_AMD_performance_monitor    
      
      glGetPerfMonitorCounterStringAMD(group, counter, bufSize, length, counterString);
      
#else
      throw std::runtime_error("OpenGL command 'glGetPerfMonitorCounterStringAMD' not available on this platform");
#endif
    }

    void get_perf_monitor_counters_amd(gl::uint_t group, gl::int_t * numCounters, gl::int_t * maxActiveCounters, gl::sizei_t counterSize, gl::uint_t * counters) {
#if GL_AMD_performance_monitor    
      
      glGetPerfMonitorCountersAMD(group, numCounters, maxActiveCounters, counterSize, counters);
      
#else
      throw std::runtime_error("OpenGL command 'glGetPerfMonitorCountersAMD' not available on this platform");
#endif
    }

    void get_perf_monitor_group_string_amd(gl::uint_t group, gl::sizei_t bufSize, gl::sizei_t * length, gl::char_t * groupString) {
#if GL_AMD_performance_monitor    
      
      glGetPerfMonitorGroupStringAMD(group, bufSize, length, groupString);
      
#else
      throw std::runtime_error("OpenGL command 'glGetPerfMonitorGroupStringAMD' not available on this platform");
#endif
    }

    void get_perf_monitor_groups_amd(gl::int_t * numGroups, gl::sizei_t groupsSize, gl::uint_t * groups) {
#if GL_AMD_performance_monitor    
      
      glGetPerfMonitorGroupsAMD(numGroups, groupsSize, groups);
      
#else
      throw std::runtime_error("OpenGL command 'glGetPerfMonitorGroupsAMD' not available on this platform");
#endif
    }

    void get_perf_query_data_intel(gl::uint_t queryHandle, gl::uint_t flags, gl::sizei_t dataSize, void * data, gl::uint_t * bytesWritten) {
#if GL_INTEL_performance_query    
      
      glGetPerfQueryDataINTEL(queryHandle, flags, dataSize, data, bytesWritten);
      
#else
      throw std::runtime_error("OpenGL command 'glGetPerfQueryDataINTEL' not available on this platform");
#endif
    }

    void get_perf_query_id_by_name_intel(gl::char_t * queryName, gl::uint_t * queryId) {
#if GL_INTEL_performance_query    
      
      glGetPerfQueryIdByNameINTEL(queryName, queryId);
      
#else
      throw std::runtime_error("OpenGL command 'glGetPerfQueryIdByNameINTEL' not available on this platform");
#endif
    }

    void get_perf_query_info_intel(gl::uint_t queryId, gl::uint_t queryNameLength, gl::char_t * queryName, gl::uint_t * dataSize, gl::uint_t * noCounters, gl::uint_t * noInstances, gl::uint_t * capsMask) {
#if GL_INTEL_performance_query    
      
      glGetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, dataSize, noCounters, noInstances, capsMask);
      
#else
      throw std::runtime_error("OpenGL command 'glGetPerfQueryInfoINTEL' not available on this platform");
#endif
    }

//    void get_pointerv_khr(get_pointerv_p_name_t pname, void ** params) {
//#if GL_KHR_debug    
//      
//      glGetPointervKHR(static_cast<GLenum>(pname), params);
//      
//#else
//      throw std::runtime_error("OpenGL command 'glGetPointervKHR' not available on this platform");
//#endif
//    }

    void get_program_binary_oes(gl::uint_t program, gl::sizei_t bufSize, gl::sizei_t * length, gl::enum_t * binaryFormat, void * binary) {
#if GL_OES_get_program_binary    
      
      glGetProgramBinaryOES(program, bufSize, length, binaryFormat, binary);
      
#else
      throw std::runtime_error("OpenGL command 'glGetProgramBinaryOES' not available on this platform");
#endif
    }

    void get_program_pipeline_info_log_ext(gl::uint_t pipeline, gl::sizei_t bufSize, gl::sizei_t * length, gl::char_t * infoLog) {
#if GL_EXT_separate_shader_objects    
      
      glGetProgramPipelineInfoLogEXT(pipeline, bufSize, length, infoLog);
      
#else
      throw std::runtime_error("OpenGL command 'glGetProgramPipelineInfoLogEXT' not available on this platform");
#endif
    }

    void get_program_pipelineiv_ext(gl::uint_t pipeline, gl::enum_t pname, gl::int_t * params) {
#if GL_EXT_separate_shader_objects    
      
      glGetProgramPipelineivEXT(pipeline, pname, params);
      
#else
      throw std::runtime_error("OpenGL command 'glGetProgramPipelineivEXT' not available on this platform");
#endif
    }

    void get_program_resourcefv_nv(gl::uint_t program, gl::enum_t programInterface, gl::uint_t index, gl::sizei_t propCount, const gl::enum_t * props, gl::sizei_t bufSize, gl::sizei_t * length, gl::float_t * params) {
#if GL_NV_path_rendering    
      
      glGetProgramResourcefvNV(program, programInterface, index, propCount, props, bufSize, length, params);
      
#else
      throw std::runtime_error("OpenGL command 'glGetProgramResourcefvNV' not available on this platform");
#endif
    }

    void get_query_objecti_64v_ext(gl::uint_t id, gl::enum_t pname, gl::int64_t * params) {
#if GL_EXT_disjoint_timer_query    
      
      glGetQueryObjecti64vEXT(id, pname, params);
      
#else
      throw std::runtime_error("OpenGL command 'glGetQueryObjecti64vEXT' not available on this platform");
#endif
    }

    void get_query_objectiv_ext(gl::uint_t id, gl::enum_t pname, gl::int_t * params) {
#if GL_EXT_disjoint_timer_query    
      
      glGetQueryObjectivEXT(id, pname, params);
      
#else
      throw std::runtime_error("OpenGL command 'glGetQueryObjectivEXT' not available on this platform");
#endif
    }

    void get_query_objectui_64v_ext(gl::uint_t id, gl::enum_t pname, gl::uint64_t * params) {
#if GL_EXT_disjoint_timer_query    
      
      glGetQueryObjectui64vEXT(id, pname, params);
      
#else
      throw std::runtime_error("OpenGL command 'glGetQueryObjectui64vEXT' not available on this platform");
#endif
    }

    void get_query_objectuiv_ext(gl::uint_t id, gl::enum_t pname, gl::uint_t * params) {
#if GL_EXT_disjoint_timer_query || GL_EXT_occlusion_query_boolean    
      
      glGetQueryObjectuivEXT(id, pname, params);
      
#else
      throw std::runtime_error("OpenGL command 'glGetQueryObjectuivEXT' not available on this platform");
#endif
    }

    void get_queryiv_ext(gl::enum_t target, gl::enum_t pname, gl::int_t * params) {
#if GL_EXT_disjoint_timer_query || GL_EXT_occlusion_query_boolean    
      
      glGetQueryivEXT(target, pname, params);
      
#else
      throw std::runtime_error("OpenGL command 'glGetQueryivEXT' not available on this platform");
#endif
    }

    void get_sampler_parameter_iiv_ext(gl::uint_t sampler, gl::enum_t pname, gl::int_t * params) {
#if GL_EXT_texture_border_clamp    
      
      glGetSamplerParameterIivEXT(sampler, pname, params);
      
#else
      throw std::runtime_error("OpenGL command 'glGetSamplerParameterIivEXT' not available on this platform");
#endif
    }

    void get_sampler_parameter_iiv_oes(gl::uint_t sampler, gl::enum_t pname, gl::int_t * params) {
#if GL_OES_texture_border_clamp    
      
      glGetSamplerParameterIivOES(sampler, pname, params);
      
#else
      throw std::runtime_error("OpenGL command 'glGetSamplerParameterIivOES' not available on this platform");
#endif
    }

    void get_sampler_parameter_iuiv_ext(gl::uint_t sampler, gl::enum_t pname, gl::uint_t * params) {
#if GL_EXT_texture_border_clamp    
      
      glGetSamplerParameterIuivEXT(sampler, pname, params);
      
#else
      throw std::runtime_error("OpenGL command 'glGetSamplerParameterIuivEXT' not available on this platform");
#endif
    }

    void get_sampler_parameter_iuiv_oes(gl::uint_t sampler, gl::enum_t pname, gl::uint_t * params) {
#if GL_OES_texture_border_clamp    
      
      glGetSamplerParameterIuivOES(sampler, pname, params);
      
#else
      throw std::runtime_error("OpenGL command 'glGetSamplerParameterIuivOES' not available on this platform");
#endif
    }

    void get_synciv_apple(gl::sync_t sync, gl::enum_t pname, gl::sizei_t bufSize, gl::sizei_t * length, gl::int_t * values) {
#if GL_APPLE_sync    
      
      glGetSyncivAPPLE(sync, pname, bufSize, length, values);
      
#else
      throw std::runtime_error("OpenGL command 'glGetSyncivAPPLE' not available on this platform");
#endif
    }

    void get_tex_parameter_iiv_ext(texture_target_t target, get_texture_parameter_t pname, gl::int_t * params) {
#if GL_EXT_texture_border_clamp    
      
      glGetTexParameterIivEXT(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      
#else
      throw std::runtime_error("OpenGL command 'glGetTexParameterIivEXT' not available on this platform");
#endif
    }

    void get_tex_parameter_iiv_oes(texture_target_t target, get_texture_parameter_t pname, gl::int_t * params) {
#if GL_OES_texture_border_clamp    
      
      glGetTexParameterIivOES(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      
#else
      throw std::runtime_error("OpenGL command 'glGetTexParameterIivOES' not available on this platform");
#endif
    }

    void get_tex_parameter_iuiv_ext(texture_target_t target, get_texture_parameter_t pname, gl::uint_t * params) {
#if GL_EXT_texture_border_clamp    
      
      glGetTexParameterIuivEXT(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      
#else
      throw std::runtime_error("OpenGL command 'glGetTexParameterIuivEXT' not available on this platform");
#endif
    }

    void get_tex_parameter_iuiv_oes(texture_target_t target, get_texture_parameter_t pname, gl::uint_t * params) {
#if GL_OES_texture_border_clamp    
      
      glGetTexParameterIuivOES(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      
#else
      throw std::runtime_error("OpenGL command 'glGetTexParameterIuivOES' not available on this platform");
#endif
    }

    gl::uint64_t get_texture_handle_nv(gl::uint_t texture) {
#if GL_NV_bindless_texture    
      
      return glGetTextureHandleNV(texture);
      
#else
      throw std::runtime_error("OpenGL command 'glGetTextureHandleNV' not available on this platform");
#endif
    }

    gl::uint64_t get_texture_sampler_handle_nv(gl::uint_t texture, gl::uint_t sampler) {
#if GL_NV_bindless_texture    
      
      return glGetTextureSamplerHandleNV(texture, sampler);
      
#else
      throw std::runtime_error("OpenGL command 'glGetTextureSamplerHandleNV' not available on this platform");
#endif
    }

    void get_translated_shader_source_angle(gl::uint_t shader, gl::sizei_t bufsize, gl::sizei_t * length, gl::char_t * source) {
#if GL_ANGLE_translated_shader_source    
      
      glGetTranslatedShaderSourceANGLE(shader, bufsize, length, source);
      
#else
      throw std::runtime_error("OpenGL command 'glGetTranslatedShaderSourceANGLE' not available on this platform");
#endif
    }

    void getn_uniformfv_ext(gl::uint_t program, gl::int_t location, gl::sizei_t bufSize, gl::float_t * params) {
#if GL_EXT_robustness    
      
      glGetnUniformfvEXT(program, location, bufSize, params);
      
#else
      throw std::runtime_error("OpenGL command 'glGetnUniformfvEXT' not available on this platform");
#endif
    }

    void getn_uniformfv_khr(gl::uint_t program, gl::int_t location, gl::sizei_t bufSize, gl::float_t * params) {
#if GL_KHR_robustness    
      
      glGetnUniformfvKHR(program, location, bufSize, params);
      
#else
      throw std::runtime_error("OpenGL command 'glGetnUniformfvKHR' not available on this platform");
#endif
    }

    void getn_uniformiv_ext(gl::uint_t program, gl::int_t location, gl::sizei_t bufSize, gl::int_t * params) {
#if GL_EXT_robustness    
      
      glGetnUniformivEXT(program, location, bufSize, params);
      
#else
      throw std::runtime_error("OpenGL command 'glGetnUniformivEXT' not available on this platform");
#endif
    }

    void getn_uniformiv_khr(gl::uint_t program, gl::int_t location, gl::sizei_t bufSize, gl::int_t * params) {
#if GL_KHR_robustness    
      
      glGetnUniformivKHR(program, location, bufSize, params);
      
#else
      throw std::runtime_error("OpenGL command 'glGetnUniformivKHR' not available on this platform");
#endif
    }

    void getn_uniformuiv_khr(gl::uint_t program, gl::int_t location, gl::sizei_t bufSize, gl::uint_t * params) {
#if GL_KHR_robustness    
      
      glGetnUniformuivKHR(program, location, bufSize, params);
      
#else
      throw std::runtime_error("OpenGL command 'glGetnUniformuivKHR' not available on this platform");
#endif
    }

    void insert_event_marker_ext(gl::sizei_t length, const gl::char_t * marker) {
#if GL_EXT_debug_marker    
      
      glInsertEventMarkerEXT(length, marker);
      
#else
      throw std::runtime_error("OpenGL command 'glInsertEventMarkerEXT' not available on this platform");
#endif
    }

    void interpolate_paths_nv(gl::uint_t resultPath, gl::uint_t pathA, gl::uint_t pathB, gl::float_t weight) {
#if GL_NV_path_rendering    
      
      glInterpolatePathsNV(resultPath, pathA, pathB, weight);
      
#else
      throw std::runtime_error("OpenGL command 'glInterpolatePathsNV' not available on this platform");
#endif
    }

    boolean_t is_enabledi_ext(gl::enum_t target, gl::uint_t index) {
#if GL_EXT_draw_buffers_indexed    
      
      return static_cast<boolean_t>(glIsEnablediEXT(target, index));
      
#else
      throw std::runtime_error("OpenGL command 'glIsEnablediEXT' not available on this platform");
#endif
    }

    boolean_t is_enabledi_nv(gl::enum_t target, gl::uint_t index) {
#if GL_NV_viewport_array    
      
      return static_cast<boolean_t>(glIsEnablediNV(target, index));
      
#else
      throw std::runtime_error("OpenGL command 'glIsEnablediNV' not available on this platform");
#endif
    }

    boolean_t is_enabledi_oes(gl::enum_t target, gl::uint_t index) {
#if GL_OES_draw_buffers_indexed    
      
      return static_cast<boolean_t>(glIsEnablediOES(target, index));
      
#else
      throw std::runtime_error("OpenGL command 'glIsEnablediOES' not available on this platform");
#endif
    }

    boolean_t is_fence_nv(gl::uint_t fence) {
#if GL_NV_fence    
      
      return static_cast<boolean_t>(glIsFenceNV(fence));
      
#else
      throw std::runtime_error("OpenGL command 'glIsFenceNV' not available on this platform");
#endif
    }

    boolean_t is_image_handle_resident_nv(gl::uint64_t handle) {
#if GL_NV_bindless_texture    
      
      return static_cast<boolean_t>(glIsImageHandleResidentNV(handle));
      
#else
      throw std::runtime_error("OpenGL command 'glIsImageHandleResidentNV' not available on this platform");
#endif
    }

    boolean_t is_path_nv(gl::uint_t path) {
#if GL_NV_path_rendering    
      
      return static_cast<boolean_t>(glIsPathNV(path));
      
#else
      throw std::runtime_error("OpenGL command 'glIsPathNV' not available on this platform");
#endif
    }

    boolean_t is_point_in_fill_path_nv(gl::uint_t path, gl::uint_t mask, gl::float_t x, gl::float_t y) {
#if GL_NV_path_rendering    
      
      return static_cast<boolean_t>(glIsPointInFillPathNV(path, mask, x, y));
      
#else
      throw std::runtime_error("OpenGL command 'glIsPointInFillPathNV' not available on this platform");
#endif
    }

    boolean_t is_point_in_stroke_path_nv(gl::uint_t path, gl::float_t x, gl::float_t y) {
#if GL_NV_path_rendering    
      
      return static_cast<boolean_t>(glIsPointInStrokePathNV(path, x, y));
      
#else
      throw std::runtime_error("OpenGL command 'glIsPointInStrokePathNV' not available on this platform");
#endif
    }

    boolean_t is_program_pipeline_ext(gl::uint_t pipeline) {
#if GL_EXT_separate_shader_objects    
      
      return static_cast<boolean_t>(glIsProgramPipelineEXT(pipeline));
      
#else
      throw std::runtime_error("OpenGL command 'glIsProgramPipelineEXT' not available on this platform");
#endif
    }

    boolean_t is_query_ext(gl::uint_t id) {
#if GL_EXT_disjoint_timer_query || GL_EXT_occlusion_query_boolean    
      
      return static_cast<boolean_t>(glIsQueryEXT(id));
      
#else
      throw std::runtime_error("OpenGL command 'glIsQueryEXT' not available on this platform");
#endif
    }

    boolean_t is_sync_apple(gl::sync_t sync) {
#if GL_APPLE_sync    
      
      return static_cast<boolean_t>(glIsSyncAPPLE(sync));
      
#else
      throw std::runtime_error("OpenGL command 'glIsSyncAPPLE' not available on this platform");
#endif
    }

    boolean_t is_texture_handle_resident_nv(gl::uint64_t handle) {
#if GL_NV_bindless_texture    
      
      return static_cast<boolean_t>(glIsTextureHandleResidentNV(handle));
      
#else
      throw std::runtime_error("OpenGL command 'glIsTextureHandleResidentNV' not available on this platform");
#endif
    }

    boolean_t is_vertex_array_oes(gl::uint_t array) {
#if GL_OES_vertex_array_object    
      
      return static_cast<boolean_t>(glIsVertexArrayOES(array));
      
#else
      throw std::runtime_error("OpenGL command 'glIsVertexArrayOES' not available on this platform");
#endif
    }

    void label_object_ext(gl::enum_t type, gl::uint_t object, gl::sizei_t length, const gl::char_t * label) {
#if GL_EXT_debug_label    
      
      glLabelObjectEXT(type, object, length, label);
      
#else
      throw std::runtime_error("OpenGL command 'glLabelObjectEXT' not available on this platform");
#endif
    }

    void make_image_handle_non_resident_nv(gl::uint64_t handle) {
#if GL_NV_bindless_texture    
      
      glMakeImageHandleNonResidentNV(handle);
      
#else
      throw std::runtime_error("OpenGL command 'glMakeImageHandleNonResidentNV' not available on this platform");
#endif
    }

    void make_image_handle_resident_nv(gl::uint64_t handle, gl::enum_t access) {
#if GL_NV_bindless_texture    
      
      glMakeImageHandleResidentNV(handle, access);
      
#else
      throw std::runtime_error("OpenGL command 'glMakeImageHandleResidentNV' not available on this platform");
#endif
    }

    void make_texture_handle_non_resident_nv(gl::uint64_t handle) {
#if GL_NV_bindless_texture    
      
      glMakeTextureHandleNonResidentNV(handle);
      
#else
      throw std::runtime_error("OpenGL command 'glMakeTextureHandleNonResidentNV' not available on this platform");
#endif
    }

    void make_texture_handle_resident_nv(gl::uint64_t handle) {
#if GL_NV_bindless_texture    
      
      glMakeTextureHandleResidentNV(handle);
      
#else
      throw std::runtime_error("OpenGL command 'glMakeTextureHandleResidentNV' not available on this platform");
#endif
    }

    void * map_buffer_oes(buffer_target_arb_t target, gl::enum_t access) {
#if GL_OES_mapbuffer    
      
      return glMapBufferOES(static_cast<GLenum>(target), access);
      
#else
      throw std::runtime_error("OpenGL command 'glMapBufferOES' not available on this platform");
#endif
    }

    void * map_buffer_range_ext(buffer_target_arb_t target, gl::intptr_t offset, gl::sizeiptr_t length, gl::bitfield_t access) {
#if GL_EXT_map_buffer_range    
      
      return glMapBufferRangeEXT(static_cast<GLenum>(target), offset, length, access);
      
#else
      throw std::runtime_error("OpenGL command 'glMapBufferRangeEXT' not available on this platform");
#endif
    }

    void matrix_load_3x_2f_nv(gl::enum_t matrixMode, const gl::float_t * m) {
#if GL_NV_path_rendering    
      
      glMatrixLoad3x2fNV(matrixMode, m);
      
#else
      throw std::runtime_error("OpenGL command 'glMatrixLoad3x2fNV' not available on this platform");
#endif
    }

    void matrix_load_3x_3f_nv(gl::enum_t matrixMode, const gl::float_t * m) {
#if GL_NV_path_rendering    
      
      glMatrixLoad3x3fNV(matrixMode, m);
      
#else
      throw std::runtime_error("OpenGL command 'glMatrixLoad3x3fNV' not available on this platform");
#endif
    }

    void matrix_load_transpose_3x_3f_nv(gl::enum_t matrixMode, const gl::float_t * m) {
#if GL_NV_path_rendering    
      
      glMatrixLoadTranspose3x3fNV(matrixMode, m);
      
#else
      throw std::runtime_error("OpenGL command 'glMatrixLoadTranspose3x3fNV' not available on this platform");
#endif
    }

    void matrix_mult_3x_2f_nv(gl::enum_t matrixMode, const gl::float_t * m) {
#if GL_NV_path_rendering    
      
      glMatrixMult3x2fNV(matrixMode, m);
      
#else
      throw std::runtime_error("OpenGL command 'glMatrixMult3x2fNV' not available on this platform");
#endif
    }

    void matrix_mult_3x_3f_nv(gl::enum_t matrixMode, const gl::float_t * m) {
#if GL_NV_path_rendering    
      
      glMatrixMult3x3fNV(matrixMode, m);
      
#else
      throw std::runtime_error("OpenGL command 'glMatrixMult3x3fNV' not available on this platform");
#endif
    }

    void matrix_mult_transpose_3x_3f_nv(gl::enum_t matrixMode, const gl::float_t * m) {
#if GL_NV_path_rendering    
      
      glMatrixMultTranspose3x3fNV(matrixMode, m);
      
#else
      throw std::runtime_error("OpenGL command 'glMatrixMultTranspose3x3fNV' not available on this platform");
#endif
    }

    void min_sample_shading_oes(gl::float_t value) {
#if GL_OES_sample_shading    
      
      glMinSampleShadingOES(value);
      
#else
      throw std::runtime_error("OpenGL command 'glMinSampleShadingOES' not available on this platform");
#endif
    }

    void multi_draw_arrays_ext(primitive_type_t mode, const gl::int_t * first, const gl::sizei_t * count, gl::sizei_t primcount) {
#if GL_EXT_multi_draw_arrays    
      
      glMultiDrawArraysEXT(static_cast<GLenum>(mode), first, count, primcount);
      
#else
      throw std::runtime_error("OpenGL command 'glMultiDrawArraysEXT' not available on this platform");
#endif
    }

    void multi_draw_arrays_indirect_ext(gl::enum_t mode, const void * indirect, gl::sizei_t drawcount, gl::sizei_t stride) {
#if GL_EXT_multi_draw_indirect    
      
      glMultiDrawArraysIndirectEXT(mode, indirect, drawcount, stride);
      
#else
      throw std::runtime_error("OpenGL command 'glMultiDrawArraysIndirectEXT' not available on this platform");
#endif
    }

    void multi_draw_elements_base_vertex_ext(gl::enum_t mode, const gl::sizei_t * count, draw_elements_type_t type, const void *const* indices, gl::sizei_t primcount, const gl::int_t * basevertex) {
#if GL_EXT_draw_elements_base_vertex    
      
      glMultiDrawElementsBaseVertexEXT(mode, count, static_cast<GLenum>(type), indices, primcount, basevertex);
      
#else
      throw std::runtime_error("OpenGL command 'glMultiDrawElementsBaseVertexEXT' not available on this platform");
#endif
    }

    void multi_draw_elements_base_vertex_oes(gl::enum_t mode, const gl::sizei_t * count, draw_elements_type_t type, const void *const* indices, gl::sizei_t primcount, const gl::int_t * basevertex) {
#if GL_OES_draw_elements_base_vertex    
      
      glMultiDrawElementsBaseVertexOES(mode, count, static_cast<GLenum>(type), indices, primcount, basevertex);
      
#else
      throw std::runtime_error("OpenGL command 'glMultiDrawElementsBaseVertexOES' not available on this platform");
#endif
    }

    void multi_draw_elements_ext(primitive_type_t mode, const gl::sizei_t * count, draw_elements_type_t type, const void * * indices, gl::sizei_t primcount) {
#if GL_EXT_multi_draw_arrays    
      
      glMultiDrawElementsEXT(static_cast<GLenum>(mode), count, static_cast<GLenum>(type), indices, primcount);
      
#else
      throw std::runtime_error("OpenGL command 'glMultiDrawElementsEXT' not available on this platform");
#endif
    }

    void multi_draw_elements_indirect_ext(gl::enum_t mode, gl::enum_t type, const void * indirect, gl::sizei_t drawcount, gl::sizei_t stride) {
#if GL_EXT_multi_draw_indirect    
      
      glMultiDrawElementsIndirectEXT(mode, type, indirect, drawcount, stride);
      
#else
      throw std::runtime_error("OpenGL command 'glMultiDrawElementsIndirectEXT' not available on this platform");
#endif
    }

    void object_label_khr(gl::enum_t identifier, gl::uint_t name, gl::sizei_t length, const gl::char_t * label) {
#if GL_KHR_debug    
      
      glObjectLabelKHR(identifier, name, length, label);
      
#else
      throw std::runtime_error("OpenGL command 'glObjectLabelKHR' not available on this platform");
#endif
    }

    void object_ptr_label_khr(const void * ptr, gl::sizei_t length, const gl::char_t * label) {
#if GL_KHR_debug    
      
      glObjectPtrLabelKHR(ptr, length, label);
      
#else
      throw std::runtime_error("OpenGL command 'glObjectPtrLabelKHR' not available on this platform");
#endif
    }

    void patch_parameteri_ext(gl::enum_t pname, gl::int_t value) {
#if GL_EXT_tessellation_shader    
      
      glPatchParameteriEXT(pname, value);
      
#else
      throw std::runtime_error("OpenGL command 'glPatchParameteriEXT' not available on this platform");
#endif
    }

    void patch_parameteri_oes(gl::enum_t pname, gl::int_t value) {
#if GL_OES_tessellation_shader    
      
      glPatchParameteriOES(pname, value);
      
#else
      throw std::runtime_error("OpenGL command 'glPatchParameteriOES' not available on this platform");
#endif
    }

    void path_commands_nv(gl::uint_t path, gl::sizei_t numCommands, const gl::ubyte_t * commands, gl::sizei_t numCoords, gl::enum_t coordType, const void * coords) {
#if GL_NV_path_rendering    
      
      glPathCommandsNV(path, numCommands, commands, numCoords, coordType, coords);
      
#else
      throw std::runtime_error("OpenGL command 'glPathCommandsNV' not available on this platform");
#endif
    }

    void path_coords_nv(gl::uint_t path, gl::sizei_t numCoords, gl::enum_t coordType, const void * coords) {
#if GL_NV_path_rendering    
      
      glPathCoordsNV(path, numCoords, coordType, coords);
      
#else
      throw std::runtime_error("OpenGL command 'glPathCoordsNV' not available on this platform");
#endif
    }

    void path_cover_depth_func_nv(depth_function_t func) {
#if GL_NV_path_rendering    
      
      glPathCoverDepthFuncNV(static_cast<GLenum>(func));
      
#else
      throw std::runtime_error("OpenGL command 'glPathCoverDepthFuncNV' not available on this platform");
#endif
    }

    void path_dash_array_nv(gl::uint_t path, gl::sizei_t dashCount, const gl::float_t * dashArray) {
#if GL_NV_path_rendering    
      
      glPathDashArrayNV(path, dashCount, dashArray);
      
#else
      throw std::runtime_error("OpenGL command 'glPathDashArrayNV' not available on this platform");
#endif
    }

    gl::enum_t path_glyph_index_array_nv(gl::uint_t firstPathName, gl::enum_t fontTarget, const void * fontName, gl::bitfield_t fontStyle, gl::uint_t firstGlyphIndex, gl::sizei_t numGlyphs, gl::uint_t pathParameterTemplate, gl::float_t emScale) {
#if GL_NV_path_rendering    
      
      return glPathGlyphIndexArrayNV(firstPathName, fontTarget, fontName, fontStyle, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale);
      
#else
      throw std::runtime_error("OpenGL command 'glPathGlyphIndexArrayNV' not available on this platform");
#endif
    }

    gl::enum_t path_glyph_index_range_nv(gl::enum_t fontTarget, const void * fontName, gl::bitfield_t fontStyle, gl::uint_t pathParameterTemplate, gl::float_t emScale, gl::uint_t * baseAndCount) {
#if GL_NV_path_rendering    
      
      return glPathGlyphIndexRangeNV(fontTarget, fontName, fontStyle, pathParameterTemplate, emScale, baseAndCount);
      
#else
      throw std::runtime_error("OpenGL command 'glPathGlyphIndexRangeNV' not available on this platform");
#endif
    }

    void path_glyph_range_nv(gl::uint_t firstPathName, gl::enum_t fontTarget, const void * fontName, gl::bitfield_t fontStyle, gl::uint_t firstGlyph, gl::sizei_t numGlyphs, gl::enum_t handleMissingGlyphs, gl::uint_t pathParameterTemplate, gl::float_t emScale) {
#if GL_NV_path_rendering    
      
      glPathGlyphRangeNV(firstPathName, fontTarget, fontName, fontStyle, firstGlyph, numGlyphs, handleMissingGlyphs, pathParameterTemplate, emScale);
      
#else
      throw std::runtime_error("OpenGL command 'glPathGlyphRangeNV' not available on this platform");
#endif
    }

    void path_glyphs_nv(gl::uint_t firstPathName, gl::enum_t fontTarget, const void * fontName, gl::bitfield_t fontStyle, gl::sizei_t numGlyphs, gl::enum_t type, const void * charcodes, gl::enum_t handleMissingGlyphs, gl::uint_t pathParameterTemplate, gl::float_t emScale) {
#if GL_NV_path_rendering    
      
      glPathGlyphsNV(firstPathName, fontTarget, fontName, fontStyle, numGlyphs, type, charcodes, handleMissingGlyphs, pathParameterTemplate, emScale);
      
#else
      throw std::runtime_error("OpenGL command 'glPathGlyphsNV' not available on this platform");
#endif
    }

    gl::enum_t path_memory_glyph_index_array_nv(gl::uint_t firstPathName, gl::enum_t fontTarget, gl::sizeiptr_t fontSize, const void * fontData, gl::sizei_t faceIndex, gl::uint_t firstGlyphIndex, gl::sizei_t numGlyphs, gl::uint_t pathParameterTemplate, gl::float_t emScale) {
#if GL_NV_path_rendering    
      
      return glPathMemoryGlyphIndexArrayNV(firstPathName, fontTarget, fontSize, fontData, faceIndex, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale);
      
#else
      throw std::runtime_error("OpenGL command 'glPathMemoryGlyphIndexArrayNV' not available on this platform");
#endif
    }

    void path_parameterf_nv(gl::uint_t path, gl::enum_t pname, gl::float_t value) {
#if GL_NV_path_rendering    
      
      glPathParameterfNV(path, pname, value);
      
#else
      throw std::runtime_error("OpenGL command 'glPathParameterfNV' not available on this platform");
#endif
    }

    void path_parameterfv_nv(gl::uint_t path, gl::enum_t pname, const gl::float_t * value) {
#if GL_NV_path_rendering    
      
      glPathParameterfvNV(path, pname, value);
      
#else
      throw std::runtime_error("OpenGL command 'glPathParameterfvNV' not available on this platform");
#endif
    }

    void path_parameteri_nv(gl::uint_t path, gl::enum_t pname, gl::int_t value) {
#if GL_NV_path_rendering    
      
      glPathParameteriNV(path, pname, value);
      
#else
      throw std::runtime_error("OpenGL command 'glPathParameteriNV' not available on this platform");
#endif
    }

    void path_parameteriv_nv(gl::uint_t path, gl::enum_t pname, const gl::int_t * value) {
#if GL_NV_path_rendering    
      
      glPathParameterivNV(path, pname, value);
      
#else
      throw std::runtime_error("OpenGL command 'glPathParameterivNV' not available on this platform");
#endif
    }

    void path_stencil_depth_offset_nv(gl::float_t factor, gl::float_t units) {
#if GL_NV_path_rendering    
      
      glPathStencilDepthOffsetNV(factor, units);
      
#else
      throw std::runtime_error("OpenGL command 'glPathStencilDepthOffsetNV' not available on this platform");
#endif
    }

    void path_stencil_func_nv(stencil_function_t func, gl::int_t ref, gl::uint_t mask) {
#if GL_NV_path_rendering    
      
      glPathStencilFuncNV(static_cast<GLenum>(func), ref, mask);
      
#else
      throw std::runtime_error("OpenGL command 'glPathStencilFuncNV' not available on this platform");
#endif
    }

    void path_string_nv(gl::uint_t path, gl::enum_t format, gl::sizei_t length, const void * pathString) {
#if GL_NV_path_rendering    
      
      glPathStringNV(path, format, length, pathString);
      
#else
      throw std::runtime_error("OpenGL command 'glPathStringNV' not available on this platform");
#endif
    }

    void path_sub_commands_nv(gl::uint_t path, gl::sizei_t commandStart, gl::sizei_t commandsToDelete, gl::sizei_t numCommands, const gl::ubyte_t * commands, gl::sizei_t numCoords, gl::enum_t coordType, const void * coords) {
#if GL_NV_path_rendering    
      
      glPathSubCommandsNV(path, commandStart, commandsToDelete, numCommands, commands, numCoords, coordType, coords);
      
#else
      throw std::runtime_error("OpenGL command 'glPathSubCommandsNV' not available on this platform");
#endif
    }

    void path_sub_coords_nv(gl::uint_t path, gl::sizei_t coordStart, gl::sizei_t numCoords, gl::enum_t coordType, const void * coords) {
#if GL_NV_path_rendering    
      
      glPathSubCoordsNV(path, coordStart, numCoords, coordType, coords);
      
#else
      throw std::runtime_error("OpenGL command 'glPathSubCoordsNV' not available on this platform");
#endif
    }

    boolean_t point_along_path_nv(gl::uint_t path, gl::sizei_t startSegment, gl::sizei_t numSegments, gl::float_t distance, gl::float_t * x, gl::float_t * y, gl::float_t * tangentX, gl::float_t * tangentY) {
#if GL_NV_path_rendering    
      
      return static_cast<boolean_t>(glPointAlongPathNV(path, startSegment, numSegments, distance, x, y, tangentX, tangentY));
      
#else
      throw std::runtime_error("OpenGL command 'glPointAlongPathNV' not available on this platform");
#endif
    }

    void pop_debug_group_khr() {
#if GL_KHR_debug    
      
      glPopDebugGroupKHR();
      
#else
      throw std::runtime_error("OpenGL command 'glPopDebugGroupKHR' not available on this platform");
#endif
    }

    void pop_group_marker_ext() {
#if GL_EXT_debug_marker    
      
      glPopGroupMarkerEXT();
      
#else
      throw std::runtime_error("OpenGL command 'glPopGroupMarkerEXT' not available on this platform");
#endif
    }

    void primitive_bounding_box_ext(gl::float_t minX, gl::float_t minY, gl::float_t minZ, gl::float_t minW, gl::float_t maxX, gl::float_t maxY, gl::float_t maxZ, gl::float_t maxW) {
#if GL_EXT_primitive_bounding_box    
      
      glPrimitiveBoundingBoxEXT(minX, minY, minZ, minW, maxX, maxY, maxZ, maxW);
      
#else
      throw std::runtime_error("OpenGL command 'glPrimitiveBoundingBoxEXT' not available on this platform");
#endif
    }

    void primitive_bounding_box_oes(gl::float_t minX, gl::float_t minY, gl::float_t minZ, gl::float_t minW, gl::float_t maxX, gl::float_t maxY, gl::float_t maxZ, gl::float_t maxW) {
#if GL_OES_primitive_bounding_box    
      
      glPrimitiveBoundingBoxOES(minX, minY, minZ, minW, maxX, maxY, maxZ, maxW);
      
#else
      throw std::runtime_error("OpenGL command 'glPrimitiveBoundingBoxOES' not available on this platform");
#endif
    }

    void program_binary_oes(gl::uint_t program, gl::enum_t binaryFormat, const void * binary, gl::int_t length) {
#if GL_OES_get_program_binary    
      
      glProgramBinaryOES(program, binaryFormat, binary, length);
      
#else
      throw std::runtime_error("OpenGL command 'glProgramBinaryOES' not available on this platform");
#endif
    }

    void program_parameteri_ext(gl::uint_t program, gl::enum_t pname, gl::int_t value) {
#if GL_EXT_separate_shader_objects    
      
      glProgramParameteriEXT(program, pname, value);
      
#else
      throw std::runtime_error("OpenGL command 'glProgramParameteriEXT' not available on this platform");
#endif
    }

    void program_path_fragment_input_gen_nv(gl::uint_t program, gl::int_t location, gl::enum_t genMode, gl::int_t components, const gl::float_t * coeffs) {
#if GL_NV_path_rendering    
      
      glProgramPathFragmentInputGenNV(program, location, genMode, components, coeffs);
      
#else
      throw std::runtime_error("OpenGL command 'glProgramPathFragmentInputGenNV' not available on this platform");
#endif
    }

    void program_uniform_1f_ext(gl::uint_t program, gl::int_t location, gl::float_t v0) {
#if GL_EXT_separate_shader_objects    
      
      glProgramUniform1fEXT(program, location, v0);
      
#else
      throw std::runtime_error("OpenGL command 'glProgramUniform1fEXT' not available on this platform");
#endif
    }

    void program_uniform_1fv_ext(gl::uint_t program, gl::int_t location, gl::sizei_t count, const gl::float_t * value) {
#if GL_EXT_separate_shader_objects    
      
      glProgramUniform1fvEXT(program, location, count, value);
      
#else
      throw std::runtime_error("OpenGL command 'glProgramUniform1fvEXT' not available on this platform");
#endif
    }

    void program_uniform_1i_ext(gl::uint_t program, gl::int_t location, gl::int_t v0) {
#if GL_EXT_separate_shader_objects    
      
      glProgramUniform1iEXT(program, location, v0);
      
#else
      throw std::runtime_error("OpenGL command 'glProgramUniform1iEXT' not available on this platform");
#endif
    }

    void program_uniform_1iv_ext(gl::uint_t program, gl::int_t location, gl::sizei_t count, const gl::int_t * value) {
#if GL_EXT_separate_shader_objects    
      
      glProgramUniform1ivEXT(program, location, count, value);
      
#else
      throw std::runtime_error("OpenGL command 'glProgramUniform1ivEXT' not available on this platform");
#endif
    }

    void program_uniform_1ui_ext(gl::uint_t program, gl::int_t location, gl::uint_t v0) {
#if GL_EXT_separate_shader_objects    
      
      glProgramUniform1uiEXT(program, location, v0);
      
#else
      throw std::runtime_error("OpenGL command 'glProgramUniform1uiEXT' not available on this platform");
#endif
    }

    void program_uniform_1uiv_ext(gl::uint_t program, gl::int_t location, gl::sizei_t count, const gl::uint_t * value) {
#if GL_EXT_separate_shader_objects    
      
      glProgramUniform1uivEXT(program, location, count, value);
      
#else
      throw std::runtime_error("OpenGL command 'glProgramUniform1uivEXT' not available on this platform");
#endif
    }

    void program_uniform_2f_ext(gl::uint_t program, gl::int_t location, gl::float_t v0, gl::float_t v1) {
#if GL_EXT_separate_shader_objects    
      
      glProgramUniform2fEXT(program, location, v0, v1);
      
#else
      throw std::runtime_error("OpenGL command 'glProgramUniform2fEXT' not available on this platform");
#endif
    }

    void program_uniform_2fv_ext(gl::uint_t program, gl::int_t location, gl::sizei_t count, const gl::float_t * value) {
#if GL_EXT_separate_shader_objects    
      
      glProgramUniform2fvEXT(program, location, count, value);
      
#else
      throw std::runtime_error("OpenGL command 'glProgramUniform2fvEXT' not available on this platform");
#endif
    }

    void program_uniform_2i_ext(gl::uint_t program, gl::int_t location, gl::int_t v0, gl::int_t v1) {
#if GL_EXT_separate_shader_objects    
      
      glProgramUniform2iEXT(program, location, v0, v1);
      
#else
      throw std::runtime_error("OpenGL command 'glProgramUniform2iEXT' not available on this platform");
#endif
    }

    void program_uniform_2iv_ext(gl::uint_t program, gl::int_t location, gl::sizei_t count, const gl::int_t * value) {
#if GL_EXT_separate_shader_objects    
      
      glProgramUniform2ivEXT(program, location, count, value);
      
#else
      throw std::runtime_error("OpenGL command 'glProgramUniform2ivEXT' not available on this platform");
#endif
    }

    void program_uniform_2ui_ext(gl::uint_t program, gl::int_t location, gl::uint_t v0, gl::uint_t v1) {
#if GL_EXT_separate_shader_objects    
      
      glProgramUniform2uiEXT(program, location, v0, v1);
      
#else
      throw std::runtime_error("OpenGL command 'glProgramUniform2uiEXT' not available on this platform");
#endif
    }

    void program_uniform_2uiv_ext(gl::uint_t program, gl::int_t location, gl::sizei_t count, const gl::uint_t * value) {
#if GL_EXT_separate_shader_objects    
      
      glProgramUniform2uivEXT(program, location, count, value);
      
#else
      throw std::runtime_error("OpenGL command 'glProgramUniform2uivEXT' not available on this platform");
#endif
    }

    void program_uniform_3f_ext(gl::uint_t program, gl::int_t location, gl::float_t v0, gl::float_t v1, gl::float_t v2) {
#if GL_EXT_separate_shader_objects    
      
      glProgramUniform3fEXT(program, location, v0, v1, v2);
      
#else
      throw std::runtime_error("OpenGL command 'glProgramUniform3fEXT' not available on this platform");
#endif
    }

    void program_uniform_3fv_ext(gl::uint_t program, gl::int_t location, gl::sizei_t count, const gl::float_t * value) {
#if GL_EXT_separate_shader_objects    
      
      glProgramUniform3fvEXT(program, location, count, value);
      
#else
      throw std::runtime_error("OpenGL command 'glProgramUniform3fvEXT' not available on this platform");
#endif
    }

    void program_uniform_3i_ext(gl::uint_t program, gl::int_t location, gl::int_t v0, gl::int_t v1, gl::int_t v2) {
#if GL_EXT_separate_shader_objects    
      
      glProgramUniform3iEXT(program, location, v0, v1, v2);
      
#else
      throw std::runtime_error("OpenGL command 'glProgramUniform3iEXT' not available on this platform");
#endif
    }

    void program_uniform_3iv_ext(gl::uint_t program, gl::int_t location, gl::sizei_t count, const gl::int_t * value) {
#if GL_EXT_separate_shader_objects    
      
      glProgramUniform3ivEXT(program, location, count, value);
      
#else
      throw std::runtime_error("OpenGL command 'glProgramUniform3ivEXT' not available on this platform");
#endif
    }

    void program_uniform_3ui_ext(gl::uint_t program, gl::int_t location, gl::uint_t v0, gl::uint_t v1, gl::uint_t v2) {
#if GL_EXT_separate_shader_objects    
      
      glProgramUniform3uiEXT(program, location, v0, v1, v2);
      
#else
      throw std::runtime_error("OpenGL command 'glProgramUniform3uiEXT' not available on this platform");
#endif
    }

    void program_uniform_3uiv_ext(gl::uint_t program, gl::int_t location, gl::sizei_t count, const gl::uint_t * value) {
#if GL_EXT_separate_shader_objects    
      
      glProgramUniform3uivEXT(program, location, count, value);
      
#else
      throw std::runtime_error("OpenGL command 'glProgramUniform3uivEXT' not available on this platform");
#endif
    }

    void program_uniform_4f_ext(gl::uint_t program, gl::int_t location, gl::float_t v0, gl::float_t v1, gl::float_t v2, gl::float_t v3) {
#if GL_EXT_separate_shader_objects    
      
      glProgramUniform4fEXT(program, location, v0, v1, v2, v3);
      
#else
      throw std::runtime_error("OpenGL command 'glProgramUniform4fEXT' not available on this platform");
#endif
    }

    void program_uniform_4fv_ext(gl::uint_t program, gl::int_t location, gl::sizei_t count, const gl::float_t * value) {
#if GL_EXT_separate_shader_objects    
      
      glProgramUniform4fvEXT(program, location, count, value);
      
#else
      throw std::runtime_error("OpenGL command 'glProgramUniform4fvEXT' not available on this platform");
#endif
    }

    void program_uniform_4i_ext(gl::uint_t program, gl::int_t location, gl::int_t v0, gl::int_t v1, gl::int_t v2, gl::int_t v3) {
#if GL_EXT_separate_shader_objects    
      
      glProgramUniform4iEXT(program, location, v0, v1, v2, v3);
      
#else
      throw std::runtime_error("OpenGL command 'glProgramUniform4iEXT' not available on this platform");
#endif
    }

    void program_uniform_4iv_ext(gl::uint_t program, gl::int_t location, gl::sizei_t count, const gl::int_t * value) {
#if GL_EXT_separate_shader_objects    
      
      glProgramUniform4ivEXT(program, location, count, value);
      
#else
      throw std::runtime_error("OpenGL command 'glProgramUniform4ivEXT' not available on this platform");
#endif
    }

    void program_uniform_4ui_ext(gl::uint_t program, gl::int_t location, gl::uint_t v0, gl::uint_t v1, gl::uint_t v2, gl::uint_t v3) {
#if GL_EXT_separate_shader_objects    
      
      glProgramUniform4uiEXT(program, location, v0, v1, v2, v3);
      
#else
      throw std::runtime_error("OpenGL command 'glProgramUniform4uiEXT' not available on this platform");
#endif
    }

    void program_uniform_4uiv_ext(gl::uint_t program, gl::int_t location, gl::sizei_t count, const gl::uint_t * value) {
#if GL_EXT_separate_shader_objects    
      
      glProgramUniform4uivEXT(program, location, count, value);
      
#else
      throw std::runtime_error("OpenGL command 'glProgramUniform4uivEXT' not available on this platform");
#endif
    }

    void program_uniform_handleui_64nv(gl::uint_t program, gl::int_t location, gl::uint64_t value) {
#if GL_NV_bindless_texture    
      
      glProgramUniformHandleui64NV(program, location, value);
      
#else
      throw std::runtime_error("OpenGL command 'glProgramUniformHandleui64NV' not available on this platform");
#endif
    }

    void program_uniform_handleui_64v_nv(gl::uint_t program, gl::int_t location, gl::sizei_t count, const gl::uint64_t * values) {
#if GL_NV_bindless_texture    
      
      glProgramUniformHandleui64vNV(program, location, count, values);
      
#else
      throw std::runtime_error("OpenGL command 'glProgramUniformHandleui64vNV' not available on this platform");
#endif
    }

    void program_uniform_matrix_2fv_ext(gl::uint_t program, gl::int_t location, gl::sizei_t count, boolean_t transpose, const gl::float_t * value) {
#if GL_EXT_separate_shader_objects    
      
      glProgramUniformMatrix2fvEXT(program, location, count, static_cast<GLboolean>(transpose), value);
      
#else
      throw std::runtime_error("OpenGL command 'glProgramUniformMatrix2fvEXT' not available on this platform");
#endif
    }

    void program_uniform_matrix_2x_3fv_ext(gl::uint_t program, gl::int_t location, gl::sizei_t count, boolean_t transpose, const gl::float_t * value) {
#if GL_EXT_separate_shader_objects    
      
      glProgramUniformMatrix2x3fvEXT(program, location, count, static_cast<GLboolean>(transpose), value);
      
#else
      throw std::runtime_error("OpenGL command 'glProgramUniformMatrix2x3fvEXT' not available on this platform");
#endif
    }

    void program_uniform_matrix_2x_4fv_ext(gl::uint_t program, gl::int_t location, gl::sizei_t count, boolean_t transpose, const gl::float_t * value) {
#if GL_EXT_separate_shader_objects    
      
      glProgramUniformMatrix2x4fvEXT(program, location, count, static_cast<GLboolean>(transpose), value);
      
#else
      throw std::runtime_error("OpenGL command 'glProgramUniformMatrix2x4fvEXT' not available on this platform");
#endif
    }

    void program_uniform_matrix_3fv_ext(gl::uint_t program, gl::int_t location, gl::sizei_t count, boolean_t transpose, const gl::float_t * value) {
#if GL_EXT_separate_shader_objects    
      
      glProgramUniformMatrix3fvEXT(program, location, count, static_cast<GLboolean>(transpose), value);
      
#else
      throw std::runtime_error("OpenGL command 'glProgramUniformMatrix3fvEXT' not available on this platform");
#endif
    }

    void program_uniform_matrix_3x_2fv_ext(gl::uint_t program, gl::int_t location, gl::sizei_t count, boolean_t transpose, const gl::float_t * value) {
#if GL_EXT_separate_shader_objects    
      
      glProgramUniformMatrix3x2fvEXT(program, location, count, static_cast<GLboolean>(transpose), value);
      
#else
      throw std::runtime_error("OpenGL command 'glProgramUniformMatrix3x2fvEXT' not available on this platform");
#endif
    }

    void program_uniform_matrix_3x_4fv_ext(gl::uint_t program, gl::int_t location, gl::sizei_t count, boolean_t transpose, const gl::float_t * value) {
#if GL_EXT_separate_shader_objects    
      
      glProgramUniformMatrix3x4fvEXT(program, location, count, static_cast<GLboolean>(transpose), value);
      
#else
      throw std::runtime_error("OpenGL command 'glProgramUniformMatrix3x4fvEXT' not available on this platform");
#endif
    }

    void program_uniform_matrix_4fv_ext(gl::uint_t program, gl::int_t location, gl::sizei_t count, boolean_t transpose, const gl::float_t * value) {
#if GL_EXT_separate_shader_objects    
      
      glProgramUniformMatrix4fvEXT(program, location, count, static_cast<GLboolean>(transpose), value);
      
#else
      throw std::runtime_error("OpenGL command 'glProgramUniformMatrix4fvEXT' not available on this platform");
#endif
    }

    void program_uniform_matrix_4x_2fv_ext(gl::uint_t program, gl::int_t location, gl::sizei_t count, boolean_t transpose, const gl::float_t * value) {
#if GL_EXT_separate_shader_objects    
      
      glProgramUniformMatrix4x2fvEXT(program, location, count, static_cast<GLboolean>(transpose), value);
      
#else
      throw std::runtime_error("OpenGL command 'glProgramUniformMatrix4x2fvEXT' not available on this platform");
#endif
    }

    void program_uniform_matrix_4x_3fv_ext(gl::uint_t program, gl::int_t location, gl::sizei_t count, boolean_t transpose, const gl::float_t * value) {
#if GL_EXT_separate_shader_objects    
      
      glProgramUniformMatrix4x3fvEXT(program, location, count, static_cast<GLboolean>(transpose), value);
      
#else
      throw std::runtime_error("OpenGL command 'glProgramUniformMatrix4x3fvEXT' not available on this platform");
#endif
    }

    void push_debug_group_khr(gl::enum_t source, gl::uint_t id, gl::sizei_t length, const gl::char_t * message) {
#if GL_KHR_debug    
      
      glPushDebugGroupKHR(source, id, length, message);
      
#else
      throw std::runtime_error("OpenGL command 'glPushDebugGroupKHR' not available on this platform");
#endif
    }

    void push_group_marker_ext(gl::sizei_t length, const gl::char_t * marker) {
#if GL_EXT_debug_marker    
      
      glPushGroupMarkerEXT(length, marker);
      
#else
      throw std::runtime_error("OpenGL command 'glPushGroupMarkerEXT' not available on this platform");
#endif
    }

    void query_counter_ext(gl::uint_t id, gl::enum_t target) {
#if GL_EXT_disjoint_timer_query    
      
      glQueryCounterEXT(id, target);
      
#else
      throw std::runtime_error("OpenGL command 'glQueryCounterEXT' not available on this platform");
#endif
    }

    void read_buffer_indexed_ext(gl::enum_t src, gl::int_t index) {
#if GL_EXT_multiview_draw_buffers    
      
      glReadBufferIndexedEXT(src, index);
      
#else
      throw std::runtime_error("OpenGL command 'glReadBufferIndexedEXT' not available on this platform");
#endif
    }

    void read_buffer_nv(gl::enum_t mode) {
#if GL_NV_read_buffer    
      
      glReadBufferNV(mode);
      
#else
      throw std::runtime_error("OpenGL command 'glReadBufferNV' not available on this platform");
#endif
    }

    void readn_pixels_ext(gl::int_t x, gl::int_t y, gl::sizei_t width, gl::sizei_t height, gl::enum_t format, gl::enum_t type, gl::sizei_t bufSize, void * data) {
#if GL_EXT_robustness    
      
      glReadnPixelsEXT(x, y, width, height, format, type, bufSize, data);
      
#else
      throw std::runtime_error("OpenGL command 'glReadnPixelsEXT' not available on this platform");
#endif
    }

    void readn_pixels_khr(gl::int_t x, gl::int_t y, gl::sizei_t width, gl::sizei_t height, pixel_format_t format, pixel_type_t type, gl::sizei_t bufSize, void * data) {
#if GL_KHR_robustness    
      
      glReadnPixelsKHR(x, y, width, height, static_cast<GLenum>(format), static_cast<GLenum>(type), bufSize, data);
      
#else
      throw std::runtime_error("OpenGL command 'glReadnPixelsKHR' not available on this platform");
#endif
    }

    void renderbuffer_storage_multisample_angle(renderbuffer_target_t target, gl::sizei_t samples, internal_format_t internalformat, gl::sizei_t width, gl::sizei_t height) {
#if GL_ANGLE_framebuffer_multisample    
      
      glRenderbufferStorageMultisampleANGLE(static_cast<GLenum>(target), samples, static_cast<GLenum>(internalformat), width, height);
      
#else
      throw std::runtime_error("OpenGL command 'glRenderbufferStorageMultisampleANGLE' not available on this platform");
#endif
    }

    void renderbuffer_storage_multisample_apple(renderbuffer_target_t target, gl::sizei_t samples, internal_format_t internalformat, gl::sizei_t width, gl::sizei_t height) {
#if GL_APPLE_framebuffer_multisample    
      
      glRenderbufferStorageMultisampleAPPLE(static_cast<GLenum>(target), samples, static_cast<GLenum>(internalformat), width, height);
      
#else
      throw std::runtime_error("OpenGL command 'glRenderbufferStorageMultisampleAPPLE' not available on this platform");
#endif
    }

    void renderbuffer_storage_multisample_ext(renderbuffer_target_t target, gl::sizei_t samples, internal_format_t internalformat, gl::sizei_t width, gl::sizei_t height) {
#if GL_EXT_multisampled_render_to_texture    
      
      glRenderbufferStorageMultisampleEXT(static_cast<GLenum>(target), samples, static_cast<GLenum>(internalformat), width, height);
      
#else
      throw std::runtime_error("OpenGL command 'glRenderbufferStorageMultisampleEXT' not available on this platform");
#endif
    }

    void renderbuffer_storage_multisample_img(gl::enum_t target, gl::sizei_t samples, gl::enum_t internalformat, gl::sizei_t width, gl::sizei_t height) {
#if GL_IMG_multisampled_render_to_texture    
      
      glRenderbufferStorageMultisampleIMG(target, samples, internalformat, width, height);
      
#else
      throw std::runtime_error("OpenGL command 'glRenderbufferStorageMultisampleIMG' not available on this platform");
#endif
    }

    void renderbuffer_storage_multisample_nv(renderbuffer_target_t target, gl::sizei_t samples, internal_format_t internalformat, gl::sizei_t width, gl::sizei_t height) {
#if GL_NV_framebuffer_multisample    
      
      glRenderbufferStorageMultisampleNV(static_cast<GLenum>(target), samples, static_cast<GLenum>(internalformat), width, height);
      
#else
      throw std::runtime_error("OpenGL command 'glRenderbufferStorageMultisampleNV' not available on this platform");
#endif
    }

    void resolve_multisample_framebuffer_apple() {
#if GL_APPLE_framebuffer_multisample    
      
      glResolveMultisampleFramebufferAPPLE();
      
#else
      throw std::runtime_error("OpenGL command 'glResolveMultisampleFramebufferAPPLE' not available on this platform");
#endif
    }

    void sampler_parameter_iiv_ext(gl::uint_t sampler, gl::enum_t pname, const gl::int_t * param) {
#if GL_EXT_texture_border_clamp    
      
      glSamplerParameterIivEXT(sampler, pname, param);
      
#else
      throw std::runtime_error("OpenGL command 'glSamplerParameterIivEXT' not available on this platform");
#endif
    }

    void sampler_parameter_iiv_oes(gl::uint_t sampler, gl::enum_t pname, const gl::int_t * param) {
#if GL_OES_texture_border_clamp    
      
      glSamplerParameterIivOES(sampler, pname, param);
      
#else
      throw std::runtime_error("OpenGL command 'glSamplerParameterIivOES' not available on this platform");
#endif
    }

    void sampler_parameter_iuiv_ext(gl::uint_t sampler, gl::enum_t pname, const gl::uint_t * param) {
#if GL_EXT_texture_border_clamp    
      
      glSamplerParameterIuivEXT(sampler, pname, param);
      
#else
      throw std::runtime_error("OpenGL command 'glSamplerParameterIuivEXT' not available on this platform");
#endif
    }

    void sampler_parameter_iuiv_oes(gl::uint_t sampler, gl::enum_t pname, const gl::uint_t * param) {
#if GL_OES_texture_border_clamp    
      
      glSamplerParameterIuivOES(sampler, pname, param);
      
#else
      throw std::runtime_error("OpenGL command 'glSamplerParameterIuivOES' not available on this platform");
#endif
    }

    void scissor_arrayv_nv(gl::uint_t first, gl::sizei_t count, const gl::int_t * v) {
#if GL_NV_viewport_array    
      
      glScissorArrayvNV(first, count, v);
      
#else
      throw std::runtime_error("OpenGL command 'glScissorArrayvNV' not available on this platform");
#endif
    }

    void scissor_indexed_nv(gl::uint_t index, gl::int_t left, gl::int_t bottom, gl::sizei_t width, gl::sizei_t height) {
#if GL_NV_viewport_array    
      
      glScissorIndexedNV(index, left, bottom, width, height);
      
#else
      throw std::runtime_error("OpenGL command 'glScissorIndexedNV' not available on this platform");
#endif
    }

    void scissor_indexedv_nv(gl::uint_t index, const gl::int_t * v) {
#if GL_NV_viewport_array    
      
      glScissorIndexedvNV(index, v);
      
#else
      throw std::runtime_error("OpenGL command 'glScissorIndexedvNV' not available on this platform");
#endif
    }

    void select_perf_monitor_counters_amd(gl::uint_t monitor, boolean_t enable, gl::uint_t group, gl::int_t numCounters, gl::uint_t * counterList) {
#if GL_AMD_performance_monitor    
      
      glSelectPerfMonitorCountersAMD(monitor, static_cast<GLboolean>(enable), group, numCounters, counterList);
      
#else
      throw std::runtime_error("OpenGL command 'glSelectPerfMonitorCountersAMD' not available on this platform");
#endif
    }

    void set_fence_nv(gl::uint_t fence, gl::enum_t condition) {
#if GL_NV_fence    
      
      glSetFenceNV(fence, condition);
      
#else
      throw std::runtime_error("OpenGL command 'glSetFenceNV' not available on this platform");
#endif
    }

    void start_tiling_qcom(gl::uint_t x, gl::uint_t y, gl::uint_t width, gl::uint_t height, gl::bitfield_t preserveMask) {
#if GL_QCOM_tiled_rendering    
      
      glStartTilingQCOM(x, y, width, height, preserveMask);
      
#else
      throw std::runtime_error("OpenGL command 'glStartTilingQCOM' not available on this platform");
#endif
    }

    void stencil_fill_path_instanced_nv(gl::sizei_t numPaths, gl::enum_t pathNameType, const void * paths, gl::uint_t pathBase, gl::enum_t fillMode, gl::uint_t mask, gl::enum_t transformType, const gl::float_t * transformValues) {
#if GL_NV_path_rendering    
      
      glStencilFillPathInstancedNV(numPaths, pathNameType, paths, pathBase, fillMode, mask, transformType, transformValues);
      
#else
      throw std::runtime_error("OpenGL command 'glStencilFillPathInstancedNV' not available on this platform");
#endif
    }

    void stencil_fill_path_nv(gl::uint_t path, gl::enum_t fillMode, gl::uint_t mask) {
#if GL_NV_path_rendering    
      
      glStencilFillPathNV(path, fillMode, mask);
      
#else
      throw std::runtime_error("OpenGL command 'glStencilFillPathNV' not available on this platform");
#endif
    }

    void stencil_stroke_path_instanced_nv(gl::sizei_t numPaths, gl::enum_t pathNameType, const void * paths, gl::uint_t pathBase, gl::int_t reference, gl::uint_t mask, gl::enum_t transformType, const gl::float_t * transformValues) {
#if GL_NV_path_rendering    
      
      glStencilStrokePathInstancedNV(numPaths, pathNameType, paths, pathBase, reference, mask, transformType, transformValues);
      
#else
      throw std::runtime_error("OpenGL command 'glStencilStrokePathInstancedNV' not available on this platform");
#endif
    }

    void stencil_stroke_path_nv(gl::uint_t path, gl::int_t reference, gl::uint_t mask) {
#if GL_NV_path_rendering    
      
      glStencilStrokePathNV(path, reference, mask);
      
#else
      throw std::runtime_error("OpenGL command 'glStencilStrokePathNV' not available on this platform");
#endif
    }

    void stencil_then_cover_fill_path_instanced_nv(gl::sizei_t numPaths, gl::enum_t pathNameType, const void * paths, gl::uint_t pathBase, gl::enum_t fillMode, gl::uint_t mask, gl::enum_t coverMode, gl::enum_t transformType, const gl::float_t * transformValues) {
#if GL_NV_path_rendering    
      
      glStencilThenCoverFillPathInstancedNV(numPaths, pathNameType, paths, pathBase, fillMode, mask, coverMode, transformType, transformValues);
      
#else
      throw std::runtime_error("OpenGL command 'glStencilThenCoverFillPathInstancedNV' not available on this platform");
#endif
    }

    void stencil_then_cover_fill_path_nv(gl::uint_t path, gl::enum_t fillMode, gl::uint_t mask, gl::enum_t coverMode) {
#if GL_NV_path_rendering    
      
      glStencilThenCoverFillPathNV(path, fillMode, mask, coverMode);
      
#else
      throw std::runtime_error("OpenGL command 'glStencilThenCoverFillPathNV' not available on this platform");
#endif
    }

    void stencil_then_cover_stroke_path_instanced_nv(gl::sizei_t numPaths, gl::enum_t pathNameType, const void * paths, gl::uint_t pathBase, gl::int_t reference, gl::uint_t mask, gl::enum_t coverMode, gl::enum_t transformType, const gl::float_t * transformValues) {
#if GL_NV_path_rendering    
      
      glStencilThenCoverStrokePathInstancedNV(numPaths, pathNameType, paths, pathBase, reference, mask, coverMode, transformType, transformValues);
      
#else
      throw std::runtime_error("OpenGL command 'glStencilThenCoverStrokePathInstancedNV' not available on this platform");
#endif
    }

    void stencil_then_cover_stroke_path_nv(gl::uint_t path, gl::int_t reference, gl::uint_t mask, gl::enum_t coverMode) {
#if GL_NV_path_rendering    
      
      glStencilThenCoverStrokePathNV(path, reference, mask, coverMode);
      
#else
      throw std::runtime_error("OpenGL command 'glStencilThenCoverStrokePathNV' not available on this platform");
#endif
    }

    boolean_t test_fence_nv(gl::uint_t fence) {
#if GL_NV_fence    
      
      return static_cast<boolean_t>(glTestFenceNV(fence));
      
#else
      throw std::runtime_error("OpenGL command 'glTestFenceNV' not available on this platform");
#endif
    }

    void tex_buffer_ext(texture_target_t target, gl::enum_t internalformat, gl::uint_t buffer) {
#if GL_EXT_texture_buffer    
      
      glTexBufferEXT(static_cast<GLenum>(target), internalformat, buffer);
      
#else
      throw std::runtime_error("OpenGL command 'glTexBufferEXT' not available on this platform");
#endif
    }

    void tex_buffer_oes(texture_target_t target, gl::enum_t internalformat, gl::uint_t buffer) {
#if GL_OES_texture_buffer    
      
      glTexBufferOES(static_cast<GLenum>(target), internalformat, buffer);
      
#else
      throw std::runtime_error("OpenGL command 'glTexBufferOES' not available on this platform");
#endif
    }

    void tex_buffer_range_ext(gl::enum_t target, gl::enum_t internalformat, gl::uint_t buffer, gl::intptr_t offset, gl::sizeiptr_t size) {
#if GL_EXT_texture_buffer    
      
      glTexBufferRangeEXT(target, internalformat, buffer, offset, size);
      
#else
      throw std::runtime_error("OpenGL command 'glTexBufferRangeEXT' not available on this platform");
#endif
    }

    void tex_buffer_range_oes(gl::enum_t target, gl::enum_t internalformat, gl::uint_t buffer, gl::intptr_t offset, gl::sizeiptr_t size) {
#if GL_OES_texture_buffer    
      
      glTexBufferRangeOES(target, internalformat, buffer, offset, size);
      
#else
      throw std::runtime_error("OpenGL command 'glTexBufferRangeOES' not available on this platform");
#endif
    }

    void tex_image_3does(texture_target_t target, gl::int_t level, gl::enum_t internalformat, gl::sizei_t width, gl::sizei_t height, gl::sizei_t depth, gl::int_t border, pixel_format_t format, pixel_type_t type, const void * pixels) {
#if GL_OES_texture_3D    
      
      glTexImage3DOES(static_cast<GLenum>(target), level, internalformat, width, height, depth, border, static_cast<GLenum>(format), static_cast<GLenum>(type), pixels);
      
#else
      throw std::runtime_error("OpenGL command 'glTexImage3DOES' not available on this platform");
#endif
    }

    void tex_parameter_iiv_ext(texture_target_t target, texture_parameter_name_t pname, const gl::int_t * params) {
#if GL_EXT_texture_border_clamp    
      
      glTexParameterIivEXT(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      
#else
      throw std::runtime_error("OpenGL command 'glTexParameterIivEXT' not available on this platform");
#endif
    }

    void tex_parameter_iiv_oes(texture_target_t target, texture_parameter_name_t pname, const gl::int_t * params) {
#if GL_OES_texture_border_clamp    
      
      glTexParameterIivOES(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      
#else
      throw std::runtime_error("OpenGL command 'glTexParameterIivOES' not available on this platform");
#endif
    }

    void tex_parameter_iuiv_ext(texture_target_t target, texture_parameter_name_t pname, const gl::uint_t * params) {
#if GL_EXT_texture_border_clamp    
      
      glTexParameterIuivEXT(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      
#else
      throw std::runtime_error("OpenGL command 'glTexParameterIuivEXT' not available on this platform");
#endif
    }

    void tex_parameter_iuiv_oes(texture_target_t target, texture_parameter_name_t pname, const gl::uint_t * params) {
#if GL_OES_texture_border_clamp    
      
      glTexParameterIuivOES(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      
#else
      throw std::runtime_error("OpenGL command 'glTexParameterIuivOES' not available on this platform");
#endif
    }

    void tex_storage_1dext(gl::enum_t target, gl::sizei_t levels, gl::enum_t internalformat, gl::sizei_t width) {
#if GL_EXT_texture_storage    
      
      glTexStorage1DEXT(target, levels, internalformat, width);
      
#else
      throw std::runtime_error("OpenGL command 'glTexStorage1DEXT' not available on this platform");
#endif
    }

    void tex_storage_2dext(gl::enum_t target, gl::sizei_t levels, gl::enum_t internalformat, gl::sizei_t width, gl::sizei_t height) {
#if GL_EXT_texture_storage    
      
      glTexStorage2DEXT(target, levels, internalformat, width, height);
      
#else
      throw std::runtime_error("OpenGL command 'glTexStorage2DEXT' not available on this platform");
#endif
    }

    void tex_storage_3dext(gl::enum_t target, gl::sizei_t levels, gl::enum_t internalformat, gl::sizei_t width, gl::sizei_t height, gl::sizei_t depth) {
#if GL_EXT_texture_storage    
      
      glTexStorage3DEXT(target, levels, internalformat, width, height, depth);
      
#else
      throw std::runtime_error("OpenGL command 'glTexStorage3DEXT' not available on this platform");
#endif
    }

    void tex_storage_3d_multisample_oes(gl::enum_t target, gl::sizei_t samples, gl::enum_t internalformat, gl::sizei_t width, gl::sizei_t height, gl::sizei_t depth, boolean_t fixedsamplelocations) {
#if GL_OES_texture_storage_multisample_2d_array    
      
      glTexStorage3DMultisampleOES(target, samples, internalformat, width, height, depth, static_cast<GLboolean>(fixedsamplelocations));
      
#else
      throw std::runtime_error("OpenGL command 'glTexStorage3DMultisampleOES' not available on this platform");
#endif
    }

    void tex_sub_image_3does(texture_target_t target, gl::int_t level, gl::int_t xoffset, gl::int_t yoffset, gl::int_t zoffset, gl::sizei_t width, gl::sizei_t height, gl::sizei_t depth, pixel_format_t format, pixel_type_t type, const void * pixels) {
#if GL_OES_texture_3D    
      
      glTexSubImage3DOES(static_cast<GLenum>(target), level, xoffset, yoffset, zoffset, width, height, depth, static_cast<GLenum>(format), static_cast<GLenum>(type), pixels);
      
#else
      throw std::runtime_error("OpenGL command 'glTexSubImage3DOES' not available on this platform");
#endif
    }

    void texture_storage_1dext(gl::uint_t texture, gl::enum_t target, gl::sizei_t levels, gl::enum_t internalformat, gl::sizei_t width) {
#if GL_EXT_texture_storage    
      
      glTextureStorage1DEXT(texture, target, levels, internalformat, width);
      
#else
      throw std::runtime_error("OpenGL command 'glTextureStorage1DEXT' not available on this platform");
#endif
    }

    void texture_storage_2dext(gl::uint_t texture, gl::enum_t target, gl::sizei_t levels, gl::enum_t internalformat, gl::sizei_t width, gl::sizei_t height) {
#if GL_EXT_texture_storage    
      
      glTextureStorage2DEXT(texture, target, levels, internalformat, width, height);
      
#else
      throw std::runtime_error("OpenGL command 'glTextureStorage2DEXT' not available on this platform");
#endif
    }

    void texture_storage_3dext(gl::uint_t texture, gl::enum_t target, gl::sizei_t levels, gl::enum_t internalformat, gl::sizei_t width, gl::sizei_t height, gl::sizei_t depth) {
#if GL_EXT_texture_storage    
      
      glTextureStorage3DEXT(texture, target, levels, internalformat, width, height, depth);
      
#else
      throw std::runtime_error("OpenGL command 'glTextureStorage3DEXT' not available on this platform");
#endif
    }

    void texture_view_ext(gl::uint_t texture, gl::enum_t target, gl::uint_t origtexture, gl::enum_t internalformat, gl::uint_t minlevel, gl::uint_t numlevels, gl::uint_t minlayer, gl::uint_t numlayers) {
#if GL_EXT_texture_view    
      
      glTextureViewEXT(texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers);
      
#else
      throw std::runtime_error("OpenGL command 'glTextureViewEXT' not available on this platform");
#endif
    }

    void texture_view_oes(gl::uint_t texture, gl::enum_t target, gl::uint_t origtexture, gl::enum_t internalformat, gl::uint_t minlevel, gl::uint_t numlevels, gl::uint_t minlayer, gl::uint_t numlayers) {
#if GL_OES_texture_view    
      
      glTextureViewOES(texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers);
      
#else
      throw std::runtime_error("OpenGL command 'glTextureViewOES' not available on this platform");
#endif
    }

    void transform_path_nv(gl::uint_t resultPath, gl::uint_t srcPath, gl::enum_t transformType, const gl::float_t * transformValues) {
#if GL_NV_path_rendering    
      
      glTransformPathNV(resultPath, srcPath, transformType, transformValues);
      
#else
      throw std::runtime_error("OpenGL command 'glTransformPathNV' not available on this platform");
#endif
    }

    void uniform_handleui_64nv(gl::int_t location, gl::uint64_t value) {
#if GL_NV_bindless_texture    
      
      glUniformHandleui64NV(location, value);
      
#else
      throw std::runtime_error("OpenGL command 'glUniformHandleui64NV' not available on this platform");
#endif
    }

    void uniform_handleui_64v_nv(gl::int_t location, gl::sizei_t count, const gl::uint64_t * value) {
#if GL_NV_bindless_texture    
      
      glUniformHandleui64vNV(location, count, value);
      
#else
      throw std::runtime_error("OpenGL command 'glUniformHandleui64vNV' not available on this platform");
#endif
    }

    void uniform_matrix_2x_3fv_nv(gl::int_t location, gl::sizei_t count, boolean_t transpose, const gl::float_t * value) {
#if GL_NV_non_square_matrices    
      
      glUniformMatrix2x3fvNV(location, count, static_cast<GLboolean>(transpose), value);
      
#else
      throw std::runtime_error("OpenGL command 'glUniformMatrix2x3fvNV' not available on this platform");
#endif
    }

    void uniform_matrix_2x_4fv_nv(gl::int_t location, gl::sizei_t count, boolean_t transpose, const gl::float_t * value) {
#if GL_NV_non_square_matrices    
      
      glUniformMatrix2x4fvNV(location, count, static_cast<GLboolean>(transpose), value);
      
#else
      throw std::runtime_error("OpenGL command 'glUniformMatrix2x4fvNV' not available on this platform");
#endif
    }

    void uniform_matrix_3x_2fv_nv(gl::int_t location, gl::sizei_t count, boolean_t transpose, const gl::float_t * value) {
#if GL_NV_non_square_matrices    
      
      glUniformMatrix3x2fvNV(location, count, static_cast<GLboolean>(transpose), value);
      
#else
      throw std::runtime_error("OpenGL command 'glUniformMatrix3x2fvNV' not available on this platform");
#endif
    }

    void uniform_matrix_3x_4fv_nv(gl::int_t location, gl::sizei_t count, boolean_t transpose, const gl::float_t * value) {
#if GL_NV_non_square_matrices    
      
      glUniformMatrix3x4fvNV(location, count, static_cast<GLboolean>(transpose), value);
      
#else
      throw std::runtime_error("OpenGL command 'glUniformMatrix3x4fvNV' not available on this platform");
#endif
    }

    void uniform_matrix_4x_2fv_nv(gl::int_t location, gl::sizei_t count, boolean_t transpose, const gl::float_t * value) {
#if GL_NV_non_square_matrices    
      
      glUniformMatrix4x2fvNV(location, count, static_cast<GLboolean>(transpose), value);
      
#else
      throw std::runtime_error("OpenGL command 'glUniformMatrix4x2fvNV' not available on this platform");
#endif
    }

    void uniform_matrix_4x_3fv_nv(gl::int_t location, gl::sizei_t count, boolean_t transpose, const gl::float_t * value) {
#if GL_NV_non_square_matrices    
      
      glUniformMatrix4x3fvNV(location, count, static_cast<GLboolean>(transpose), value);
      
#else
      throw std::runtime_error("OpenGL command 'glUniformMatrix4x3fvNV' not available on this platform");
#endif
    }

    boolean_t unmap_buffer_oes(buffer_target_arb_t target) {
#if GL_OES_mapbuffer    
      
      return static_cast<boolean_t>(glUnmapBufferOES(static_cast<GLenum>(target)));
      
#else
      throw std::runtime_error("OpenGL command 'glUnmapBufferOES' not available on this platform");
#endif
    }

    void use_program_stages_ext(gl::uint_t pipeline, gl::bitmask<use_program_stage_flags_t> stages, gl::uint_t program) {
#if GL_EXT_separate_shader_objects    
      
      glUseProgramStagesEXT(pipeline, static_cast<GLbitfield>(stages.value), program);
      
#else
      throw std::runtime_error("OpenGL command 'glUseProgramStagesEXT' not available on this platform");
#endif
    }

    void validate_program_pipeline_ext(gl::uint_t pipeline) {
#if GL_EXT_separate_shader_objects    
      
      glValidateProgramPipelineEXT(pipeline);
      
#else
      throw std::runtime_error("OpenGL command 'glValidateProgramPipelineEXT' not available on this platform");
#endif
    }

    void vertex_attrib_divisor_angle(gl::uint_t index, gl::uint_t divisor) {
#if GL_ANGLE_instanced_arrays    
      
      glVertexAttribDivisorANGLE(index, divisor);
      
#else
      throw std::runtime_error("OpenGL command 'glVertexAttribDivisorANGLE' not available on this platform");
#endif
    }

    void vertex_attrib_divisor_ext(gl::uint_t index, gl::uint_t divisor) {
#if GL_EXT_instanced_arrays    
      
      glVertexAttribDivisorEXT(index, divisor);
      
#else
      throw std::runtime_error("OpenGL command 'glVertexAttribDivisorEXT' not available on this platform");
#endif
    }

    void vertex_attrib_divisor_nv(gl::uint_t index, gl::uint_t divisor) {
#if GL_NV_instanced_arrays    
      
      glVertexAttribDivisorNV(index, divisor);
      
#else
      throw std::runtime_error("OpenGL command 'glVertexAttribDivisorNV' not available on this platform");
#endif
    }

    void viewport_arrayv_nv(gl::uint_t first, gl::sizei_t count, const gl::float_t * v) {
#if GL_NV_viewport_array    
      
      glViewportArrayvNV(first, count, v);
      
#else
      throw std::runtime_error("OpenGL command 'glViewportArrayvNV' not available on this platform");
#endif
    }

    void viewport_indexedf_nv(gl::uint_t index, gl::float_t x, gl::float_t y, gl::float_t w, gl::float_t h) {
#if GL_NV_viewport_array    
      
      glViewportIndexedfNV(index, x, y, w, h);
      
#else
      throw std::runtime_error("OpenGL command 'glViewportIndexedfNV' not available on this platform");
#endif
    }

    void viewport_indexedfv_nv(gl::uint_t index, const gl::float_t * v) {
#if GL_NV_viewport_array    
      
      glViewportIndexedfvNV(index, v);
      
#else
      throw std::runtime_error("OpenGL command 'glViewportIndexedfvNV' not available on this platform");
#endif
    }

    void wait_sync_apple(gl::sync_t sync, gl::bitfield_t flags, gl::uint64_t timeout) {
#if GL_APPLE_sync    
      
      glWaitSyncAPPLE(sync, flags, timeout);
      
#else
      throw std::runtime_error("OpenGL command 'glWaitSyncAPPLE' not available on this platform");
#endif
    }

    void weight_paths_nv(gl::uint_t resultPath, gl::sizei_t numPaths, const gl::uint_t * paths, const gl::float_t * weights) {
#if GL_NV_path_rendering    
      
      glWeightPathsNV(resultPath, numPaths, paths, weights);
      
#else
      throw std::runtime_error("OpenGL command 'glWeightPathsNV' not available on this platform");
#endif
    }

}
