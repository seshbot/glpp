/**
 * This file was autogenerated by glgen (https://github.com/seshbot/glgen) on 2015-03-08
 * Command line: src/gen.py assets/gl.xml -p assets/gl-patch.xml -o ../glpp/ --includesubdir include/glpp --sourcesubdir src --namespace gles2 --force --cpp --es2only --synth
 */

#include <glad/glad.h>
#include <string.h>
#include <glpp/gles2/commands.h>


namespace gles2 {
    void active_texture(texture_unit_t texture) {
      
      glActiveTexture(static_cast<GLenum>(texture));
      
    }

    void attach_shader(gl::uint_t program, gl::uint_t shader) {
      
      glAttachShader(program, shader);
      
    }

    void bind_attrib_location(gl::uint_t program, gl::uint_t index, const  gl::char_t * name) {
      
      glBindAttribLocation(program, index, name);
      
    }

    void bind_buffer(buffer_target_arb_t target, gl::uint_t buffer) {
      
      glBindBuffer(static_cast<GLenum>(target), buffer);
      
    }

    void bind_framebuffer(framebuffer_target_t target, gl::uint_t framebuffer) {
      
      glBindFramebuffer(static_cast<GLenum>(target), framebuffer);
      
    }

    void bind_renderbuffer(renderbuffer_target_t target, gl::uint_t renderbuffer) {
      
      glBindRenderbuffer(static_cast<GLenum>(target), renderbuffer);
      
    }

    void bind_texture(texture_target_t target, gl::uint_t texture) {
      
      glBindTexture(static_cast<GLenum>(target), texture);
      
    }

    void blend_color(gl::float_t red, gl::float_t green, gl::float_t blue, gl::float_t alpha) {
      
      glBlendColor(red, green, blue, alpha);
      
    }

    void blend_equation(blend_equation_mode_t mode) {
      
      glBlendEquation(static_cast<GLenum>(mode));
      
    }

    void blend_equation_separate(blend_equation_mode_ext_t modeRGB, blend_equation_mode_ext_t modeAlpha) {
      
      glBlendEquationSeparate(static_cast<GLenum>(modeRGB), static_cast<GLenum>(modeAlpha));
      
    }

    void blend_func(blending_factor_src_t sfactor, blending_factor_dest_t dfactor) {
      
      glBlendFunc(static_cast<GLenum>(sfactor), static_cast<GLenum>(dfactor));
      
    }

    void blend_func_separate(blend_func_separate_parameter_ext_t sfactorRGB, blend_func_separate_parameter_ext_t dfactorRGB, blend_func_separate_parameter_ext_t sfactorAlpha, blend_func_separate_parameter_ext_t dfactorAlpha) {
      
      glBlendFuncSeparate(static_cast<GLenum>(sfactorRGB), static_cast<GLenum>(dfactorRGB), static_cast<GLenum>(sfactorAlpha), static_cast<GLenum>(dfactorAlpha));
      
    }

    void buffer_data(buffer_target_arb_t target, gl::sizeiptr_t size, const  void * data, buffer_usage_arb_t usage) {
      
      glBufferData(static_cast<GLenum>(target), size, data, static_cast<GLenum>(usage));
      
    }

    void buffer_sub_data(buffer_target_arb_t target, gl::intptr_t offset, gl::sizeiptr_t size, const  void * data) {
      
      glBufferSubData(static_cast<GLenum>(target), offset, size, data);
      
    }

    framebuffer_status_t check_framebuffer_status(framebuffer_target_t target) {
      
      return static_cast<framebuffer_status_t>(glCheckFramebufferStatus(static_cast<GLenum>(target)));
      
    }

    void clear(gl::bitmask<clear_buffer_flags_t> mask) {
      
      glClear(static_cast<GLbitfield>(mask.value));
      
    }

    void clear_color(gl::float_t red, gl::float_t green, gl::float_t blue, gl::float_t alpha) {
      
      glClearColor(red, green, blue, alpha);
      
    }

    void clear_depthf(gl::float_t d) {
      
      glClearDepthf(d);
      
    }

    void clear_stencil(gl::int_t s) {
      
      glClearStencil(s);
      
    }

    void color_mask(boolean_t red, boolean_t green, boolean_t blue, boolean_t alpha) {
      
      glColorMask(static_cast<GLboolean>(red), static_cast<GLboolean>(green), static_cast<GLboolean>(blue), static_cast<GLboolean>(alpha));
      
    }

    void compile_shader(gl::uint_t shader) {
      
      glCompileShader(shader);
      
    }

    void compressed_tex_image_2d(texture_target_t target, gl::int_t level, gl::enum_t internalformat, gl::sizei_t width, gl::sizei_t height, gl::int_t border, gl::sizei_t imageSize, const  void * data) {
      
      glCompressedTexImage2D(static_cast<GLenum>(target), level, internalformat, width, height, border, imageSize, data);
      
    }

    void compressed_tex_sub_image_2d(texture_target_t target, gl::int_t level, gl::int_t xoffset, gl::int_t yoffset, gl::sizei_t width, gl::sizei_t height, pixel_format_t format, gl::sizei_t imageSize, const  void * data) {
      
      glCompressedTexSubImage2D(static_cast<GLenum>(target), level, xoffset, yoffset, width, height, static_cast<GLenum>(format), imageSize, data);
      
    }

    void copy_tex_image_2d(texture_target_t target, gl::int_t level, gl::enum_t internalformat, gl::int_t x, gl::int_t y, gl::sizei_t width, gl::sizei_t height, gl::int_t border) {
      
      glCopyTexImage2D(static_cast<GLenum>(target), level, internalformat, x, y, width, height, border);
      
    }

    void copy_tex_sub_image_2d(texture_target_t target, gl::int_t level, gl::int_t xoffset, gl::int_t yoffset, gl::int_t x, gl::int_t y, gl::sizei_t width, gl::sizei_t height) {
      
      glCopyTexSubImage2D(static_cast<GLenum>(target), level, xoffset, yoffset, x, y, width, height);
      
    }

    gl::uint_t create_program() {
      
      return glCreateProgram();
      
    }

    gl::uint_t create_shader(shader_type_t type) {
      
      return glCreateShader(static_cast<GLenum>(type));
      
    }

    void cull_face(cull_face_mode_t mode) {
      
      glCullFace(static_cast<GLenum>(mode));
      
    }

    void delete_buffers(gl::sizei_t n, const  gl::uint_t * buffers) {
      
      glDeleteBuffers(n, buffers);
      
    }

    void delete_framebuffers(gl::sizei_t n, const  gl::uint_t * framebuffers) {
      
      glDeleteFramebuffers(n, framebuffers);
      
    }

    void delete_program(gl::uint_t program) {
      
      glDeleteProgram(program);
      
    }

    void delete_renderbuffers(gl::sizei_t n, const  gl::uint_t * renderbuffers) {
      
      glDeleteRenderbuffers(n, renderbuffers);
      
    }

    void delete_shader(gl::uint_t shader) {
      
      glDeleteShader(shader);
      
    }

    void delete_textures(gl::sizei_t n, const  gl::uint_t * textures) {
      
      glDeleteTextures(n, textures);
      
    }

    void depth_func(depth_function_t func) {
      
      glDepthFunc(static_cast<GLenum>(func));
      
    }

    void depth_mask(boolean_t flag) {
      
      glDepthMask(static_cast<GLboolean>(flag));
      
    }

    void depth_rangef(gl::float_t n, gl::float_t f) {
      
      glDepthRangef(n, f);
      
    }

    void detach_shader(gl::uint_t program, gl::uint_t shader) {
      
      glDetachShader(program, shader);
      
    }

    void disable(enable_cap_t cap) {
      
      glDisable(static_cast<GLenum>(cap));
      
    }

    void disable_vertex_attrib_array(gl::uint_t index) {
      
      glDisableVertexAttribArray(index);
      
    }

    void draw_arrays(primitive_type_t mode, gl::int_t first, gl::sizei_t count) {
      
      glDrawArrays(static_cast<GLenum>(mode), first, count);
      
    }

    void draw_elements(primitive_type_t mode, gl::sizei_t count, draw_elements_type_t type, const  void * indices) {
      
      glDrawElements(static_cast<GLenum>(mode), count, static_cast<GLenum>(type), indices);
      
    }

    void enable(enable_cap_t cap) {
      
      glEnable(static_cast<GLenum>(cap));
      
    }

    void enable_vertex_attrib_array(gl::uint_t index) {
      
      glEnableVertexAttribArray(index);
      
    }

    void finish() {
      
      glFinish();
      
    }

    void flush() {
      
      glFlush();
      
    }

    void framebuffer_renderbuffer(framebuffer_target_t target, framebuffer_attachment_t attachment, renderbuffer_target_t renderbuffertarget, gl::uint_t renderbuffer) {
      
      glFramebufferRenderbuffer(static_cast<GLenum>(target), static_cast<GLenum>(attachment), static_cast<GLenum>(renderbuffertarget), renderbuffer);
      
    }

    void framebuffer_texture_2d(framebuffer_target_t target, framebuffer_attachment_t attachment, framebuffer_texture_target_t textarget, gl::uint_t texture, gl::int_t level) {
      
      glFramebufferTexture2D(static_cast<GLenum>(target), static_cast<GLenum>(attachment), static_cast<GLenum>(textarget), texture, level);
      
    }

    void front_face(front_face_direction_t mode) {
      
      glFrontFace(static_cast<GLenum>(mode));
      
    }

    void gen_buffers(gl::sizei_t n, gl::uint_t * buffers) {
      
      glGenBuffers(n, buffers);
      
    }

    void gen_framebuffers(gl::sizei_t n, gl::uint_t * framebuffers) {
      
      glGenFramebuffers(n, framebuffers);
      
    }

    void gen_renderbuffers(gl::sizei_t n, gl::uint_t * renderbuffers) {
      
      glGenRenderbuffers(n, renderbuffers);
      
    }

    void gen_textures(gl::sizei_t n, gl::uint_t * textures) {
      
      glGenTextures(n, textures);
      
    }

    void generate_mipmap(mipmap_target_t target) {
      
      glGenerateMipmap(static_cast<GLenum>(target));
      
    }

    void get_active_attrib(gl::uint_t program, gl::uint_t index, gl::sizei_t bufSize, gl::sizei_t * length, gl::int_t * size, attrib_type_t * type, gl::char_t * name) {
      GLenum type_; 
      glGetActiveAttrib(program, index, bufSize, length, size, &type_, name);
      *type = static_cast<attrib_type_t>(type_); 
    }

    void get_active_uniform(gl::uint_t program, gl::uint_t index, gl::sizei_t bufSize, gl::sizei_t * length, gl::int_t * size, uniform_type_t * type, gl::char_t * name) {
      GLenum type_; 
      glGetActiveUniform(program, index, bufSize, length, size, &type_, name);
      *type = static_cast<uniform_type_t>(type_); 
    }

    void get_attached_shaders(gl::uint_t program, gl::sizei_t maxCount, gl::sizei_t * count, gl::uint_t * shaders) {
      
      glGetAttachedShaders(program, maxCount, count, shaders);
      
    }

    gl::int_t get_attrib_location(gl::uint_t program, const  gl::char_t * name) {
      
      return glGetAttribLocation(program, name);
      
    }

    void get_booleanv(get_p_name_t pname, boolean_t * data) {
      GLboolean data_; 
      glGetBooleanv(static_cast<GLenum>(pname), &data_);
      *data = static_cast<boolean_t>(data_); 
    }

    void get_buffer_parameteriv(buffer_target_arb_t target, buffer_p_name_arb_t pname, gl::int_t * params) {
      
      glGetBufferParameteriv(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      
    }

    error_code_t get_error() {
      
      return static_cast<error_code_t>(glGetError());
      
    }

    void get_floatv(get_p_name_t pname, gl::float_t * data) {
      
      glGetFloatv(static_cast<GLenum>(pname), data);
      
    }

    void get_framebuffer_attachment_parameteriv(framebuffer_target_t target, framebuffer_attachment_t attachment, gl::enum_t pname, gl::int_t * params) {
      
      glGetFramebufferAttachmentParameteriv(static_cast<GLenum>(target), static_cast<GLenum>(attachment), pname, params);
      
    }

    void get_integerv(get_p_name_t pname, gl::int_t * data) {
      
      glGetIntegerv(static_cast<GLenum>(pname), data);
      
    }

    void get_program_info_log(gl::uint_t program, gl::sizei_t bufSize, gl::sizei_t * length, gl::char_t * infoLog) {
      
      glGetProgramInfoLog(program, bufSize, length, infoLog);
      
    }

    void get_programiv(gl::uint_t program, get_programiv_p_name_t pname, gl::int_t * params) {
      
      glGetProgramiv(program, static_cast<GLenum>(pname), params);
      
    }

    void get_renderbuffer_parameteriv(renderbuffer_target_t target, gl::enum_t pname, gl::int_t * params) {
      
      glGetRenderbufferParameteriv(static_cast<GLenum>(target), pname, params);
      
    }

    void get_shader_info_log(gl::uint_t shader, gl::sizei_t bufSize, gl::sizei_t * length, gl::char_t * infoLog) {
      
      glGetShaderInfoLog(shader, bufSize, length, infoLog);
      
    }

    void get_shader_precision_format(shader_type_t shadertype, precision_type_t precisiontype, gl::int_t * range, gl::int_t * precision) {
      
      glGetShaderPrecisionFormat(static_cast<GLenum>(shadertype), static_cast<GLenum>(precisiontype), range, precision);
      
    }

    void get_shader_source(gl::uint_t shader, gl::sizei_t bufSize, gl::sizei_t * length, gl::char_t * source) {
      
      glGetShaderSource(shader, bufSize, length, source);
      
    }

    void get_shaderiv(gl::uint_t shader, get_shaderiv_p_name_t pname, gl::int_t * params) {
      
      glGetShaderiv(shader, static_cast<GLenum>(pname), params);
      
    }

    const gl::ubyte_t * get_string(string_name_t name) {
      
      return glGetString(static_cast<GLenum>(name));
      
    }

    void get_tex_parameterfv(texture_target_t target, get_texture_parameter_t pname, gl::float_t * params) {
      
      glGetTexParameterfv(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      
    }

    void get_tex_parameteriv(texture_target_t target, get_texture_parameter_t pname, gl::int_t * params) {
      
      glGetTexParameteriv(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      
    }

    gl::int_t get_uniform_location(gl::uint_t program, const  gl::char_t * name) {
      
      return glGetUniformLocation(program, name);
      
    }

    void get_uniformfv(gl::uint_t program, gl::int_t location, gl::float_t * params) {
      
      glGetUniformfv(program, location, params);
      
    }

    void get_uniformiv(gl::uint_t program, gl::int_t location, gl::int_t * params) {
      
      glGetUniformiv(program, location, params);
      
    }

    void get_vertex_attrib_pointerv(gl::uint_t index, vertex_attrib_pointer_property_arb_t pname, void ** pointer) {
      
      glGetVertexAttribPointerv(index, static_cast<GLenum>(pname), pointer);
      
    }

    void get_vertex_attribfv(gl::uint_t index, vertex_attrib_property_arb_t pname, gl::float_t * params) {
      
      glGetVertexAttribfv(index, static_cast<GLenum>(pname), params);
      
    }

    void get_vertex_attribiv(gl::uint_t index, vertex_attrib_property_arb_t pname, gl::int_t * params) {
      
      glGetVertexAttribiv(index, static_cast<GLenum>(pname), params);
      
    }

    void hint(hint_target_t target, hint_mode_t mode) {
      
      glHint(static_cast<GLenum>(target), static_cast<GLenum>(mode));
      
    }

    boolean_t is_buffer(gl::uint_t buffer) {
      
      return static_cast<boolean_t>(glIsBuffer(buffer));
      
    }

    boolean_t is_enabled(enable_cap_t cap) {
      
      return static_cast<boolean_t>(glIsEnabled(static_cast<GLenum>(cap)));
      
    }

    boolean_t is_framebuffer(gl::uint_t framebuffer) {
      
      return static_cast<boolean_t>(glIsFramebuffer(framebuffer));
      
    }

    boolean_t is_program(gl::uint_t program) {
      
      return static_cast<boolean_t>(glIsProgram(program));
      
    }

    boolean_t is_renderbuffer(gl::uint_t renderbuffer) {
      
      return static_cast<boolean_t>(glIsRenderbuffer(renderbuffer));
      
    }

    boolean_t is_shader(gl::uint_t shader) {
      
      return static_cast<boolean_t>(glIsShader(shader));
      
    }

    boolean_t is_texture(gl::uint_t texture) {
      
      return static_cast<boolean_t>(glIsTexture(texture));
      
    }

    void line_width(gl::float_t width) {
      
      glLineWidth(width);
      
    }

    void link_program(gl::uint_t program) {
      
      glLinkProgram(program);
      
    }

    void pixel_storei(pixel_store_parameter_t pname, gl::int_t param) {
      
      glPixelStorei(static_cast<GLenum>(pname), param);
      
    }

    void polygon_offset(gl::float_t factor, gl::float_t units) {
      
      glPolygonOffset(factor, units);
      
    }

    void read_pixels(gl::int_t x, gl::int_t y, gl::sizei_t width, gl::sizei_t height, pixel_format_t format, pixel_type_t type, void * pixels) {
      
      glReadPixels(x, y, width, height, static_cast<GLenum>(format), static_cast<GLenum>(type), pixels);
      
    }

    void release_shader_compiler() {
      
      glReleaseShaderCompiler();
      
    }

    void renderbuffer_storage(renderbuffer_target_t target, internal_format_t internalformat, gl::sizei_t width, gl::sizei_t height) {
      
      glRenderbufferStorage(static_cast<GLenum>(target), static_cast<GLenum>(internalformat), width, height);
      
    }

    void sample_coverage(gl::float_t value, boolean_t invert) {
      
      glSampleCoverage(value, static_cast<GLboolean>(invert));
      
    }

    void scissor(gl::int_t x, gl::int_t y, gl::sizei_t width, gl::sizei_t height) {
      
      glScissor(x, y, width, height);
      
    }

    void shader_binary(gl::sizei_t count, const  gl::uint_t * shaders, gl::enum_t binaryformat, const  void * binary, gl::sizei_t length) {
      
      glShaderBinary(count, shaders, binaryformat, binary, length);
      
    }

    void shader_source(gl::uint_t shader, gl::sizei_t count, const  gl::char_t ** string, const  gl::int_t * length) {
      
      glShaderSource(shader, count, string, length);
      
    }

    void stencil_func(stencil_function_t func, gl::int_t ref, gl::uint_t mask) {
      
      glStencilFunc(static_cast<GLenum>(func), ref, mask);
      
    }

    void stencil_func_separate(stencil_face_direction_t face, stencil_function_t func, gl::int_t ref, gl::uint_t mask) {
      
      glStencilFuncSeparate(static_cast<GLenum>(face), static_cast<GLenum>(func), ref, mask);
      
    }

    void stencil_mask(gl::uint_t mask) {
      
      glStencilMask(mask);
      
    }

    void stencil_mask_separate(stencil_face_direction_t face, gl::uint_t mask) {
      
      glStencilMaskSeparate(static_cast<GLenum>(face), mask);
      
    }

    void stencil_op(stencil_op_t fail, stencil_op_t zfail, stencil_op_t zpass) {
      
      glStencilOp(static_cast<GLenum>(fail), static_cast<GLenum>(zfail), static_cast<GLenum>(zpass));
      
    }

    void stencil_op_separate(stencil_face_direction_t face, stencil_op_t sfail, stencil_op_t dpfail, stencil_op_t dppass) {
      
      glStencilOpSeparate(static_cast<GLenum>(face), static_cast<GLenum>(sfail), static_cast<GLenum>(dpfail), static_cast<GLenum>(dppass));
      
    }

    void tex_image_2d(texture_target_t target, gl::int_t level, texture_component_count_t internalformat, gl::sizei_t width, gl::sizei_t height, gl::int_t border, pixel_format_t format, pixel_type_t type, const  void * pixels) {
      
      glTexImage2D(static_cast<GLenum>(target), level, static_cast<GLint>(internalformat), width, height, border, static_cast<GLenum>(format), static_cast<GLenum>(type), pixels);
      
    }

    void tex_parameterf(texture_target_t target, texture_parameter_name_t pname, gl::float_t param) {
      
      glTexParameterf(static_cast<GLenum>(target), static_cast<GLenum>(pname), param);
      
    }

    void tex_parameterfv(texture_target_t target, texture_parameter_name_t pname, const  gl::float_t * params) {
      
      glTexParameterfv(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      
    }

    void tex_parameteri(texture_target_t target, texture_parameter_name_t pname, gl::int_t param) {
      
      glTexParameteri(static_cast<GLenum>(target), static_cast<GLenum>(pname), param);
      
    }

    void tex_parameteriv(texture_target_t target, texture_parameter_name_t pname, const  gl::int_t * params) {
      
      glTexParameteriv(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      
    }

    void tex_sub_image_2d(texture_target_t target, gl::int_t level, gl::int_t xoffset, gl::int_t yoffset, gl::sizei_t width, gl::sizei_t height, pixel_format_t format, pixel_type_t type, const  void * pixels) {
      
      glTexSubImage2D(static_cast<GLenum>(target), level, xoffset, yoffset, width, height, static_cast<GLenum>(format), static_cast<GLenum>(type), pixels);
      
    }

    void uniform_1f(gl::int_t location, gl::float_t v0) {
      
      glUniform1f(location, v0);
      
    }

    void uniform_1fv(gl::int_t location, gl::sizei_t count, const  gl::float_t * value) {
      
      glUniform1fv(location, count, value);
      
    }

    void uniform_1i(gl::int_t location, gl::int_t v0) {
      
      glUniform1i(location, v0);
      
    }

    void uniform_1iv(gl::int_t location, gl::sizei_t count, const  gl::int_t * value) {
      
      glUniform1iv(location, count, value);
      
    }

    void uniform_2f(gl::int_t location, gl::float_t v0, gl::float_t v1) {
      
      glUniform2f(location, v0, v1);
      
    }

    void uniform_2fv(gl::int_t location, gl::sizei_t count, const  gl::float_t * value) {
      
      glUniform2fv(location, count, value);
      
    }

    void uniform_2i(gl::int_t location, gl::int_t v0, gl::int_t v1) {
      
      glUniform2i(location, v0, v1);
      
    }

    void uniform_2iv(gl::int_t location, gl::sizei_t count, const  gl::int_t * value) {
      
      glUniform2iv(location, count, value);
      
    }

    void uniform_3f(gl::int_t location, gl::float_t v0, gl::float_t v1, gl::float_t v2) {
      
      glUniform3f(location, v0, v1, v2);
      
    }

    void uniform_3fv(gl::int_t location, gl::sizei_t count, const  gl::float_t * value) {
      
      glUniform3fv(location, count, value);
      
    }

    void uniform_3i(gl::int_t location, gl::int_t v0, gl::int_t v1, gl::int_t v2) {
      
      glUniform3i(location, v0, v1, v2);
      
    }

    void uniform_3iv(gl::int_t location, gl::sizei_t count, const  gl::int_t * value) {
      
      glUniform3iv(location, count, value);
      
    }

    void uniform_4f(gl::int_t location, gl::float_t v0, gl::float_t v1, gl::float_t v2, gl::float_t v3) {
      
      glUniform4f(location, v0, v1, v2, v3);
      
    }

    void uniform_4fv(gl::int_t location, gl::sizei_t count, const  gl::float_t * value) {
      
      glUniform4fv(location, count, value);
      
    }

    void uniform_4i(gl::int_t location, gl::int_t v0, gl::int_t v1, gl::int_t v2, gl::int_t v3) {
      
      glUniform4i(location, v0, v1, v2, v3);
      
    }

    void uniform_4iv(gl::int_t location, gl::sizei_t count, const  gl::int_t * value) {
      
      glUniform4iv(location, count, value);
      
    }

    void uniform_matrix_2fv(gl::int_t location, gl::sizei_t count, boolean_t transpose, const  gl::float_t * value) {
      
      glUniformMatrix2fv(location, count, static_cast<GLboolean>(transpose), value);
      
    }

    void uniform_matrix_3fv(gl::int_t location, gl::sizei_t count, boolean_t transpose, const  gl::float_t * value) {
      
      glUniformMatrix3fv(location, count, static_cast<GLboolean>(transpose), value);
      
    }

    void uniform_matrix_4fv(gl::int_t location, gl::sizei_t count, boolean_t transpose, const  gl::float_t * value) {
      
      glUniformMatrix4fv(location, count, static_cast<GLboolean>(transpose), value);
      
    }

    void use_program(gl::uint_t program) {
      
      glUseProgram(program);
      
    }

    void validate_program(gl::uint_t program) {
      
      glValidateProgram(program);
      
    }

    void vertex_attrib_1f(gl::uint_t index, gl::float_t x) {
      
      glVertexAttrib1f(index, x);
      
    }

    void vertex_attrib_1fv(gl::uint_t index, const  gl::float_t * v) {
      
      glVertexAttrib1fv(index, v);
      
    }

    void vertex_attrib_2f(gl::uint_t index, gl::float_t x, gl::float_t y) {
      
      glVertexAttrib2f(index, x, y);
      
    }

    void vertex_attrib_2fv(gl::uint_t index, const  gl::float_t * v) {
      
      glVertexAttrib2fv(index, v);
      
    }

    void vertex_attrib_3f(gl::uint_t index, gl::float_t x, gl::float_t y, gl::float_t z) {
      
      glVertexAttrib3f(index, x, y, z);
      
    }

    void vertex_attrib_3fv(gl::uint_t index, const  gl::float_t * v) {
      
      glVertexAttrib3fv(index, v);
      
    }

    void vertex_attrib_4f(gl::uint_t index, gl::float_t x, gl::float_t y, gl::float_t z, gl::float_t w) {
      
      glVertexAttrib4f(index, x, y, z, w);
      
    }

    void vertex_attrib_4fv(gl::uint_t index, const  gl::float_t * v) {
      
      glVertexAttrib4fv(index, v);
      
    }

    void vertex_attrib_pointer(gl::uint_t index, gl::int_t size, vertex_attrib_pointer_type_t type, boolean_t normalized, gl::sizei_t stride, const  void * pointer) {
      
      glVertexAttribPointer(index, size, static_cast<GLenum>(type), static_cast<GLboolean>(normalized), stride, pointer);
      
    }

    void viewport(gl::int_t x, gl::int_t y, gl::sizei_t width, gl::sizei_t height) {
      
      glViewport(x, y, width, height);
      
    }

}
