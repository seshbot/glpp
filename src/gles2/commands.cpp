/**
 * This file was autogenerated by glgen (https://github.com/seshbot/glgen) on 2015-02-19
 * Command line: src/gen.py assets/gl.xml -p assets/gl-patch.xml -o build/lib/ --force --cpp --es2only
 */

#include <GLES2/gl2.h>
#include <glpp/gles2/commands.h>


namespace gl {
    void active_texture(texture_unit_t texture) {
      
      glActiveTexture(static_cast<GLenum>(texture));
      
    }

    void attach_shader(uint_t program, uint_t shader) {
      
      glAttachShader(program, shader);
      
    }

    void bind_attrib_location(uint_t program, uint_t index, const char_t * name) {
      
      glBindAttribLocation(program, index, name);
      
    }

    void bind_buffer(buffer_target_arb_t target, uint_t buffer) {
      
      glBindBuffer(static_cast<GLenum>(target), buffer);
      
    }

    void bind_framebuffer(framebuffer_target_t target, uint_t framebuffer) {
      
      glBindFramebuffer(static_cast<GLenum>(target), framebuffer);
      
    }

    void bind_renderbuffer(renderbuffer_target_t target, uint_t renderbuffer) {
      
      glBindRenderbuffer(static_cast<GLenum>(target), renderbuffer);
      
    }

    void bind_texture(texture_target_t target, uint_t texture) {
      
      glBindTexture(static_cast<GLenum>(target), texture);
      
    }

    void blend_color(float_t red, float_t green, float_t blue, float_t alpha) {
      
      glBlendColor(red, green, blue, alpha);
      
    }

    void blend_equation(blend_equation_mode_t mode) {
      
      glBlendEquation(static_cast<GLenum>(mode));
      
    }

    void blend_equation_separate(blend_equation_mode_ext_t modeRGB, blend_equation_mode_ext_t modeAlpha) {
      
      glBlendEquationSeparate(static_cast<GLenum>(modeRGB), static_cast<GLenum>(modeAlpha));
      
    }

    void blend_func(blending_factor_src_t sfactor, blending_factor_dest_t dfactor) {
      
      glBlendFunc(static_cast<GLenum>(sfactor), static_cast<GLenum>(dfactor));
      
    }

    void blend_func_separate(blend_func_separate_parameter_ext_t sfactorRGB, blend_func_separate_parameter_ext_t dfactorRGB, blend_func_separate_parameter_ext_t sfactorAlpha, blend_func_separate_parameter_ext_t dfactorAlpha) {
      
      glBlendFuncSeparate(static_cast<GLenum>(sfactorRGB), static_cast<GLenum>(dfactorRGB), static_cast<GLenum>(sfactorAlpha), static_cast<GLenum>(dfactorAlpha));
      
    }

    void buffer_data(buffer_target_arb_t target, sizeiptr_t size, const void * data, buffer_usage_arb_t usage) {
      
      glBufferData(static_cast<GLenum>(target), size, data, static_cast<GLenum>(usage));
      
    }

    void buffer_sub_data(buffer_target_arb_t target, intptr_t offset, sizeiptr_t size, const void * data) {
      
      glBufferSubData(static_cast<GLenum>(target), offset, size, data);
      
    }

    framebuffer_status_t check_framebuffer_status(framebuffer_target_t target) {
      
      return static_cast<framebuffer_status_t>(glCheckFramebufferStatus(static_cast<GLenum>(target)));
      
    }

    void clear(bitmask<clear_buffer_flags_t> mask) {
      
      glClear(static_cast<GLbitfield>(mask.value));
      
    }

    void clear_color(float_t red, float_t green, float_t blue, float_t alpha) {
      
      glClearColor(red, green, blue, alpha);
      
    }

    void clear_depthf(float_t d) {
      
      glClearDepthf(d);
      
    }

    void clear_stencil(int_t s) {
      
      glClearStencil(s);
      
    }

    void color_mask(boolean_t red, boolean_t green, boolean_t blue, boolean_t alpha) {
      
      glColorMask(static_cast<GLboolean>(red), static_cast<GLboolean>(green), static_cast<GLboolean>(blue), static_cast<GLboolean>(alpha));
      
    }

    void compile_shader(uint_t shader) {
      
      glCompileShader(shader);
      
    }

    void compressed_tex_image_2d(texture_target_t target, int_t level, enum_t internalformat, sizei_t width, sizei_t height, int_t border, sizei_t imageSize, const void * data) {
      
      glCompressedTexImage2D(static_cast<GLenum>(target), level, internalformat, width, height, border, imageSize, data);
      
    }

    void compressed_tex_sub_image_2d(texture_target_t target, int_t level, int_t xoffset, int_t yoffset, sizei_t width, sizei_t height, pixel_format_t format, sizei_t imageSize, const void * data) {
      
      glCompressedTexSubImage2D(static_cast<GLenum>(target), level, xoffset, yoffset, width, height, static_cast<GLenum>(format), imageSize, data);
      
    }

    void copy_tex_image_2d(texture_target_t target, int_t level, enum_t internalformat, int_t x, int_t y, sizei_t width, sizei_t height, int_t border) {
      
      glCopyTexImage2D(static_cast<GLenum>(target), level, internalformat, x, y, width, height, border);
      
    }

    void copy_tex_sub_image_2d(texture_target_t target, int_t level, int_t xoffset, int_t yoffset, int_t x, int_t y, sizei_t width, sizei_t height) {
      
      glCopyTexSubImage2D(static_cast<GLenum>(target), level, xoffset, yoffset, x, y, width, height);
      
    }

    uint_t create_program() {
      
      return glCreateProgram();
      
    }

    uint_t create_shader(shader_type_t type) {
      
      return glCreateShader(static_cast<GLenum>(type));
      
    }

    void cull_face(cull_face_mode_t mode) {
      
      glCullFace(static_cast<GLenum>(mode));
      
    }

    void delete_buffers(sizei_t n, const uint_t * buffers) {
      
      glDeleteBuffers(n, buffers);
      
    }

    void delete_framebuffers(sizei_t n, const uint_t * framebuffers) {
      
      glDeleteFramebuffers(n, framebuffers);
      
    }

    void delete_program(uint_t program) {
      
      glDeleteProgram(program);
      
    }

    void delete_renderbuffers(sizei_t n, const uint_t * renderbuffers) {
      
      glDeleteRenderbuffers(n, renderbuffers);
      
    }

    void delete_shader(uint_t shader) {
      
      glDeleteShader(shader);
      
    }

    void delete_textures(sizei_t n, const uint_t * textures) {
      
      glDeleteTextures(n, textures);
      
    }

    void depth_func(depth_function_t func) {
      
      glDepthFunc(static_cast<GLenum>(func));
      
    }

    void depth_mask(boolean_t flag) {
      
      glDepthMask(static_cast<GLboolean>(flag));
      
    }

    void depth_rangef(float_t n, float_t f) {
      
      glDepthRangef(n, f);
      
    }

    void detach_shader(uint_t program, uint_t shader) {
      
      glDetachShader(program, shader);
      
    }

    void disable(enable_cap_t cap) {
      
      glDisable(static_cast<GLenum>(cap));
      
    }

    void disable_vertex_attrib_array(uint_t index) {
      
      glDisableVertexAttribArray(index);
      
    }

    void draw_arrays(primitive_type_t mode, int_t first, sizei_t count) {
      
      glDrawArrays(static_cast<GLenum>(mode), first, count);
      
    }

    void draw_elements(primitive_type_t mode, sizei_t count, draw_elements_type_t type, const void * indices) {
      
      glDrawElements(static_cast<GLenum>(mode), count, static_cast<GLenum>(type), indices);
      
    }

    void enable(enable_cap_t cap) {
      
      glEnable(static_cast<GLenum>(cap));
      
    }

    void enable_vertex_attrib_array(uint_t index) {
      
      glEnableVertexAttribArray(index);
      
    }

    void finish() {
      
      glFinish();
      
    }

    void flush() {
      
      glFlush();
      
    }

    void framebuffer_renderbuffer(framebuffer_target_t target, framebuffer_attachment_t attachment, renderbuffer_target_t renderbuffertarget, uint_t renderbuffer) {
      
      glFramebufferRenderbuffer(static_cast<GLenum>(target), static_cast<GLenum>(attachment), static_cast<GLenum>(renderbuffertarget), renderbuffer);
      
    }

    void framebuffer_texture_2d(framebuffer_target_t target, framebuffer_attachment_t attachment, enum_t textarget, uint_t texture, int_t level) {
      
      glFramebufferTexture2D(static_cast<GLenum>(target), static_cast<GLenum>(attachment), textarget, texture, level);
      
    }

    void front_face(front_face_direction_t mode) {
      
      glFrontFace(static_cast<GLenum>(mode));
      
    }

    void gen_buffers(sizei_t n, uint_t * buffers) {
      
      glGenBuffers(n, buffers);
      
    }

    void gen_framebuffers(sizei_t n, uint_t * framebuffers) {
      
      glGenFramebuffers(n, framebuffers);
      
    }

    void gen_renderbuffers(sizei_t n, uint_t * renderbuffers) {
      
      glGenRenderbuffers(n, renderbuffers);
      
    }

    void gen_textures(sizei_t n, uint_t * textures) {
      
      glGenTextures(n, textures);
      
    }

    void generate_mipmap(mipmap_target_t target) {
      
      glGenerateMipmap(static_cast<GLenum>(target));
      
    }

    void get_active_attrib(uint_t program, uint_t index, sizei_t bufSize, sizei_t * length, int_t * size, enum_t * type, char_t * name) {
      
      glGetActiveAttrib(program, index, bufSize, length, size, type, name);
      
    }

    void get_active_uniform(uint_t program, uint_t index, sizei_t bufSize, sizei_t * length, int_t * size, enum_t * type, char_t * name) {
      
      glGetActiveUniform(program, index, bufSize, length, size, type, name);
      
    }

    void get_attached_shaders(uint_t program, sizei_t maxCount, sizei_t * count, uint_t * shaders) {
      
      glGetAttachedShaders(program, maxCount, count, shaders);
      
    }

    int_t get_attrib_location(uint_t program, const char_t * name) {
      
      return glGetAttribLocation(program, name);
      
    }

    void get_booleanv(get_p_name_t pname, boolean_t * data) {
      GLboolean data_; 
      glGetBooleanv(static_cast<GLenum>(pname), &data_);
      *data = static_cast<boolean_t>(data_); 
    }

    void get_buffer_parameteriv(buffer_target_arb_t target, buffer_p_name_arb_t pname, int_t * params) {
      
      glGetBufferParameteriv(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      
    }

    error_code_t get_error() {
      
      return static_cast<error_code_t>(glGetError());
      
    }

    void get_floatv(get_p_name_t pname, float_t * data) {
      
      glGetFloatv(static_cast<GLenum>(pname), data);
      
    }

    void get_framebuffer_attachment_parameteriv(framebuffer_target_t target, framebuffer_attachment_t attachment, get_pointerv_p_name_t pname, int_t * params) {
      
      glGetFramebufferAttachmentParameteriv(static_cast<GLenum>(target), static_cast<GLenum>(attachment), static_cast<GLenum>(pname), params);
      
    }

    void get_integerv(get_p_name_t pname, int_t * data) {
      
      glGetIntegerv(static_cast<GLenum>(pname), data);
      
    }

    void get_program_info_log(uint_t program, sizei_t bufSize, sizei_t * length, char_t * infoLog) {
      
      glGetProgramInfoLog(program, bufSize, length, infoLog);
      
    }

    void get_programiv(uint_t program, get_pointerv_p_name_t pname, int_t * params) {
      
      glGetProgramiv(program, static_cast<GLenum>(pname), params);
      
    }

    void get_renderbuffer_parameteriv(renderbuffer_target_t target, get_pointerv_p_name_t pname, int_t * params) {
      
      glGetRenderbufferParameteriv(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      
    }

    void get_shader_info_log(uint_t shader, sizei_t bufSize, sizei_t * length, char_t * infoLog) {
      
      glGetShaderInfoLog(shader, bufSize, length, infoLog);
      
    }

    void get_shader_precision_format(shader_type_t shadertype, precision_type_t precisiontype, int_t * range, int_t * precision) {
      
      glGetShaderPrecisionFormat(static_cast<GLenum>(shadertype), static_cast<GLenum>(precisiontype), range, precision);
      
    }

    void get_shader_source(uint_t shader, sizei_t bufSize, sizei_t * length, char_t * source) {
      
      glGetShaderSource(shader, bufSize, length, source);
      
    }

    void get_shaderiv(uint_t shader, get_pointerv_p_name_t pname, int_t * params) {
      
      glGetShaderiv(shader, static_cast<GLenum>(pname), params);
      
    }

    const ubyte_t * get_string(string_name_t name) {
      
      return glGetString(static_cast<GLenum>(name));
      
    }

    void get_tex_parameterfv(texture_target_t target, get_texture_parameter_t pname, float_t * params) {
      
      glGetTexParameterfv(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      
    }

    void get_tex_parameteriv(texture_target_t target, get_texture_parameter_t pname, int_t * params) {
      
      glGetTexParameteriv(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      
    }

    int_t get_uniform_location(uint_t program, const char_t * name) {
      
      return glGetUniformLocation(program, name);
      
    }

    void get_uniformfv(uint_t program, int_t location, float_t * params) {
      
      glGetUniformfv(program, location, params);
      
    }

    void get_uniformiv(uint_t program, int_t location, int_t * params) {
      
      glGetUniformiv(program, location, params);
      
    }

    void get_vertex_attrib_pointerv(uint_t index, vertex_attrib_pointer_property_arb_t pname, void ** pointer) {
      
      glGetVertexAttribPointerv(index, static_cast<GLenum>(pname), pointer);
      
    }

    void get_vertex_attribfv(uint_t index, vertex_attrib_property_arb_t pname, float_t * params) {
      
      glGetVertexAttribfv(index, static_cast<GLenum>(pname), params);
      
    }

    void get_vertex_attribiv(uint_t index, vertex_attrib_property_arb_t pname, int_t * params) {
      
      glGetVertexAttribiv(index, static_cast<GLenum>(pname), params);
      
    }

    void hint(hint_target_t target, hint_mode_t mode) {
      
      glHint(static_cast<GLenum>(target), static_cast<GLenum>(mode));
      
    }

    boolean_t is_buffer(uint_t buffer) {
      
      return static_cast<boolean_t>(glIsBuffer(buffer));
      
    }

    boolean_t is_enabled(enable_cap_t cap) {
      
      return static_cast<boolean_t>(glIsEnabled(static_cast<GLenum>(cap)));
      
    }

    boolean_t is_framebuffer(uint_t framebuffer) {
      
      return static_cast<boolean_t>(glIsFramebuffer(framebuffer));
      
    }

    boolean_t is_program(uint_t program) {
      
      return static_cast<boolean_t>(glIsProgram(program));
      
    }

    boolean_t is_renderbuffer(uint_t renderbuffer) {
      
      return static_cast<boolean_t>(glIsRenderbuffer(renderbuffer));
      
    }

    boolean_t is_shader(uint_t shader) {
      
      return static_cast<boolean_t>(glIsShader(shader));
      
    }

    boolean_t is_texture(uint_t texture) {
      
      return static_cast<boolean_t>(glIsTexture(texture));
      
    }

    void line_width(float_t width) {
      
      glLineWidth(width);
      
    }

    void link_program(uint_t program) {
      
      glLinkProgram(program);
      
    }

    void pixel_storei(pixel_store_parameter_t pname, int_t param) {
      
      glPixelStorei(static_cast<GLenum>(pname), param);
      
    }

    void polygon_offset(float_t factor, float_t units) {
      
      glPolygonOffset(factor, units);
      
    }

    void read_pixels(int_t x, int_t y, sizei_t width, sizei_t height, pixel_format_t format, pixel_type_t type, void * pixels) {
      
      glReadPixels(x, y, width, height, static_cast<GLenum>(format), static_cast<GLenum>(type), pixels);
      
    }

    void release_shader_compiler() {
      
      glReleaseShaderCompiler();
      
    }

    void renderbuffer_storage(renderbuffer_target_t target, internal_format_t internalformat, sizei_t width, sizei_t height) {
      
      glRenderbufferStorage(static_cast<GLenum>(target), static_cast<GLenum>(internalformat), width, height);
      
    }

    void sample_coverage(float_t value, boolean_t invert) {
      
      glSampleCoverage(value, static_cast<GLboolean>(invert));
      
    }

    void scissor(int_t x, int_t y, sizei_t width, sizei_t height) {
      
      glScissor(x, y, width, height);
      
    }

    void shader_binary(sizei_t count, const uint_t * shaders, enum_t binaryformat, const void * binary, sizei_t length) {
      
      glShaderBinary(count, shaders, binaryformat, binary, length);
      
    }

    void shader_source(uint_t shader, sizei_t count, const char_t *const* string, const int_t * length) {
      
      glShaderSource(shader, count, string, length);
      
    }

    void stencil_func(stencil_function_t func, int_t ref, uint_t mask) {
      
      glStencilFunc(static_cast<GLenum>(func), ref, mask);
      
    }

    void stencil_func_separate(stencil_face_direction_t face, stencil_function_t func, int_t ref, uint_t mask) {
      
      glStencilFuncSeparate(static_cast<GLenum>(face), static_cast<GLenum>(func), ref, mask);
      
    }

    void stencil_mask(uint_t mask) {
      
      glStencilMask(mask);
      
    }

    void stencil_mask_separate(stencil_face_direction_t face, uint_t mask) {
      
      glStencilMaskSeparate(static_cast<GLenum>(face), mask);
      
    }

    void stencil_op(stencil_op_t fail, stencil_op_t zfail, stencil_op_t zpass) {
      
      glStencilOp(static_cast<GLenum>(fail), static_cast<GLenum>(zfail), static_cast<GLenum>(zpass));
      
    }

    void stencil_op_separate(stencil_face_direction_t face, stencil_op_t sfail, stencil_op_t dpfail, stencil_op_t dppass) {
      
      glStencilOpSeparate(static_cast<GLenum>(face), static_cast<GLenum>(sfail), static_cast<GLenum>(dpfail), static_cast<GLenum>(dppass));
      
    }

    void tex_image_2d(texture_target_t target, int_t level, texture_component_count_t internalformat, sizei_t width, sizei_t height, int_t border, pixel_format_t format, pixel_type_t type, const void * pixels) {
      
      glTexImage2D(static_cast<GLenum>(target), level, static_cast<GLint>(internalformat), width, height, border, static_cast<GLenum>(format), static_cast<GLenum>(type), pixels);
      
    }

    void tex_parameterf(texture_target_t target, texture_parameter_name_t pname, float_t param) {
      
      glTexParameterf(static_cast<GLenum>(target), static_cast<GLenum>(pname), param);
      
    }

    void tex_parameterfv(texture_target_t target, texture_parameter_name_t pname, const float_t * params) {
      
      glTexParameterfv(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      
    }

    void tex_parameteri(texture_target_t target, texture_parameter_name_t pname, int_t param) {
      
      glTexParameteri(static_cast<GLenum>(target), static_cast<GLenum>(pname), param);
      
    }

    void tex_parameteriv(texture_target_t target, texture_parameter_name_t pname, const int_t * params) {
      
      glTexParameteriv(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      
    }

    void tex_sub_image_2d(texture_target_t target, int_t level, int_t xoffset, int_t yoffset, sizei_t width, sizei_t height, pixel_format_t format, pixel_type_t type, const void * pixels) {
      
      glTexSubImage2D(static_cast<GLenum>(target), level, xoffset, yoffset, width, height, static_cast<GLenum>(format), static_cast<GLenum>(type), pixels);
      
    }

    void uniform_1f(int_t location, float_t v0) {
      
      glUniform1f(location, v0);
      
    }

    void uniform_1fv(int_t location, sizei_t count, const float_t * value) {
      
      glUniform1fv(location, count, value);
      
    }

    void uniform_1i(int_t location, int_t v0) {
      
      glUniform1i(location, v0);
      
    }

    void uniform_1iv(int_t location, sizei_t count, const int_t * value) {
      
      glUniform1iv(location, count, value);
      
    }

    void uniform_2f(int_t location, float_t v0, float_t v1) {
      
      glUniform2f(location, v0, v1);
      
    }

    void uniform_2fv(int_t location, sizei_t count, const float_t * value) {
      
      glUniform2fv(location, count, value);
      
    }

    void uniform_2i(int_t location, int_t v0, int_t v1) {
      
      glUniform2i(location, v0, v1);
      
    }

    void uniform_2iv(int_t location, sizei_t count, const int_t * value) {
      
      glUniform2iv(location, count, value);
      
    }

    void uniform_3f(int_t location, float_t v0, float_t v1, float_t v2) {
      
      glUniform3f(location, v0, v1, v2);
      
    }

    void uniform_3fv(int_t location, sizei_t count, const float_t * value) {
      
      glUniform3fv(location, count, value);
      
    }

    void uniform_3i(int_t location, int_t v0, int_t v1, int_t v2) {
      
      glUniform3i(location, v0, v1, v2);
      
    }

    void uniform_3iv(int_t location, sizei_t count, const int_t * value) {
      
      glUniform3iv(location, count, value);
      
    }

    void uniform_4f(int_t location, float_t v0, float_t v1, float_t v2, float_t v3) {
      
      glUniform4f(location, v0, v1, v2, v3);
      
    }

    void uniform_4fv(int_t location, sizei_t count, const float_t * value) {
      
      glUniform4fv(location, count, value);
      
    }

    void uniform_4i(int_t location, int_t v0, int_t v1, int_t v2, int_t v3) {
      
      glUniform4i(location, v0, v1, v2, v3);
      
    }

    void uniform_4iv(int_t location, sizei_t count, const int_t * value) {
      
      glUniform4iv(location, count, value);
      
    }

    void uniform_matrix_2fv(int_t location, sizei_t count, boolean_t transpose, const float_t * value) {
      
      glUniformMatrix2fv(location, count, static_cast<GLboolean>(transpose), value);
      
    }

    void uniform_matrix_3fv(int_t location, sizei_t count, boolean_t transpose, const float_t * value) {
      
      glUniformMatrix3fv(location, count, static_cast<GLboolean>(transpose), value);
      
    }

    void uniform_matrix_4fv(int_t location, sizei_t count, boolean_t transpose, const float_t * value) {
      
      glUniformMatrix4fv(location, count, static_cast<GLboolean>(transpose), value);
      
    }

    void use_program(uint_t program) {
      
      glUseProgram(program);
      
    }

    void validate_program(uint_t program) {
      
      glValidateProgram(program);
      
    }

    void vertex_attrib_1f(uint_t index, float_t x) {
      
      glVertexAttrib1f(index, x);
      
    }

    void vertex_attrib_1fv(uint_t index, const float_t * v) {
      
      glVertexAttrib1fv(index, v);
      
    }

    void vertex_attrib_2f(uint_t index, float_t x, float_t y) {
      
      glVertexAttrib2f(index, x, y);
      
    }

    void vertex_attrib_2fv(uint_t index, const float_t * v) {
      
      glVertexAttrib2fv(index, v);
      
    }

    void vertex_attrib_3f(uint_t index, float_t x, float_t y, float_t z) {
      
      glVertexAttrib3f(index, x, y, z);
      
    }

    void vertex_attrib_3fv(uint_t index, const float_t * v) {
      
      glVertexAttrib3fv(index, v);
      
    }

    void vertex_attrib_4f(uint_t index, float_t x, float_t y, float_t z, float_t w) {
      
      glVertexAttrib4f(index, x, y, z, w);
      
    }

    void vertex_attrib_4fv(uint_t index, const float_t * v) {
      
      glVertexAttrib4fv(index, v);
      
    }

    void vertex_attrib_pointer(uint_t index, int_t size, vertex_attrib_pointer_type_t type, boolean_t normalized, sizei_t stride, const void * pointer) {
      
      glVertexAttribPointer(index, size, static_cast<GLenum>(type), static_cast<GLboolean>(normalized), stride, pointer);
      
    }

    void viewport(int_t x, int_t y, sizei_t width, sizei_t height) {
      
      glViewport(x, y, width, height);
      
    }

}
