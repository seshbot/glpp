/**
 * This file was autogenerated by glgen (https://github.com/seshbot/glgen) on 2015-03-10
 * Command line: src/gen.py assets/gl.xml -p assets/gl-patch.xml -o ../glpp/ --includesubdir include/glpp --sourcesubdir src --namespace gl2 --force --cpp --gl2only
 */

#include <glad/glad.h>
#include <stdexcept>
#include <glpp/gl2/extensions.h>


namespace gl2 {
    void accumx_oes(gl::enum_t op, gl::fixed_t value) {
      if ( GLAD_GL_OES_fixed_point ) {
        glAccumxOES(op, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glAccumxOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void active_program_ext(gl::uint_t program) {
      if ( GLAD_GL_EXT_separate_shader_objects ) {
        glActiveProgramEXT(program);
      }
      else {
        throw std::runtime_error("OpenGL command 'glActiveProgramEXT' not available on this platform (extensions: GL_EXT_separate_shader_objects)");
      }
    }

    void active_shader_program(gl::uint_t pipeline, gl::uint_t program) {
      if ( GLAD_GL_ARB_separate_shader_objects ) {
        glActiveShaderProgram(pipeline, program);
      }
      else {
        throw std::runtime_error("OpenGL command 'glActiveShaderProgram' not available on this platform (extensions: GL_ARB_separate_shader_objects)");
      }
    }

    void active_stencil_face_ext(stencil_face_direction_t face) {
      if ( GLAD_GL_EXT_stencil_two_side ) {
        glActiveStencilFaceEXT(static_cast<GLenum>(face));
      }
      else {
        throw std::runtime_error("OpenGL command 'glActiveStencilFaceEXT' not available on this platform (extensions: GL_EXT_stencil_two_side)");
      }
    }

    void active_texture_arb(texture_unit_t texture) {
      if ( GLAD_GL_ARB_multitexture ) {
        glActiveTextureARB(static_cast<GLenum>(texture));
      }
      else {
        throw std::runtime_error("OpenGL command 'glActiveTextureARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void active_varying_nv(gl::uint_t program, const  gl::char_t * name) {
      if ( GLAD_GL_NV_transform_feedback ) {
        glActiveVaryingNV(program, name);
      }
      else {
        throw std::runtime_error("OpenGL command 'glActiveVaryingNV' not available on this platform (extensions: GL_NV_transform_feedback)");
      }
    }

    void alpha_fragment_op_1ati(gl::enum_t op, gl::uint_t dst, gl::uint_t dstMod, gl::uint_t arg1, gl::uint_t arg1Rep, gl::uint_t arg1Mod) {
      if ( GLAD_GL_ATI_fragment_shader ) {
        glAlphaFragmentOp1ATI(op, dst, dstMod, arg1, arg1Rep, arg1Mod);
      }
      else {
        throw std::runtime_error("OpenGL command 'glAlphaFragmentOp1ATI' not available on this platform (extensions: GL_ATI_fragment_shader)");
      }
    }

    void alpha_fragment_op_2ati(gl::enum_t op, gl::uint_t dst, gl::uint_t dstMod, gl::uint_t arg1, gl::uint_t arg1Rep, gl::uint_t arg1Mod, gl::uint_t arg2, gl::uint_t arg2Rep, gl::uint_t arg2Mod) {
      if ( GLAD_GL_ATI_fragment_shader ) {
        glAlphaFragmentOp2ATI(op, dst, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod);
      }
      else {
        throw std::runtime_error("OpenGL command 'glAlphaFragmentOp2ATI' not available on this platform (extensions: GL_ATI_fragment_shader)");
      }
    }

    void alpha_fragment_op_3ati(gl::enum_t op, gl::uint_t dst, gl::uint_t dstMod, gl::uint_t arg1, gl::uint_t arg1Rep, gl::uint_t arg1Mod, gl::uint_t arg2, gl::uint_t arg2Rep, gl::uint_t arg2Mod, gl::uint_t arg3, gl::uint_t arg3Rep, gl::uint_t arg3Mod) {
      if ( GLAD_GL_ATI_fragment_shader ) {
        glAlphaFragmentOp3ATI(op, dst, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod, arg3, arg3Rep, arg3Mod);
      }
      else {
        throw std::runtime_error("OpenGL command 'glAlphaFragmentOp3ATI' not available on this platform (extensions: GL_ATI_fragment_shader)");
      }
    }

    void alpha_funcx_oes(gl::enum_t func, gl::fixed_t ref) {
      if ( GLAD_GL_OES_fixed_point ) {
        glAlphaFuncxOES(func, ref);
      }
      else {
        throw std::runtime_error("OpenGL command 'glAlphaFuncxOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void apply_texture_ext(gl::enum_t mode) {
      if ( GLAD_GL_EXT_light_texture ) {
        glApplyTextureEXT(mode);
      }
      else {
        throw std::runtime_error("OpenGL command 'glApplyTextureEXT' not available on this platform (extensions: GL_EXT_light_texture)");
      }
    }

    gl::boolean_t are_programs_resident_nv(gl::sizei_t n, const  gl::uint_t * programs, gl::boolean_t * residences) {
      if ( GLAD_GL_NV_vertex_program ) {
        return glAreProgramsResidentNV(n, programs, residences);
      }
      else {
        throw std::runtime_error("OpenGL command 'glAreProgramsResidentNV' not available on this platform (extensions: GL_NV_vertex_program)");
      }
    }

    gl::boolean_t are_textures_resident_ext(gl::sizei_t n, const  gl::uint_t * textures, gl::boolean_t * residences) {
      if ( GLAD_GL_EXT_texture_object ) {
        return glAreTexturesResidentEXT(n, textures, residences);
      }
      else {
        throw std::runtime_error("OpenGL command 'glAreTexturesResidentEXT' not available on this platform (extensions: GL_EXT_texture_object)");
      }
    }

    void array_element_ext(gl::int_t i) {
      if ( GLAD_GL_EXT_vertex_array ) {
        glArrayElementEXT(i);
      }
      else {
        throw std::runtime_error("OpenGL command 'glArrayElementEXT' not available on this platform (extensions: GL_EXT_vertex_array)");
      }
    }

    void array_object_ati(enable_cap_t array, gl::int_t size, gl::enum_t type, gl::sizei_t stride, gl::uint_t buffer, gl::uint_t offset) {
      if ( GLAD_GL_ATI_vertex_array_object ) {
        glArrayObjectATI(static_cast<GLenum>(array), size, type, stride, buffer, offset);
      }
      else {
        throw std::runtime_error("OpenGL command 'glArrayObjectATI' not available on this platform (extensions: GL_ATI_vertex_array_object)");
      }
    }

    void async_marker_sgix(gl::uint_t marker) {
      if ( GLAD_GL_SGIX_async ) {
        glAsyncMarkerSGIX(marker);
      }
      else {
        throw std::runtime_error("OpenGL command 'glAsyncMarkerSGIX' not available on this platform (extensions: GL_SGIX_async)");
      }
    }

    void attach_object_arb(gl::handleARB_t containerObj, gl::handleARB_t obj) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glAttachObjectARB(containerObj, obj);
      }
      else {
        throw std::runtime_error("OpenGL command 'glAttachObjectARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void begin_conditional_render_nv(gl::uint_t id, gl::enum_t mode) {
      if ( GLAD_GL_NV_conditional_render ) {
        glBeginConditionalRenderNV(id, mode);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBeginConditionalRenderNV' not available on this platform (extensions: GL_NV_conditional_render)");
      }
    }

    void begin_conditional_render_nvx(gl::uint_t id) {
      if ( GLAD_GL_NVX_conditional_render ) {
        glBeginConditionalRenderNVX(id);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBeginConditionalRenderNVX' not available on this platform (extensions: GL_NVX_conditional_render)");
      }
    }

    void begin_fragment_shader_ati() {
      if ( GLAD_GL_ATI_fragment_shader ) {
        glBeginFragmentShaderATI();
      }
      else {
        throw std::runtime_error("OpenGL command 'glBeginFragmentShaderATI' not available on this platform (extensions: GL_ATI_fragment_shader)");
      }
    }

    void begin_occlusion_query_nv(gl::uint_t id) {
      if ( GLAD_GL_NV_occlusion_query ) {
        glBeginOcclusionQueryNV(id);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBeginOcclusionQueryNV' not available on this platform (extensions: GL_NV_occlusion_query)");
      }
    }

    void begin_perf_monitor_amd(gl::uint_t monitor) {
      if ( GLAD_GL_AMD_performance_monitor ) {
        glBeginPerfMonitorAMD(monitor);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBeginPerfMonitorAMD' not available on this platform (extensions: GL_AMD_performance_monitor)");
      }
    }

    void begin_perf_query_intel(gl::uint_t queryHandle) {
      if ( GLAD_GL_INTEL_performance_query ) {
        glBeginPerfQueryINTEL(queryHandle);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBeginPerfQueryINTEL' not available on this platform (extensions: GL_INTEL_performance_query)");
      }
    }

    void begin_query_arb(gl::enum_t target, gl::uint_t id) {
      if ( GLAD_GL_ARB_occlusion_query ) {
        glBeginQueryARB(target, id);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBeginQueryARB' not available on this platform (extensions: GL_ARB_occlusion_query)");
      }
    }

    void begin_query_indexed(gl::enum_t target, gl::uint_t index, gl::uint_t id) {
      if ( GLAD_GL_ARB_transform_feedback3 ) {
        glBeginQueryIndexed(target, index, id);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBeginQueryIndexed' not available on this platform (extensions: GL_ARB_transform_feedback3)");
      }
    }

    void begin_transform_feedback_ext(gl::enum_t primitiveMode) {
      if ( GLAD_GL_EXT_transform_feedback ) {
        glBeginTransformFeedbackEXT(primitiveMode);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBeginTransformFeedbackEXT' not available on this platform (extensions: GL_EXT_transform_feedback)");
      }
    }

    void begin_transform_feedback_nv(gl::enum_t primitiveMode) {
      if ( GLAD_GL_NV_transform_feedback ) {
        glBeginTransformFeedbackNV(primitiveMode);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBeginTransformFeedbackNV' not available on this platform (extensions: GL_NV_transform_feedback)");
      }
    }

    void begin_vertex_shader_ext() {
      if ( GLAD_GL_EXT_vertex_shader ) {
        glBeginVertexShaderEXT();
      }
      else {
        throw std::runtime_error("OpenGL command 'glBeginVertexShaderEXT' not available on this platform (extensions: GL_EXT_vertex_shader)");
      }
    }

    void begin_video_capture_nv(gl::uint_t video_capture_slot) {
      if ( GLAD_GL_NV_video_capture ) {
        glBeginVideoCaptureNV(video_capture_slot);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBeginVideoCaptureNV' not available on this platform (extensions: GL_NV_video_capture)");
      }
    }

    void bind_attrib_location_arb(gl::handleARB_t programObj, gl::uint_t index, const  gl::charARB_t * name) {
      if ( GLAD_GL_ARB_vertex_shader ) {
        glBindAttribLocationARB(programObj, index, name);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBindAttribLocationARB' not available on this platform (extensions: GL_ARB_vertex_shader)");
      }
    }

    void bind_buffer_arb(buffer_target_arb_t target, gl::uint_t buffer) {
      if ( GLAD_GL_ARB_vertex_buffer_object ) {
        glBindBufferARB(static_cast<GLenum>(target), buffer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBindBufferARB' not available on this platform (extensions: GL_ARB_vertex_buffer_object)");
      }
    }

    void bind_buffer_base_ext(gl::enum_t target, gl::uint_t index, gl::uint_t buffer) {
      if ( GLAD_GL_EXT_transform_feedback ) {
        glBindBufferBaseEXT(target, index, buffer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBindBufferBaseEXT' not available on this platform (extensions: GL_EXT_transform_feedback)");
      }
    }

    void bind_buffer_base_nv(gl::enum_t target, gl::uint_t index, gl::uint_t buffer) {
      if ( GLAD_GL_NV_transform_feedback ) {
        glBindBufferBaseNV(target, index, buffer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBindBufferBaseNV' not available on this platform (extensions: GL_NV_transform_feedback)");
      }
    }

    void bind_buffer_offset_ext(gl::enum_t target, gl::uint_t index, gl::uint_t buffer, gl::intptr_t offset) {
      if ( GLAD_GL_EXT_transform_feedback ) {
        glBindBufferOffsetEXT(target, index, buffer, offset);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBindBufferOffsetEXT' not available on this platform (extensions: GL_EXT_transform_feedback)");
      }
    }

    void bind_buffer_offset_nv(gl::enum_t target, gl::uint_t index, gl::uint_t buffer, gl::intptr_t offset) {
      if ( GLAD_GL_NV_transform_feedback ) {
        glBindBufferOffsetNV(target, index, buffer, offset);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBindBufferOffsetNV' not available on this platform (extensions: GL_NV_transform_feedback)");
      }
    }

    void bind_buffer_range_ext(gl::enum_t target, gl::uint_t index, gl::uint_t buffer, gl::intptr_t offset, gl::sizeiptr_t size) {
      if ( GLAD_GL_EXT_transform_feedback ) {
        glBindBufferRangeEXT(target, index, buffer, offset, size);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBindBufferRangeEXT' not available on this platform (extensions: GL_EXT_transform_feedback)");
      }
    }

    void bind_buffer_range_nv(gl::enum_t target, gl::uint_t index, gl::uint_t buffer, gl::intptr_t offset, gl::sizeiptr_t size) {
      if ( GLAD_GL_NV_transform_feedback ) {
        glBindBufferRangeNV(target, index, buffer, offset, size);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBindBufferRangeNV' not available on this platform (extensions: GL_NV_transform_feedback)");
      }
    }

    void bind_buffers_base(gl::enum_t target, gl::uint_t first, gl::sizei_t count, const  gl::uint_t * buffers) {
      if ( GLAD_GL_ARB_multi_bind ) {
        glBindBuffersBase(target, first, count, buffers);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBindBuffersBase' not available on this platform (extensions: GL_ARB_multi_bind)");
      }
    }

    void bind_buffers_range(gl::enum_t target, gl::uint_t first, gl::sizei_t count, const  gl::uint_t * buffers, const  gl::intptr_t * offsets, const  gl::sizeiptr_t * sizes) {
      if ( GLAD_GL_ARB_multi_bind ) {
        glBindBuffersRange(target, first, count, buffers, offsets, sizes);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBindBuffersRange' not available on this platform (extensions: GL_ARB_multi_bind)");
      }
    }

    void bind_frag_data_location_ext(gl::uint_t program, gl::uint_t color, const  gl::char_t * name) {
      if ( GLAD_GL_EXT_gpu_shader4 ) {
        glBindFragDataLocationEXT(program, color, name);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBindFragDataLocationEXT' not available on this platform (extensions: GL_EXT_gpu_shader4)");
      }
    }

    void bind_frag_data_location_indexed(gl::uint_t program, gl::uint_t colorNumber, gl::uint_t index, const  gl::char_t * name) {
      if ( GLAD_GL_ARB_blend_func_extended ) {
        glBindFragDataLocationIndexed(program, colorNumber, index, name);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBindFragDataLocationIndexed' not available on this platform (extensions: GL_ARB_blend_func_extended)");
      }
    }

    void bind_fragment_shader_ati(gl::uint_t id) {
      if ( GLAD_GL_ATI_fragment_shader ) {
        glBindFragmentShaderATI(id);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBindFragmentShaderATI' not available on this platform (extensions: GL_ATI_fragment_shader)");
      }
    }

    void bind_framebuffer(framebuffer_target_t target, gl::uint_t framebuffer) {
      if ( GLAD_GL_ARB_framebuffer_object ) {
        glBindFramebuffer(static_cast<GLenum>(target), framebuffer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBindFramebuffer' not available on this platform (extensions: GL_ARB_framebuffer_object)");
      }
    }

    void bind_framebuffer_ext(framebuffer_target_t target, gl::uint_t framebuffer) {
      if ( GLAD_GL_EXT_framebuffer_object ) {
        glBindFramebufferEXT(static_cast<GLenum>(target), framebuffer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBindFramebufferEXT' not available on this platform (extensions: GL_EXT_framebuffer_object)");
      }
    }

    void bind_image_texture(gl::uint_t unit, gl::uint_t texture, gl::int_t level, gl::boolean_t layered, gl::int_t layer, gl::enum_t access, gl::enum_t format) {
      if ( GLAD_GL_ARB_shader_image_load_store ) {
        glBindImageTexture(unit, texture, level, layered, layer, access, format);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBindImageTexture' not available on this platform (extensions: GL_ARB_shader_image_load_store)");
      }
    }

    void bind_image_texture_ext(gl::uint_t index, gl::uint_t texture, gl::int_t level, gl::boolean_t layered, gl::int_t layer, gl::enum_t access, gl::int_t format) {
      if ( GLAD_GL_EXT_shader_image_load_store ) {
        glBindImageTextureEXT(index, texture, level, layered, layer, access, format);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBindImageTextureEXT' not available on this platform (extensions: GL_EXT_shader_image_load_store)");
      }
    }

    void bind_image_textures(gl::uint_t first, gl::sizei_t count, const  gl::uint_t * textures) {
      if ( GLAD_GL_ARB_multi_bind ) {
        glBindImageTextures(first, count, textures);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBindImageTextures' not available on this platform (extensions: GL_ARB_multi_bind)");
      }
    }

    gl::uint_t bind_light_parameter_ext(light_name_t light, light_parameter_t value) {
      if ( GLAD_GL_EXT_vertex_shader ) {
        return glBindLightParameterEXT(static_cast<GLenum>(light), static_cast<GLenum>(value));
      }
      else {
        throw std::runtime_error("OpenGL command 'glBindLightParameterEXT' not available on this platform (extensions: GL_EXT_vertex_shader)");
      }
    }

    gl::uint_t bind_material_parameter_ext(material_face_t face, material_parameter_t value) {
      if ( GLAD_GL_EXT_vertex_shader ) {
        return glBindMaterialParameterEXT(static_cast<GLenum>(face), static_cast<GLenum>(value));
      }
      else {
        throw std::runtime_error("OpenGL command 'glBindMaterialParameterEXT' not available on this platform (extensions: GL_EXT_vertex_shader)");
      }
    }

    void bind_multi_texture_ext(texture_unit_t texunit, texture_target_t target, gl::uint_t texture) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glBindMultiTextureEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(target), texture);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBindMultiTextureEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    gl::uint_t bind_parameter_ext(gl::enum_t value) {
      if ( GLAD_GL_EXT_vertex_shader ) {
        return glBindParameterEXT(value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBindParameterEXT' not available on this platform (extensions: GL_EXT_vertex_shader)");
      }
    }

    void bind_program_arb(gl::enum_t target, gl::uint_t program) {
      if ( GLAD_GL_ARB_fragment_program || GLAD_GL_ARB_vertex_program ) {
        glBindProgramARB(target, program);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBindProgramARB' not available on this platform (extensions: GL_ARB_fragment_program, GL_ARB_vertex_program)");
      }
    }

    void bind_program_nv(gl::enum_t target, gl::uint_t id) {
      if ( GLAD_GL_NV_vertex_program ) {
        glBindProgramNV(target, id);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBindProgramNV' not available on this platform (extensions: GL_NV_vertex_program)");
      }
    }

    void bind_program_pipeline(gl::uint_t pipeline) {
      if ( GLAD_GL_ARB_separate_shader_objects ) {
        glBindProgramPipeline(pipeline);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBindProgramPipeline' not available on this platform (extensions: GL_ARB_separate_shader_objects)");
      }
    }

    void bind_renderbuffer(renderbuffer_target_t target, gl::uint_t renderbuffer) {
      if ( GLAD_GL_ARB_framebuffer_object ) {
        glBindRenderbuffer(static_cast<GLenum>(target), renderbuffer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBindRenderbuffer' not available on this platform (extensions: GL_ARB_framebuffer_object)");
      }
    }

    void bind_renderbuffer_ext(renderbuffer_target_t target, gl::uint_t renderbuffer) {
      if ( GLAD_GL_EXT_framebuffer_object ) {
        glBindRenderbufferEXT(static_cast<GLenum>(target), renderbuffer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBindRenderbufferEXT' not available on this platform (extensions: GL_EXT_framebuffer_object)");
      }
    }

    void bind_sampler(gl::uint_t unit, gl::uint_t sampler) {
      if ( GLAD_GL_ARB_sampler_objects ) {
        glBindSampler(unit, sampler);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBindSampler' not available on this platform (extensions: GL_ARB_sampler_objects)");
      }
    }

    void bind_samplers(gl::uint_t first, gl::sizei_t count, const  gl::uint_t * samplers) {
      if ( GLAD_GL_ARB_multi_bind ) {
        glBindSamplers(first, count, samplers);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBindSamplers' not available on this platform (extensions: GL_ARB_multi_bind)");
      }
    }

    gl::uint_t bind_tex_gen_parameter_ext(texture_unit_t unit, texture_coord_name_t coord, texture_gen_parameter_t value) {
      if ( GLAD_GL_EXT_vertex_shader ) {
        return glBindTexGenParameterEXT(static_cast<GLenum>(unit), static_cast<GLenum>(coord), static_cast<GLenum>(value));
      }
      else {
        throw std::runtime_error("OpenGL command 'glBindTexGenParameterEXT' not available on this platform (extensions: GL_EXT_vertex_shader)");
      }
    }

    void bind_texture_ext(texture_target_t target, gl::uint_t texture) {
      if ( GLAD_GL_EXT_texture_object ) {
        glBindTextureEXT(static_cast<GLenum>(target), texture);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBindTextureEXT' not available on this platform (extensions: GL_EXT_texture_object)");
      }
    }

    void bind_texture_unit(gl::uint_t unit, gl::uint_t texture) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glBindTextureUnit(unit, texture);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBindTextureUnit' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    gl::uint_t bind_texture_unit_parameter_ext(texture_unit_t unit, gl::enum_t value) {
      if ( GLAD_GL_EXT_vertex_shader ) {
        return glBindTextureUnitParameterEXT(static_cast<GLenum>(unit), value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBindTextureUnitParameterEXT' not available on this platform (extensions: GL_EXT_vertex_shader)");
      }
    }

    void bind_textures(gl::uint_t first, gl::sizei_t count, const  gl::uint_t * textures) {
      if ( GLAD_GL_ARB_multi_bind ) {
        glBindTextures(first, count, textures);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBindTextures' not available on this platform (extensions: GL_ARB_multi_bind)");
      }
    }

    void bind_transform_feedback(gl::enum_t target, gl::uint_t id) {
      if ( GLAD_GL_ARB_transform_feedback2 ) {
        glBindTransformFeedback(target, id);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBindTransformFeedback' not available on this platform (extensions: GL_ARB_transform_feedback2)");
      }
    }

    void bind_transform_feedback_nv(buffer_target_arb_t target, gl::uint_t id) {
      if ( GLAD_GL_NV_transform_feedback2 ) {
        glBindTransformFeedbackNV(static_cast<GLenum>(target), id);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBindTransformFeedbackNV' not available on this platform (extensions: GL_NV_transform_feedback2)");
      }
    }

    void bind_vertex_array(gl::uint_t array) {
      if ( GLAD_GL_ARB_vertex_array_object ) {
        glBindVertexArray(array);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBindVertexArray' not available on this platform (extensions: GL_ARB_vertex_array_object)");
      }
    }

    void bind_vertex_array_apple(gl::uint_t array) {
      if ( GLAD_GL_APPLE_vertex_array_object ) {
        glBindVertexArrayAPPLE(array);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBindVertexArrayAPPLE' not available on this platform (extensions: GL_APPLE_vertex_array_object)");
      }
    }

    void bind_vertex_buffer(gl::uint_t bindingindex, gl::uint_t buffer, gl::intptr_t offset, gl::sizei_t stride) {
      if ( GLAD_GL_ARB_vertex_attrib_binding ) {
        glBindVertexBuffer(bindingindex, buffer, offset, stride);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBindVertexBuffer' not available on this platform (extensions: GL_ARB_vertex_attrib_binding)");
      }
    }

    void bind_vertex_buffers(gl::uint_t first, gl::sizei_t count, const  gl::uint_t * buffers, const  gl::intptr_t * offsets, const  gl::sizei_t * strides) {
      if ( GLAD_GL_ARB_multi_bind ) {
        glBindVertexBuffers(first, count, buffers, offsets, strides);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBindVertexBuffers' not available on this platform (extensions: GL_ARB_multi_bind)");
      }
    }

    void bind_vertex_shader_ext(gl::uint_t id) {
      if ( GLAD_GL_EXT_vertex_shader ) {
        glBindVertexShaderEXT(id);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBindVertexShaderEXT' not available on this platform (extensions: GL_EXT_vertex_shader)");
      }
    }

    void bind_video_capture_stream_buffer_nv(gl::uint_t video_capture_slot, gl::uint_t stream, gl::enum_t frame_region, gl::intptrARB_t offset) {
      if ( GLAD_GL_NV_video_capture ) {
        glBindVideoCaptureStreamBufferNV(video_capture_slot, stream, frame_region, offset);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBindVideoCaptureStreamBufferNV' not available on this platform (extensions: GL_NV_video_capture)");
      }
    }

    void bind_video_capture_stream_texture_nv(gl::uint_t video_capture_slot, gl::uint_t stream, gl::enum_t frame_region, gl::enum_t target, gl::uint_t texture) {
      if ( GLAD_GL_NV_video_capture ) {
        glBindVideoCaptureStreamTextureNV(video_capture_slot, stream, frame_region, target, texture);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBindVideoCaptureStreamTextureNV' not available on this platform (extensions: GL_NV_video_capture)");
      }
    }

    void binormal_3b_ext(gl::byte_t bx, gl::byte_t by, gl::byte_t bz) {
      if ( GLAD_GL_EXT_coordinate_frame ) {
        glBinormal3bEXT(bx, by, bz);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBinormal3bEXT' not available on this platform (extensions: GL_EXT_coordinate_frame)");
      }
    }

    void binormal_3bv_ext(const  gl::byte_t * v) {
      if ( GLAD_GL_EXT_coordinate_frame ) {
        glBinormal3bvEXT(v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBinormal3bvEXT' not available on this platform (extensions: GL_EXT_coordinate_frame)");
      }
    }

    void binormal_3d_ext(gl::double_t bx, gl::double_t by, gl::double_t bz) {
      if ( GLAD_GL_EXT_coordinate_frame ) {
        glBinormal3dEXT(bx, by, bz);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBinormal3dEXT' not available on this platform (extensions: GL_EXT_coordinate_frame)");
      }
    }

    void binormal_3dv_ext(const  gl::double_t * v) {
      if ( GLAD_GL_EXT_coordinate_frame ) {
        glBinormal3dvEXT(v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBinormal3dvEXT' not available on this platform (extensions: GL_EXT_coordinate_frame)");
      }
    }

    void binormal_3f_ext(gl::float_t bx, gl::float_t by, gl::float_t bz) {
      if ( GLAD_GL_EXT_coordinate_frame ) {
        glBinormal3fEXT(bx, by, bz);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBinormal3fEXT' not available on this platform (extensions: GL_EXT_coordinate_frame)");
      }
    }

    void binormal_3fv_ext(const  gl::float_t * v) {
      if ( GLAD_GL_EXT_coordinate_frame ) {
        glBinormal3fvEXT(v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBinormal3fvEXT' not available on this platform (extensions: GL_EXT_coordinate_frame)");
      }
    }

    void binormal_3i_ext(gl::int_t bx, gl::int_t by, gl::int_t bz) {
      if ( GLAD_GL_EXT_coordinate_frame ) {
        glBinormal3iEXT(bx, by, bz);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBinormal3iEXT' not available on this platform (extensions: GL_EXT_coordinate_frame)");
      }
    }

    void binormal_3iv_ext(const  gl::int_t * v) {
      if ( GLAD_GL_EXT_coordinate_frame ) {
        glBinormal3ivEXT(v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBinormal3ivEXT' not available on this platform (extensions: GL_EXT_coordinate_frame)");
      }
    }

    void binormal_3s_ext(gl::short_t bx, gl::short_t by, gl::short_t bz) {
      if ( GLAD_GL_EXT_coordinate_frame ) {
        glBinormal3sEXT(bx, by, bz);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBinormal3sEXT' not available on this platform (extensions: GL_EXT_coordinate_frame)");
      }
    }

    void binormal_3sv_ext(const  gl::short_t * v) {
      if ( GLAD_GL_EXT_coordinate_frame ) {
        glBinormal3svEXT(v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBinormal3svEXT' not available on this platform (extensions: GL_EXT_coordinate_frame)");
      }
    }

    void binormal_pointer_ext(gl::enum_t type, gl::sizei_t stride, const  void * pointer) {
      if ( GLAD_GL_EXT_coordinate_frame ) {
        glBinormalPointerEXT(type, stride, pointer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBinormalPointerEXT' not available on this platform (extensions: GL_EXT_coordinate_frame)");
      }
    }

    void bitmapx_oes(gl::sizei_t width, gl::sizei_t height, gl::fixed_t xorig, gl::fixed_t yorig, gl::fixed_t xmove, gl::fixed_t ymove, const  gl::ubyte_t * bitmap) {
      if ( GLAD_GL_OES_fixed_point ) {
        glBitmapxOES(width, height, xorig, yorig, xmove, ymove, bitmap);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBitmapxOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void blend_barrier_khr() {
      if ( GLAD_GL_KHR_blend_equation_advanced ) {
        glBlendBarrierKHR();
      }
      else {
        throw std::runtime_error("OpenGL command 'glBlendBarrierKHR' not available on this platform (extensions: GL_KHR_blend_equation_advanced)");
      }
    }

    void blend_barrier_nv() {
      if ( GLAD_GL_NV_blend_equation_advanced ) {
        glBlendBarrierNV();
      }
      else {
        throw std::runtime_error("OpenGL command 'glBlendBarrierNV' not available on this platform (extensions: GL_NV_blend_equation_advanced)");
      }
    }

    void blend_color_ext(gl::float_t red, gl::float_t green, gl::float_t blue, gl::float_t alpha) {
      if ( GLAD_GL_EXT_blend_color ) {
        glBlendColorEXT(red, green, blue, alpha);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBlendColorEXT' not available on this platform (extensions: GL_EXT_blend_color)");
      }
    }

    void blend_colorx_oes(gl::fixed_t red, gl::fixed_t green, gl::fixed_t blue, gl::fixed_t alpha) {
      if ( GLAD_GL_OES_fixed_point ) {
        glBlendColorxOES(red, green, blue, alpha);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBlendColorxOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void blend_equation_ext(blend_equation_mode_ext_t mode) {
      if ( GLAD_GL_EXT_blend_minmax ) {
        glBlendEquationEXT(static_cast<GLenum>(mode));
      }
      else {
        throw std::runtime_error("OpenGL command 'glBlendEquationEXT' not available on this platform (extensions: GL_EXT_blend_minmax)");
      }
    }

    void blend_equation_indexed_amd(gl::uint_t buf, gl::enum_t mode) {
      if ( GLAD_GL_AMD_draw_buffers_blend ) {
        glBlendEquationIndexedAMD(buf, mode);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBlendEquationIndexedAMD' not available on this platform (extensions: GL_AMD_draw_buffers_blend)");
      }
    }

    void blend_equation_separate_ext(blend_equation_mode_ext_t modeRGB, blend_equation_mode_ext_t modeAlpha) {
      if ( GLAD_GL_EXT_blend_equation_separate ) {
        glBlendEquationSeparateEXT(static_cast<GLenum>(modeRGB), static_cast<GLenum>(modeAlpha));
      }
      else {
        throw std::runtime_error("OpenGL command 'glBlendEquationSeparateEXT' not available on this platform (extensions: GL_EXT_blend_equation_separate)");
      }
    }

    void blend_equation_separate_indexed_amd(gl::uint_t buf, gl::enum_t modeRGB, gl::enum_t modeAlpha) {
      if ( GLAD_GL_AMD_draw_buffers_blend ) {
        glBlendEquationSeparateIndexedAMD(buf, modeRGB, modeAlpha);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBlendEquationSeparateIndexedAMD' not available on this platform (extensions: GL_AMD_draw_buffers_blend)");
      }
    }

    void blend_equation_separatei_arb(gl::uint_t buf, gl::enum_t modeRGB, gl::enum_t modeAlpha) {
      if ( GLAD_GL_ARB_draw_buffers_blend ) {
        glBlendEquationSeparateiARB(buf, modeRGB, modeAlpha);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBlendEquationSeparateiARB' not available on this platform (extensions: GL_ARB_draw_buffers_blend)");
      }
    }

    void blend_equationi_arb(gl::uint_t buf, gl::enum_t mode) {
      if ( GLAD_GL_ARB_draw_buffers_blend ) {
        glBlendEquationiARB(buf, mode);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBlendEquationiARB' not available on this platform (extensions: GL_ARB_draw_buffers_blend)");
      }
    }

    void blend_func_indexed_amd(gl::uint_t buf, gl::enum_t src, gl::enum_t dst) {
      if ( GLAD_GL_AMD_draw_buffers_blend ) {
        glBlendFuncIndexedAMD(buf, src, dst);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBlendFuncIndexedAMD' not available on this platform (extensions: GL_AMD_draw_buffers_blend)");
      }
    }

    void blend_func_separate_ext(blend_func_separate_parameter_ext_t sfactorRGB, blend_func_separate_parameter_ext_t dfactorRGB, blend_func_separate_parameter_ext_t sfactorAlpha, blend_func_separate_parameter_ext_t dfactorAlpha) {
      if ( GLAD_GL_EXT_blend_func_separate ) {
        glBlendFuncSeparateEXT(static_cast<GLenum>(sfactorRGB), static_cast<GLenum>(dfactorRGB), static_cast<GLenum>(sfactorAlpha), static_cast<GLenum>(dfactorAlpha));
      }
      else {
        throw std::runtime_error("OpenGL command 'glBlendFuncSeparateEXT' not available on this platform (extensions: GL_EXT_blend_func_separate)");
      }
    }

    void blend_func_separate_ingr(blend_func_separate_parameter_ext_t sfactorRGB, blend_func_separate_parameter_ext_t dfactorRGB, blend_func_separate_parameter_ext_t sfactorAlpha, blend_func_separate_parameter_ext_t dfactorAlpha) {
      if ( GLAD_GL_INGR_blend_func_separate ) {
        glBlendFuncSeparateINGR(static_cast<GLenum>(sfactorRGB), static_cast<GLenum>(dfactorRGB), static_cast<GLenum>(sfactorAlpha), static_cast<GLenum>(dfactorAlpha));
      }
      else {
        throw std::runtime_error("OpenGL command 'glBlendFuncSeparateINGR' not available on this platform (extensions: GL_INGR_blend_func_separate)");
      }
    }

    void blend_func_separate_indexed_amd(gl::uint_t buf, gl::enum_t srcRGB, gl::enum_t dstRGB, gl::enum_t srcAlpha, gl::enum_t dstAlpha) {
      if ( GLAD_GL_AMD_draw_buffers_blend ) {
        glBlendFuncSeparateIndexedAMD(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBlendFuncSeparateIndexedAMD' not available on this platform (extensions: GL_AMD_draw_buffers_blend)");
      }
    }

    void blend_func_separatei_arb(gl::uint_t buf, gl::enum_t srcRGB, gl::enum_t dstRGB, gl::enum_t srcAlpha, gl::enum_t dstAlpha) {
      if ( GLAD_GL_ARB_draw_buffers_blend ) {
        glBlendFuncSeparateiARB(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBlendFuncSeparateiARB' not available on this platform (extensions: GL_ARB_draw_buffers_blend)");
      }
    }

    void blend_funci_arb(gl::uint_t buf, gl::enum_t src, gl::enum_t dst) {
      if ( GLAD_GL_ARB_draw_buffers_blend ) {
        glBlendFunciARB(buf, src, dst);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBlendFunciARB' not available on this platform (extensions: GL_ARB_draw_buffers_blend)");
      }
    }

    void blend_parameteri_nv(gl::enum_t pname, gl::int_t value) {
      if ( GLAD_GL_NV_blend_equation_advanced ) {
        glBlendParameteriNV(pname, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBlendParameteriNV' not available on this platform (extensions: GL_NV_blend_equation_advanced)");
      }
    }

    void blit_framebuffer(gl::int_t srcX0, gl::int_t srcY0, gl::int_t srcX1, gl::int_t srcY1, gl::int_t dstX0, gl::int_t dstY0, gl::int_t dstX1, gl::int_t dstY1, gl::bitmask<clear_buffer_flags_t> mask, gl::enum_t filter) {
      if ( GLAD_GL_ARB_framebuffer_object ) {
        glBlitFramebuffer(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, static_cast<GLbitfield>(mask.value), filter);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBlitFramebuffer' not available on this platform (extensions: GL_ARB_framebuffer_object)");
      }
    }

    void blit_framebuffer_ext(gl::int_t srcX0, gl::int_t srcY0, gl::int_t srcX1, gl::int_t srcY1, gl::int_t dstX0, gl::int_t dstY0, gl::int_t dstX1, gl::int_t dstY1, gl::bitmask<clear_buffer_flags_t> mask, gl::enum_t filter) {
      if ( GLAD_GL_EXT_framebuffer_blit ) {
        glBlitFramebufferEXT(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, static_cast<GLbitfield>(mask.value), filter);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBlitFramebufferEXT' not available on this platform (extensions: GL_EXT_framebuffer_blit)");
      }
    }

    void blit_named_framebuffer(gl::uint_t readFramebuffer, gl::uint_t drawFramebuffer, gl::int_t srcX0, gl::int_t srcY0, gl::int_t srcX1, gl::int_t srcY1, gl::int_t dstX0, gl::int_t dstY0, gl::int_t dstX1, gl::int_t dstY1, gl::bitfield_t mask, gl::enum_t filter) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glBlitNamedFramebuffer(readFramebuffer, drawFramebuffer, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBlitNamedFramebuffer' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void buffer_address_range_nv(gl::enum_t pname, gl::uint_t index, gl::uint64EXT_t address, gl::sizeiptr_t length) {
      if ( GLAD_GL_NV_vertex_buffer_unified_memory ) {
        glBufferAddressRangeNV(pname, index, address, length);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBufferAddressRangeNV' not available on this platform (extensions: GL_NV_vertex_buffer_unified_memory)");
      }
    }

    void buffer_data_arb(buffer_target_arb_t target, gl::sizeiptrARB_t size, const  void * data, buffer_usage_arb_t usage) {
      if ( GLAD_GL_ARB_vertex_buffer_object ) {
        glBufferDataARB(static_cast<GLenum>(target), size, data, static_cast<GLenum>(usage));
      }
      else {
        throw std::runtime_error("OpenGL command 'glBufferDataARB' not available on this platform (extensions: GL_ARB_vertex_buffer_object)");
      }
    }

    void buffer_page_commitment_arb(gl::enum_t target, gl::intptr_t offset, gl::sizeiptr_t size, gl::boolean_t commit) {
      if ( GLAD_GL_ARB_sparse_buffer ) {
        glBufferPageCommitmentARB(target, offset, size, commit);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBufferPageCommitmentARB' not available on this platform (extensions: GL_ARB_sparse_buffer)");
      }
    }

    void buffer_parameteri_apple(gl::enum_t target, gl::enum_t pname, gl::int_t param) {
      if ( GLAD_GL_APPLE_flush_buffer_range ) {
        glBufferParameteriAPPLE(target, pname, param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBufferParameteriAPPLE' not available on this platform (extensions: GL_APPLE_flush_buffer_range)");
      }
    }

    void buffer_storage(gl::enum_t target, gl::sizeiptr_t size, const  void * data, gl::bitfield_t flags) {
      if ( GLAD_GL_ARB_buffer_storage ) {
        glBufferStorage(target, size, data, flags);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBufferStorage' not available on this platform (extensions: GL_ARB_buffer_storage)");
      }
    }

    void buffer_sub_data_arb(buffer_target_arb_t target, gl::intptrARB_t offset, gl::sizeiptrARB_t size, const  void * data) {
      if ( GLAD_GL_ARB_vertex_buffer_object ) {
        glBufferSubDataARB(static_cast<GLenum>(target), offset, size, data);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBufferSubDataARB' not available on this platform (extensions: GL_ARB_vertex_buffer_object)");
      }
    }

    framebuffer_status_t check_framebuffer_status(framebuffer_target_t target) {
      if ( GLAD_GL_ARB_framebuffer_object ) {
        return static_cast<framebuffer_status_t>(glCheckFramebufferStatus(static_cast<GLenum>(target)));
      }
      else {
        throw std::runtime_error("OpenGL command 'glCheckFramebufferStatus' not available on this platform (extensions: GL_ARB_framebuffer_object)");
      }
    }

    gl::enum_t check_framebuffer_status_ext(framebuffer_target_t target) {
      if ( GLAD_GL_EXT_framebuffer_object ) {
        return glCheckFramebufferStatusEXT(static_cast<GLenum>(target));
      }
      else {
        throw std::runtime_error("OpenGL command 'glCheckFramebufferStatusEXT' not available on this platform (extensions: GL_EXT_framebuffer_object)");
      }
    }

    gl::enum_t check_named_framebuffer_status(gl::uint_t framebuffer, gl::enum_t target) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        return glCheckNamedFramebufferStatus(framebuffer, target);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCheckNamedFramebufferStatus' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    framebuffer_status_t check_named_framebuffer_status_ext(gl::uint_t framebuffer, framebuffer_target_t target) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        return static_cast<framebuffer_status_t>(glCheckNamedFramebufferStatusEXT(framebuffer, static_cast<GLenum>(target)));
      }
      else {
        throw std::runtime_error("OpenGL command 'glCheckNamedFramebufferStatusEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void clamp_color_arb(gl::enum_t target, gl::enum_t clamp) {
      if ( GLAD_GL_ARB_color_buffer_float ) {
        glClampColorARB(target, clamp);
      }
      else {
        throw std::runtime_error("OpenGL command 'glClampColorARB' not available on this platform (extensions: GL_ARB_color_buffer_float)");
      }
    }

    void clear_accumx_oes(gl::fixed_t red, gl::fixed_t green, gl::fixed_t blue, gl::fixed_t alpha) {
      if ( GLAD_GL_OES_fixed_point ) {
        glClearAccumxOES(red, green, blue, alpha);
      }
      else {
        throw std::runtime_error("OpenGL command 'glClearAccumxOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void clear_buffer_data(gl::enum_t target, gl::enum_t internalformat, gl::enum_t format, gl::enum_t type, const  void * data) {
      if ( GLAD_GL_ARB_clear_buffer_object ) {
        glClearBufferData(target, internalformat, format, type, data);
      }
      else {
        throw std::runtime_error("OpenGL command 'glClearBufferData' not available on this platform (extensions: GL_ARB_clear_buffer_object)");
      }
    }

    void clear_buffer_sub_data(gl::enum_t target, gl::enum_t internalformat, gl::intptr_t offset, gl::sizeiptr_t size, gl::enum_t format, gl::enum_t type, const  void * data) {
      if ( GLAD_GL_ARB_clear_buffer_object ) {
        glClearBufferSubData(target, internalformat, offset, size, format, type, data);
      }
      else {
        throw std::runtime_error("OpenGL command 'glClearBufferSubData' not available on this platform (extensions: GL_ARB_clear_buffer_object)");
      }
    }

    void clear_color_ii_ext(gl::int_t red, gl::int_t green, gl::int_t blue, gl::int_t alpha) {
      if ( GLAD_GL_EXT_texture_integer ) {
        glClearColorIiEXT(red, green, blue, alpha);
      }
      else {
        throw std::runtime_error("OpenGL command 'glClearColorIiEXT' not available on this platform (extensions: GL_EXT_texture_integer)");
      }
    }

    void clear_color_iui_ext(gl::uint_t red, gl::uint_t green, gl::uint_t blue, gl::uint_t alpha) {
      if ( GLAD_GL_EXT_texture_integer ) {
        glClearColorIuiEXT(red, green, blue, alpha);
      }
      else {
        throw std::runtime_error("OpenGL command 'glClearColorIuiEXT' not available on this platform (extensions: GL_EXT_texture_integer)");
      }
    }

    void clear_colorx_oes(gl::fixed_t red, gl::fixed_t green, gl::fixed_t blue, gl::fixed_t alpha) {
      if ( GLAD_GL_OES_fixed_point ) {
        glClearColorxOES(red, green, blue, alpha);
      }
      else {
        throw std::runtime_error("OpenGL command 'glClearColorxOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void clear_depthd_nv(gl::double_t depth) {
      if ( GLAD_GL_NV_depth_buffer_float ) {
        glClearDepthdNV(depth);
      }
      else {
        throw std::runtime_error("OpenGL command 'glClearDepthdNV' not available on this platform (extensions: GL_NV_depth_buffer_float)");
      }
    }

    void clear_depthf(gl::float_t d) {
      if ( GLAD_GL_ARB_ES2_compatibility ) {
        glClearDepthf(d);
      }
      else {
        throw std::runtime_error("OpenGL command 'glClearDepthf' not available on this platform (extensions: GL_ARB_ES2_compatibility)");
      }
    }

    void clear_depthf_oes(gl::clampf_t depth) {
      if ( GLAD_GL_OES_single_precision ) {
        glClearDepthfOES(depth);
      }
      else {
        throw std::runtime_error("OpenGL command 'glClearDepthfOES' not available on this platform (extensions: GL_OES_single_precision)");
      }
    }

    void clear_depthx_oes(gl::fixed_t depth) {
      if ( GLAD_GL_OES_fixed_point ) {
        glClearDepthxOES(depth);
      }
      else {
        throw std::runtime_error("OpenGL command 'glClearDepthxOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void clear_named_buffer_data(gl::uint_t buffer, gl::enum_t internalformat, gl::enum_t format, gl::enum_t type, const  void * data) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glClearNamedBufferData(buffer, internalformat, format, type, data);
      }
      else {
        throw std::runtime_error("OpenGL command 'glClearNamedBufferData' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void clear_named_buffer_data_ext(gl::uint_t buffer, gl::enum_t internalformat, pixel_format_t format, pixel_type_t type, const  void * data) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glClearNamedBufferDataEXT(buffer, internalformat, static_cast<GLenum>(format), static_cast<GLenum>(type), data);
      }
      else {
        throw std::runtime_error("OpenGL command 'glClearNamedBufferDataEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void clear_named_buffer_sub_data(gl::uint_t buffer, gl::enum_t internalformat, gl::intptr_t offset, gl::sizeiptr_t size, gl::enum_t format, gl::enum_t type, const  void * data) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glClearNamedBufferSubData(buffer, internalformat, offset, size, format, type, data);
      }
      else {
        throw std::runtime_error("OpenGL command 'glClearNamedBufferSubData' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void clear_named_buffer_sub_data_ext(gl::uint_t buffer, gl::enum_t internalformat, gl::sizeiptr_t offset, gl::sizeiptr_t size, pixel_format_t format, pixel_type_t type, const  void * data) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glClearNamedBufferSubDataEXT(buffer, internalformat, offset, size, static_cast<GLenum>(format), static_cast<GLenum>(type), data);
      }
      else {
        throw std::runtime_error("OpenGL command 'glClearNamedBufferSubDataEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void clear_named_framebufferfi(gl::uint_t framebuffer, gl::enum_t buffer, const  gl::float_t depth, gl::int_t stencil) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glClearNamedFramebufferfi(framebuffer, buffer, depth, stencil);
      }
      else {
        throw std::runtime_error("OpenGL command 'glClearNamedFramebufferfi' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void clear_named_framebufferfv(gl::uint_t framebuffer, gl::enum_t buffer, gl::int_t drawbuffer, const  gl::float_t * value) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glClearNamedFramebufferfv(framebuffer, buffer, drawbuffer, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glClearNamedFramebufferfv' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void clear_named_framebufferiv(gl::uint_t framebuffer, gl::enum_t buffer, gl::int_t drawbuffer, const  gl::int_t * value) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glClearNamedFramebufferiv(framebuffer, buffer, drawbuffer, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glClearNamedFramebufferiv' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void clear_named_framebufferuiv(gl::uint_t framebuffer, gl::enum_t buffer, gl::int_t drawbuffer, const  gl::uint_t * value) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glClearNamedFramebufferuiv(framebuffer, buffer, drawbuffer, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glClearNamedFramebufferuiv' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void clear_tex_image(gl::uint_t texture, gl::int_t level, gl::enum_t format, gl::enum_t type, const  void * data) {
      if ( GLAD_GL_ARB_clear_texture ) {
        glClearTexImage(texture, level, format, type, data);
      }
      else {
        throw std::runtime_error("OpenGL command 'glClearTexImage' not available on this platform (extensions: GL_ARB_clear_texture)");
      }
    }

    void clear_tex_sub_image(gl::uint_t texture, gl::int_t level, gl::int_t xoffset, gl::int_t yoffset, gl::int_t zoffset, gl::sizei_t width, gl::sizei_t height, gl::sizei_t depth, gl::enum_t format, gl::enum_t type, const  void * data) {
      if ( GLAD_GL_ARB_clear_texture ) {
        glClearTexSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, data);
      }
      else {
        throw std::runtime_error("OpenGL command 'glClearTexSubImage' not available on this platform (extensions: GL_ARB_clear_texture)");
      }
    }

    void client_active_texture_arb(texture_unit_t texture) {
      if ( GLAD_GL_ARB_multitexture ) {
        glClientActiveTextureARB(static_cast<GLenum>(texture));
      }
      else {
        throw std::runtime_error("OpenGL command 'glClientActiveTextureARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void client_active_vertex_stream_ati(gl::enum_t stream) {
      if ( GLAD_GL_ATI_vertex_streams ) {
        glClientActiveVertexStreamATI(stream);
      }
      else {
        throw std::runtime_error("OpenGL command 'glClientActiveVertexStreamATI' not available on this platform (extensions: GL_ATI_vertex_streams)");
      }
    }

    void client_attrib_default_ext(gl::bitmask<client_attrib_flags_t> mask) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glClientAttribDefaultEXT(static_cast<GLbitfield>(mask.value));
      }
      else {
        throw std::runtime_error("OpenGL command 'glClientAttribDefaultEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    gl::enum_t client_wait_sync(gl::sync_t sync, gl::bitfield_t flags, gl::uint64_t timeout) {
      if ( GLAD_GL_ARB_sync ) {
        return glClientWaitSync(sync, flags, timeout);
      }
      else {
        throw std::runtime_error("OpenGL command 'glClientWaitSync' not available on this platform (extensions: GL_ARB_sync)");
      }
    }

    void clip_control(gl::enum_t origin, gl::enum_t depth) {
      if ( GLAD_GL_ARB_clip_control ) {
        glClipControl(origin, depth);
      }
      else {
        throw std::runtime_error("OpenGL command 'glClipControl' not available on this platform (extensions: GL_ARB_clip_control)");
      }
    }

    void clip_planef_oes(gl::enum_t plane, const  gl::float_t * equation) {
      if ( GLAD_GL_OES_single_precision ) {
        glClipPlanefOES(plane, equation);
      }
      else {
        throw std::runtime_error("OpenGL command 'glClipPlanefOES' not available on this platform (extensions: GL_OES_single_precision)");
      }
    }

    void clip_planex_oes(gl::enum_t plane, const  gl::fixed_t * equation) {
      if ( GLAD_GL_OES_fixed_point ) {
        glClipPlanexOES(plane, equation);
      }
      else {
        throw std::runtime_error("OpenGL command 'glClipPlanexOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void color_3f_vertex_3f_sun(gl::float_t r, gl::float_t g, gl::float_t b, gl::float_t x, gl::float_t y, gl::float_t z) {
      if ( GLAD_GL_SUN_vertex ) {
        glColor3fVertex3fSUN(r, g, b, x, y, z);
      }
      else {
        throw std::runtime_error("OpenGL command 'glColor3fVertex3fSUN' not available on this platform (extensions: GL_SUN_vertex)");
      }
    }

    void color_3f_vertex_3fv_sun(const  gl::float_t * c, const  gl::float_t * v) {
      if ( GLAD_GL_SUN_vertex ) {
        glColor3fVertex3fvSUN(c, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glColor3fVertex3fvSUN' not available on this platform (extensions: GL_SUN_vertex)");
      }
    }

    void color_3h_nv(gl::halfNV_t red, gl::halfNV_t green, gl::halfNV_t blue) {
      if ( GLAD_GL_NV_half_float ) {
        glColor3hNV(red, green, blue);
      }
      else {
        throw std::runtime_error("OpenGL command 'glColor3hNV' not available on this platform (extensions: GL_NV_half_float)");
      }
    }

    void color_3hv_nv(const  gl::halfNV_t * v) {
      if ( GLAD_GL_NV_half_float ) {
        glColor3hvNV(v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glColor3hvNV' not available on this platform (extensions: GL_NV_half_float)");
      }
    }

    void color_3x_oes(gl::fixed_t red, gl::fixed_t green, gl::fixed_t blue) {
      if ( GLAD_GL_OES_fixed_point ) {
        glColor3xOES(red, green, blue);
      }
      else {
        throw std::runtime_error("OpenGL command 'glColor3xOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void color_3xv_oes(const  gl::fixed_t * components) {
      if ( GLAD_GL_OES_fixed_point ) {
        glColor3xvOES(components);
      }
      else {
        throw std::runtime_error("OpenGL command 'glColor3xvOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void color_4f_normal_3f_vertex_3f_sun(gl::float_t r, gl::float_t g, gl::float_t b, gl::float_t a, gl::float_t nx, gl::float_t ny, gl::float_t nz, gl::float_t x, gl::float_t y, gl::float_t z) {
      if ( GLAD_GL_SUN_vertex ) {
        glColor4fNormal3fVertex3fSUN(r, g, b, a, nx, ny, nz, x, y, z);
      }
      else {
        throw std::runtime_error("OpenGL command 'glColor4fNormal3fVertex3fSUN' not available on this platform (extensions: GL_SUN_vertex)");
      }
    }

    void color_4f_normal_3f_vertex_3fv_sun(const  gl::float_t * c, const  gl::float_t * n, const  gl::float_t * v) {
      if ( GLAD_GL_SUN_vertex ) {
        glColor4fNormal3fVertex3fvSUN(c, n, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glColor4fNormal3fVertex3fvSUN' not available on this platform (extensions: GL_SUN_vertex)");
      }
    }

    void color_4h_nv(gl::halfNV_t red, gl::halfNV_t green, gl::halfNV_t blue, gl::halfNV_t alpha) {
      if ( GLAD_GL_NV_half_float ) {
        glColor4hNV(red, green, blue, alpha);
      }
      else {
        throw std::runtime_error("OpenGL command 'glColor4hNV' not available on this platform (extensions: GL_NV_half_float)");
      }
    }

    void color_4hv_nv(const  gl::halfNV_t * v) {
      if ( GLAD_GL_NV_half_float ) {
        glColor4hvNV(v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glColor4hvNV' not available on this platform (extensions: GL_NV_half_float)");
      }
    }

    void color_4ub_vertex_2f_sun(gl::ubyte_t r, gl::ubyte_t g, gl::ubyte_t b, gl::ubyte_t a, gl::float_t x, gl::float_t y) {
      if ( GLAD_GL_SUN_vertex ) {
        glColor4ubVertex2fSUN(r, g, b, a, x, y);
      }
      else {
        throw std::runtime_error("OpenGL command 'glColor4ubVertex2fSUN' not available on this platform (extensions: GL_SUN_vertex)");
      }
    }

    void color_4ub_vertex_2fv_sun(const  gl::ubyte_t * c, const  gl::float_t * v) {
      if ( GLAD_GL_SUN_vertex ) {
        glColor4ubVertex2fvSUN(c, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glColor4ubVertex2fvSUN' not available on this platform (extensions: GL_SUN_vertex)");
      }
    }

    void color_4ub_vertex_3f_sun(gl::ubyte_t r, gl::ubyte_t g, gl::ubyte_t b, gl::ubyte_t a, gl::float_t x, gl::float_t y, gl::float_t z) {
      if ( GLAD_GL_SUN_vertex ) {
        glColor4ubVertex3fSUN(r, g, b, a, x, y, z);
      }
      else {
        throw std::runtime_error("OpenGL command 'glColor4ubVertex3fSUN' not available on this platform (extensions: GL_SUN_vertex)");
      }
    }

    void color_4ub_vertex_3fv_sun(const  gl::ubyte_t * c, const  gl::float_t * v) {
      if ( GLAD_GL_SUN_vertex ) {
        glColor4ubVertex3fvSUN(c, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glColor4ubVertex3fvSUN' not available on this platform (extensions: GL_SUN_vertex)");
      }
    }

    void color_4x_oes(gl::fixed_t red, gl::fixed_t green, gl::fixed_t blue, gl::fixed_t alpha) {
      if ( GLAD_GL_OES_fixed_point ) {
        glColor4xOES(red, green, blue, alpha);
      }
      else {
        throw std::runtime_error("OpenGL command 'glColor4xOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void color_4xv_oes(const  gl::fixed_t * components) {
      if ( GLAD_GL_OES_fixed_point ) {
        glColor4xvOES(components);
      }
      else {
        throw std::runtime_error("OpenGL command 'glColor4xvOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void color_format_nv(gl::int_t size, gl::enum_t type, gl::sizei_t stride) {
      if ( GLAD_GL_NV_vertex_buffer_unified_memory ) {
        glColorFormatNV(size, type, stride);
      }
      else {
        throw std::runtime_error("OpenGL command 'glColorFormatNV' not available on this platform (extensions: GL_NV_vertex_buffer_unified_memory)");
      }
    }

    void color_fragment_op_1ati(gl::enum_t op, gl::uint_t dst, gl::uint_t dstMask, gl::uint_t dstMod, gl::uint_t arg1, gl::uint_t arg1Rep, gl::uint_t arg1Mod) {
      if ( GLAD_GL_ATI_fragment_shader ) {
        glColorFragmentOp1ATI(op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod);
      }
      else {
        throw std::runtime_error("OpenGL command 'glColorFragmentOp1ATI' not available on this platform (extensions: GL_ATI_fragment_shader)");
      }
    }

    void color_fragment_op_2ati(gl::enum_t op, gl::uint_t dst, gl::uint_t dstMask, gl::uint_t dstMod, gl::uint_t arg1, gl::uint_t arg1Rep, gl::uint_t arg1Mod, gl::uint_t arg2, gl::uint_t arg2Rep, gl::uint_t arg2Mod) {
      if ( GLAD_GL_ATI_fragment_shader ) {
        glColorFragmentOp2ATI(op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod);
      }
      else {
        throw std::runtime_error("OpenGL command 'glColorFragmentOp2ATI' not available on this platform (extensions: GL_ATI_fragment_shader)");
      }
    }

    void color_fragment_op_3ati(gl::enum_t op, gl::uint_t dst, gl::uint_t dstMask, gl::uint_t dstMod, gl::uint_t arg1, gl::uint_t arg1Rep, gl::uint_t arg1Mod, gl::uint_t arg2, gl::uint_t arg2Rep, gl::uint_t arg2Mod, gl::uint_t arg3, gl::uint_t arg3Rep, gl::uint_t arg3Mod) {
      if ( GLAD_GL_ATI_fragment_shader ) {
        glColorFragmentOp3ATI(op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod, arg3, arg3Rep, arg3Mod);
      }
      else {
        throw std::runtime_error("OpenGL command 'glColorFragmentOp3ATI' not available on this platform (extensions: GL_ATI_fragment_shader)");
      }
    }

    void color_mask_indexed_ext(gl::uint_t index, gl::boolean_t r, gl::boolean_t g, gl::boolean_t b, gl::boolean_t a) {
      if ( GLAD_GL_EXT_draw_buffers2 ) {
        glColorMaskIndexedEXT(index, r, g, b, a);
      }
      else {
        throw std::runtime_error("OpenGL command 'glColorMaskIndexedEXT' not available on this platform (extensions: GL_EXT_draw_buffers2)");
      }
    }

    void color_p3ui(gl::enum_t type, gl::uint_t color) {
      if ( GLAD_GL_ARB_vertex_type_2_10_10_10_rev ) {
        glColorP3ui(type, color);
      }
      else {
        throw std::runtime_error("OpenGL command 'glColorP3ui' not available on this platform (extensions: GL_ARB_vertex_type_2_10_10_10_rev)");
      }
    }

    void color_p3uiv(gl::enum_t type, const  gl::uint_t * color) {
      if ( GLAD_GL_ARB_vertex_type_2_10_10_10_rev ) {
        glColorP3uiv(type, color);
      }
      else {
        throw std::runtime_error("OpenGL command 'glColorP3uiv' not available on this platform (extensions: GL_ARB_vertex_type_2_10_10_10_rev)");
      }
    }

    void color_p4ui(gl::enum_t type, gl::uint_t color) {
      if ( GLAD_GL_ARB_vertex_type_2_10_10_10_rev ) {
        glColorP4ui(type, color);
      }
      else {
        throw std::runtime_error("OpenGL command 'glColorP4ui' not available on this platform (extensions: GL_ARB_vertex_type_2_10_10_10_rev)");
      }
    }

    void color_p4uiv(gl::enum_t type, const  gl::uint_t * color) {
      if ( GLAD_GL_ARB_vertex_type_2_10_10_10_rev ) {
        glColorP4uiv(type, color);
      }
      else {
        throw std::runtime_error("OpenGL command 'glColorP4uiv' not available on this platform (extensions: GL_ARB_vertex_type_2_10_10_10_rev)");
      }
    }

    void color_pointer_ext(gl::int_t size, color_pointer_type_t type, gl::sizei_t stride, gl::sizei_t count, const  void * pointer) {
      if ( GLAD_GL_EXT_vertex_array ) {
        glColorPointerEXT(size, static_cast<GLenum>(type), stride, count, pointer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glColorPointerEXT' not available on this platform (extensions: GL_EXT_vertex_array)");
      }
    }

    void color_pointer_list_ibm(gl::int_t size, color_pointer_type_t type, gl::int_t stride, const  void ** pointer, gl::int_t ptrstride) {
      if ( GLAD_GL_IBM_vertex_array_lists ) {
        glColorPointerListIBM(size, static_cast<GLenum>(type), stride, pointer, ptrstride);
      }
      else {
        throw std::runtime_error("OpenGL command 'glColorPointerListIBM' not available on this platform (extensions: GL_IBM_vertex_array_lists)");
      }
    }

    void color_pointerv_intel(gl::int_t size, vertex_pointer_type_t type, const  void ** pointer) {
      if ( GLAD_GL_INTEL_parallel_arrays ) {
        glColorPointervINTEL(size, static_cast<GLenum>(type), pointer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glColorPointervINTEL' not available on this platform (extensions: GL_INTEL_parallel_arrays)");
      }
    }

    void color_sub_table(gl::enum_t target, gl::sizei_t start, gl::sizei_t count, pixel_format_t format, pixel_type_t type, const  void * data) {
      if ( GLAD_GL_ARB_imaging ) {
        glColorSubTable(target, start, count, static_cast<GLenum>(format), static_cast<GLenum>(type), data);
      }
      else {
        throw std::runtime_error("OpenGL command 'glColorSubTable' not available on this platform (extensions: GL_ARB_imaging)");
      }
    }

    void color_sub_table_ext(gl::enum_t target, gl::sizei_t start, gl::sizei_t count, pixel_format_t format, pixel_type_t type, const  void * data) {
      if ( GLAD_GL_EXT_color_subtable ) {
        glColorSubTableEXT(target, start, count, static_cast<GLenum>(format), static_cast<GLenum>(type), data);
      }
      else {
        throw std::runtime_error("OpenGL command 'glColorSubTableEXT' not available on this platform (extensions: GL_EXT_color_subtable)");
      }
    }

    void color_table(gl::enum_t target, gl::enum_t internalformat, gl::sizei_t width, pixel_format_t format, pixel_type_t type, const  void * table) {
      if ( GLAD_GL_ARB_imaging ) {
        glColorTable(target, internalformat, width, static_cast<GLenum>(format), static_cast<GLenum>(type), table);
      }
      else {
        throw std::runtime_error("OpenGL command 'glColorTable' not available on this platform (extensions: GL_ARB_imaging)");
      }
    }

    void color_table_ext(gl::enum_t target, gl::enum_t internalFormat, gl::sizei_t width, pixel_format_t format, pixel_type_t type, const  void * table) {
      if ( GLAD_GL_EXT_paletted_texture ) {
        glColorTableEXT(target, internalFormat, width, static_cast<GLenum>(format), static_cast<GLenum>(type), table);
      }
      else {
        throw std::runtime_error("OpenGL command 'glColorTableEXT' not available on this platform (extensions: GL_EXT_paletted_texture)");
      }
    }

    void color_table_parameterfv(gl::enum_t target, gl::enum_t pname, const  gl::float_t * params) {
      if ( GLAD_GL_ARB_imaging ) {
        glColorTableParameterfv(target, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glColorTableParameterfv' not available on this platform (extensions: GL_ARB_imaging)");
      }
    }

    void color_table_parameterfv_sgi(color_table_target_sgi_t target, color_table_parameter_p_name_sgi_t pname, const  gl::float_t * params) {
      if ( GLAD_GL_SGI_color_table ) {
        glColorTableParameterfvSGI(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glColorTableParameterfvSGI' not available on this platform (extensions: GL_SGI_color_table)");
      }
    }

    void color_table_parameteriv(gl::enum_t target, gl::enum_t pname, const  gl::int_t * params) {
      if ( GLAD_GL_ARB_imaging ) {
        glColorTableParameteriv(target, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glColorTableParameteriv' not available on this platform (extensions: GL_ARB_imaging)");
      }
    }

    void color_table_parameteriv_sgi(color_table_target_sgi_t target, color_table_parameter_p_name_sgi_t pname, const  gl::int_t * params) {
      if ( GLAD_GL_SGI_color_table ) {
        glColorTableParameterivSGI(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glColorTableParameterivSGI' not available on this platform (extensions: GL_SGI_color_table)");
      }
    }

    void color_table_sgi(color_table_target_sgi_t target, gl::enum_t internalformat, gl::sizei_t width, pixel_format_t format, pixel_type_t type, const  void * table) {
      if ( GLAD_GL_SGI_color_table ) {
        glColorTableSGI(static_cast<GLenum>(target), internalformat, width, static_cast<GLenum>(format), static_cast<GLenum>(type), table);
      }
      else {
        throw std::runtime_error("OpenGL command 'glColorTableSGI' not available on this platform (extensions: GL_SGI_color_table)");
      }
    }

    void combiner_input_nv(gl::enum_t stage, gl::enum_t portion, gl::enum_t variable, gl::enum_t input, gl::enum_t mapping, gl::enum_t componentUsage) {
      if ( GLAD_GL_NV_register_combiners ) {
        glCombinerInputNV(stage, portion, variable, input, mapping, componentUsage);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCombinerInputNV' not available on this platform (extensions: GL_NV_register_combiners)");
      }
    }

    void combiner_output_nv(gl::enum_t stage, gl::enum_t portion, gl::enum_t abOutput, gl::enum_t cdOutput, gl::enum_t sumOutput, gl::enum_t scale, gl::enum_t bias, gl::boolean_t abDotProduct, gl::boolean_t cdDotProduct, gl::boolean_t muxSum) {
      if ( GLAD_GL_NV_register_combiners ) {
        glCombinerOutputNV(stage, portion, abOutput, cdOutput, sumOutput, scale, bias, abDotProduct, cdDotProduct, muxSum);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCombinerOutputNV' not available on this platform (extensions: GL_NV_register_combiners)");
      }
    }

    void combiner_parameterf_nv(gl::enum_t pname, gl::float_t param) {
      if ( GLAD_GL_NV_register_combiners ) {
        glCombinerParameterfNV(pname, param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCombinerParameterfNV' not available on this platform (extensions: GL_NV_register_combiners)");
      }
    }

    void combiner_parameterfv_nv(gl::enum_t pname, const  gl::float_t * params) {
      if ( GLAD_GL_NV_register_combiners ) {
        glCombinerParameterfvNV(pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCombinerParameterfvNV' not available on this platform (extensions: GL_NV_register_combiners)");
      }
    }

    void combiner_parameteri_nv(gl::enum_t pname, gl::int_t param) {
      if ( GLAD_GL_NV_register_combiners ) {
        glCombinerParameteriNV(pname, param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCombinerParameteriNV' not available on this platform (extensions: GL_NV_register_combiners)");
      }
    }

    void combiner_parameteriv_nv(gl::enum_t pname, const  gl::int_t * params) {
      if ( GLAD_GL_NV_register_combiners ) {
        glCombinerParameterivNV(pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCombinerParameterivNV' not available on this platform (extensions: GL_NV_register_combiners)");
      }
    }

    void combiner_stage_parameterfv_nv(gl::enum_t stage, gl::enum_t pname, const  gl::float_t * params) {
      if ( GLAD_GL_NV_register_combiners2 ) {
        glCombinerStageParameterfvNV(stage, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCombinerStageParameterfvNV' not available on this platform (extensions: GL_NV_register_combiners2)");
      }
    }

    void compile_shader_arb(gl::handleARB_t shaderObj) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glCompileShaderARB(shaderObj);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCompileShaderARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void compile_shader_include_arb(gl::uint_t shader, gl::sizei_t count, const  gl::char_t ** path, const  gl::int_t * length) {
      if ( GLAD_GL_ARB_shading_language_include ) {
        glCompileShaderIncludeARB(shader, count, path, length);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCompileShaderIncludeARB' not available on this platform (extensions: GL_ARB_shading_language_include)");
      }
    }

    void compressed_multi_tex_image_1dext(texture_unit_t texunit, texture_target_t target, gl::int_t level, gl::enum_t internalformat, gl::sizei_t width, gl::int_t border, gl::sizei_t imageSize, const  void * bits) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glCompressedMultiTexImage1DEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(target), level, internalformat, width, border, imageSize, bits);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCompressedMultiTexImage1DEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void compressed_multi_tex_image_2dext(texture_unit_t texunit, texture_target_t target, gl::int_t level, gl::enum_t internalformat, gl::sizei_t width, gl::sizei_t height, gl::int_t border, gl::sizei_t imageSize, const  void * bits) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glCompressedMultiTexImage2DEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(target), level, internalformat, width, height, border, imageSize, bits);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCompressedMultiTexImage2DEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void compressed_multi_tex_image_3dext(texture_unit_t texunit, texture_target_t target, gl::int_t level, gl::enum_t internalformat, gl::sizei_t width, gl::sizei_t height, gl::sizei_t depth, gl::int_t border, gl::sizei_t imageSize, const  void * bits) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glCompressedMultiTexImage3DEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(target), level, internalformat, width, height, depth, border, imageSize, bits);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCompressedMultiTexImage3DEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void compressed_multi_tex_sub_image_1dext(texture_unit_t texunit, texture_target_t target, gl::int_t level, gl::int_t xoffset, gl::sizei_t width, pixel_format_t format, gl::sizei_t imageSize, const  void * bits) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glCompressedMultiTexSubImage1DEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(target), level, xoffset, width, static_cast<GLenum>(format), imageSize, bits);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCompressedMultiTexSubImage1DEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void compressed_multi_tex_sub_image_2dext(texture_unit_t texunit, texture_target_t target, gl::int_t level, gl::int_t xoffset, gl::int_t yoffset, gl::sizei_t width, gl::sizei_t height, pixel_format_t format, gl::sizei_t imageSize, const  void * bits) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glCompressedMultiTexSubImage2DEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(target), level, xoffset, yoffset, width, height, static_cast<GLenum>(format), imageSize, bits);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCompressedMultiTexSubImage2DEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void compressed_multi_tex_sub_image_3dext(texture_unit_t texunit, texture_target_t target, gl::int_t level, gl::int_t xoffset, gl::int_t yoffset, gl::int_t zoffset, gl::sizei_t width, gl::sizei_t height, gl::sizei_t depth, pixel_format_t format, gl::sizei_t imageSize, const  void * bits) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glCompressedMultiTexSubImage3DEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(target), level, xoffset, yoffset, zoffset, width, height, depth, static_cast<GLenum>(format), imageSize, bits);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCompressedMultiTexSubImage3DEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void compressed_tex_image_1darb(texture_target_t target, gl::int_t level, gl::enum_t internalformat, gl::sizei_t width, gl::int_t border, gl::sizei_t imageSize, const  void * data) {
      if ( GLAD_GL_ARB_texture_compression ) {
        glCompressedTexImage1DARB(static_cast<GLenum>(target), level, internalformat, width, border, imageSize, data);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCompressedTexImage1DARB' not available on this platform (extensions: GL_ARB_texture_compression)");
      }
    }

    void compressed_tex_image_2darb(texture_target_t target, gl::int_t level, gl::enum_t internalformat, gl::sizei_t width, gl::sizei_t height, gl::int_t border, gl::sizei_t imageSize, const  void * data) {
      if ( GLAD_GL_ARB_texture_compression ) {
        glCompressedTexImage2DARB(static_cast<GLenum>(target), level, internalformat, width, height, border, imageSize, data);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCompressedTexImage2DARB' not available on this platform (extensions: GL_ARB_texture_compression)");
      }
    }

    void compressed_tex_image_3darb(texture_target_t target, gl::int_t level, gl::enum_t internalformat, gl::sizei_t width, gl::sizei_t height, gl::sizei_t depth, gl::int_t border, gl::sizei_t imageSize, const  void * data) {
      if ( GLAD_GL_ARB_texture_compression ) {
        glCompressedTexImage3DARB(static_cast<GLenum>(target), level, internalformat, width, height, depth, border, imageSize, data);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCompressedTexImage3DARB' not available on this platform (extensions: GL_ARB_texture_compression)");
      }
    }

    void compressed_tex_sub_image_1darb(texture_target_t target, gl::int_t level, gl::int_t xoffset, gl::sizei_t width, pixel_format_t format, gl::sizei_t imageSize, const  void * data) {
      if ( GLAD_GL_ARB_texture_compression ) {
        glCompressedTexSubImage1DARB(static_cast<GLenum>(target), level, xoffset, width, static_cast<GLenum>(format), imageSize, data);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCompressedTexSubImage1DARB' not available on this platform (extensions: GL_ARB_texture_compression)");
      }
    }

    void compressed_tex_sub_image_2darb(texture_target_t target, gl::int_t level, gl::int_t xoffset, gl::int_t yoffset, gl::sizei_t width, gl::sizei_t height, pixel_format_t format, gl::sizei_t imageSize, const  void * data) {
      if ( GLAD_GL_ARB_texture_compression ) {
        glCompressedTexSubImage2DARB(static_cast<GLenum>(target), level, xoffset, yoffset, width, height, static_cast<GLenum>(format), imageSize, data);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCompressedTexSubImage2DARB' not available on this platform (extensions: GL_ARB_texture_compression)");
      }
    }

    void compressed_tex_sub_image_3darb(texture_target_t target, gl::int_t level, gl::int_t xoffset, gl::int_t yoffset, gl::int_t zoffset, gl::sizei_t width, gl::sizei_t height, gl::sizei_t depth, pixel_format_t format, gl::sizei_t imageSize, const  void * data) {
      if ( GLAD_GL_ARB_texture_compression ) {
        glCompressedTexSubImage3DARB(static_cast<GLenum>(target), level, xoffset, yoffset, zoffset, width, height, depth, static_cast<GLenum>(format), imageSize, data);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCompressedTexSubImage3DARB' not available on this platform (extensions: GL_ARB_texture_compression)");
      }
    }

    void compressed_texture_image_1dext(gl::uint_t texture, texture_target_t target, gl::int_t level, gl::enum_t internalformat, gl::sizei_t width, gl::int_t border, gl::sizei_t imageSize, const  void * bits) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glCompressedTextureImage1DEXT(texture, static_cast<GLenum>(target), level, internalformat, width, border, imageSize, bits);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCompressedTextureImage1DEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void compressed_texture_image_2dext(gl::uint_t texture, texture_target_t target, gl::int_t level, gl::enum_t internalformat, gl::sizei_t width, gl::sizei_t height, gl::int_t border, gl::sizei_t imageSize, const  void * bits) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glCompressedTextureImage2DEXT(texture, static_cast<GLenum>(target), level, internalformat, width, height, border, imageSize, bits);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCompressedTextureImage2DEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void compressed_texture_image_3dext(gl::uint_t texture, texture_target_t target, gl::int_t level, gl::enum_t internalformat, gl::sizei_t width, gl::sizei_t height, gl::sizei_t depth, gl::int_t border, gl::sizei_t imageSize, const  void * bits) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glCompressedTextureImage3DEXT(texture, static_cast<GLenum>(target), level, internalformat, width, height, depth, border, imageSize, bits);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCompressedTextureImage3DEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void compressed_texture_sub_image_1d(gl::uint_t texture, gl::int_t level, gl::int_t xoffset, gl::sizei_t width, gl::enum_t format, gl::sizei_t imageSize, const  void * data) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glCompressedTextureSubImage1D(texture, level, xoffset, width, format, imageSize, data);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCompressedTextureSubImage1D' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void compressed_texture_sub_image_1dext(gl::uint_t texture, texture_target_t target, gl::int_t level, gl::int_t xoffset, gl::sizei_t width, pixel_format_t format, gl::sizei_t imageSize, const  void * bits) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glCompressedTextureSubImage1DEXT(texture, static_cast<GLenum>(target), level, xoffset, width, static_cast<GLenum>(format), imageSize, bits);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCompressedTextureSubImage1DEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void compressed_texture_sub_image_2d(gl::uint_t texture, gl::int_t level, gl::int_t xoffset, gl::int_t yoffset, gl::sizei_t width, gl::sizei_t height, gl::enum_t format, gl::sizei_t imageSize, const  void * data) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glCompressedTextureSubImage2D(texture, level, xoffset, yoffset, width, height, format, imageSize, data);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCompressedTextureSubImage2D' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void compressed_texture_sub_image_2dext(gl::uint_t texture, texture_target_t target, gl::int_t level, gl::int_t xoffset, gl::int_t yoffset, gl::sizei_t width, gl::sizei_t height, pixel_format_t format, gl::sizei_t imageSize, const  void * bits) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glCompressedTextureSubImage2DEXT(texture, static_cast<GLenum>(target), level, xoffset, yoffset, width, height, static_cast<GLenum>(format), imageSize, bits);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCompressedTextureSubImage2DEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void compressed_texture_sub_image_3d(gl::uint_t texture, gl::int_t level, gl::int_t xoffset, gl::int_t yoffset, gl::int_t zoffset, gl::sizei_t width, gl::sizei_t height, gl::sizei_t depth, gl::enum_t format, gl::sizei_t imageSize, const  void * data) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glCompressedTextureSubImage3D(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCompressedTextureSubImage3D' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void compressed_texture_sub_image_3dext(gl::uint_t texture, texture_target_t target, gl::int_t level, gl::int_t xoffset, gl::int_t yoffset, gl::int_t zoffset, gl::sizei_t width, gl::sizei_t height, gl::sizei_t depth, pixel_format_t format, gl::sizei_t imageSize, const  void * bits) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glCompressedTextureSubImage3DEXT(texture, static_cast<GLenum>(target), level, xoffset, yoffset, zoffset, width, height, depth, static_cast<GLenum>(format), imageSize, bits);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCompressedTextureSubImage3DEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void convolution_filter_1d(gl::enum_t target, gl::enum_t internalformat, gl::sizei_t width, pixel_format_t format, pixel_type_t type, const  void * image) {
      if ( GLAD_GL_ARB_imaging ) {
        glConvolutionFilter1D(target, internalformat, width, static_cast<GLenum>(format), static_cast<GLenum>(type), image);
      }
      else {
        throw std::runtime_error("OpenGL command 'glConvolutionFilter1D' not available on this platform (extensions: GL_ARB_imaging)");
      }
    }

    void convolution_filter_1dext(convolution_target_ext_t target, gl::enum_t internalformat, gl::sizei_t width, pixel_format_t format, pixel_type_t type, const  void * image) {
      if ( GLAD_GL_EXT_convolution ) {
        glConvolutionFilter1DEXT(static_cast<GLenum>(target), internalformat, width, static_cast<GLenum>(format), static_cast<GLenum>(type), image);
      }
      else {
        throw std::runtime_error("OpenGL command 'glConvolutionFilter1DEXT' not available on this platform (extensions: GL_EXT_convolution)");
      }
    }

    void convolution_filter_2d(gl::enum_t target, gl::enum_t internalformat, gl::sizei_t width, gl::sizei_t height, pixel_format_t format, pixel_type_t type, const  void * image) {
      if ( GLAD_GL_ARB_imaging ) {
        glConvolutionFilter2D(target, internalformat, width, height, static_cast<GLenum>(format), static_cast<GLenum>(type), image);
      }
      else {
        throw std::runtime_error("OpenGL command 'glConvolutionFilter2D' not available on this platform (extensions: GL_ARB_imaging)");
      }
    }

    void convolution_filter_2dext(convolution_target_ext_t target, gl::enum_t internalformat, gl::sizei_t width, gl::sizei_t height, pixel_format_t format, pixel_type_t type, const  void * image) {
      if ( GLAD_GL_EXT_convolution ) {
        glConvolutionFilter2DEXT(static_cast<GLenum>(target), internalformat, width, height, static_cast<GLenum>(format), static_cast<GLenum>(type), image);
      }
      else {
        throw std::runtime_error("OpenGL command 'glConvolutionFilter2DEXT' not available on this platform (extensions: GL_EXT_convolution)");
      }
    }

    void convolution_parameterf(gl::enum_t target, gl::enum_t pname, gl::float_t params) {
      if ( GLAD_GL_ARB_imaging ) {
        glConvolutionParameterf(target, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glConvolutionParameterf' not available on this platform (extensions: GL_ARB_imaging)");
      }
    }

    void convolution_parameterf_ext(convolution_target_ext_t target, convolution_parameter_ext_t pname, gl::float_t params) {
      if ( GLAD_GL_EXT_convolution ) {
        glConvolutionParameterfEXT(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glConvolutionParameterfEXT' not available on this platform (extensions: GL_EXT_convolution)");
      }
    }

    void convolution_parameterfv(gl::enum_t target, gl::enum_t pname, const  gl::float_t * params) {
      if ( GLAD_GL_ARB_imaging ) {
        glConvolutionParameterfv(target, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glConvolutionParameterfv' not available on this platform (extensions: GL_ARB_imaging)");
      }
    }

    void convolution_parameterfv_ext(convolution_target_ext_t target, convolution_parameter_ext_t pname, const  gl::float_t * params) {
      if ( GLAD_GL_EXT_convolution ) {
        glConvolutionParameterfvEXT(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glConvolutionParameterfvEXT' not available on this platform (extensions: GL_EXT_convolution)");
      }
    }

    void convolution_parameteri(gl::enum_t target, gl::enum_t pname, gl::int_t params) {
      if ( GLAD_GL_ARB_imaging ) {
        glConvolutionParameteri(target, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glConvolutionParameteri' not available on this platform (extensions: GL_ARB_imaging)");
      }
    }

    void convolution_parameteri_ext(convolution_target_ext_t target, convolution_parameter_ext_t pname, gl::int_t params) {
      if ( GLAD_GL_EXT_convolution ) {
        glConvolutionParameteriEXT(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glConvolutionParameteriEXT' not available on this platform (extensions: GL_EXT_convolution)");
      }
    }

    void convolution_parameteriv(gl::enum_t target, gl::enum_t pname, const  gl::int_t * params) {
      if ( GLAD_GL_ARB_imaging ) {
        glConvolutionParameteriv(target, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glConvolutionParameteriv' not available on this platform (extensions: GL_ARB_imaging)");
      }
    }

    void convolution_parameteriv_ext(convolution_target_ext_t target, convolution_parameter_ext_t pname, const  gl::int_t * params) {
      if ( GLAD_GL_EXT_convolution ) {
        glConvolutionParameterivEXT(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glConvolutionParameterivEXT' not available on this platform (extensions: GL_EXT_convolution)");
      }
    }

    void convolution_parameterx_oes(gl::enum_t target, gl::enum_t pname, gl::fixed_t param) {
      if ( GLAD_GL_OES_fixed_point ) {
        glConvolutionParameterxOES(target, pname, param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glConvolutionParameterxOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void convolution_parameterxv_oes(gl::enum_t target, gl::enum_t pname, const  gl::fixed_t * params) {
      if ( GLAD_GL_OES_fixed_point ) {
        glConvolutionParameterxvOES(target, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glConvolutionParameterxvOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void copy_buffer_sub_data(gl::enum_t readTarget, gl::enum_t writeTarget, gl::intptr_t readOffset, gl::intptr_t writeOffset, gl::sizeiptr_t size) {
      if ( GLAD_GL_ARB_copy_buffer ) {
        glCopyBufferSubData(readTarget, writeTarget, readOffset, writeOffset, size);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCopyBufferSubData' not available on this platform (extensions: GL_ARB_copy_buffer)");
      }
    }

    void copy_color_sub_table(gl::enum_t target, gl::sizei_t start, gl::int_t x, gl::int_t y, gl::sizei_t width) {
      if ( GLAD_GL_ARB_imaging ) {
        glCopyColorSubTable(target, start, x, y, width);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCopyColorSubTable' not available on this platform (extensions: GL_ARB_imaging)");
      }
    }

    void copy_color_sub_table_ext(gl::enum_t target, gl::sizei_t start, gl::int_t x, gl::int_t y, gl::sizei_t width) {
      if ( GLAD_GL_EXT_color_subtable ) {
        glCopyColorSubTableEXT(target, start, x, y, width);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCopyColorSubTableEXT' not available on this platform (extensions: GL_EXT_color_subtable)");
      }
    }

    void copy_color_table(gl::enum_t target, gl::enum_t internalformat, gl::int_t x, gl::int_t y, gl::sizei_t width) {
      if ( GLAD_GL_ARB_imaging ) {
        glCopyColorTable(target, internalformat, x, y, width);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCopyColorTable' not available on this platform (extensions: GL_ARB_imaging)");
      }
    }

    void copy_color_table_sgi(color_table_target_sgi_t target, gl::enum_t internalformat, gl::int_t x, gl::int_t y, gl::sizei_t width) {
      if ( GLAD_GL_SGI_color_table ) {
        glCopyColorTableSGI(static_cast<GLenum>(target), internalformat, x, y, width);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCopyColorTableSGI' not available on this platform (extensions: GL_SGI_color_table)");
      }
    }

    void copy_convolution_filter_1d(gl::enum_t target, gl::enum_t internalformat, gl::int_t x, gl::int_t y, gl::sizei_t width) {
      if ( GLAD_GL_ARB_imaging ) {
        glCopyConvolutionFilter1D(target, internalformat, x, y, width);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCopyConvolutionFilter1D' not available on this platform (extensions: GL_ARB_imaging)");
      }
    }

    void copy_convolution_filter_1dext(convolution_target_ext_t target, gl::enum_t internalformat, gl::int_t x, gl::int_t y, gl::sizei_t width) {
      if ( GLAD_GL_EXT_convolution ) {
        glCopyConvolutionFilter1DEXT(static_cast<GLenum>(target), internalformat, x, y, width);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCopyConvolutionFilter1DEXT' not available on this platform (extensions: GL_EXT_convolution)");
      }
    }

    void copy_convolution_filter_2d(gl::enum_t target, gl::enum_t internalformat, gl::int_t x, gl::int_t y, gl::sizei_t width, gl::sizei_t height) {
      if ( GLAD_GL_ARB_imaging ) {
        glCopyConvolutionFilter2D(target, internalformat, x, y, width, height);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCopyConvolutionFilter2D' not available on this platform (extensions: GL_ARB_imaging)");
      }
    }

    void copy_convolution_filter_2dext(convolution_target_ext_t target, gl::enum_t internalformat, gl::int_t x, gl::int_t y, gl::sizei_t width, gl::sizei_t height) {
      if ( GLAD_GL_EXT_convolution ) {
        glCopyConvolutionFilter2DEXT(static_cast<GLenum>(target), internalformat, x, y, width, height);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCopyConvolutionFilter2DEXT' not available on this platform (extensions: GL_EXT_convolution)");
      }
    }

    void copy_image_sub_data(gl::uint_t srcName, gl::enum_t srcTarget, gl::int_t srcLevel, gl::int_t srcX, gl::int_t srcY, gl::int_t srcZ, gl::uint_t dstName, gl::enum_t dstTarget, gl::int_t dstLevel, gl::int_t dstX, gl::int_t dstY, gl::int_t dstZ, gl::sizei_t srcWidth, gl::sizei_t srcHeight, gl::sizei_t srcDepth) {
      if ( GLAD_GL_ARB_copy_image ) {
        glCopyImageSubData(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCopyImageSubData' not available on this platform (extensions: GL_ARB_copy_image)");
      }
    }

    void copy_image_sub_data_nv(gl::uint_t srcName, gl::enum_t srcTarget, gl::int_t srcLevel, gl::int_t srcX, gl::int_t srcY, gl::int_t srcZ, gl::uint_t dstName, gl::enum_t dstTarget, gl::int_t dstLevel, gl::int_t dstX, gl::int_t dstY, gl::int_t dstZ, gl::sizei_t width, gl::sizei_t height, gl::sizei_t depth) {
      if ( GLAD_GL_NV_copy_image ) {
        glCopyImageSubDataNV(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCopyImageSubDataNV' not available on this platform (extensions: GL_NV_copy_image)");
      }
    }

    void copy_multi_tex_image_1dext(texture_unit_t texunit, texture_target_t target, gl::int_t level, gl::enum_t internalformat, gl::int_t x, gl::int_t y, gl::sizei_t width, gl::int_t border) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glCopyMultiTexImage1DEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(target), level, internalformat, x, y, width, border);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCopyMultiTexImage1DEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void copy_multi_tex_image_2dext(texture_unit_t texunit, texture_target_t target, gl::int_t level, gl::enum_t internalformat, gl::int_t x, gl::int_t y, gl::sizei_t width, gl::sizei_t height, gl::int_t border) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glCopyMultiTexImage2DEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(target), level, internalformat, x, y, width, height, border);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCopyMultiTexImage2DEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void copy_multi_tex_sub_image_1dext(texture_unit_t texunit, texture_target_t target, gl::int_t level, gl::int_t xoffset, gl::int_t x, gl::int_t y, gl::sizei_t width) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glCopyMultiTexSubImage1DEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(target), level, xoffset, x, y, width);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCopyMultiTexSubImage1DEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void copy_multi_tex_sub_image_2dext(texture_unit_t texunit, texture_target_t target, gl::int_t level, gl::int_t xoffset, gl::int_t yoffset, gl::int_t x, gl::int_t y, gl::sizei_t width, gl::sizei_t height) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glCopyMultiTexSubImage2DEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(target), level, xoffset, yoffset, x, y, width, height);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCopyMultiTexSubImage2DEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void copy_multi_tex_sub_image_3dext(texture_unit_t texunit, texture_target_t target, gl::int_t level, gl::int_t xoffset, gl::int_t yoffset, gl::int_t zoffset, gl::int_t x, gl::int_t y, gl::sizei_t width, gl::sizei_t height) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glCopyMultiTexSubImage3DEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(target), level, xoffset, yoffset, zoffset, x, y, width, height);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCopyMultiTexSubImage3DEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void copy_named_buffer_sub_data(gl::uint_t readBuffer, gl::uint_t writeBuffer, gl::intptr_t readOffset, gl::intptr_t writeOffset, gl::sizeiptr_t size) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glCopyNamedBufferSubData(readBuffer, writeBuffer, readOffset, writeOffset, size);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCopyNamedBufferSubData' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void copy_path_nv(gl::uint_t resultPath, gl::uint_t srcPath) {
      if ( GLAD_GL_NV_path_rendering ) {
        glCopyPathNV(resultPath, srcPath);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCopyPathNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void copy_tex_image_1dext(texture_target_t target, gl::int_t level, gl::enum_t internalformat, gl::int_t x, gl::int_t y, gl::sizei_t width, gl::int_t border) {
      if ( GLAD_GL_EXT_copy_texture ) {
        glCopyTexImage1DEXT(static_cast<GLenum>(target), level, internalformat, x, y, width, border);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCopyTexImage1DEXT' not available on this platform (extensions: GL_EXT_copy_texture)");
      }
    }

    void copy_tex_image_2dext(texture_target_t target, gl::int_t level, gl::enum_t internalformat, gl::int_t x, gl::int_t y, gl::sizei_t width, gl::sizei_t height, gl::int_t border) {
      if ( GLAD_GL_EXT_copy_texture ) {
        glCopyTexImage2DEXT(static_cast<GLenum>(target), level, internalformat, x, y, width, height, border);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCopyTexImage2DEXT' not available on this platform (extensions: GL_EXT_copy_texture)");
      }
    }

    void copy_tex_sub_image_1dext(texture_target_t target, gl::int_t level, gl::int_t xoffset, gl::int_t x, gl::int_t y, gl::sizei_t width) {
      if ( GLAD_GL_EXT_copy_texture ) {
        glCopyTexSubImage1DEXT(static_cast<GLenum>(target), level, xoffset, x, y, width);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCopyTexSubImage1DEXT' not available on this platform (extensions: GL_EXT_copy_texture)");
      }
    }

    void copy_tex_sub_image_2dext(texture_target_t target, gl::int_t level, gl::int_t xoffset, gl::int_t yoffset, gl::int_t x, gl::int_t y, gl::sizei_t width, gl::sizei_t height) {
      if ( GLAD_GL_EXT_copy_texture ) {
        glCopyTexSubImage2DEXT(static_cast<GLenum>(target), level, xoffset, yoffset, x, y, width, height);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCopyTexSubImage2DEXT' not available on this platform (extensions: GL_EXT_copy_texture)");
      }
    }

    void copy_tex_sub_image_3dext(texture_target_t target, gl::int_t level, gl::int_t xoffset, gl::int_t yoffset, gl::int_t zoffset, gl::int_t x, gl::int_t y, gl::sizei_t width, gl::sizei_t height) {
      if ( GLAD_GL_EXT_copy_texture ) {
        glCopyTexSubImage3DEXT(static_cast<GLenum>(target), level, xoffset, yoffset, zoffset, x, y, width, height);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCopyTexSubImage3DEXT' not available on this platform (extensions: GL_EXT_copy_texture)");
      }
    }

    void copy_texture_image_1dext(gl::uint_t texture, texture_target_t target, gl::int_t level, gl::enum_t internalformat, gl::int_t x, gl::int_t y, gl::sizei_t width, gl::int_t border) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glCopyTextureImage1DEXT(texture, static_cast<GLenum>(target), level, internalformat, x, y, width, border);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCopyTextureImage1DEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void copy_texture_image_2dext(gl::uint_t texture, texture_target_t target, gl::int_t level, gl::enum_t internalformat, gl::int_t x, gl::int_t y, gl::sizei_t width, gl::sizei_t height, gl::int_t border) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glCopyTextureImage2DEXT(texture, static_cast<GLenum>(target), level, internalformat, x, y, width, height, border);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCopyTextureImage2DEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void copy_texture_sub_image_1d(gl::uint_t texture, gl::int_t level, gl::int_t xoffset, gl::int_t x, gl::int_t y, gl::sizei_t width) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glCopyTextureSubImage1D(texture, level, xoffset, x, y, width);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCopyTextureSubImage1D' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void copy_texture_sub_image_1dext(gl::uint_t texture, texture_target_t target, gl::int_t level, gl::int_t xoffset, gl::int_t x, gl::int_t y, gl::sizei_t width) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glCopyTextureSubImage1DEXT(texture, static_cast<GLenum>(target), level, xoffset, x, y, width);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCopyTextureSubImage1DEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void copy_texture_sub_image_2d(gl::uint_t texture, gl::int_t level, gl::int_t xoffset, gl::int_t yoffset, gl::int_t x, gl::int_t y, gl::sizei_t width, gl::sizei_t height) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glCopyTextureSubImage2D(texture, level, xoffset, yoffset, x, y, width, height);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCopyTextureSubImage2D' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void copy_texture_sub_image_2dext(gl::uint_t texture, texture_target_t target, gl::int_t level, gl::int_t xoffset, gl::int_t yoffset, gl::int_t x, gl::int_t y, gl::sizei_t width, gl::sizei_t height) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glCopyTextureSubImage2DEXT(texture, static_cast<GLenum>(target), level, xoffset, yoffset, x, y, width, height);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCopyTextureSubImage2DEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void copy_texture_sub_image_3d(gl::uint_t texture, gl::int_t level, gl::int_t xoffset, gl::int_t yoffset, gl::int_t zoffset, gl::int_t x, gl::int_t y, gl::sizei_t width, gl::sizei_t height) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glCopyTextureSubImage3D(texture, level, xoffset, yoffset, zoffset, x, y, width, height);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCopyTextureSubImage3D' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void copy_texture_sub_image_3dext(gl::uint_t texture, texture_target_t target, gl::int_t level, gl::int_t xoffset, gl::int_t yoffset, gl::int_t zoffset, gl::int_t x, gl::int_t y, gl::sizei_t width, gl::sizei_t height) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glCopyTextureSubImage3DEXT(texture, static_cast<GLenum>(target), level, xoffset, yoffset, zoffset, x, y, width, height);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCopyTextureSubImage3DEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void cover_fill_path_instanced_nv(gl::sizei_t numPaths, gl::enum_t pathNameType, const  void * paths, gl::uint_t pathBase, gl::enum_t coverMode, gl::enum_t transformType, const  gl::float_t * transformValues) {
      if ( GLAD_GL_NV_path_rendering ) {
        glCoverFillPathInstancedNV(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCoverFillPathInstancedNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void cover_fill_path_nv(gl::uint_t path, gl::enum_t coverMode) {
      if ( GLAD_GL_NV_path_rendering ) {
        glCoverFillPathNV(path, coverMode);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCoverFillPathNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void cover_stroke_path_instanced_nv(gl::sizei_t numPaths, gl::enum_t pathNameType, const  void * paths, gl::uint_t pathBase, gl::enum_t coverMode, gl::enum_t transformType, const  gl::float_t * transformValues) {
      if ( GLAD_GL_NV_path_rendering ) {
        glCoverStrokePathInstancedNV(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCoverStrokePathInstancedNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void cover_stroke_path_nv(gl::uint_t path, gl::enum_t coverMode) {
      if ( GLAD_GL_NV_path_rendering ) {
        glCoverStrokePathNV(path, coverMode);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCoverStrokePathNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void coverage_modulation_nv(gl::enum_t components) {
      if ( GLAD_GL_NV_framebuffer_mixed_samples ) {
        glCoverageModulationNV(components);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCoverageModulationNV' not available on this platform (extensions: GL_NV_framebuffer_mixed_samples)");
      }
    }

    void coverage_modulation_table_nv(gl::sizei_t n, const  gl::float_t * v) {
      if ( GLAD_GL_NV_framebuffer_mixed_samples ) {
        glCoverageModulationTableNV(n, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCoverageModulationTableNV' not available on this platform (extensions: GL_NV_framebuffer_mixed_samples)");
      }
    }

    void create_buffers(gl::sizei_t n, gl::uint_t * buffers) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glCreateBuffers(n, buffers);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCreateBuffers' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void create_framebuffers(gl::sizei_t n, gl::uint_t * framebuffers) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glCreateFramebuffers(n, framebuffers);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCreateFramebuffers' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void create_perf_query_intel(gl::uint_t queryId, gl::uint_t * queryHandle) {
      if ( GLAD_GL_INTEL_performance_query ) {
        glCreatePerfQueryINTEL(queryId, queryHandle);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCreatePerfQueryINTEL' not available on this platform (extensions: GL_INTEL_performance_query)");
      }
    }

    gl::handleARB_t create_program_object_arb() {
      if ( GLAD_GL_ARB_shader_objects ) {
        return glCreateProgramObjectARB();
      }
      else {
        throw std::runtime_error("OpenGL command 'glCreateProgramObjectARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void create_program_pipelines(gl::sizei_t n, gl::uint_t * pipelines) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glCreateProgramPipelines(n, pipelines);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCreateProgramPipelines' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void create_queries(gl::enum_t target, gl::sizei_t n, gl::uint_t * ids) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glCreateQueries(target, n, ids);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCreateQueries' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void create_renderbuffers(gl::sizei_t n, gl::uint_t * renderbuffers) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glCreateRenderbuffers(n, renderbuffers);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCreateRenderbuffers' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void create_samplers(gl::sizei_t n, gl::uint_t * samplers) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glCreateSamplers(n, samplers);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCreateSamplers' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    gl::handleARB_t create_shader_object_arb(gl::enum_t shaderType) {
      if ( GLAD_GL_ARB_shader_objects ) {
        return glCreateShaderObjectARB(shaderType);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCreateShaderObjectARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    gl::uint_t create_shader_program_ext(gl::enum_t type, const  gl::char_t * string) {
      if ( GLAD_GL_EXT_separate_shader_objects ) {
        return glCreateShaderProgramEXT(type, string);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCreateShaderProgramEXT' not available on this platform (extensions: GL_EXT_separate_shader_objects)");
      }
    }

    gl::uint_t create_shader_programv(gl::enum_t type, gl::sizei_t count, const  gl::char_t ** strings) {
      if ( GLAD_GL_ARB_separate_shader_objects ) {
        return glCreateShaderProgramv(type, count, strings);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCreateShaderProgramv' not available on this platform (extensions: GL_ARB_separate_shader_objects)");
      }
    }

    gl::sync_t create_sync_from_c_levent_arb(gl::_cl_context_t * context, gl::_cl_event_t * event, gl::bitfield_t flags) {
      if ( GLAD_GL_ARB_cl_event ) {
        return glCreateSyncFromCLeventARB(reinterpret_cast<_cl_context *>(context), reinterpret_cast<_cl_event *>(event), flags);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCreateSyncFromCLeventARB' not available on this platform (extensions: GL_ARB_cl_event)");
      }
    }

    void create_textures(gl::enum_t target, gl::sizei_t n, gl::uint_t * textures) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glCreateTextures(target, n, textures);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCreateTextures' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void create_transform_feedbacks(gl::sizei_t n, gl::uint_t * ids) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glCreateTransformFeedbacks(n, ids);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCreateTransformFeedbacks' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void create_vertex_arrays(gl::sizei_t n, gl::uint_t * arrays) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glCreateVertexArrays(n, arrays);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCreateVertexArrays' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void cull_parameterdv_ext(gl::enum_t pname, gl::double_t * params) {
      if ( GLAD_GL_EXT_cull_vertex ) {
        glCullParameterdvEXT(pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCullParameterdvEXT' not available on this platform (extensions: GL_EXT_cull_vertex)");
      }
    }

    void cull_parameterfv_ext(gl::enum_t pname, gl::float_t * params) {
      if ( GLAD_GL_EXT_cull_vertex ) {
        glCullParameterfvEXT(pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCullParameterfvEXT' not available on this platform (extensions: GL_EXT_cull_vertex)");
      }
    }

    void current_palette_matrix_arb(gl::int_t index) {
      if ( GLAD_GL_ARB_matrix_palette ) {
        glCurrentPaletteMatrixARB(index);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCurrentPaletteMatrixARB' not available on this platform (extensions: GL_ARB_matrix_palette)");
      }
    }

    void debug_message_callback(gl::DEBUGPROC_t callback, const  void * userParam) {
      if ( GLAD_GL_KHR_debug ) {
        glDebugMessageCallback(callback, userParam);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDebugMessageCallback' not available on this platform (extensions: GL_KHR_debug)");
      }
    }

    void debug_message_callback_amd(gl::DEBUGPROCAMD_t callback, void * userParam) {
      if ( GLAD_GL_AMD_debug_output ) {
        glDebugMessageCallbackAMD(callback, userParam);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDebugMessageCallbackAMD' not available on this platform (extensions: GL_AMD_debug_output)");
      }
    }

    void debug_message_callback_arb(gl::DEBUGPROCARB_t callback, const  void * userParam) {
      if ( GLAD_GL_ARB_debug_output ) {
        glDebugMessageCallbackARB(callback, userParam);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDebugMessageCallbackARB' not available on this platform (extensions: GL_ARB_debug_output)");
      }
    }

    void debug_message_control(gl::enum_t source, gl::enum_t type, gl::enum_t severity, gl::sizei_t count, const  gl::uint_t * ids, gl::boolean_t enabled) {
      if ( GLAD_GL_KHR_debug ) {
        glDebugMessageControl(source, type, severity, count, ids, enabled);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDebugMessageControl' not available on this platform (extensions: GL_KHR_debug)");
      }
    }

    void debug_message_control_arb(gl::enum_t source, gl::enum_t type, gl::enum_t severity, gl::sizei_t count, const  gl::uint_t * ids, gl::boolean_t enabled) {
      if ( GLAD_GL_ARB_debug_output ) {
        glDebugMessageControlARB(source, type, severity, count, ids, enabled);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDebugMessageControlARB' not available on this platform (extensions: GL_ARB_debug_output)");
      }
    }

    void debug_message_enable_amd(gl::enum_t category, gl::enum_t severity, gl::sizei_t count, const  gl::uint_t * ids, gl::boolean_t enabled) {
      if ( GLAD_GL_AMD_debug_output ) {
        glDebugMessageEnableAMD(category, severity, count, ids, enabled);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDebugMessageEnableAMD' not available on this platform (extensions: GL_AMD_debug_output)");
      }
    }

    void debug_message_insert(gl::enum_t source, gl::enum_t type, gl::uint_t id, gl::enum_t severity, gl::sizei_t length, const  gl::char_t * buf) {
      if ( GLAD_GL_KHR_debug ) {
        glDebugMessageInsert(source, type, id, severity, length, buf);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDebugMessageInsert' not available on this platform (extensions: GL_KHR_debug)");
      }
    }

    void debug_message_insert_amd(gl::enum_t category, gl::enum_t severity, gl::uint_t id, gl::sizei_t length, const  gl::char_t * buf) {
      if ( GLAD_GL_AMD_debug_output ) {
        glDebugMessageInsertAMD(category, severity, id, length, buf);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDebugMessageInsertAMD' not available on this platform (extensions: GL_AMD_debug_output)");
      }
    }

    void debug_message_insert_arb(gl::enum_t source, gl::enum_t type, gl::uint_t id, gl::enum_t severity, gl::sizei_t length, const  gl::char_t * buf) {
      if ( GLAD_GL_ARB_debug_output ) {
        glDebugMessageInsertARB(source, type, id, severity, length, buf);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDebugMessageInsertARB' not available on this platform (extensions: GL_ARB_debug_output)");
      }
    }

    void deform_sgix(gl::bitmask<ffd_mask_sgix_flags_t> mask) {
      if ( GLAD_GL_SGIX_polynomial_ffd ) {
        glDeformSGIX(static_cast<GLbitfield>(mask.value));
      }
      else {
        throw std::runtime_error("OpenGL command 'glDeformSGIX' not available on this platform (extensions: GL_SGIX_polynomial_ffd)");
      }
    }

    void deformation_map_3d_sgix(ffd_target_sgix_t target, gl::double_t u1, gl::double_t u2, gl::int_t ustride, gl::int_t uorder, gl::double_t v1, gl::double_t v2, gl::int_t vstride, gl::int_t vorder, gl::double_t w1, gl::double_t w2, gl::int_t wstride, gl::int_t worder, const  gl::double_t * points) {
      if ( GLAD_GL_SGIX_polynomial_ffd ) {
        glDeformationMap3dSGIX(static_cast<GLenum>(target), u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDeformationMap3dSGIX' not available on this platform (extensions: GL_SGIX_polynomial_ffd)");
      }
    }

    void deformation_map_3f_sgix(ffd_target_sgix_t target, gl::float_t u1, gl::float_t u2, gl::int_t ustride, gl::int_t uorder, gl::float_t v1, gl::float_t v2, gl::int_t vstride, gl::int_t vorder, gl::float_t w1, gl::float_t w2, gl::int_t wstride, gl::int_t worder, const  gl::float_t * points) {
      if ( GLAD_GL_SGIX_polynomial_ffd ) {
        glDeformationMap3fSGIX(static_cast<GLenum>(target), u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDeformationMap3fSGIX' not available on this platform (extensions: GL_SGIX_polynomial_ffd)");
      }
    }

    void delete_async_markers_sgix(gl::uint_t marker, gl::sizei_t range) {
      if ( GLAD_GL_SGIX_async ) {
        glDeleteAsyncMarkersSGIX(marker, range);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDeleteAsyncMarkersSGIX' not available on this platform (extensions: GL_SGIX_async)");
      }
    }

    void delete_buffers_arb(gl::sizei_t n, const  gl::uint_t * buffers) {
      if ( GLAD_GL_ARB_vertex_buffer_object ) {
        glDeleteBuffersARB(n, buffers);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDeleteBuffersARB' not available on this platform (extensions: GL_ARB_vertex_buffer_object)");
      }
    }

    void delete_fences_apple(gl::sizei_t n, const  gl::uint_t * fences) {
      if ( GLAD_GL_APPLE_fence ) {
        glDeleteFencesAPPLE(n, fences);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDeleteFencesAPPLE' not available on this platform (extensions: GL_APPLE_fence)");
      }
    }

    void delete_fences_nv(gl::sizei_t n, const  gl::uint_t * fences) {
      if ( GLAD_GL_NV_fence ) {
        glDeleteFencesNV(n, fences);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDeleteFencesNV' not available on this platform (extensions: GL_NV_fence)");
      }
    }

    void delete_fragment_shader_ati(gl::uint_t id) {
      if ( GLAD_GL_ATI_fragment_shader ) {
        glDeleteFragmentShaderATI(id);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDeleteFragmentShaderATI' not available on this platform (extensions: GL_ATI_fragment_shader)");
      }
    }

    void delete_framebuffers(gl::sizei_t n, const  gl::uint_t * framebuffers) {
      if ( GLAD_GL_ARB_framebuffer_object ) {
        glDeleteFramebuffers(n, framebuffers);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDeleteFramebuffers' not available on this platform (extensions: GL_ARB_framebuffer_object)");
      }
    }

    void delete_framebuffers_ext(gl::sizei_t n, const  gl::uint_t * framebuffers) {
      if ( GLAD_GL_EXT_framebuffer_object ) {
        glDeleteFramebuffersEXT(n, framebuffers);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDeleteFramebuffersEXT' not available on this platform (extensions: GL_EXT_framebuffer_object)");
      }
    }

    void delete_named_string_arb(gl::int_t namelen, const  gl::char_t * name) {
      if ( GLAD_GL_ARB_shading_language_include ) {
        glDeleteNamedStringARB(namelen, name);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDeleteNamedStringARB' not available on this platform (extensions: GL_ARB_shading_language_include)");
      }
    }

    void delete_names_amd(gl::enum_t identifier, gl::uint_t num, const  gl::uint_t * names) {
      if ( GLAD_GL_AMD_name_gen_delete ) {
        glDeleteNamesAMD(identifier, num, names);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDeleteNamesAMD' not available on this platform (extensions: GL_AMD_name_gen_delete)");
      }
    }

    void delete_object_arb(gl::handleARB_t obj) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glDeleteObjectARB(obj);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDeleteObjectARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void delete_occlusion_queries_nv(gl::sizei_t n, const  gl::uint_t * ids) {
      if ( GLAD_GL_NV_occlusion_query ) {
        glDeleteOcclusionQueriesNV(n, ids);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDeleteOcclusionQueriesNV' not available on this platform (extensions: GL_NV_occlusion_query)");
      }
    }

    void delete_paths_nv(gl::uint_t path, gl::sizei_t range) {
      if ( GLAD_GL_NV_path_rendering ) {
        glDeletePathsNV(path, range);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDeletePathsNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void delete_perf_monitors_amd(gl::sizei_t n, gl::uint_t * monitors) {
      if ( GLAD_GL_AMD_performance_monitor ) {
        glDeletePerfMonitorsAMD(n, monitors);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDeletePerfMonitorsAMD' not available on this platform (extensions: GL_AMD_performance_monitor)");
      }
    }

    void delete_perf_query_intel(gl::uint_t queryHandle) {
      if ( GLAD_GL_INTEL_performance_query ) {
        glDeletePerfQueryINTEL(queryHandle);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDeletePerfQueryINTEL' not available on this platform (extensions: GL_INTEL_performance_query)");
      }
    }

    void delete_program_pipelines(gl::sizei_t n, const  gl::uint_t * pipelines) {
      if ( GLAD_GL_ARB_separate_shader_objects ) {
        glDeleteProgramPipelines(n, pipelines);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDeleteProgramPipelines' not available on this platform (extensions: GL_ARB_separate_shader_objects)");
      }
    }

    void delete_programs_arb(gl::sizei_t n, const  gl::uint_t * programs) {
      if ( GLAD_GL_ARB_fragment_program || GLAD_GL_ARB_vertex_program ) {
        glDeleteProgramsARB(n, programs);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDeleteProgramsARB' not available on this platform (extensions: GL_ARB_fragment_program, GL_ARB_vertex_program)");
      }
    }

    void delete_programs_nv(gl::sizei_t n, const  gl::uint_t * programs) {
      if ( GLAD_GL_NV_vertex_program ) {
        glDeleteProgramsNV(n, programs);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDeleteProgramsNV' not available on this platform (extensions: GL_NV_vertex_program)");
      }
    }

    void delete_queries_arb(gl::sizei_t n, const  gl::uint_t * ids) {
      if ( GLAD_GL_ARB_occlusion_query ) {
        glDeleteQueriesARB(n, ids);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDeleteQueriesARB' not available on this platform (extensions: GL_ARB_occlusion_query)");
      }
    }

    void delete_renderbuffers(gl::sizei_t n, const  gl::uint_t * renderbuffers) {
      if ( GLAD_GL_ARB_framebuffer_object ) {
        glDeleteRenderbuffers(n, renderbuffers);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDeleteRenderbuffers' not available on this platform (extensions: GL_ARB_framebuffer_object)");
      }
    }

    void delete_renderbuffers_ext(gl::sizei_t n, const  gl::uint_t * renderbuffers) {
      if ( GLAD_GL_EXT_framebuffer_object ) {
        glDeleteRenderbuffersEXT(n, renderbuffers);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDeleteRenderbuffersEXT' not available on this platform (extensions: GL_EXT_framebuffer_object)");
      }
    }

    void delete_samplers(gl::sizei_t count, const  gl::uint_t * samplers) {
      if ( GLAD_GL_ARB_sampler_objects ) {
        glDeleteSamplers(count, samplers);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDeleteSamplers' not available on this platform (extensions: GL_ARB_sampler_objects)");
      }
    }

    void delete_sync(gl::sync_t sync) {
      if ( GLAD_GL_ARB_sync ) {
        glDeleteSync(sync);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDeleteSync' not available on this platform (extensions: GL_ARB_sync)");
      }
    }

    void delete_textures_ext(gl::sizei_t n, const  gl::uint_t * textures) {
      if ( GLAD_GL_EXT_texture_object ) {
        glDeleteTexturesEXT(n, textures);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDeleteTexturesEXT' not available on this platform (extensions: GL_EXT_texture_object)");
      }
    }

    void delete_transform_feedbacks(gl::sizei_t n, const  gl::uint_t * ids) {
      if ( GLAD_GL_ARB_transform_feedback2 ) {
        glDeleteTransformFeedbacks(n, ids);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDeleteTransformFeedbacks' not available on this platform (extensions: GL_ARB_transform_feedback2)");
      }
    }

    void delete_transform_feedbacks_nv(gl::sizei_t n, const  gl::uint_t * ids) {
      if ( GLAD_GL_NV_transform_feedback2 ) {
        glDeleteTransformFeedbacksNV(n, ids);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDeleteTransformFeedbacksNV' not available on this platform (extensions: GL_NV_transform_feedback2)");
      }
    }

    void delete_vertex_arrays(gl::sizei_t n, const  gl::uint_t * arrays) {
      if ( GLAD_GL_ARB_vertex_array_object ) {
        glDeleteVertexArrays(n, arrays);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDeleteVertexArrays' not available on this platform (extensions: GL_ARB_vertex_array_object)");
      }
    }

    void delete_vertex_arrays_apple(gl::sizei_t n, const  gl::uint_t * arrays) {
      if ( GLAD_GL_APPLE_vertex_array_object ) {
        glDeleteVertexArraysAPPLE(n, arrays);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDeleteVertexArraysAPPLE' not available on this platform (extensions: GL_APPLE_vertex_array_object)");
      }
    }

    void delete_vertex_shader_ext(gl::uint_t id) {
      if ( GLAD_GL_EXT_vertex_shader ) {
        glDeleteVertexShaderEXT(id);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDeleteVertexShaderEXT' not available on this platform (extensions: GL_EXT_vertex_shader)");
      }
    }

    void depth_bounds_ext(gl::clampd_t zmin, gl::clampd_t zmax) {
      if ( GLAD_GL_EXT_depth_bounds_test ) {
        glDepthBoundsEXT(zmin, zmax);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDepthBoundsEXT' not available on this platform (extensions: GL_EXT_depth_bounds_test)");
      }
    }

    void depth_boundsd_nv(gl::double_t zmin, gl::double_t zmax) {
      if ( GLAD_GL_NV_depth_buffer_float ) {
        glDepthBoundsdNV(zmin, zmax);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDepthBoundsdNV' not available on this platform (extensions: GL_NV_depth_buffer_float)");
      }
    }

    void depth_range_arrayv(gl::uint_t first, gl::sizei_t count, const  gl::double_t * v) {
      if ( GLAD_GL_ARB_viewport_array ) {
        glDepthRangeArrayv(first, count, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDepthRangeArrayv' not available on this platform (extensions: GL_ARB_viewport_array)");
      }
    }

    void depth_range_indexed(gl::uint_t index, gl::double_t n, gl::double_t f) {
      if ( GLAD_GL_ARB_viewport_array ) {
        glDepthRangeIndexed(index, n, f);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDepthRangeIndexed' not available on this platform (extensions: GL_ARB_viewport_array)");
      }
    }

    void depth_ranged_nv(gl::double_t zNear, gl::double_t zFar) {
      if ( GLAD_GL_NV_depth_buffer_float ) {
        glDepthRangedNV(zNear, zFar);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDepthRangedNV' not available on this platform (extensions: GL_NV_depth_buffer_float)");
      }
    }

    void depth_rangef(gl::float_t n, gl::float_t f) {
      if ( GLAD_GL_ARB_ES2_compatibility ) {
        glDepthRangef(n, f);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDepthRangef' not available on this platform (extensions: GL_ARB_ES2_compatibility)");
      }
    }

    void depth_rangef_oes(gl::clampf_t n, gl::clampf_t f) {
      if ( GLAD_GL_OES_single_precision ) {
        glDepthRangefOES(n, f);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDepthRangefOES' not available on this platform (extensions: GL_OES_single_precision)");
      }
    }

    void depth_rangex_oes(gl::fixed_t n, gl::fixed_t f) {
      if ( GLAD_GL_OES_fixed_point ) {
        glDepthRangexOES(n, f);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDepthRangexOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void detach_object_arb(gl::handleARB_t containerObj, gl::handleARB_t attachedObj) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glDetachObjectARB(containerObj, attachedObj);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDetachObjectARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void detail_tex_func_sgis(texture_target_t target, gl::sizei_t n, const  gl::float_t * points) {
      if ( GLAD_GL_SGIS_detail_texture ) {
        glDetailTexFuncSGIS(static_cast<GLenum>(target), n, points);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDetailTexFuncSGIS' not available on this platform (extensions: GL_SGIS_detail_texture)");
      }
    }

    void disable_client_state_indexed_ext(enable_cap_t array, gl::uint_t index) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glDisableClientStateIndexedEXT(static_cast<GLenum>(array), index);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDisableClientStateIndexedEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void disable_client_statei_ext(enable_cap_t array, gl::uint_t index) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glDisableClientStateiEXT(static_cast<GLenum>(array), index);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDisableClientStateiEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void disable_indexed_ext(gl::enum_t target, gl::uint_t index) {
      if ( GLAD_GL_EXT_direct_state_access || GLAD_GL_EXT_draw_buffers2 ) {
        glDisableIndexedEXT(target, index);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDisableIndexedEXT' not available on this platform (extensions: GL_EXT_direct_state_access, GL_EXT_draw_buffers2)");
      }
    }

    void disable_variant_client_state_ext(gl::uint_t id) {
      if ( GLAD_GL_EXT_vertex_shader ) {
        glDisableVariantClientStateEXT(id);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDisableVariantClientStateEXT' not available on this platform (extensions: GL_EXT_vertex_shader)");
      }
    }

    void disable_vertex_array_attrib(gl::uint_t vaobj, gl::uint_t index) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glDisableVertexArrayAttrib(vaobj, index);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDisableVertexArrayAttrib' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void disable_vertex_array_attrib_ext(gl::uint_t vaobj, gl::uint_t index) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glDisableVertexArrayAttribEXT(vaobj, index);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDisableVertexArrayAttribEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void disable_vertex_array_ext(gl::uint_t vaobj, enable_cap_t array) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glDisableVertexArrayEXT(vaobj, static_cast<GLenum>(array));
      }
      else {
        throw std::runtime_error("OpenGL command 'glDisableVertexArrayEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void disable_vertex_attrib_apple(gl::uint_t index, gl::enum_t pname) {
      if ( GLAD_GL_APPLE_vertex_program_evaluators ) {
        glDisableVertexAttribAPPLE(index, pname);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDisableVertexAttribAPPLE' not available on this platform (extensions: GL_APPLE_vertex_program_evaluators)");
      }
    }

    void disable_vertex_attrib_array_arb(gl::uint_t index) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glDisableVertexAttribArrayARB(index);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDisableVertexAttribArrayARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void dispatch_compute(gl::uint_t num_groups_x, gl::uint_t num_groups_y, gl::uint_t num_groups_z) {
      if ( GLAD_GL_ARB_compute_shader ) {
        glDispatchCompute(num_groups_x, num_groups_y, num_groups_z);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDispatchCompute' not available on this platform (extensions: GL_ARB_compute_shader)");
      }
    }

    void dispatch_compute_group_size_arb(gl::uint_t num_groups_x, gl::uint_t num_groups_y, gl::uint_t num_groups_z, gl::uint_t group_size_x, gl::uint_t group_size_y, gl::uint_t group_size_z) {
      if ( GLAD_GL_ARB_compute_variable_group_size ) {
        glDispatchComputeGroupSizeARB(num_groups_x, num_groups_y, num_groups_z, group_size_x, group_size_y, group_size_z);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDispatchComputeGroupSizeARB' not available on this platform (extensions: GL_ARB_compute_variable_group_size)");
      }
    }

    void dispatch_compute_indirect(gl::intptr_t indirect) {
      if ( GLAD_GL_ARB_compute_shader ) {
        glDispatchComputeIndirect(indirect);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDispatchComputeIndirect' not available on this platform (extensions: GL_ARB_compute_shader)");
      }
    }

    void draw_arrays_ext(primitive_type_t mode, gl::int_t first, gl::sizei_t count) {
      if ( GLAD_GL_EXT_vertex_array ) {
        glDrawArraysEXT(static_cast<GLenum>(mode), first, count);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDrawArraysEXT' not available on this platform (extensions: GL_EXT_vertex_array)");
      }
    }

    void draw_arrays_indirect(primitive_type_t mode, const  void * indirect) {
      if ( GLAD_GL_ARB_draw_indirect ) {
        glDrawArraysIndirect(static_cast<GLenum>(mode), indirect);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDrawArraysIndirect' not available on this platform (extensions: GL_ARB_draw_indirect)");
      }
    }

    void draw_arrays_instanced_arb(primitive_type_t mode, gl::int_t first, gl::sizei_t count, gl::sizei_t primcount) {
      if ( GLAD_GL_ARB_draw_instanced ) {
        glDrawArraysInstancedARB(static_cast<GLenum>(mode), first, count, primcount);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDrawArraysInstancedARB' not available on this platform (extensions: GL_ARB_draw_instanced)");
      }
    }

    void draw_arrays_instanced_base_instance(primitive_type_t mode, gl::int_t first, gl::sizei_t count, gl::sizei_t instancecount, gl::uint_t baseinstance) {
      if ( GLAD_GL_ARB_base_instance ) {
        glDrawArraysInstancedBaseInstance(static_cast<GLenum>(mode), first, count, instancecount, baseinstance);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDrawArraysInstancedBaseInstance' not available on this platform (extensions: GL_ARB_base_instance)");
      }
    }

    void draw_arrays_instanced_ext(primitive_type_t mode, gl::int_t start, gl::sizei_t count, gl::sizei_t primcount) {
      if ( GLAD_GL_EXT_draw_instanced ) {
        glDrawArraysInstancedEXT(static_cast<GLenum>(mode), start, count, primcount);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDrawArraysInstancedEXT' not available on this platform (extensions: GL_EXT_draw_instanced)");
      }
    }

    void draw_buffers_arb(gl::sizei_t n, const  gl::enum_t * bufs) {
      if ( GLAD_GL_ARB_draw_buffers ) {
        glDrawBuffersARB(n, bufs);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDrawBuffersARB' not available on this platform (extensions: GL_ARB_draw_buffers)");
      }
    }

    void draw_buffers_ati(gl::sizei_t n, const  gl::enum_t * bufs) {
      if ( GLAD_GL_ATI_draw_buffers ) {
        glDrawBuffersATI(n, bufs);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDrawBuffersATI' not available on this platform (extensions: GL_ATI_draw_buffers)");
      }
    }

    void draw_element_array_apple(primitive_type_t mode, gl::int_t first, gl::sizei_t count) {
      if ( GLAD_GL_APPLE_element_array ) {
        glDrawElementArrayAPPLE(static_cast<GLenum>(mode), first, count);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDrawElementArrayAPPLE' not available on this platform (extensions: GL_APPLE_element_array)");
      }
    }

    void draw_element_array_ati(primitive_type_t mode, gl::sizei_t count) {
      if ( GLAD_GL_ATI_element_array ) {
        glDrawElementArrayATI(static_cast<GLenum>(mode), count);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDrawElementArrayATI' not available on this platform (extensions: GL_ATI_element_array)");
      }
    }

    void draw_elements_base_vertex(primitive_type_t mode, gl::sizei_t count, draw_elements_type_t type, const  void * indices, gl::int_t basevertex) {
      if ( GLAD_GL_ARB_draw_elements_base_vertex ) {
        glDrawElementsBaseVertex(static_cast<GLenum>(mode), count, static_cast<GLenum>(type), indices, basevertex);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDrawElementsBaseVertex' not available on this platform (extensions: GL_ARB_draw_elements_base_vertex)");
      }
    }

    void draw_elements_indirect(primitive_type_t mode, gl::enum_t type, const  void * indirect) {
      if ( GLAD_GL_ARB_draw_indirect ) {
        glDrawElementsIndirect(static_cast<GLenum>(mode), type, indirect);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDrawElementsIndirect' not available on this platform (extensions: GL_ARB_draw_indirect)");
      }
    }

    void draw_elements_instanced_arb(primitive_type_t mode, gl::sizei_t count, draw_elements_type_t type, const  void * indices, gl::sizei_t primcount) {
      if ( GLAD_GL_ARB_draw_instanced ) {
        glDrawElementsInstancedARB(static_cast<GLenum>(mode), count, static_cast<GLenum>(type), indices, primcount);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDrawElementsInstancedARB' not available on this platform (extensions: GL_ARB_draw_instanced)");
      }
    }

    void draw_elements_instanced_base_instance(primitive_type_t mode, gl::sizei_t count, gl::enum_t type, const  void * indices, gl::sizei_t instancecount, gl::uint_t baseinstance) {
      if ( GLAD_GL_ARB_base_instance ) {
        glDrawElementsInstancedBaseInstance(static_cast<GLenum>(mode), count, type, indices, instancecount, baseinstance);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDrawElementsInstancedBaseInstance' not available on this platform (extensions: GL_ARB_base_instance)");
      }
    }

    void draw_elements_instanced_base_vertex(primitive_type_t mode, gl::sizei_t count, draw_elements_type_t type, const  void * indices, gl::sizei_t instancecount, gl::int_t basevertex) {
      if ( GLAD_GL_ARB_draw_elements_base_vertex ) {
        glDrawElementsInstancedBaseVertex(static_cast<GLenum>(mode), count, static_cast<GLenum>(type), indices, instancecount, basevertex);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDrawElementsInstancedBaseVertex' not available on this platform (extensions: GL_ARB_draw_elements_base_vertex)");
      }
    }

    void draw_elements_instanced_base_vertex_base_instance(primitive_type_t mode, gl::sizei_t count, gl::enum_t type, const  void * indices, gl::sizei_t instancecount, gl::int_t basevertex, gl::uint_t baseinstance) {
      if ( GLAD_GL_ARB_base_instance ) {
        glDrawElementsInstancedBaseVertexBaseInstance(static_cast<GLenum>(mode), count, type, indices, instancecount, basevertex, baseinstance);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDrawElementsInstancedBaseVertexBaseInstance' not available on this platform (extensions: GL_ARB_base_instance)");
      }
    }

    void draw_elements_instanced_ext(primitive_type_t mode, gl::sizei_t count, draw_elements_type_t type, const  void * indices, gl::sizei_t primcount) {
      if ( GLAD_GL_EXT_draw_instanced ) {
        glDrawElementsInstancedEXT(static_cast<GLenum>(mode), count, static_cast<GLenum>(type), indices, primcount);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDrawElementsInstancedEXT' not available on this platform (extensions: GL_EXT_draw_instanced)");
      }
    }

    void draw_mesh_arrays_sun(primitive_type_t mode, gl::int_t first, gl::sizei_t count, gl::sizei_t width) {
      if ( GLAD_GL_SUN_mesh_array ) {
        glDrawMeshArraysSUN(static_cast<GLenum>(mode), first, count, width);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDrawMeshArraysSUN' not available on this platform (extensions: GL_SUN_mesh_array)");
      }
    }

    void draw_range_element_array_apple(primitive_type_t mode, gl::uint_t start, gl::uint_t end, gl::int_t first, gl::sizei_t count) {
      if ( GLAD_GL_APPLE_element_array ) {
        glDrawRangeElementArrayAPPLE(static_cast<GLenum>(mode), start, end, first, count);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDrawRangeElementArrayAPPLE' not available on this platform (extensions: GL_APPLE_element_array)");
      }
    }

    void draw_range_element_array_ati(primitive_type_t mode, gl::uint_t start, gl::uint_t end, gl::sizei_t count) {
      if ( GLAD_GL_ATI_element_array ) {
        glDrawRangeElementArrayATI(static_cast<GLenum>(mode), start, end, count);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDrawRangeElementArrayATI' not available on this platform (extensions: GL_ATI_element_array)");
      }
    }

    void draw_range_elements_base_vertex(primitive_type_t mode, gl::uint_t start, gl::uint_t end, gl::sizei_t count, draw_elements_type_t type, const  void * indices, gl::int_t basevertex) {
      if ( GLAD_GL_ARB_draw_elements_base_vertex ) {
        glDrawRangeElementsBaseVertex(static_cast<GLenum>(mode), start, end, count, static_cast<GLenum>(type), indices, basevertex);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDrawRangeElementsBaseVertex' not available on this platform (extensions: GL_ARB_draw_elements_base_vertex)");
      }
    }

    void draw_range_elements_ext(primitive_type_t mode, gl::uint_t start, gl::uint_t end, gl::sizei_t count, draw_elements_type_t type, const  void * indices) {
      if ( GLAD_GL_EXT_draw_range_elements ) {
        glDrawRangeElementsEXT(static_cast<GLenum>(mode), start, end, count, static_cast<GLenum>(type), indices);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDrawRangeElementsEXT' not available on this platform (extensions: GL_EXT_draw_range_elements)");
      }
    }

    void draw_texture_nv(gl::uint_t texture, gl::uint_t sampler, gl::float_t x0, gl::float_t y0, gl::float_t x1, gl::float_t y1, gl::float_t z, gl::float_t s0, gl::float_t t0, gl::float_t s1, gl::float_t t1) {
      if ( GLAD_GL_NV_draw_texture ) {
        glDrawTextureNV(texture, sampler, x0, y0, x1, y1, z, s0, t0, s1, t1);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDrawTextureNV' not available on this platform (extensions: GL_NV_draw_texture)");
      }
    }

    void draw_transform_feedback(primitive_type_t mode, gl::uint_t id) {
      if ( GLAD_GL_ARB_transform_feedback2 ) {
        glDrawTransformFeedback(static_cast<GLenum>(mode), id);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDrawTransformFeedback' not available on this platform (extensions: GL_ARB_transform_feedback2)");
      }
    }

    void draw_transform_feedback_instanced(primitive_type_t mode, gl::uint_t id, gl::sizei_t instancecount) {
      if ( GLAD_GL_ARB_transform_feedback_instanced ) {
        glDrawTransformFeedbackInstanced(static_cast<GLenum>(mode), id, instancecount);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDrawTransformFeedbackInstanced' not available on this platform (extensions: GL_ARB_transform_feedback_instanced)");
      }
    }

    void draw_transform_feedback_nv(primitive_type_t mode, gl::uint_t id) {
      if ( GLAD_GL_NV_transform_feedback2 ) {
        glDrawTransformFeedbackNV(static_cast<GLenum>(mode), id);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDrawTransformFeedbackNV' not available on this platform (extensions: GL_NV_transform_feedback2)");
      }
    }

    void draw_transform_feedback_stream(primitive_type_t mode, gl::uint_t id, gl::uint_t stream) {
      if ( GLAD_GL_ARB_transform_feedback3 ) {
        glDrawTransformFeedbackStream(static_cast<GLenum>(mode), id, stream);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDrawTransformFeedbackStream' not available on this platform (extensions: GL_ARB_transform_feedback3)");
      }
    }

    void draw_transform_feedback_stream_instanced(primitive_type_t mode, gl::uint_t id, gl::uint_t stream, gl::sizei_t instancecount) {
      if ( GLAD_GL_ARB_transform_feedback_instanced ) {
        glDrawTransformFeedbackStreamInstanced(static_cast<GLenum>(mode), id, stream, instancecount);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDrawTransformFeedbackStreamInstanced' not available on this platform (extensions: GL_ARB_transform_feedback_instanced)");
      }
    }

    void edge_flag_format_nv(gl::sizei_t stride) {
      if ( GLAD_GL_NV_vertex_buffer_unified_memory ) {
        glEdgeFlagFormatNV(stride);
      }
      else {
        throw std::runtime_error("OpenGL command 'glEdgeFlagFormatNV' not available on this platform (extensions: GL_NV_vertex_buffer_unified_memory)");
      }
    }

    void edge_flag_pointer_ext(gl::sizei_t stride, gl::sizei_t count, const  gl::boolean_t * pointer) {
      if ( GLAD_GL_EXT_vertex_array ) {
        glEdgeFlagPointerEXT(stride, count, pointer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glEdgeFlagPointerEXT' not available on this platform (extensions: GL_EXT_vertex_array)");
      }
    }

    void edge_flag_pointer_list_ibm(gl::int_t stride, const  gl::boolean_t ** pointer, gl::int_t ptrstride) {
      if ( GLAD_GL_IBM_vertex_array_lists ) {
        glEdgeFlagPointerListIBM(stride, pointer, ptrstride);
      }
      else {
        throw std::runtime_error("OpenGL command 'glEdgeFlagPointerListIBM' not available on this platform (extensions: GL_IBM_vertex_array_lists)");
      }
    }

    void element_pointer_apple(gl::enum_t type, const  void * pointer) {
      if ( GLAD_GL_APPLE_element_array ) {
        glElementPointerAPPLE(type, pointer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glElementPointerAPPLE' not available on this platform (extensions: GL_APPLE_element_array)");
      }
    }

    void element_pointer_ati(gl::enum_t type, const  void * pointer) {
      if ( GLAD_GL_ATI_element_array ) {
        glElementPointerATI(type, pointer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glElementPointerATI' not available on this platform (extensions: GL_ATI_element_array)");
      }
    }

    void enable_client_state_indexed_ext(enable_cap_t array, gl::uint_t index) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glEnableClientStateIndexedEXT(static_cast<GLenum>(array), index);
      }
      else {
        throw std::runtime_error("OpenGL command 'glEnableClientStateIndexedEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void enable_client_statei_ext(enable_cap_t array, gl::uint_t index) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glEnableClientStateiEXT(static_cast<GLenum>(array), index);
      }
      else {
        throw std::runtime_error("OpenGL command 'glEnableClientStateiEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void enable_indexed_ext(gl::enum_t target, gl::uint_t index) {
      if ( GLAD_GL_EXT_direct_state_access || GLAD_GL_EXT_draw_buffers2 ) {
        glEnableIndexedEXT(target, index);
      }
      else {
        throw std::runtime_error("OpenGL command 'glEnableIndexedEXT' not available on this platform (extensions: GL_EXT_direct_state_access, GL_EXT_draw_buffers2)");
      }
    }

    void enable_variant_client_state_ext(gl::uint_t id) {
      if ( GLAD_GL_EXT_vertex_shader ) {
        glEnableVariantClientStateEXT(id);
      }
      else {
        throw std::runtime_error("OpenGL command 'glEnableVariantClientStateEXT' not available on this platform (extensions: GL_EXT_vertex_shader)");
      }
    }

    void enable_vertex_array_attrib(gl::uint_t vaobj, gl::uint_t index) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glEnableVertexArrayAttrib(vaobj, index);
      }
      else {
        throw std::runtime_error("OpenGL command 'glEnableVertexArrayAttrib' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void enable_vertex_array_attrib_ext(gl::uint_t vaobj, gl::uint_t index) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glEnableVertexArrayAttribEXT(vaobj, index);
      }
      else {
        throw std::runtime_error("OpenGL command 'glEnableVertexArrayAttribEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void enable_vertex_array_ext(gl::uint_t vaobj, enable_cap_t array) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glEnableVertexArrayEXT(vaobj, static_cast<GLenum>(array));
      }
      else {
        throw std::runtime_error("OpenGL command 'glEnableVertexArrayEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void enable_vertex_attrib_apple(gl::uint_t index, gl::enum_t pname) {
      if ( GLAD_GL_APPLE_vertex_program_evaluators ) {
        glEnableVertexAttribAPPLE(index, pname);
      }
      else {
        throw std::runtime_error("OpenGL command 'glEnableVertexAttribAPPLE' not available on this platform (extensions: GL_APPLE_vertex_program_evaluators)");
      }
    }

    void enable_vertex_attrib_array_arb(gl::uint_t index) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glEnableVertexAttribArrayARB(index);
      }
      else {
        throw std::runtime_error("OpenGL command 'glEnableVertexAttribArrayARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void end_conditional_render_nv() {
      if ( GLAD_GL_NV_conditional_render ) {
        glEndConditionalRenderNV();
      }
      else {
        throw std::runtime_error("OpenGL command 'glEndConditionalRenderNV' not available on this platform (extensions: GL_NV_conditional_render)");
      }
    }

    void end_conditional_render_nvx() {
      if ( GLAD_GL_NVX_conditional_render ) {
        glEndConditionalRenderNVX();
      }
      else {
        throw std::runtime_error("OpenGL command 'glEndConditionalRenderNVX' not available on this platform (extensions: GL_NVX_conditional_render)");
      }
    }

    void end_fragment_shader_ati() {
      if ( GLAD_GL_ATI_fragment_shader ) {
        glEndFragmentShaderATI();
      }
      else {
        throw std::runtime_error("OpenGL command 'glEndFragmentShaderATI' not available on this platform (extensions: GL_ATI_fragment_shader)");
      }
    }

    void end_occlusion_query_nv() {
      if ( GLAD_GL_NV_occlusion_query ) {
        glEndOcclusionQueryNV();
      }
      else {
        throw std::runtime_error("OpenGL command 'glEndOcclusionQueryNV' not available on this platform (extensions: GL_NV_occlusion_query)");
      }
    }

    void end_perf_monitor_amd(gl::uint_t monitor) {
      if ( GLAD_GL_AMD_performance_monitor ) {
        glEndPerfMonitorAMD(monitor);
      }
      else {
        throw std::runtime_error("OpenGL command 'glEndPerfMonitorAMD' not available on this platform (extensions: GL_AMD_performance_monitor)");
      }
    }

    void end_perf_query_intel(gl::uint_t queryHandle) {
      if ( GLAD_GL_INTEL_performance_query ) {
        glEndPerfQueryINTEL(queryHandle);
      }
      else {
        throw std::runtime_error("OpenGL command 'glEndPerfQueryINTEL' not available on this platform (extensions: GL_INTEL_performance_query)");
      }
    }

    void end_query_arb(gl::enum_t target) {
      if ( GLAD_GL_ARB_occlusion_query ) {
        glEndQueryARB(target);
      }
      else {
        throw std::runtime_error("OpenGL command 'glEndQueryARB' not available on this platform (extensions: GL_ARB_occlusion_query)");
      }
    }

    void end_query_indexed(gl::enum_t target, gl::uint_t index) {
      if ( GLAD_GL_ARB_transform_feedback3 ) {
        glEndQueryIndexed(target, index);
      }
      else {
        throw std::runtime_error("OpenGL command 'glEndQueryIndexed' not available on this platform (extensions: GL_ARB_transform_feedback3)");
      }
    }

    void end_transform_feedback_ext() {
      if ( GLAD_GL_EXT_transform_feedback ) {
        glEndTransformFeedbackEXT();
      }
      else {
        throw std::runtime_error("OpenGL command 'glEndTransformFeedbackEXT' not available on this platform (extensions: GL_EXT_transform_feedback)");
      }
    }

    void end_transform_feedback_nv() {
      if ( GLAD_GL_NV_transform_feedback ) {
        glEndTransformFeedbackNV();
      }
      else {
        throw std::runtime_error("OpenGL command 'glEndTransformFeedbackNV' not available on this platform (extensions: GL_NV_transform_feedback)");
      }
    }

    void end_vertex_shader_ext() {
      if ( GLAD_GL_EXT_vertex_shader ) {
        glEndVertexShaderEXT();
      }
      else {
        throw std::runtime_error("OpenGL command 'glEndVertexShaderEXT' not available on this platform (extensions: GL_EXT_vertex_shader)");
      }
    }

    void end_video_capture_nv(gl::uint_t video_capture_slot) {
      if ( GLAD_GL_NV_video_capture ) {
        glEndVideoCaptureNV(video_capture_slot);
      }
      else {
        throw std::runtime_error("OpenGL command 'glEndVideoCaptureNV' not available on this platform (extensions: GL_NV_video_capture)");
      }
    }

    void eval_coord_1x_oes(gl::fixed_t u) {
      if ( GLAD_GL_OES_fixed_point ) {
        glEvalCoord1xOES(u);
      }
      else {
        throw std::runtime_error("OpenGL command 'glEvalCoord1xOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void eval_coord_1xv_oes(const  gl::fixed_t * coords) {
      if ( GLAD_GL_OES_fixed_point ) {
        glEvalCoord1xvOES(coords);
      }
      else {
        throw std::runtime_error("OpenGL command 'glEvalCoord1xvOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void eval_coord_2x_oes(gl::fixed_t u, gl::fixed_t v) {
      if ( GLAD_GL_OES_fixed_point ) {
        glEvalCoord2xOES(u, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glEvalCoord2xOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void eval_coord_2xv_oes(const  gl::fixed_t * coords) {
      if ( GLAD_GL_OES_fixed_point ) {
        glEvalCoord2xvOES(coords);
      }
      else {
        throw std::runtime_error("OpenGL command 'glEvalCoord2xvOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void eval_maps_nv(gl::enum_t target, gl::enum_t mode) {
      if ( GLAD_GL_NV_evaluators ) {
        glEvalMapsNV(target, mode);
      }
      else {
        throw std::runtime_error("OpenGL command 'glEvalMapsNV' not available on this platform (extensions: GL_NV_evaluators)");
      }
    }

    void execute_program_nv(gl::enum_t target, gl::uint_t id, const  gl::float_t * params) {
      if ( GLAD_GL_NV_vertex_program ) {
        glExecuteProgramNV(target, id, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glExecuteProgramNV' not available on this platform (extensions: GL_NV_vertex_program)");
      }
    }

    void extract_component_ext(gl::uint_t res, gl::uint_t src, gl::uint_t num) {
      if ( GLAD_GL_EXT_vertex_shader ) {
        glExtractComponentEXT(res, src, num);
      }
      else {
        throw std::runtime_error("OpenGL command 'glExtractComponentEXT' not available on this platform (extensions: GL_EXT_vertex_shader)");
      }
    }

    void feedback_bufferx_oes(gl::sizei_t n, gl::enum_t type, const  gl::fixed_t * buffer) {
      if ( GLAD_GL_OES_fixed_point ) {
        glFeedbackBufferxOES(n, type, buffer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFeedbackBufferxOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    gl::sync_t fence_sync(gl::enum_t condition, gl::bitfield_t flags) {
      if ( GLAD_GL_ARB_sync ) {
        return glFenceSync(condition, flags);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFenceSync' not available on this platform (extensions: GL_ARB_sync)");
      }
    }

    void final_combiner_input_nv(gl::enum_t variable, gl::enum_t input, gl::enum_t mapping, gl::enum_t componentUsage) {
      if ( GLAD_GL_NV_register_combiners ) {
        glFinalCombinerInputNV(variable, input, mapping, componentUsage);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFinalCombinerInputNV' not available on this platform (extensions: GL_NV_register_combiners)");
      }
    }

    gl::int_t finish_async_sgix(gl::uint_t * markerp) {
      if ( GLAD_GL_SGIX_async ) {
        return glFinishAsyncSGIX(markerp);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFinishAsyncSGIX' not available on this platform (extensions: GL_SGIX_async)");
      }
    }

    void finish_fence_apple(gl::uint_t fence) {
      if ( GLAD_GL_APPLE_fence ) {
        glFinishFenceAPPLE(fence);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFinishFenceAPPLE' not available on this platform (extensions: GL_APPLE_fence)");
      }
    }

    void finish_fence_nv(gl::uint_t fence) {
      if ( GLAD_GL_NV_fence ) {
        glFinishFenceNV(fence);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFinishFenceNV' not available on this platform (extensions: GL_NV_fence)");
      }
    }

    void finish_object_apple(gl::enum_t object, gl::int_t name) {
      if ( GLAD_GL_APPLE_fence ) {
        glFinishObjectAPPLE(object, name);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFinishObjectAPPLE' not available on this platform (extensions: GL_APPLE_fence)");
      }
    }

    void finish_texture_sunx() {
      if ( GLAD_GL_SUNX_constant_data ) {
        glFinishTextureSUNX();
      }
      else {
        throw std::runtime_error("OpenGL command 'glFinishTextureSUNX' not available on this platform (extensions: GL_SUNX_constant_data)");
      }
    }

    void flush_mapped_buffer_range(buffer_target_arb_t target, gl::intptr_t offset, gl::sizeiptr_t length) {
      if ( GLAD_GL_ARB_map_buffer_range ) {
        glFlushMappedBufferRange(static_cast<GLenum>(target), offset, length);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFlushMappedBufferRange' not available on this platform (extensions: GL_ARB_map_buffer_range)");
      }
    }

    void flush_mapped_buffer_range_apple(buffer_target_arb_t target, gl::intptr_t offset, gl::sizeiptr_t size) {
      if ( GLAD_GL_APPLE_flush_buffer_range ) {
        glFlushMappedBufferRangeAPPLE(static_cast<GLenum>(target), offset, size);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFlushMappedBufferRangeAPPLE' not available on this platform (extensions: GL_APPLE_flush_buffer_range)");
      }
    }

    void flush_mapped_named_buffer_range(gl::uint_t buffer, gl::intptr_t offset, gl::sizeiptr_t length) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glFlushMappedNamedBufferRange(buffer, offset, length);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFlushMappedNamedBufferRange' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void flush_mapped_named_buffer_range_ext(gl::uint_t buffer, gl::intptr_t offset, gl::sizeiptr_t length) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glFlushMappedNamedBufferRangeEXT(buffer, offset, length);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFlushMappedNamedBufferRangeEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void flush_pixel_data_range_nv(gl::enum_t target) {
      if ( GLAD_GL_NV_pixel_data_range ) {
        glFlushPixelDataRangeNV(target);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFlushPixelDataRangeNV' not available on this platform (extensions: GL_NV_pixel_data_range)");
      }
    }

    void flush_raster_sgix() {
      if ( GLAD_GL_SGIX_flush_raster ) {
        glFlushRasterSGIX();
      }
      else {
        throw std::runtime_error("OpenGL command 'glFlushRasterSGIX' not available on this platform (extensions: GL_SGIX_flush_raster)");
      }
    }

    void flush_static_data_ibm(gl::enum_t target) {
      if ( GLAD_GL_IBM_static_data ) {
        glFlushStaticDataIBM(target);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFlushStaticDataIBM' not available on this platform (extensions: GL_IBM_static_data)");
      }
    }

    void flush_vertex_array_range_apple(gl::sizei_t length, void * pointer) {
      if ( GLAD_GL_APPLE_vertex_array_range ) {
        glFlushVertexArrayRangeAPPLE(length, pointer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFlushVertexArrayRangeAPPLE' not available on this platform (extensions: GL_APPLE_vertex_array_range)");
      }
    }

    void flush_vertex_array_range_nv() {
      if ( GLAD_GL_NV_vertex_array_range ) {
        glFlushVertexArrayRangeNV();
      }
      else {
        throw std::runtime_error("OpenGL command 'glFlushVertexArrayRangeNV' not available on this platform (extensions: GL_NV_vertex_array_range)");
      }
    }

    void fog_coord_format_nv(gl::enum_t type, gl::sizei_t stride) {
      if ( GLAD_GL_NV_vertex_buffer_unified_memory ) {
        glFogCoordFormatNV(type, stride);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFogCoordFormatNV' not available on this platform (extensions: GL_NV_vertex_buffer_unified_memory)");
      }
    }

    void fog_coord_pointer_ext(fog_pointer_type_ext_t type, gl::sizei_t stride, const  void * pointer) {
      if ( GLAD_GL_EXT_fog_coord ) {
        glFogCoordPointerEXT(static_cast<GLenum>(type), stride, pointer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFogCoordPointerEXT' not available on this platform (extensions: GL_EXT_fog_coord)");
      }
    }

    void fog_coord_pointer_list_ibm(fog_pointer_type_ibm_t type, gl::int_t stride, const  void ** pointer, gl::int_t ptrstride) {
      if ( GLAD_GL_IBM_vertex_array_lists ) {
        glFogCoordPointerListIBM(static_cast<GLenum>(type), stride, pointer, ptrstride);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFogCoordPointerListIBM' not available on this platform (extensions: GL_IBM_vertex_array_lists)");
      }
    }

    void fog_coordd_ext(gl::double_t coord) {
      if ( GLAD_GL_EXT_fog_coord ) {
        glFogCoorddEXT(coord);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFogCoorddEXT' not available on this platform (extensions: GL_EXT_fog_coord)");
      }
    }

    void fog_coorddv_ext(const  gl::double_t * coord) {
      if ( GLAD_GL_EXT_fog_coord ) {
        glFogCoorddvEXT(coord);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFogCoorddvEXT' not available on this platform (extensions: GL_EXT_fog_coord)");
      }
    }

    void fog_coordf_ext(gl::float_t coord) {
      if ( GLAD_GL_EXT_fog_coord ) {
        glFogCoordfEXT(coord);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFogCoordfEXT' not available on this platform (extensions: GL_EXT_fog_coord)");
      }
    }

    void fog_coordfv_ext(const  gl::float_t * coord) {
      if ( GLAD_GL_EXT_fog_coord ) {
        glFogCoordfvEXT(coord);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFogCoordfvEXT' not available on this platform (extensions: GL_EXT_fog_coord)");
      }
    }

    void fog_coordh_nv(gl::halfNV_t fog) {
      if ( GLAD_GL_NV_half_float ) {
        glFogCoordhNV(fog);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFogCoordhNV' not available on this platform (extensions: GL_NV_half_float)");
      }
    }

    void fog_coordhv_nv(const  gl::halfNV_t * fog) {
      if ( GLAD_GL_NV_half_float ) {
        glFogCoordhvNV(fog);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFogCoordhvNV' not available on this platform (extensions: GL_NV_half_float)");
      }
    }

    void fog_func_sgis(gl::sizei_t n, const  gl::float_t * points) {
      if ( GLAD_GL_SGIS_fog_function ) {
        glFogFuncSGIS(n, points);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFogFuncSGIS' not available on this platform (extensions: GL_SGIS_fog_function)");
      }
    }

    void fogx_oes(gl::enum_t pname, gl::fixed_t param) {
      if ( GLAD_GL_OES_fixed_point ) {
        glFogxOES(pname, param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFogxOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void fogxv_oes(gl::enum_t pname, const  gl::fixed_t * param) {
      if ( GLAD_GL_OES_fixed_point ) {
        glFogxvOES(pname, param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFogxvOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void fragment_color_material_sgix(material_face_t face, material_parameter_t mode) {
      if ( GLAD_GL_SGIX_fragment_lighting ) {
        glFragmentColorMaterialSGIX(static_cast<GLenum>(face), static_cast<GLenum>(mode));
      }
      else {
        throw std::runtime_error("OpenGL command 'glFragmentColorMaterialSGIX' not available on this platform (extensions: GL_SGIX_fragment_lighting)");
      }
    }

    void fragment_coverage_color_nv(gl::uint_t color) {
      if ( GLAD_GL_NV_fragment_coverage_to_color ) {
        glFragmentCoverageColorNV(color);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFragmentCoverageColorNV' not available on this platform (extensions: GL_NV_fragment_coverage_to_color)");
      }
    }

    void fragment_light_modelf_sgix(fragment_light_model_parameter_sgix_t pname, gl::float_t param) {
      if ( GLAD_GL_SGIX_fragment_lighting ) {
        glFragmentLightModelfSGIX(static_cast<GLenum>(pname), param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFragmentLightModelfSGIX' not available on this platform (extensions: GL_SGIX_fragment_lighting)");
      }
    }

    void fragment_light_modelfv_sgix(fragment_light_model_parameter_sgix_t pname, const  gl::float_t * params) {
      if ( GLAD_GL_SGIX_fragment_lighting ) {
        glFragmentLightModelfvSGIX(static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFragmentLightModelfvSGIX' not available on this platform (extensions: GL_SGIX_fragment_lighting)");
      }
    }

    void fragment_light_modeli_sgix(fragment_light_model_parameter_sgix_t pname, gl::int_t param) {
      if ( GLAD_GL_SGIX_fragment_lighting ) {
        glFragmentLightModeliSGIX(static_cast<GLenum>(pname), param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFragmentLightModeliSGIX' not available on this platform (extensions: GL_SGIX_fragment_lighting)");
      }
    }

    void fragment_light_modeliv_sgix(fragment_light_model_parameter_sgix_t pname, const  gl::int_t * params) {
      if ( GLAD_GL_SGIX_fragment_lighting ) {
        glFragmentLightModelivSGIX(static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFragmentLightModelivSGIX' not available on this platform (extensions: GL_SGIX_fragment_lighting)");
      }
    }

    void fragment_lightf_sgix(gl::enum_t light, gl::enum_t pname, gl::float_t param) {
      if ( GLAD_GL_SGIX_fragment_lighting ) {
        glFragmentLightfSGIX(light, pname, param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFragmentLightfSGIX' not available on this platform (extensions: GL_SGIX_fragment_lighting)");
      }
    }

    void fragment_lightfv_sgix(gl::enum_t light, gl::enum_t pname, const  gl::float_t * params) {
      if ( GLAD_GL_SGIX_fragment_lighting ) {
        glFragmentLightfvSGIX(light, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFragmentLightfvSGIX' not available on this platform (extensions: GL_SGIX_fragment_lighting)");
      }
    }

    void fragment_lighti_sgix(gl::enum_t light, gl::enum_t pname, gl::int_t param) {
      if ( GLAD_GL_SGIX_fragment_lighting ) {
        glFragmentLightiSGIX(light, pname, param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFragmentLightiSGIX' not available on this platform (extensions: GL_SGIX_fragment_lighting)");
      }
    }

    void fragment_lightiv_sgix(gl::enum_t light, gl::enum_t pname, const  gl::int_t * params) {
      if ( GLAD_GL_SGIX_fragment_lighting ) {
        glFragmentLightivSGIX(light, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFragmentLightivSGIX' not available on this platform (extensions: GL_SGIX_fragment_lighting)");
      }
    }

    void fragment_materialf_sgix(material_face_t face, material_parameter_t pname, gl::float_t param) {
      if ( GLAD_GL_SGIX_fragment_lighting ) {
        glFragmentMaterialfSGIX(static_cast<GLenum>(face), static_cast<GLenum>(pname), param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFragmentMaterialfSGIX' not available on this platform (extensions: GL_SGIX_fragment_lighting)");
      }
    }

    void fragment_materialfv_sgix(material_face_t face, material_parameter_t pname, const  gl::float_t * params) {
      if ( GLAD_GL_SGIX_fragment_lighting ) {
        glFragmentMaterialfvSGIX(static_cast<GLenum>(face), static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFragmentMaterialfvSGIX' not available on this platform (extensions: GL_SGIX_fragment_lighting)");
      }
    }

    void fragment_materiali_sgix(material_face_t face, material_parameter_t pname, gl::int_t param) {
      if ( GLAD_GL_SGIX_fragment_lighting ) {
        glFragmentMaterialiSGIX(static_cast<GLenum>(face), static_cast<GLenum>(pname), param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFragmentMaterialiSGIX' not available on this platform (extensions: GL_SGIX_fragment_lighting)");
      }
    }

    void fragment_materialiv_sgix(material_face_t face, material_parameter_t pname, const  gl::int_t * params) {
      if ( GLAD_GL_SGIX_fragment_lighting ) {
        glFragmentMaterialivSGIX(static_cast<GLenum>(face), static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFragmentMaterialivSGIX' not available on this platform (extensions: GL_SGIX_fragment_lighting)");
      }
    }

    void frame_terminator_gremedy() {
      if ( GLAD_GL_GREMEDY_frame_terminator ) {
        glFrameTerminatorGREMEDY();
      }
      else {
        throw std::runtime_error("OpenGL command 'glFrameTerminatorGREMEDY' not available on this platform (extensions: GL_GREMEDY_frame_terminator)");
      }
    }

    void frame_zoom_sgix(gl::int_t factor) {
      if ( GLAD_GL_SGIX_framezoom ) {
        glFrameZoomSGIX(factor);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFrameZoomSGIX' not available on this platform (extensions: GL_SGIX_framezoom)");
      }
    }

    void framebuffer_draw_buffer_ext(gl::uint_t framebuffer, draw_buffer_mode_t mode) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glFramebufferDrawBufferEXT(framebuffer, static_cast<GLenum>(mode));
      }
      else {
        throw std::runtime_error("OpenGL command 'glFramebufferDrawBufferEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void framebuffer_draw_buffers_ext(gl::uint_t framebuffer, gl::sizei_t n, const  draw_buffer_mode_t * bufs) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glFramebufferDrawBuffersEXT(framebuffer, n, reinterpret_cast<const  GLenum *>(bufs));
      }
      else {
        throw std::runtime_error("OpenGL command 'glFramebufferDrawBuffersEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void framebuffer_parameteri(gl::enum_t target, gl::enum_t pname, gl::int_t param) {
      if ( GLAD_GL_ARB_framebuffer_no_attachments ) {
        glFramebufferParameteri(target, pname, param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFramebufferParameteri' not available on this platform (extensions: GL_ARB_framebuffer_no_attachments)");
      }
    }

    void framebuffer_read_buffer_ext(gl::uint_t framebuffer, read_buffer_mode_t mode) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glFramebufferReadBufferEXT(framebuffer, static_cast<GLenum>(mode));
      }
      else {
        throw std::runtime_error("OpenGL command 'glFramebufferReadBufferEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void framebuffer_renderbuffer(framebuffer_target_t target, framebuffer_attachment_t attachment, renderbuffer_target_t renderbuffertarget, gl::uint_t renderbuffer) {
      if ( GLAD_GL_ARB_framebuffer_object ) {
        glFramebufferRenderbuffer(static_cast<GLenum>(target), static_cast<GLenum>(attachment), static_cast<GLenum>(renderbuffertarget), renderbuffer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFramebufferRenderbuffer' not available on this platform (extensions: GL_ARB_framebuffer_object)");
      }
    }

    void framebuffer_renderbuffer_ext(framebuffer_target_t target, framebuffer_attachment_t attachment, renderbuffer_target_t renderbuffertarget, gl::uint_t renderbuffer) {
      if ( GLAD_GL_EXT_framebuffer_object ) {
        glFramebufferRenderbufferEXT(static_cast<GLenum>(target), static_cast<GLenum>(attachment), static_cast<GLenum>(renderbuffertarget), renderbuffer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFramebufferRenderbufferEXT' not available on this platform (extensions: GL_EXT_framebuffer_object)");
      }
    }

    void framebuffer_sample_locationsfv_nv(gl::enum_t target, gl::uint_t start, gl::sizei_t count, const  gl::float_t * v) {
      if ( GLAD_GL_NV_sample_locations ) {
        glFramebufferSampleLocationsfvNV(target, start, count, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFramebufferSampleLocationsfvNV' not available on this platform (extensions: GL_NV_sample_locations)");
      }
    }

    void framebuffer_texture_1d(framebuffer_target_t target, framebuffer_attachment_t attachment, gl::enum_t textarget, gl::uint_t texture, gl::int_t level) {
      if ( GLAD_GL_ARB_framebuffer_object ) {
        glFramebufferTexture1D(static_cast<GLenum>(target), static_cast<GLenum>(attachment), textarget, texture, level);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFramebufferTexture1D' not available on this platform (extensions: GL_ARB_framebuffer_object)");
      }
    }

    void framebuffer_texture_1dext(framebuffer_target_t target, framebuffer_attachment_t attachment, gl::enum_t textarget, gl::uint_t texture, gl::int_t level) {
      if ( GLAD_GL_EXT_framebuffer_object ) {
        glFramebufferTexture1DEXT(static_cast<GLenum>(target), static_cast<GLenum>(attachment), textarget, texture, level);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFramebufferTexture1DEXT' not available on this platform (extensions: GL_EXT_framebuffer_object)");
      }
    }

    void framebuffer_texture_2d(framebuffer_target_t target, framebuffer_attachment_t attachment, framebuffer_texture_target_t textarget, gl::uint_t texture, gl::int_t level) {
      if ( GLAD_GL_ARB_framebuffer_object ) {
        glFramebufferTexture2D(static_cast<GLenum>(target), static_cast<GLenum>(attachment), static_cast<GLenum>(textarget), texture, level);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFramebufferTexture2D' not available on this platform (extensions: GL_ARB_framebuffer_object)");
      }
    }

    void framebuffer_texture_2dext(framebuffer_target_t target, framebuffer_attachment_t attachment, framebuffer_texture_target_t textarget, gl::uint_t texture, gl::int_t level) {
      if ( GLAD_GL_EXT_framebuffer_object ) {
        glFramebufferTexture2DEXT(static_cast<GLenum>(target), static_cast<GLenum>(attachment), static_cast<GLenum>(textarget), texture, level);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFramebufferTexture2DEXT' not available on this platform (extensions: GL_EXT_framebuffer_object)");
      }
    }

    void framebuffer_texture_3d(framebuffer_target_t target, framebuffer_attachment_t attachment, gl::enum_t textarget, gl::uint_t texture, gl::int_t level, gl::int_t zoffset) {
      if ( GLAD_GL_ARB_framebuffer_object ) {
        glFramebufferTexture3D(static_cast<GLenum>(target), static_cast<GLenum>(attachment), textarget, texture, level, zoffset);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFramebufferTexture3D' not available on this platform (extensions: GL_ARB_framebuffer_object)");
      }
    }

    void framebuffer_texture_3dext(framebuffer_target_t target, framebuffer_attachment_t attachment, gl::enum_t textarget, gl::uint_t texture, gl::int_t level, gl::int_t zoffset) {
      if ( GLAD_GL_EXT_framebuffer_object ) {
        glFramebufferTexture3DEXT(static_cast<GLenum>(target), static_cast<GLenum>(attachment), textarget, texture, level, zoffset);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFramebufferTexture3DEXT' not available on this platform (extensions: GL_EXT_framebuffer_object)");
      }
    }

    void framebuffer_texture_arb(framebuffer_target_t target, framebuffer_attachment_t attachment, gl::uint_t texture, gl::int_t level) {
      if ( GLAD_GL_ARB_geometry_shader4 ) {
        glFramebufferTextureARB(static_cast<GLenum>(target), static_cast<GLenum>(attachment), texture, level);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFramebufferTextureARB' not available on this platform (extensions: GL_ARB_geometry_shader4)");
      }
    }

    void framebuffer_texture_ext(framebuffer_target_t target, framebuffer_attachment_t attachment, gl::uint_t texture, gl::int_t level) {
      if ( GLAD_GL_NV_geometry_program4 ) {
        glFramebufferTextureEXT(static_cast<GLenum>(target), static_cast<GLenum>(attachment), texture, level);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFramebufferTextureEXT' not available on this platform (extensions: GL_NV_geometry_program4)");
      }
    }

    void framebuffer_texture_face_arb(framebuffer_target_t target, framebuffer_attachment_t attachment, gl::uint_t texture, gl::int_t level, texture_target_t face) {
      if ( GLAD_GL_ARB_geometry_shader4 ) {
        glFramebufferTextureFaceARB(static_cast<GLenum>(target), static_cast<GLenum>(attachment), texture, level, static_cast<GLenum>(face));
      }
      else {
        throw std::runtime_error("OpenGL command 'glFramebufferTextureFaceARB' not available on this platform (extensions: GL_ARB_geometry_shader4)");
      }
    }

    void framebuffer_texture_face_ext(framebuffer_target_t target, framebuffer_attachment_t attachment, gl::uint_t texture, gl::int_t level, texture_target_t face) {
      if ( GLAD_GL_NV_geometry_program4 ) {
        glFramebufferTextureFaceEXT(static_cast<GLenum>(target), static_cast<GLenum>(attachment), texture, level, static_cast<GLenum>(face));
      }
      else {
        throw std::runtime_error("OpenGL command 'glFramebufferTextureFaceEXT' not available on this platform (extensions: GL_NV_geometry_program4)");
      }
    }

    void framebuffer_texture_layer(framebuffer_target_t target, framebuffer_attachment_t attachment, gl::uint_t texture, gl::int_t level, gl::int_t layer) {
      if ( GLAD_GL_ARB_framebuffer_object ) {
        glFramebufferTextureLayer(static_cast<GLenum>(target), static_cast<GLenum>(attachment), texture, level, layer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFramebufferTextureLayer' not available on this platform (extensions: GL_ARB_framebuffer_object)");
      }
    }

    void framebuffer_texture_layer_arb(framebuffer_target_t target, framebuffer_attachment_t attachment, gl::uint_t texture, gl::int_t level, gl::int_t layer) {
      if ( GLAD_GL_ARB_geometry_shader4 ) {
        glFramebufferTextureLayerARB(static_cast<GLenum>(target), static_cast<GLenum>(attachment), texture, level, layer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFramebufferTextureLayerARB' not available on this platform (extensions: GL_ARB_geometry_shader4)");
      }
    }

    void framebuffer_texture_layer_ext(framebuffer_target_t target, framebuffer_attachment_t attachment, gl::uint_t texture, gl::int_t level, gl::int_t layer) {
      if ( GLAD_GL_EXT_texture_array || GLAD_GL_NV_geometry_program4 ) {
        glFramebufferTextureLayerEXT(static_cast<GLenum>(target), static_cast<GLenum>(attachment), texture, level, layer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFramebufferTextureLayerEXT' not available on this platform (extensions: GL_EXT_texture_array, GL_NV_geometry_program4)");
      }
    }

    void free_object_buffer_ati(gl::uint_t buffer) {
      if ( GLAD_GL_ATI_vertex_array_object ) {
        glFreeObjectBufferATI(buffer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFreeObjectBufferATI' not available on this platform (extensions: GL_ATI_vertex_array_object)");
      }
    }

    void frustumf_oes(gl::float_t l, gl::float_t r, gl::float_t b, gl::float_t t, gl::float_t n, gl::float_t f) {
      if ( GLAD_GL_OES_single_precision ) {
        glFrustumfOES(l, r, b, t, n, f);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFrustumfOES' not available on this platform (extensions: GL_OES_single_precision)");
      }
    }

    void frustumx_oes(gl::fixed_t l, gl::fixed_t r, gl::fixed_t b, gl::fixed_t t, gl::fixed_t n, gl::fixed_t f) {
      if ( GLAD_GL_OES_fixed_point ) {
        glFrustumxOES(l, r, b, t, n, f);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFrustumxOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    gl::uint_t gen_async_markers_sgix(gl::sizei_t range) {
      if ( GLAD_GL_SGIX_async ) {
        return glGenAsyncMarkersSGIX(range);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGenAsyncMarkersSGIX' not available on this platform (extensions: GL_SGIX_async)");
      }
    }

    void gen_buffers_arb(gl::sizei_t n, gl::uint_t * buffers) {
      if ( GLAD_GL_ARB_vertex_buffer_object ) {
        glGenBuffersARB(n, buffers);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGenBuffersARB' not available on this platform (extensions: GL_ARB_vertex_buffer_object)");
      }
    }

    void gen_fences_apple(gl::sizei_t n, gl::uint_t * fences) {
      if ( GLAD_GL_APPLE_fence ) {
        glGenFencesAPPLE(n, fences);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGenFencesAPPLE' not available on this platform (extensions: GL_APPLE_fence)");
      }
    }

    void gen_fences_nv(gl::sizei_t n, gl::uint_t * fences) {
      if ( GLAD_GL_NV_fence ) {
        glGenFencesNV(n, fences);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGenFencesNV' not available on this platform (extensions: GL_NV_fence)");
      }
    }

    gl::uint_t gen_fragment_shaders_ati(gl::uint_t range) {
      if ( GLAD_GL_ATI_fragment_shader ) {
        return glGenFragmentShadersATI(range);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGenFragmentShadersATI' not available on this platform (extensions: GL_ATI_fragment_shader)");
      }
    }

    void gen_framebuffers(gl::sizei_t n, gl::uint_t * framebuffers) {
      if ( GLAD_GL_ARB_framebuffer_object ) {
        glGenFramebuffers(n, framebuffers);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGenFramebuffers' not available on this platform (extensions: GL_ARB_framebuffer_object)");
      }
    }

    void gen_framebuffers_ext(gl::sizei_t n, gl::uint_t * framebuffers) {
      if ( GLAD_GL_EXT_framebuffer_object ) {
        glGenFramebuffersEXT(n, framebuffers);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGenFramebuffersEXT' not available on this platform (extensions: GL_EXT_framebuffer_object)");
      }
    }

    void gen_names_amd(gl::enum_t identifier, gl::uint_t num, gl::uint_t * names) {
      if ( GLAD_GL_AMD_name_gen_delete ) {
        glGenNamesAMD(identifier, num, names);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGenNamesAMD' not available on this platform (extensions: GL_AMD_name_gen_delete)");
      }
    }

    void gen_occlusion_queries_nv(gl::sizei_t n, gl::uint_t * ids) {
      if ( GLAD_GL_NV_occlusion_query ) {
        glGenOcclusionQueriesNV(n, ids);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGenOcclusionQueriesNV' not available on this platform (extensions: GL_NV_occlusion_query)");
      }
    }

    gl::uint_t gen_paths_nv(gl::sizei_t range) {
      if ( GLAD_GL_NV_path_rendering ) {
        return glGenPathsNV(range);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGenPathsNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void gen_perf_monitors_amd(gl::sizei_t n, gl::uint_t * monitors) {
      if ( GLAD_GL_AMD_performance_monitor ) {
        glGenPerfMonitorsAMD(n, monitors);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGenPerfMonitorsAMD' not available on this platform (extensions: GL_AMD_performance_monitor)");
      }
    }

    void gen_program_pipelines(gl::sizei_t n, gl::uint_t * pipelines) {
      if ( GLAD_GL_ARB_separate_shader_objects ) {
        glGenProgramPipelines(n, pipelines);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGenProgramPipelines' not available on this platform (extensions: GL_ARB_separate_shader_objects)");
      }
    }

    void gen_programs_arb(gl::sizei_t n, gl::uint_t * programs) {
      if ( GLAD_GL_ARB_fragment_program || GLAD_GL_ARB_vertex_program ) {
        glGenProgramsARB(n, programs);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGenProgramsARB' not available on this platform (extensions: GL_ARB_fragment_program, GL_ARB_vertex_program)");
      }
    }

    void gen_programs_nv(gl::sizei_t n, gl::uint_t * programs) {
      if ( GLAD_GL_NV_vertex_program ) {
        glGenProgramsNV(n, programs);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGenProgramsNV' not available on this platform (extensions: GL_NV_vertex_program)");
      }
    }

    void gen_queries_arb(gl::sizei_t n, gl::uint_t * ids) {
      if ( GLAD_GL_ARB_occlusion_query ) {
        glGenQueriesARB(n, ids);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGenQueriesARB' not available on this platform (extensions: GL_ARB_occlusion_query)");
      }
    }

    void gen_renderbuffers(gl::sizei_t n, gl::uint_t * renderbuffers) {
      if ( GLAD_GL_ARB_framebuffer_object ) {
        glGenRenderbuffers(n, renderbuffers);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGenRenderbuffers' not available on this platform (extensions: GL_ARB_framebuffer_object)");
      }
    }

    void gen_renderbuffers_ext(gl::sizei_t n, gl::uint_t * renderbuffers) {
      if ( GLAD_GL_EXT_framebuffer_object ) {
        glGenRenderbuffersEXT(n, renderbuffers);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGenRenderbuffersEXT' not available on this platform (extensions: GL_EXT_framebuffer_object)");
      }
    }

    void gen_samplers(gl::sizei_t count, gl::uint_t * samplers) {
      if ( GLAD_GL_ARB_sampler_objects ) {
        glGenSamplers(count, samplers);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGenSamplers' not available on this platform (extensions: GL_ARB_sampler_objects)");
      }
    }

    gl::uint_t gen_symbols_ext(gl::enum_t datatype, gl::enum_t storagetype, gl::enum_t range, gl::uint_t components) {
      if ( GLAD_GL_EXT_vertex_shader ) {
        return glGenSymbolsEXT(datatype, storagetype, range, components);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGenSymbolsEXT' not available on this platform (extensions: GL_EXT_vertex_shader)");
      }
    }

    void gen_textures_ext(gl::sizei_t n, gl::uint_t * textures) {
      if ( GLAD_GL_EXT_texture_object ) {
        glGenTexturesEXT(n, textures);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGenTexturesEXT' not available on this platform (extensions: GL_EXT_texture_object)");
      }
    }

    void gen_transform_feedbacks(gl::sizei_t n, gl::uint_t * ids) {
      if ( GLAD_GL_ARB_transform_feedback2 ) {
        glGenTransformFeedbacks(n, ids);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGenTransformFeedbacks' not available on this platform (extensions: GL_ARB_transform_feedback2)");
      }
    }

    void gen_transform_feedbacks_nv(gl::sizei_t n, gl::uint_t * ids) {
      if ( GLAD_GL_NV_transform_feedback2 ) {
        glGenTransformFeedbacksNV(n, ids);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGenTransformFeedbacksNV' not available on this platform (extensions: GL_NV_transform_feedback2)");
      }
    }

    void gen_vertex_arrays(gl::sizei_t n, gl::uint_t * arrays) {
      if ( GLAD_GL_ARB_vertex_array_object ) {
        glGenVertexArrays(n, arrays);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGenVertexArrays' not available on this platform (extensions: GL_ARB_vertex_array_object)");
      }
    }

    void gen_vertex_arrays_apple(gl::sizei_t n, gl::uint_t * arrays) {
      if ( GLAD_GL_APPLE_vertex_array_object ) {
        glGenVertexArraysAPPLE(n, arrays);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGenVertexArraysAPPLE' not available on this platform (extensions: GL_APPLE_vertex_array_object)");
      }
    }

    gl::uint_t gen_vertex_shaders_ext(gl::uint_t range) {
      if ( GLAD_GL_EXT_vertex_shader ) {
        return glGenVertexShadersEXT(range);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGenVertexShadersEXT' not available on this platform (extensions: GL_EXT_vertex_shader)");
      }
    }

    void generate_mipmap(mipmap_target_t target) {
      if ( GLAD_GL_ARB_framebuffer_object ) {
        glGenerateMipmap(static_cast<GLenum>(target));
      }
      else {
        throw std::runtime_error("OpenGL command 'glGenerateMipmap' not available on this platform (extensions: GL_ARB_framebuffer_object)");
      }
    }

    void generate_mipmap_ext(mipmap_target_t target) {
      if ( GLAD_GL_EXT_framebuffer_object ) {
        glGenerateMipmapEXT(static_cast<GLenum>(target));
      }
      else {
        throw std::runtime_error("OpenGL command 'glGenerateMipmapEXT' not available on this platform (extensions: GL_EXT_framebuffer_object)");
      }
    }

    void generate_multi_tex_mipmap_ext(texture_unit_t texunit, texture_target_t target) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glGenerateMultiTexMipmapEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(target));
      }
      else {
        throw std::runtime_error("OpenGL command 'glGenerateMultiTexMipmapEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void generate_texture_mipmap(gl::uint_t texture) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glGenerateTextureMipmap(texture);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGenerateTextureMipmap' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void generate_texture_mipmap_ext(gl::uint_t texture, texture_target_t target) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glGenerateTextureMipmapEXT(texture, static_cast<GLenum>(target));
      }
      else {
        throw std::runtime_error("OpenGL command 'glGenerateTextureMipmapEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void get_active_atomic_counter_bufferiv(gl::uint_t program, gl::uint_t bufferIndex, gl::enum_t pname, gl::int_t * params) {
      if ( GLAD_GL_ARB_shader_atomic_counters ) {
        glGetActiveAtomicCounterBufferiv(program, bufferIndex, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetActiveAtomicCounterBufferiv' not available on this platform (extensions: GL_ARB_shader_atomic_counters)");
      }
    }

    void get_active_attrib_arb(gl::handleARB_t programObj, gl::uint_t index, gl::sizei_t maxLength, gl::sizei_t * length, gl::int_t * size, attrib_type_t * type, gl::charARB_t * name) {
      if ( GLAD_GL_ARB_vertex_shader ) {
        glGetActiveAttribARB(programObj, index, maxLength, length, size, reinterpret_cast<GLenum *>(type), name);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetActiveAttribARB' not available on this platform (extensions: GL_ARB_vertex_shader)");
      }
    }

    void get_active_subroutine_name(gl::uint_t program, gl::enum_t shadertype, gl::uint_t index, gl::sizei_t bufsize, gl::sizei_t * length, gl::char_t * name) {
      if ( GLAD_GL_ARB_shader_subroutine ) {
        glGetActiveSubroutineName(program, shadertype, index, bufsize, length, name);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetActiveSubroutineName' not available on this platform (extensions: GL_ARB_shader_subroutine)");
      }
    }

    void get_active_subroutine_uniform_name(gl::uint_t program, gl::enum_t shadertype, gl::uint_t index, gl::sizei_t bufsize, gl::sizei_t * length, gl::char_t * name) {
      if ( GLAD_GL_ARB_shader_subroutine ) {
        glGetActiveSubroutineUniformName(program, shadertype, index, bufsize, length, name);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetActiveSubroutineUniformName' not available on this platform (extensions: GL_ARB_shader_subroutine)");
      }
    }

    void get_active_subroutine_uniformiv(gl::uint_t program, gl::enum_t shadertype, gl::uint_t index, gl::enum_t pname, gl::int_t * values) {
      if ( GLAD_GL_ARB_shader_subroutine ) {
        glGetActiveSubroutineUniformiv(program, shadertype, index, pname, values);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetActiveSubroutineUniformiv' not available on this platform (extensions: GL_ARB_shader_subroutine)");
      }
    }

    void get_active_uniform_arb(gl::handleARB_t programObj, gl::uint_t index, gl::sizei_t maxLength, gl::sizei_t * length, gl::int_t * size, uniform_type_t * type, gl::charARB_t * name) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glGetActiveUniformARB(programObj, index, maxLength, length, size, reinterpret_cast<GLenum *>(type), name);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetActiveUniformARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void get_active_uniform_block_name(gl::uint_t program, gl::uint_t uniformBlockIndex, gl::sizei_t bufSize, gl::sizei_t * length, gl::char_t * uniformBlockName) {
      if ( GLAD_GL_ARB_uniform_buffer_object ) {
        glGetActiveUniformBlockName(program, uniformBlockIndex, bufSize, length, uniformBlockName);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetActiveUniformBlockName' not available on this platform (extensions: GL_ARB_uniform_buffer_object)");
      }
    }

    void get_active_uniform_blockiv(gl::uint_t program, gl::uint_t uniformBlockIndex, gl::enum_t pname, gl::int_t * params) {
      if ( GLAD_GL_ARB_uniform_buffer_object ) {
        glGetActiveUniformBlockiv(program, uniformBlockIndex, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetActiveUniformBlockiv' not available on this platform (extensions: GL_ARB_uniform_buffer_object)");
      }
    }

    void get_active_uniform_name(gl::uint_t program, gl::uint_t uniformIndex, gl::sizei_t bufSize, gl::sizei_t * length, gl::char_t * uniformName) {
      if ( GLAD_GL_ARB_uniform_buffer_object ) {
        glGetActiveUniformName(program, uniformIndex, bufSize, length, uniformName);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetActiveUniformName' not available on this platform (extensions: GL_ARB_uniform_buffer_object)");
      }
    }

    void get_active_uniformsiv(gl::uint_t program, gl::sizei_t uniformCount, const  gl::uint_t * uniformIndices, gl::enum_t pname, gl::int_t * params) {
      if ( GLAD_GL_ARB_uniform_buffer_object ) {
        glGetActiveUniformsiv(program, uniformCount, uniformIndices, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetActiveUniformsiv' not available on this platform (extensions: GL_ARB_uniform_buffer_object)");
      }
    }

    void get_active_varying_nv(gl::uint_t program, gl::uint_t index, gl::sizei_t bufSize, gl::sizei_t * length, gl::sizei_t * size, gl::enum_t * type, gl::char_t * name) {
      if ( GLAD_GL_NV_transform_feedback ) {
        glGetActiveVaryingNV(program, index, bufSize, length, size, type, name);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetActiveVaryingNV' not available on this platform (extensions: GL_NV_transform_feedback)");
      }
    }

    void get_array_objectfv_ati(enable_cap_t array, gl::enum_t pname, gl::float_t * params) {
      if ( GLAD_GL_ATI_vertex_array_object ) {
        glGetArrayObjectfvATI(static_cast<GLenum>(array), pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetArrayObjectfvATI' not available on this platform (extensions: GL_ATI_vertex_array_object)");
      }
    }

    void get_array_objectiv_ati(enable_cap_t array, gl::enum_t pname, gl::int_t * params) {
      if ( GLAD_GL_ATI_vertex_array_object ) {
        glGetArrayObjectivATI(static_cast<GLenum>(array), pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetArrayObjectivATI' not available on this platform (extensions: GL_ATI_vertex_array_object)");
      }
    }

    void get_attached_objects_arb(gl::handleARB_t containerObj, gl::sizei_t maxCount, gl::sizei_t * count, gl::handleARB_t * obj) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glGetAttachedObjectsARB(containerObj, maxCount, count, obj);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetAttachedObjectsARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    gl::int_t get_attrib_location_arb(gl::handleARB_t programObj, const  gl::charARB_t * name) {
      if ( GLAD_GL_ARB_vertex_shader ) {
        return glGetAttribLocationARB(programObj, name);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetAttribLocationARB' not available on this platform (extensions: GL_ARB_vertex_shader)");
      }
    }

    void get_boolean_indexedv_ext(gl::enum_t target, gl::uint_t index, gl::boolean_t * data) {
      if ( GLAD_GL_EXT_direct_state_access || GLAD_GL_EXT_draw_buffers2 ) {
        glGetBooleanIndexedvEXT(target, index, data);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetBooleanIndexedvEXT' not available on this platform (extensions: GL_EXT_direct_state_access, GL_EXT_draw_buffers2)");
      }
    }

    void get_buffer_parameteriv_arb(buffer_target_arb_t target, buffer_p_name_arb_t pname, gl::int_t * params) {
      if ( GLAD_GL_ARB_vertex_buffer_object ) {
        glGetBufferParameterivARB(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetBufferParameterivARB' not available on this platform (extensions: GL_ARB_vertex_buffer_object)");
      }
    }

    void get_buffer_parameterui_64v_nv(gl::enum_t target, gl::enum_t pname, gl::uint64EXT_t * params) {
      if ( GLAD_GL_NV_shader_buffer_load ) {
        glGetBufferParameterui64vNV(target, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetBufferParameterui64vNV' not available on this platform (extensions: GL_NV_shader_buffer_load)");
      }
    }

    void get_buffer_pointerv_arb(buffer_target_arb_t target, gl::enum_t pname, void ** params) {
      if ( GLAD_GL_ARB_vertex_buffer_object ) {
        glGetBufferPointervARB(static_cast<GLenum>(target), pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetBufferPointervARB' not available on this platform (extensions: GL_ARB_vertex_buffer_object)");
      }
    }

    void get_buffer_sub_data_arb(buffer_target_arb_t target, gl::intptrARB_t offset, gl::sizeiptrARB_t size, void * data) {
      if ( GLAD_GL_ARB_vertex_buffer_object ) {
        glGetBufferSubDataARB(static_cast<GLenum>(target), offset, size, data);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetBufferSubDataARB' not available on this platform (extensions: GL_ARB_vertex_buffer_object)");
      }
    }

    void get_clip_planef_oes(gl::enum_t plane, gl::float_t * equation) {
      if ( GLAD_GL_OES_single_precision ) {
        glGetClipPlanefOES(plane, equation);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetClipPlanefOES' not available on this platform (extensions: GL_OES_single_precision)");
      }
    }

    void get_clip_planex_oes(gl::enum_t plane, gl::fixed_t * equation) {
      if ( GLAD_GL_OES_fixed_point ) {
        glGetClipPlanexOES(plane, equation);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetClipPlanexOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void get_color_table(gl::enum_t target, pixel_format_t format, pixel_type_t type, void * table) {
      if ( GLAD_GL_ARB_imaging ) {
        glGetColorTable(target, static_cast<GLenum>(format), static_cast<GLenum>(type), table);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetColorTable' not available on this platform (extensions: GL_ARB_imaging)");
      }
    }

    void get_color_table_ext(gl::enum_t target, pixel_format_t format, pixel_type_t type, void * data) {
      if ( GLAD_GL_EXT_paletted_texture ) {
        glGetColorTableEXT(target, static_cast<GLenum>(format), static_cast<GLenum>(type), data);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetColorTableEXT' not available on this platform (extensions: GL_EXT_paletted_texture)");
      }
    }

    void get_color_table_parameterfv(gl::enum_t target, gl::enum_t pname, gl::float_t * params) {
      if ( GLAD_GL_ARB_imaging ) {
        glGetColorTableParameterfv(target, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetColorTableParameterfv' not available on this platform (extensions: GL_ARB_imaging)");
      }
    }

    void get_color_table_parameterfv_ext(gl::enum_t target, gl::enum_t pname, gl::float_t * params) {
      if ( GLAD_GL_EXT_paletted_texture ) {
        glGetColorTableParameterfvEXT(target, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetColorTableParameterfvEXT' not available on this platform (extensions: GL_EXT_paletted_texture)");
      }
    }

    void get_color_table_parameterfv_sgi(color_table_target_sgi_t target, get_color_table_parameter_p_name_sgi_t pname, gl::float_t * params) {
      if ( GLAD_GL_SGI_color_table ) {
        glGetColorTableParameterfvSGI(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetColorTableParameterfvSGI' not available on this platform (extensions: GL_SGI_color_table)");
      }
    }

    void get_color_table_parameteriv(gl::enum_t target, gl::enum_t pname, gl::int_t * params) {
      if ( GLAD_GL_ARB_imaging ) {
        glGetColorTableParameteriv(target, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetColorTableParameteriv' not available on this platform (extensions: GL_ARB_imaging)");
      }
    }

    void get_color_table_parameteriv_ext(gl::enum_t target, gl::enum_t pname, gl::int_t * params) {
      if ( GLAD_GL_EXT_paletted_texture ) {
        glGetColorTableParameterivEXT(target, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetColorTableParameterivEXT' not available on this platform (extensions: GL_EXT_paletted_texture)");
      }
    }

    void get_color_table_parameteriv_sgi(color_table_target_sgi_t target, get_color_table_parameter_p_name_sgi_t pname, gl::int_t * params) {
      if ( GLAD_GL_SGI_color_table ) {
        glGetColorTableParameterivSGI(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetColorTableParameterivSGI' not available on this platform (extensions: GL_SGI_color_table)");
      }
    }

    void get_color_table_sgi(color_table_target_sgi_t target, pixel_format_t format, pixel_type_t type, void * table) {
      if ( GLAD_GL_SGI_color_table ) {
        glGetColorTableSGI(static_cast<GLenum>(target), static_cast<GLenum>(format), static_cast<GLenum>(type), table);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetColorTableSGI' not available on this platform (extensions: GL_SGI_color_table)");
      }
    }

    void get_combiner_input_parameterfv_nv(gl::enum_t stage, gl::enum_t portion, gl::enum_t variable, gl::enum_t pname, gl::float_t * params) {
      if ( GLAD_GL_NV_register_combiners ) {
        glGetCombinerInputParameterfvNV(stage, portion, variable, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetCombinerInputParameterfvNV' not available on this platform (extensions: GL_NV_register_combiners)");
      }
    }

    void get_combiner_input_parameteriv_nv(gl::enum_t stage, gl::enum_t portion, gl::enum_t variable, gl::enum_t pname, gl::int_t * params) {
      if ( GLAD_GL_NV_register_combiners ) {
        glGetCombinerInputParameterivNV(stage, portion, variable, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetCombinerInputParameterivNV' not available on this platform (extensions: GL_NV_register_combiners)");
      }
    }

    void get_combiner_output_parameterfv_nv(gl::enum_t stage, gl::enum_t portion, gl::enum_t pname, gl::float_t * params) {
      if ( GLAD_GL_NV_register_combiners ) {
        glGetCombinerOutputParameterfvNV(stage, portion, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetCombinerOutputParameterfvNV' not available on this platform (extensions: GL_NV_register_combiners)");
      }
    }

    void get_combiner_output_parameteriv_nv(gl::enum_t stage, gl::enum_t portion, gl::enum_t pname, gl::int_t * params) {
      if ( GLAD_GL_NV_register_combiners ) {
        glGetCombinerOutputParameterivNV(stage, portion, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetCombinerOutputParameterivNV' not available on this platform (extensions: GL_NV_register_combiners)");
      }
    }

    void get_combiner_stage_parameterfv_nv(gl::enum_t stage, gl::enum_t pname, gl::float_t * params) {
      if ( GLAD_GL_NV_register_combiners2 ) {
        glGetCombinerStageParameterfvNV(stage, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetCombinerStageParameterfvNV' not available on this platform (extensions: GL_NV_register_combiners2)");
      }
    }

    void get_compressed_multi_tex_image_ext(texture_unit_t texunit, texture_target_t target, gl::int_t lod, void * img) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glGetCompressedMultiTexImageEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(target), lod, img);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetCompressedMultiTexImageEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void get_compressed_tex_image_arb(texture_target_t target, gl::int_t level, void * img) {
      if ( GLAD_GL_ARB_texture_compression ) {
        glGetCompressedTexImageARB(static_cast<GLenum>(target), level, img);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetCompressedTexImageARB' not available on this platform (extensions: GL_ARB_texture_compression)");
      }
    }

    void get_compressed_texture_image(gl::uint_t texture, gl::int_t level, gl::sizei_t bufSize, void * pixels) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glGetCompressedTextureImage(texture, level, bufSize, pixels);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetCompressedTextureImage' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void get_compressed_texture_image_ext(gl::uint_t texture, texture_target_t target, gl::int_t lod, void * img) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glGetCompressedTextureImageEXT(texture, static_cast<GLenum>(target), lod, img);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetCompressedTextureImageEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void get_compressed_texture_sub_image(gl::uint_t texture, gl::int_t level, gl::int_t xoffset, gl::int_t yoffset, gl::int_t zoffset, gl::sizei_t width, gl::sizei_t height, gl::sizei_t depth, gl::sizei_t bufSize, void * pixels) {
      if ( GLAD_GL_ARB_get_texture_sub_image ) {
        glGetCompressedTextureSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth, bufSize, pixels);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetCompressedTextureSubImage' not available on this platform (extensions: GL_ARB_get_texture_sub_image)");
      }
    }

    void get_convolution_filter(gl::enum_t target, pixel_format_t format, pixel_type_t type, void * image) {
      if ( GLAD_GL_ARB_imaging ) {
        glGetConvolutionFilter(target, static_cast<GLenum>(format), static_cast<GLenum>(type), image);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetConvolutionFilter' not available on this platform (extensions: GL_ARB_imaging)");
      }
    }

    void get_convolution_filter_ext(convolution_target_ext_t target, pixel_format_t format, pixel_type_t type, void * image) {
      if ( GLAD_GL_EXT_convolution ) {
        glGetConvolutionFilterEXT(static_cast<GLenum>(target), static_cast<GLenum>(format), static_cast<GLenum>(type), image);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetConvolutionFilterEXT' not available on this platform (extensions: GL_EXT_convolution)");
      }
    }

    void get_convolution_parameterfv(gl::enum_t target, gl::enum_t pname, gl::float_t * params) {
      if ( GLAD_GL_ARB_imaging ) {
        glGetConvolutionParameterfv(target, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetConvolutionParameterfv' not available on this platform (extensions: GL_ARB_imaging)");
      }
    }

    void get_convolution_parameterfv_ext(convolution_target_ext_t target, convolution_parameter_ext_t pname, gl::float_t * params) {
      if ( GLAD_GL_EXT_convolution ) {
        glGetConvolutionParameterfvEXT(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetConvolutionParameterfvEXT' not available on this platform (extensions: GL_EXT_convolution)");
      }
    }

    void get_convolution_parameteriv(gl::enum_t target, gl::enum_t pname, gl::int_t * params) {
      if ( GLAD_GL_ARB_imaging ) {
        glGetConvolutionParameteriv(target, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetConvolutionParameteriv' not available on this platform (extensions: GL_ARB_imaging)");
      }
    }

    void get_convolution_parameteriv_ext(convolution_target_ext_t target, convolution_parameter_ext_t pname, gl::int_t * params) {
      if ( GLAD_GL_EXT_convolution ) {
        glGetConvolutionParameterivEXT(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetConvolutionParameterivEXT' not available on this platform (extensions: GL_EXT_convolution)");
      }
    }

    void get_convolution_parameterxv_oes(gl::enum_t target, gl::enum_t pname, gl::fixed_t * params) {
      if ( GLAD_GL_OES_fixed_point ) {
        glGetConvolutionParameterxvOES(target, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetConvolutionParameterxvOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void get_coverage_modulation_table_nv(gl::sizei_t bufsize, gl::float_t * v) {
      if ( GLAD_GL_NV_framebuffer_mixed_samples ) {
        glGetCoverageModulationTableNV(bufsize, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetCoverageModulationTableNV' not available on this platform (extensions: GL_NV_framebuffer_mixed_samples)");
      }
    }

    gl::uint_t get_debug_message_log(gl::uint_t count, gl::sizei_t bufSize, gl::enum_t * sources, gl::enum_t * types, gl::uint_t * ids, gl::enum_t * severities, gl::sizei_t * lengths, gl::char_t * messageLog) {
      if ( GLAD_GL_KHR_debug ) {
        return glGetDebugMessageLog(count, bufSize, sources, types, ids, severities, lengths, messageLog);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetDebugMessageLog' not available on this platform (extensions: GL_KHR_debug)");
      }
    }

    gl::uint_t get_debug_message_log_amd(gl::uint_t count, gl::sizei_t bufsize, gl::enum_t * categories, gl::uint_t * severities, gl::uint_t * ids, gl::sizei_t * lengths, gl::char_t * message) {
      if ( GLAD_GL_AMD_debug_output ) {
        return glGetDebugMessageLogAMD(count, bufsize, categories, severities, ids, lengths, message);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetDebugMessageLogAMD' not available on this platform (extensions: GL_AMD_debug_output)");
      }
    }

    gl::uint_t get_debug_message_log_arb(gl::uint_t count, gl::sizei_t bufSize, gl::enum_t * sources, gl::enum_t * types, gl::uint_t * ids, gl::enum_t * severities, gl::sizei_t * lengths, gl::char_t * messageLog) {
      if ( GLAD_GL_ARB_debug_output ) {
        return glGetDebugMessageLogARB(count, bufSize, sources, types, ids, severities, lengths, messageLog);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetDebugMessageLogARB' not available on this platform (extensions: GL_ARB_debug_output)");
      }
    }

    void get_detail_tex_func_sgis(texture_target_t target, gl::float_t * points) {
      if ( GLAD_GL_SGIS_detail_texture ) {
        glGetDetailTexFuncSGIS(static_cast<GLenum>(target), points);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetDetailTexFuncSGIS' not available on this platform (extensions: GL_SGIS_detail_texture)");
      }
    }

    void get_double_indexedv_ext(gl::enum_t target, gl::uint_t index, gl::double_t * data) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glGetDoubleIndexedvEXT(target, index, data);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetDoubleIndexedvEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void get_doublei_v(gl::enum_t target, gl::uint_t index, gl::double_t * data) {
      if ( GLAD_GL_ARB_viewport_array ) {
        glGetDoublei_v(target, index, data);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetDoublei_v' not available on this platform (extensions: GL_ARB_viewport_array)");
      }
    }

    void get_doublei_v_ext(gl::enum_t pname, gl::uint_t index, gl::double_t * params) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glGetDoublei_vEXT(pname, index, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetDoublei_vEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void get_fenceiv_nv(gl::uint_t fence, gl::enum_t pname, gl::int_t * params) {
      if ( GLAD_GL_NV_fence ) {
        glGetFenceivNV(fence, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetFenceivNV' not available on this platform (extensions: GL_NV_fence)");
      }
    }

    void get_final_combiner_input_parameterfv_nv(gl::enum_t variable, gl::enum_t pname, gl::float_t * params) {
      if ( GLAD_GL_NV_register_combiners ) {
        glGetFinalCombinerInputParameterfvNV(variable, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetFinalCombinerInputParameterfvNV' not available on this platform (extensions: GL_NV_register_combiners)");
      }
    }

    void get_final_combiner_input_parameteriv_nv(gl::enum_t variable, gl::enum_t pname, gl::int_t * params) {
      if ( GLAD_GL_NV_register_combiners ) {
        glGetFinalCombinerInputParameterivNV(variable, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetFinalCombinerInputParameterivNV' not available on this platform (extensions: GL_NV_register_combiners)");
      }
    }

    void get_first_perf_query_id_intel(gl::uint_t * queryId) {
      if ( GLAD_GL_INTEL_performance_query ) {
        glGetFirstPerfQueryIdINTEL(queryId);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetFirstPerfQueryIdINTEL' not available on this platform (extensions: GL_INTEL_performance_query)");
      }
    }

    void get_fixedv_oes(gl::enum_t pname, gl::fixed_t * params) {
      if ( GLAD_GL_OES_fixed_point ) {
        glGetFixedvOES(pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetFixedvOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void get_float_indexedv_ext(gl::enum_t target, gl::uint_t index, gl::float_t * data) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glGetFloatIndexedvEXT(target, index, data);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetFloatIndexedvEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void get_floati_v(gl::enum_t target, gl::uint_t index, gl::float_t * data) {
      if ( GLAD_GL_ARB_viewport_array ) {
        glGetFloati_v(target, index, data);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetFloati_v' not available on this platform (extensions: GL_ARB_viewport_array)");
      }
    }

    void get_floati_v_ext(gl::enum_t pname, gl::uint_t index, gl::float_t * params) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glGetFloati_vEXT(pname, index, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetFloati_vEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void get_fog_func_sgis(gl::float_t * points) {
      if ( GLAD_GL_SGIS_fog_function ) {
        glGetFogFuncSGIS(points);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetFogFuncSGIS' not available on this platform (extensions: GL_SGIS_fog_function)");
      }
    }

    gl::int_t get_frag_data_index(gl::uint_t program, const  gl::char_t * name) {
      if ( GLAD_GL_ARB_blend_func_extended ) {
        return glGetFragDataIndex(program, name);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetFragDataIndex' not available on this platform (extensions: GL_ARB_blend_func_extended)");
      }
    }

    gl::int_t get_frag_data_location_ext(gl::uint_t program, const  gl::char_t * name) {
      if ( GLAD_GL_EXT_gpu_shader4 ) {
        return glGetFragDataLocationEXT(program, name);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetFragDataLocationEXT' not available on this platform (extensions: GL_EXT_gpu_shader4)");
      }
    }

    void get_fragment_lightfv_sgix(gl::enum_t light, gl::enum_t pname, gl::float_t * params) {
      if ( GLAD_GL_SGIX_fragment_lighting ) {
        glGetFragmentLightfvSGIX(light, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetFragmentLightfvSGIX' not available on this platform (extensions: GL_SGIX_fragment_lighting)");
      }
    }

    void get_fragment_lightiv_sgix(gl::enum_t light, gl::enum_t pname, gl::int_t * params) {
      if ( GLAD_GL_SGIX_fragment_lighting ) {
        glGetFragmentLightivSGIX(light, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetFragmentLightivSGIX' not available on this platform (extensions: GL_SGIX_fragment_lighting)");
      }
    }

    void get_fragment_materialfv_sgix(material_face_t face, material_parameter_t pname, gl::float_t * params) {
      if ( GLAD_GL_SGIX_fragment_lighting ) {
        glGetFragmentMaterialfvSGIX(static_cast<GLenum>(face), static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetFragmentMaterialfvSGIX' not available on this platform (extensions: GL_SGIX_fragment_lighting)");
      }
    }

    void get_fragment_materialiv_sgix(material_face_t face, material_parameter_t pname, gl::int_t * params) {
      if ( GLAD_GL_SGIX_fragment_lighting ) {
        glGetFragmentMaterialivSGIX(static_cast<GLenum>(face), static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetFragmentMaterialivSGIX' not available on this platform (extensions: GL_SGIX_fragment_lighting)");
      }
    }

    void get_framebuffer_attachment_parameteriv(framebuffer_target_t target, framebuffer_attachment_t attachment, gl::enum_t pname, gl::int_t * params) {
      if ( GLAD_GL_ARB_framebuffer_object ) {
        glGetFramebufferAttachmentParameteriv(static_cast<GLenum>(target), static_cast<GLenum>(attachment), pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetFramebufferAttachmentParameteriv' not available on this platform (extensions: GL_ARB_framebuffer_object)");
      }
    }

    void get_framebuffer_attachment_parameteriv_ext(framebuffer_target_t target, framebuffer_attachment_t attachment, gl::enum_t pname, gl::int_t * params) {
      if ( GLAD_GL_EXT_framebuffer_object ) {
        glGetFramebufferAttachmentParameterivEXT(static_cast<GLenum>(target), static_cast<GLenum>(attachment), pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetFramebufferAttachmentParameterivEXT' not available on this platform (extensions: GL_EXT_framebuffer_object)");
      }
    }

    void get_framebuffer_parameteriv(gl::enum_t target, gl::enum_t pname, gl::int_t * params) {
      if ( GLAD_GL_ARB_framebuffer_no_attachments ) {
        glGetFramebufferParameteriv(target, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetFramebufferParameteriv' not available on this platform (extensions: GL_ARB_framebuffer_no_attachments)");
      }
    }

    void get_framebuffer_parameteriv_ext(gl::uint_t framebuffer, gl::enum_t pname, gl::int_t * params) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glGetFramebufferParameterivEXT(framebuffer, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetFramebufferParameterivEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    gl::enum_t get_graphics_reset_status() {
      if ( GLAD_GL_KHR_robustness ) {
        return glGetGraphicsResetStatus();
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetGraphicsResetStatus' not available on this platform (extensions: GL_KHR_robustness)");
      }
    }

    gl::enum_t get_graphics_reset_status_arb() {
      if ( GLAD_GL_ARB_robustness ) {
        return glGetGraphicsResetStatusARB();
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetGraphicsResetStatusARB' not available on this platform (extensions: GL_ARB_robustness)");
      }
    }

    gl::handleARB_t get_handle_arb(gl::enum_t pname) {
      if ( GLAD_GL_ARB_shader_objects ) {
        return glGetHandleARB(pname);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetHandleARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void get_histogram(gl::enum_t target, gl::boolean_t reset, pixel_format_t format, pixel_type_t type, void * values) {
      if ( GLAD_GL_ARB_imaging ) {
        glGetHistogram(target, reset, static_cast<GLenum>(format), static_cast<GLenum>(type), values);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetHistogram' not available on this platform (extensions: GL_ARB_imaging)");
      }
    }

    void get_histogram_ext(histogram_target_ext_t target, gl::boolean_t reset, pixel_format_t format, pixel_type_t type, void * values) {
      if ( GLAD_GL_EXT_histogram ) {
        glGetHistogramEXT(static_cast<GLenum>(target), reset, static_cast<GLenum>(format), static_cast<GLenum>(type), values);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetHistogramEXT' not available on this platform (extensions: GL_EXT_histogram)");
      }
    }

    void get_histogram_parameterfv(gl::enum_t target, gl::enum_t pname, gl::float_t * params) {
      if ( GLAD_GL_ARB_imaging ) {
        glGetHistogramParameterfv(target, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetHistogramParameterfv' not available on this platform (extensions: GL_ARB_imaging)");
      }
    }

    void get_histogram_parameterfv_ext(histogram_target_ext_t target, get_histogram_parameter_p_name_ext_t pname, gl::float_t * params) {
      if ( GLAD_GL_EXT_histogram ) {
        glGetHistogramParameterfvEXT(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetHistogramParameterfvEXT' not available on this platform (extensions: GL_EXT_histogram)");
      }
    }

    void get_histogram_parameteriv(gl::enum_t target, gl::enum_t pname, gl::int_t * params) {
      if ( GLAD_GL_ARB_imaging ) {
        glGetHistogramParameteriv(target, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetHistogramParameteriv' not available on this platform (extensions: GL_ARB_imaging)");
      }
    }

    void get_histogram_parameteriv_ext(histogram_target_ext_t target, get_histogram_parameter_p_name_ext_t pname, gl::int_t * params) {
      if ( GLAD_GL_EXT_histogram ) {
        glGetHistogramParameterivEXT(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetHistogramParameterivEXT' not available on this platform (extensions: GL_EXT_histogram)");
      }
    }

    void get_histogram_parameterxv_oes(gl::enum_t target, gl::enum_t pname, gl::fixed_t * params) {
      if ( GLAD_GL_OES_fixed_point ) {
        glGetHistogramParameterxvOES(target, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetHistogramParameterxvOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    gl::uint64_t get_image_handle_arb(gl::uint_t texture, gl::int_t level, gl::boolean_t layered, gl::int_t layer, gl::enum_t format) {
      if ( GLAD_GL_ARB_bindless_texture ) {
        return glGetImageHandleARB(texture, level, layered, layer, format);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetImageHandleARB' not available on this platform (extensions: GL_ARB_bindless_texture)");
      }
    }

    gl::uint64_t get_image_handle_nv(gl::uint_t texture, gl::int_t level, gl::boolean_t layered, gl::int_t layer, gl::enum_t format) {
      if ( GLAD_GL_NV_bindless_texture ) {
        return glGetImageHandleNV(texture, level, layered, layer, format);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetImageHandleNV' not available on this platform (extensions: GL_NV_bindless_texture)");
      }
    }

    void get_image_transform_parameterfv_hp(gl::enum_t target, gl::enum_t pname, gl::float_t * params) {
      if ( GLAD_GL_HP_image_transform ) {
        glGetImageTransformParameterfvHP(target, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetImageTransformParameterfvHP' not available on this platform (extensions: GL_HP_image_transform)");
      }
    }

    void get_image_transform_parameteriv_hp(gl::enum_t target, gl::enum_t pname, gl::int_t * params) {
      if ( GLAD_GL_HP_image_transform ) {
        glGetImageTransformParameterivHP(target, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetImageTransformParameterivHP' not available on this platform (extensions: GL_HP_image_transform)");
      }
    }

    void get_info_log_arb(gl::handleARB_t obj, gl::sizei_t maxLength, gl::sizei_t * length, gl::charARB_t * infoLog) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glGetInfoLogARB(obj, maxLength, length, infoLog);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetInfoLogARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    gl::int_t get_instruments_sgix() {
      if ( GLAD_GL_SGIX_instruments ) {
        return glGetInstrumentsSGIX();
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetInstrumentsSGIX' not available on this platform (extensions: GL_SGIX_instruments)");
      }
    }

    void get_integer_64v(gl::enum_t pname, gl::int64_t * data) {
      if ( GLAD_GL_ARB_sync ) {
        glGetInteger64v(pname, data);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetInteger64v' not available on this platform (extensions: GL_ARB_sync)");
      }
    }

    void get_integer_indexedv_ext(gl::enum_t target, gl::uint_t index, gl::int_t * data) {
      if ( GLAD_GL_EXT_direct_state_access || GLAD_GL_EXT_draw_buffers2 ) {
        glGetIntegerIndexedvEXT(target, index, data);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetIntegerIndexedvEXT' not available on this platform (extensions: GL_EXT_direct_state_access, GL_EXT_draw_buffers2)");
      }
    }

    void get_integerui_64i_v_nv(gl::enum_t value, gl::uint_t index, gl::uint64EXT_t * result) {
      if ( GLAD_GL_NV_vertex_buffer_unified_memory ) {
        glGetIntegerui64i_vNV(value, index, result);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetIntegerui64i_vNV' not available on this platform (extensions: GL_NV_vertex_buffer_unified_memory)");
      }
    }

    void get_integerui_64v_nv(gl::enum_t value, gl::uint64EXT_t * result) {
      if ( GLAD_GL_NV_shader_buffer_load ) {
        glGetIntegerui64vNV(value, result);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetIntegerui64vNV' not available on this platform (extensions: GL_NV_shader_buffer_load)");
      }
    }

    void get_internalformat_sampleiv_nv(gl::enum_t target, gl::enum_t internalformat, gl::sizei_t samples, gl::enum_t pname, gl::sizei_t bufSize, gl::int_t * params) {
      if ( GLAD_GL_NV_internalformat_sample_query ) {
        glGetInternalformatSampleivNV(target, internalformat, samples, pname, bufSize, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetInternalformatSampleivNV' not available on this platform (extensions: GL_NV_internalformat_sample_query)");
      }
    }

    void get_internalformati_64v(gl::enum_t target, gl::enum_t internalformat, gl::enum_t pname, gl::sizei_t bufSize, gl::int64_t * params) {
      if ( GLAD_GL_ARB_internalformat_query2 ) {
        glGetInternalformati64v(target, internalformat, pname, bufSize, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetInternalformati64v' not available on this platform (extensions: GL_ARB_internalformat_query2)");
      }
    }

    void get_internalformativ(gl::enum_t target, gl::enum_t internalformat, gl::enum_t pname, gl::sizei_t bufSize, gl::int_t * params) {
      if ( GLAD_GL_ARB_internalformat_query ) {
        glGetInternalformativ(target, internalformat, pname, bufSize, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetInternalformativ' not available on this platform (extensions: GL_ARB_internalformat_query)");
      }
    }

    void get_invariant_booleanv_ext(gl::uint_t id, gl::enum_t value, gl::boolean_t * data) {
      if ( GLAD_GL_EXT_vertex_shader ) {
        glGetInvariantBooleanvEXT(id, value, data);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetInvariantBooleanvEXT' not available on this platform (extensions: GL_EXT_vertex_shader)");
      }
    }

    void get_invariant_floatv_ext(gl::uint_t id, gl::enum_t value, gl::float_t * data) {
      if ( GLAD_GL_EXT_vertex_shader ) {
        glGetInvariantFloatvEXT(id, value, data);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetInvariantFloatvEXT' not available on this platform (extensions: GL_EXT_vertex_shader)");
      }
    }

    void get_invariant_integerv_ext(gl::uint_t id, gl::enum_t value, gl::int_t * data) {
      if ( GLAD_GL_EXT_vertex_shader ) {
        glGetInvariantIntegervEXT(id, value, data);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetInvariantIntegervEXT' not available on this platform (extensions: GL_EXT_vertex_shader)");
      }
    }

    void get_lightx_oes(gl::enum_t light, gl::enum_t pname, gl::fixed_t * params) {
      if ( GLAD_GL_OES_fixed_point ) {
        glGetLightxOES(light, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetLightxOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void get_list_parameterfv_sgix(gl::uint_t list, list_parameter_name_t pname, gl::float_t * params) {
      if ( GLAD_GL_SGIX_list_priority ) {
        glGetListParameterfvSGIX(list, static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetListParameterfvSGIX' not available on this platform (extensions: GL_SGIX_list_priority)");
      }
    }

    void get_list_parameteriv_sgix(gl::uint_t list, list_parameter_name_t pname, gl::int_t * params) {
      if ( GLAD_GL_SGIX_list_priority ) {
        glGetListParameterivSGIX(list, static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetListParameterivSGIX' not available on this platform (extensions: GL_SGIX_list_priority)");
      }
    }

    void get_local_constant_booleanv_ext(gl::uint_t id, gl::enum_t value, gl::boolean_t * data) {
      if ( GLAD_GL_EXT_vertex_shader ) {
        glGetLocalConstantBooleanvEXT(id, value, data);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetLocalConstantBooleanvEXT' not available on this platform (extensions: GL_EXT_vertex_shader)");
      }
    }

    void get_local_constant_floatv_ext(gl::uint_t id, gl::enum_t value, gl::float_t * data) {
      if ( GLAD_GL_EXT_vertex_shader ) {
        glGetLocalConstantFloatvEXT(id, value, data);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetLocalConstantFloatvEXT' not available on this platform (extensions: GL_EXT_vertex_shader)");
      }
    }

    void get_local_constant_integerv_ext(gl::uint_t id, gl::enum_t value, gl::int_t * data) {
      if ( GLAD_GL_EXT_vertex_shader ) {
        glGetLocalConstantIntegervEXT(id, value, data);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetLocalConstantIntegervEXT' not available on this platform (extensions: GL_EXT_vertex_shader)");
      }
    }

    void get_map_attrib_parameterfv_nv(gl::enum_t target, gl::uint_t index, gl::enum_t pname, gl::float_t * params) {
      if ( GLAD_GL_NV_evaluators ) {
        glGetMapAttribParameterfvNV(target, index, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetMapAttribParameterfvNV' not available on this platform (extensions: GL_NV_evaluators)");
      }
    }

    void get_map_attrib_parameteriv_nv(gl::enum_t target, gl::uint_t index, gl::enum_t pname, gl::int_t * params) {
      if ( GLAD_GL_NV_evaluators ) {
        glGetMapAttribParameterivNV(target, index, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetMapAttribParameterivNV' not available on this platform (extensions: GL_NV_evaluators)");
      }
    }

    void get_map_control_points_nv(gl::enum_t target, gl::uint_t index, gl::enum_t type, gl::sizei_t ustride, gl::sizei_t vstride, gl::boolean_t packed, void * points) {
      if ( GLAD_GL_NV_evaluators ) {
        glGetMapControlPointsNV(target, index, type, ustride, vstride, packed, points);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetMapControlPointsNV' not available on this platform (extensions: GL_NV_evaluators)");
      }
    }

    void get_map_parameterfv_nv(gl::enum_t target, gl::enum_t pname, gl::float_t * params) {
      if ( GLAD_GL_NV_evaluators ) {
        glGetMapParameterfvNV(target, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetMapParameterfvNV' not available on this platform (extensions: GL_NV_evaluators)");
      }
    }

    void get_map_parameteriv_nv(gl::enum_t target, gl::enum_t pname, gl::int_t * params) {
      if ( GLAD_GL_NV_evaluators ) {
        glGetMapParameterivNV(target, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetMapParameterivNV' not available on this platform (extensions: GL_NV_evaluators)");
      }
    }

    void get_mapxv_oes(gl::enum_t target, gl::enum_t query, gl::fixed_t * v) {
      if ( GLAD_GL_OES_fixed_point ) {
        glGetMapxvOES(target, query, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetMapxvOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void get_materialx_oes(gl::enum_t face, gl::enum_t pname, gl::fixed_t param) {
      if ( GLAD_GL_OES_fixed_point ) {
        glGetMaterialxOES(face, pname, param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetMaterialxOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void get_minmax(gl::enum_t target, gl::boolean_t reset, pixel_format_t format, pixel_type_t type, void * values) {
      if ( GLAD_GL_ARB_imaging ) {
        glGetMinmax(target, reset, static_cast<GLenum>(format), static_cast<GLenum>(type), values);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetMinmax' not available on this platform (extensions: GL_ARB_imaging)");
      }
    }

    void get_minmax_ext(minmax_target_ext_t target, gl::boolean_t reset, pixel_format_t format, pixel_type_t type, void * values) {
      if ( GLAD_GL_EXT_histogram ) {
        glGetMinmaxEXT(static_cast<GLenum>(target), reset, static_cast<GLenum>(format), static_cast<GLenum>(type), values);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetMinmaxEXT' not available on this platform (extensions: GL_EXT_histogram)");
      }
    }

    void get_minmax_parameterfv(gl::enum_t target, gl::enum_t pname, gl::float_t * params) {
      if ( GLAD_GL_ARB_imaging ) {
        glGetMinmaxParameterfv(target, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetMinmaxParameterfv' not available on this platform (extensions: GL_ARB_imaging)");
      }
    }

    void get_minmax_parameterfv_ext(minmax_target_ext_t target, get_minmax_parameter_p_name_ext_t pname, gl::float_t * params) {
      if ( GLAD_GL_EXT_histogram ) {
        glGetMinmaxParameterfvEXT(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetMinmaxParameterfvEXT' not available on this platform (extensions: GL_EXT_histogram)");
      }
    }

    void get_minmax_parameteriv(gl::enum_t target, gl::enum_t pname, gl::int_t * params) {
      if ( GLAD_GL_ARB_imaging ) {
        glGetMinmaxParameteriv(target, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetMinmaxParameteriv' not available on this platform (extensions: GL_ARB_imaging)");
      }
    }

    void get_minmax_parameteriv_ext(minmax_target_ext_t target, get_minmax_parameter_p_name_ext_t pname, gl::int_t * params) {
      if ( GLAD_GL_EXT_histogram ) {
        glGetMinmaxParameterivEXT(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetMinmaxParameterivEXT' not available on this platform (extensions: GL_EXT_histogram)");
      }
    }

    void get_multi_tex_envfv_ext(texture_unit_t texunit, texture_env_target_t target, texture_env_parameter_t pname, gl::float_t * params) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glGetMultiTexEnvfvEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetMultiTexEnvfvEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void get_multi_tex_enviv_ext(texture_unit_t texunit, texture_env_target_t target, texture_env_parameter_t pname, gl::int_t * params) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glGetMultiTexEnvivEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetMultiTexEnvivEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void get_multi_tex_gendv_ext(texture_unit_t texunit, texture_coord_name_t coord, texture_gen_parameter_t pname, gl::double_t * params) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glGetMultiTexGendvEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(coord), static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetMultiTexGendvEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void get_multi_tex_genfv_ext(texture_unit_t texunit, texture_coord_name_t coord, texture_gen_parameter_t pname, gl::float_t * params) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glGetMultiTexGenfvEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(coord), static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetMultiTexGenfvEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void get_multi_tex_geniv_ext(texture_unit_t texunit, texture_coord_name_t coord, texture_gen_parameter_t pname, gl::int_t * params) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glGetMultiTexGenivEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(coord), static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetMultiTexGenivEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void get_multi_tex_image_ext(texture_unit_t texunit, texture_target_t target, gl::int_t level, pixel_format_t format, pixel_type_t type, void * pixels) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glGetMultiTexImageEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(target), level, static_cast<GLenum>(format), static_cast<GLenum>(type), pixels);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetMultiTexImageEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void get_multi_tex_level_parameterfv_ext(texture_unit_t texunit, texture_target_t target, gl::int_t level, get_texture_parameter_t pname, gl::float_t * params) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glGetMultiTexLevelParameterfvEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(target), level, static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetMultiTexLevelParameterfvEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void get_multi_tex_level_parameteriv_ext(texture_unit_t texunit, texture_target_t target, gl::int_t level, get_texture_parameter_t pname, gl::int_t * params) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glGetMultiTexLevelParameterivEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(target), level, static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetMultiTexLevelParameterivEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void get_multi_tex_parameter_iiv_ext(texture_unit_t texunit, texture_target_t target, get_texture_parameter_t pname, gl::int_t * params) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glGetMultiTexParameterIivEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetMultiTexParameterIivEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void get_multi_tex_parameter_iuiv_ext(texture_unit_t texunit, texture_target_t target, get_texture_parameter_t pname, gl::uint_t * params) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glGetMultiTexParameterIuivEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetMultiTexParameterIuivEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void get_multi_tex_parameterfv_ext(texture_unit_t texunit, texture_target_t target, get_texture_parameter_t pname, gl::float_t * params) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glGetMultiTexParameterfvEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetMultiTexParameterfvEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void get_multi_tex_parameteriv_ext(texture_unit_t texunit, texture_target_t target, get_texture_parameter_t pname, gl::int_t * params) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glGetMultiTexParameterivEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetMultiTexParameterivEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void get_multisamplefv(gl::enum_t pname, gl::uint_t index, gl::float_t * val) {
      if ( GLAD_GL_ARB_texture_multisample ) {
        glGetMultisamplefv(pname, index, val);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetMultisamplefv' not available on this platform (extensions: GL_ARB_texture_multisample)");
      }
    }

    void get_multisamplefv_nv(gl::enum_t pname, gl::uint_t index, gl::float_t * val) {
      if ( GLAD_GL_NV_explicit_multisample ) {
        glGetMultisamplefvNV(pname, index, val);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetMultisamplefvNV' not available on this platform (extensions: GL_NV_explicit_multisample)");
      }
    }

    void get_named_buffer_parameteri_64v(gl::uint_t buffer, gl::enum_t pname, gl::int64_t * params) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glGetNamedBufferParameteri64v(buffer, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetNamedBufferParameteri64v' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void get_named_buffer_parameteriv(gl::uint_t buffer, gl::enum_t pname, gl::int_t * params) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glGetNamedBufferParameteriv(buffer, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetNamedBufferParameteriv' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void get_named_buffer_parameteriv_ext(gl::uint_t buffer, gl::enum_t pname, gl::int_t * params) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glGetNamedBufferParameterivEXT(buffer, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetNamedBufferParameterivEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void get_named_buffer_parameterui_64v_nv(gl::uint_t buffer, gl::enum_t pname, gl::uint64EXT_t * params) {
      if ( GLAD_GL_NV_shader_buffer_load ) {
        glGetNamedBufferParameterui64vNV(buffer, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetNamedBufferParameterui64vNV' not available on this platform (extensions: GL_NV_shader_buffer_load)");
      }
    }

    void get_named_buffer_pointerv(gl::uint_t buffer, gl::enum_t pname, void ** params) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glGetNamedBufferPointerv(buffer, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetNamedBufferPointerv' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void get_named_buffer_pointerv_ext(gl::uint_t buffer, gl::enum_t pname, void ** params) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glGetNamedBufferPointervEXT(buffer, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetNamedBufferPointervEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void get_named_buffer_sub_data(gl::uint_t buffer, gl::intptr_t offset, gl::sizeiptr_t size, void * data) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glGetNamedBufferSubData(buffer, offset, size, data);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetNamedBufferSubData' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void get_named_buffer_sub_data_ext(gl::uint_t buffer, gl::intptr_t offset, gl::sizeiptr_t size, void * data) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glGetNamedBufferSubDataEXT(buffer, offset, size, data);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetNamedBufferSubDataEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void get_named_framebuffer_attachment_parameteriv(gl::uint_t framebuffer, gl::enum_t attachment, gl::enum_t pname, gl::int_t * params) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glGetNamedFramebufferAttachmentParameteriv(framebuffer, attachment, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetNamedFramebufferAttachmentParameteriv' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void get_named_framebuffer_attachment_parameteriv_ext(gl::uint_t framebuffer, framebuffer_attachment_t attachment, gl::enum_t pname, gl::int_t * params) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glGetNamedFramebufferAttachmentParameterivEXT(framebuffer, static_cast<GLenum>(attachment), pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetNamedFramebufferAttachmentParameterivEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void get_named_framebuffer_parameteriv(gl::uint_t framebuffer, gl::enum_t pname, gl::int_t * param) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glGetNamedFramebufferParameteriv(framebuffer, pname, param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetNamedFramebufferParameteriv' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void get_named_framebuffer_parameteriv_ext(gl::uint_t framebuffer, gl::enum_t pname, gl::int_t * params) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glGetNamedFramebufferParameterivEXT(framebuffer, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetNamedFramebufferParameterivEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void get_named_program_local_parameter_iiv_ext(gl::uint_t program, gl::enum_t target, gl::uint_t index, gl::int_t * params) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glGetNamedProgramLocalParameterIivEXT(program, target, index, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetNamedProgramLocalParameterIivEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void get_named_program_local_parameter_iuiv_ext(gl::uint_t program, gl::enum_t target, gl::uint_t index, gl::uint_t * params) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glGetNamedProgramLocalParameterIuivEXT(program, target, index, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetNamedProgramLocalParameterIuivEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void get_named_program_local_parameterdv_ext(gl::uint_t program, gl::enum_t target, gl::uint_t index, gl::double_t * params) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glGetNamedProgramLocalParameterdvEXT(program, target, index, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetNamedProgramLocalParameterdvEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void get_named_program_local_parameterfv_ext(gl::uint_t program, gl::enum_t target, gl::uint_t index, gl::float_t * params) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glGetNamedProgramLocalParameterfvEXT(program, target, index, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetNamedProgramLocalParameterfvEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void get_named_program_string_ext(gl::uint_t program, gl::enum_t target, gl::enum_t pname, void * string) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glGetNamedProgramStringEXT(program, target, pname, string);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetNamedProgramStringEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void get_named_programiv_ext(gl::uint_t program, gl::enum_t target, gl::enum_t pname, gl::int_t * params) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glGetNamedProgramivEXT(program, target, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetNamedProgramivEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void get_named_renderbuffer_parameteriv(gl::uint_t renderbuffer, gl::enum_t pname, gl::int_t * params) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glGetNamedRenderbufferParameteriv(renderbuffer, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetNamedRenderbufferParameteriv' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void get_named_renderbuffer_parameteriv_ext(gl::uint_t renderbuffer, gl::enum_t pname, gl::int_t * params) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glGetNamedRenderbufferParameterivEXT(renderbuffer, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetNamedRenderbufferParameterivEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void get_named_string_arb(gl::int_t namelen, const  gl::char_t * name, gl::sizei_t bufSize, gl::int_t * stringlen, gl::char_t * string) {
      if ( GLAD_GL_ARB_shading_language_include ) {
        glGetNamedStringARB(namelen, name, bufSize, stringlen, string);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetNamedStringARB' not available on this platform (extensions: GL_ARB_shading_language_include)");
      }
    }

    void get_named_stringiv_arb(gl::int_t namelen, const  gl::char_t * name, gl::enum_t pname, gl::int_t * params) {
      if ( GLAD_GL_ARB_shading_language_include ) {
        glGetNamedStringivARB(namelen, name, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetNamedStringivARB' not available on this platform (extensions: GL_ARB_shading_language_include)");
      }
    }

    void get_next_perf_query_id_intel(gl::uint_t queryId, gl::uint_t * nextQueryId) {
      if ( GLAD_GL_INTEL_performance_query ) {
        glGetNextPerfQueryIdINTEL(queryId, nextQueryId);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetNextPerfQueryIdINTEL' not available on this platform (extensions: GL_INTEL_performance_query)");
      }
    }

    void get_object_bufferfv_ati(gl::uint_t buffer, gl::enum_t pname, gl::float_t * params) {
      if ( GLAD_GL_ATI_vertex_array_object ) {
        glGetObjectBufferfvATI(buffer, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetObjectBufferfvATI' not available on this platform (extensions: GL_ATI_vertex_array_object)");
      }
    }

    void get_object_bufferiv_ati(gl::uint_t buffer, gl::enum_t pname, gl::int_t * params) {
      if ( GLAD_GL_ATI_vertex_array_object ) {
        glGetObjectBufferivATI(buffer, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetObjectBufferivATI' not available on this platform (extensions: GL_ATI_vertex_array_object)");
      }
    }

    void get_object_label(gl::enum_t identifier, gl::uint_t name, gl::sizei_t bufSize, gl::sizei_t * length, gl::char_t * label) {
      if ( GLAD_GL_KHR_debug ) {
        glGetObjectLabel(identifier, name, bufSize, length, label);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetObjectLabel' not available on this platform (extensions: GL_KHR_debug)");
      }
    }

    void get_object_label_ext(gl::enum_t type, gl::uint_t object, gl::sizei_t bufSize, gl::sizei_t * length, gl::char_t * label) {
      if ( GLAD_GL_EXT_debug_label ) {
        glGetObjectLabelEXT(type, object, bufSize, length, label);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetObjectLabelEXT' not available on this platform (extensions: GL_EXT_debug_label)");
      }
    }

    void get_object_parameterfv_arb(gl::handleARB_t obj, gl::enum_t pname, gl::float_t * params) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glGetObjectParameterfvARB(obj, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetObjectParameterfvARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void get_object_parameteriv_apple(gl::enum_t objectType, gl::uint_t name, gl::enum_t pname, gl::int_t * params) {
      if ( GLAD_GL_APPLE_object_purgeable ) {
        glGetObjectParameterivAPPLE(objectType, name, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetObjectParameterivAPPLE' not available on this platform (extensions: GL_APPLE_object_purgeable)");
      }
    }

    void get_object_parameteriv_arb(gl::handleARB_t obj, gl::enum_t pname, gl::int_t * params) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glGetObjectParameterivARB(obj, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetObjectParameterivARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void get_object_ptr_label(const  void * ptr, gl::sizei_t bufSize, gl::sizei_t * length, gl::char_t * label) {
      if ( GLAD_GL_KHR_debug ) {
        glGetObjectPtrLabel(ptr, bufSize, length, label);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetObjectPtrLabel' not available on this platform (extensions: GL_KHR_debug)");
      }
    }

    void get_occlusion_queryiv_nv(gl::uint_t id, gl::enum_t pname, gl::int_t * params) {
      if ( GLAD_GL_NV_occlusion_query ) {
        glGetOcclusionQueryivNV(id, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetOcclusionQueryivNV' not available on this platform (extensions: GL_NV_occlusion_query)");
      }
    }

    void get_occlusion_queryuiv_nv(gl::uint_t id, gl::enum_t pname, gl::uint_t * params) {
      if ( GLAD_GL_NV_occlusion_query ) {
        glGetOcclusionQueryuivNV(id, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetOcclusionQueryuivNV' not available on this platform (extensions: GL_NV_occlusion_query)");
      }
    }

    void get_path_color_genfv_nv(gl::enum_t color, gl::enum_t pname, gl::float_t * value) {
      if ( GLAD_GL_NV_path_rendering ) {
        glGetPathColorGenfvNV(color, pname, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetPathColorGenfvNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void get_path_color_geniv_nv(gl::enum_t color, gl::enum_t pname, gl::int_t * value) {
      if ( GLAD_GL_NV_path_rendering ) {
        glGetPathColorGenivNV(color, pname, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetPathColorGenivNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void get_path_commands_nv(gl::uint_t path, gl::ubyte_t * commands) {
      if ( GLAD_GL_NV_path_rendering ) {
        glGetPathCommandsNV(path, commands);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetPathCommandsNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void get_path_coords_nv(gl::uint_t path, gl::float_t * coords) {
      if ( GLAD_GL_NV_path_rendering ) {
        glGetPathCoordsNV(path, coords);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetPathCoordsNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void get_path_dash_array_nv(gl::uint_t path, gl::float_t * dashArray) {
      if ( GLAD_GL_NV_path_rendering ) {
        glGetPathDashArrayNV(path, dashArray);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetPathDashArrayNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    gl::float_t get_path_length_nv(gl::uint_t path, gl::sizei_t startSegment, gl::sizei_t numSegments) {
      if ( GLAD_GL_NV_path_rendering ) {
        return glGetPathLengthNV(path, startSegment, numSegments);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetPathLengthNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void get_path_metric_range_nv(gl::bitfield_t metricQueryMask, gl::uint_t firstPathName, gl::sizei_t numPaths, gl::sizei_t stride, gl::float_t * metrics) {
      if ( GLAD_GL_NV_path_rendering ) {
        glGetPathMetricRangeNV(metricQueryMask, firstPathName, numPaths, stride, metrics);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetPathMetricRangeNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void get_path_metrics_nv(gl::bitfield_t metricQueryMask, gl::sizei_t numPaths, gl::enum_t pathNameType, const  void * paths, gl::uint_t pathBase, gl::sizei_t stride, gl::float_t * metrics) {
      if ( GLAD_GL_NV_path_rendering ) {
        glGetPathMetricsNV(metricQueryMask, numPaths, pathNameType, paths, pathBase, stride, metrics);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetPathMetricsNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void get_path_parameterfv_nv(gl::uint_t path, gl::enum_t pname, gl::float_t * value) {
      if ( GLAD_GL_NV_path_rendering ) {
        glGetPathParameterfvNV(path, pname, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetPathParameterfvNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void get_path_parameteriv_nv(gl::uint_t path, gl::enum_t pname, gl::int_t * value) {
      if ( GLAD_GL_NV_path_rendering ) {
        glGetPathParameterivNV(path, pname, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetPathParameterivNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void get_path_spacing_nv(gl::enum_t pathListMode, gl::sizei_t numPaths, gl::enum_t pathNameType, const  void * paths, gl::uint_t pathBase, gl::float_t advanceScale, gl::float_t kerningScale, gl::enum_t transformType, gl::float_t * returnedSpacing) {
      if ( GLAD_GL_NV_path_rendering ) {
        glGetPathSpacingNV(pathListMode, numPaths, pathNameType, paths, pathBase, advanceScale, kerningScale, transformType, returnedSpacing);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetPathSpacingNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void get_path_tex_genfv_nv(texture_unit_t texCoordSet, gl::enum_t pname, gl::float_t * value) {
      if ( GLAD_GL_NV_path_rendering ) {
        glGetPathTexGenfvNV(static_cast<GLenum>(texCoordSet), pname, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetPathTexGenfvNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void get_path_tex_geniv_nv(texture_unit_t texCoordSet, gl::enum_t pname, gl::int_t * value) {
      if ( GLAD_GL_NV_path_rendering ) {
        glGetPathTexGenivNV(static_cast<GLenum>(texCoordSet), pname, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetPathTexGenivNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void get_perf_counter_info_intel(gl::uint_t queryId, gl::uint_t counterId, gl::uint_t counterNameLength, gl::char_t * counterName, gl::uint_t counterDescLength, gl::char_t * counterDesc, gl::uint_t * counterOffset, gl::uint_t * counterDataSize, gl::uint_t * counterTypeEnum, gl::uint_t * counterDataTypeEnum, gl::uint64_t * rawCounterMaxValue) {
      if ( GLAD_GL_INTEL_performance_query ) {
        glGetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetPerfCounterInfoINTEL' not available on this platform (extensions: GL_INTEL_performance_query)");
      }
    }

    void get_perf_monitor_counter_data_amd(gl::uint_t monitor, gl::enum_t pname, gl::sizei_t dataSize, gl::uint_t * data, gl::int_t * bytesWritten) {
      if ( GLAD_GL_AMD_performance_monitor ) {
        glGetPerfMonitorCounterDataAMD(monitor, pname, dataSize, data, bytesWritten);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetPerfMonitorCounterDataAMD' not available on this platform (extensions: GL_AMD_performance_monitor)");
      }
    }

    void get_perf_monitor_counter_info_amd(gl::uint_t group, gl::uint_t counter, gl::enum_t pname, void * data) {
      if ( GLAD_GL_AMD_performance_monitor ) {
        glGetPerfMonitorCounterInfoAMD(group, counter, pname, data);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetPerfMonitorCounterInfoAMD' not available on this platform (extensions: GL_AMD_performance_monitor)");
      }
    }

    void get_perf_monitor_counter_string_amd(gl::uint_t group, gl::uint_t counter, gl::sizei_t bufSize, gl::sizei_t * length, gl::char_t * counterString) {
      if ( GLAD_GL_AMD_performance_monitor ) {
        glGetPerfMonitorCounterStringAMD(group, counter, bufSize, length, counterString);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetPerfMonitorCounterStringAMD' not available on this platform (extensions: GL_AMD_performance_monitor)");
      }
    }

    void get_perf_monitor_counters_amd(gl::uint_t group, gl::int_t * numCounters, gl::int_t * maxActiveCounters, gl::sizei_t counterSize, gl::uint_t * counters) {
      if ( GLAD_GL_AMD_performance_monitor ) {
        glGetPerfMonitorCountersAMD(group, numCounters, maxActiveCounters, counterSize, counters);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetPerfMonitorCountersAMD' not available on this platform (extensions: GL_AMD_performance_monitor)");
      }
    }

    void get_perf_monitor_group_string_amd(gl::uint_t group, gl::sizei_t bufSize, gl::sizei_t * length, gl::char_t * groupString) {
      if ( GLAD_GL_AMD_performance_monitor ) {
        glGetPerfMonitorGroupStringAMD(group, bufSize, length, groupString);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetPerfMonitorGroupStringAMD' not available on this platform (extensions: GL_AMD_performance_monitor)");
      }
    }

    void get_perf_monitor_groups_amd(gl::int_t * numGroups, gl::sizei_t groupsSize, gl::uint_t * groups) {
      if ( GLAD_GL_AMD_performance_monitor ) {
        glGetPerfMonitorGroupsAMD(numGroups, groupsSize, groups);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetPerfMonitorGroupsAMD' not available on this platform (extensions: GL_AMD_performance_monitor)");
      }
    }

    void get_perf_query_data_intel(gl::uint_t queryHandle, gl::uint_t flags, gl::sizei_t dataSize, void * data, gl::uint_t * bytesWritten) {
      if ( GLAD_GL_INTEL_performance_query ) {
        glGetPerfQueryDataINTEL(queryHandle, flags, dataSize, data, bytesWritten);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetPerfQueryDataINTEL' not available on this platform (extensions: GL_INTEL_performance_query)");
      }
    }

    void get_perf_query_id_by_name_intel(gl::char_t * queryName, gl::uint_t * queryId) {
      if ( GLAD_GL_INTEL_performance_query ) {
        glGetPerfQueryIdByNameINTEL(queryName, queryId);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetPerfQueryIdByNameINTEL' not available on this platform (extensions: GL_INTEL_performance_query)");
      }
    }

    void get_perf_query_info_intel(gl::uint_t queryId, gl::uint_t queryNameLength, gl::char_t * queryName, gl::uint_t * dataSize, gl::uint_t * noCounters, gl::uint_t * noInstances, gl::uint_t * capsMask) {
      if ( GLAD_GL_INTEL_performance_query ) {
        glGetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, dataSize, noCounters, noInstances, capsMask);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetPerfQueryInfoINTEL' not available on this platform (extensions: GL_INTEL_performance_query)");
      }
    }

    void get_pixel_mapxv(gl::enum_t map, gl::int_t size, gl::fixed_t * values) {
      if ( GLAD_GL_OES_fixed_point ) {
        glGetPixelMapxv(map, size, values);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetPixelMapxv' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void get_pixel_tex_gen_parameterfv_sgis(pixel_tex_gen_parameter_name_sgis_t pname, gl::float_t * params) {
      if ( GLAD_GL_SGIS_pixel_texture ) {
        glGetPixelTexGenParameterfvSGIS(static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetPixelTexGenParameterfvSGIS' not available on this platform (extensions: GL_SGIS_pixel_texture)");
      }
    }

    void get_pixel_tex_gen_parameteriv_sgis(pixel_tex_gen_parameter_name_sgis_t pname, gl::int_t * params) {
      if ( GLAD_GL_SGIS_pixel_texture ) {
        glGetPixelTexGenParameterivSGIS(static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetPixelTexGenParameterivSGIS' not available on this platform (extensions: GL_SGIS_pixel_texture)");
      }
    }

    void get_pixel_transform_parameterfv_ext(gl::enum_t target, gl::enum_t pname, gl::float_t * params) {
      if ( GLAD_GL_EXT_pixel_transform ) {
        glGetPixelTransformParameterfvEXT(target, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetPixelTransformParameterfvEXT' not available on this platform (extensions: GL_EXT_pixel_transform)");
      }
    }

    void get_pixel_transform_parameteriv_ext(gl::enum_t target, gl::enum_t pname, gl::int_t * params) {
      if ( GLAD_GL_EXT_pixel_transform ) {
        glGetPixelTransformParameterivEXT(target, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetPixelTransformParameterivEXT' not available on this platform (extensions: GL_EXT_pixel_transform)");
      }
    }

    void get_pointer_indexedv_ext(gl::enum_t target, gl::uint_t index, void ** data) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glGetPointerIndexedvEXT(target, index, data);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetPointerIndexedvEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void get_pointeri_v_ext(gl::enum_t pname, gl::uint_t index, void ** params) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glGetPointeri_vEXT(pname, index, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetPointeri_vEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void get_pointerv_ext(get_pointerv_p_name_t pname, void ** params) {
      if ( GLAD_GL_EXT_vertex_array ) {
        glGetPointervEXT(static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetPointervEXT' not available on this platform (extensions: GL_EXT_vertex_array)");
      }
    }

    void get_program_binary(gl::uint_t program, gl::sizei_t bufSize, gl::sizei_t * length, gl::enum_t * binaryFormat, void * binary) {
      if ( GLAD_GL_ARB_get_program_binary ) {
        glGetProgramBinary(program, bufSize, length, binaryFormat, binary);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetProgramBinary' not available on this platform (extensions: GL_ARB_get_program_binary)");
      }
    }

    void get_program_env_parameter_iiv_nv(gl::enum_t target, gl::uint_t index, gl::int_t * params) {
      if ( GLAD_GL_NV_gpu_program4 ) {
        glGetProgramEnvParameterIivNV(target, index, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetProgramEnvParameterIivNV' not available on this platform (extensions: GL_NV_gpu_program4)");
      }
    }

    void get_program_env_parameter_iuiv_nv(gl::enum_t target, gl::uint_t index, gl::uint_t * params) {
      if ( GLAD_GL_NV_gpu_program4 ) {
        glGetProgramEnvParameterIuivNV(target, index, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetProgramEnvParameterIuivNV' not available on this platform (extensions: GL_NV_gpu_program4)");
      }
    }

    void get_program_env_parameterdv_arb(gl::enum_t target, gl::uint_t index, gl::double_t * params) {
      if ( GLAD_GL_ARB_fragment_program || GLAD_GL_ARB_vertex_program ) {
        glGetProgramEnvParameterdvARB(target, index, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetProgramEnvParameterdvARB' not available on this platform (extensions: GL_ARB_fragment_program, GL_ARB_vertex_program)");
      }
    }

    void get_program_env_parameterfv_arb(gl::enum_t target, gl::uint_t index, gl::float_t * params) {
      if ( GLAD_GL_ARB_fragment_program || GLAD_GL_ARB_vertex_program ) {
        glGetProgramEnvParameterfvARB(target, index, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetProgramEnvParameterfvARB' not available on this platform (extensions: GL_ARB_fragment_program, GL_ARB_vertex_program)");
      }
    }

    void get_program_interfaceiv(gl::uint_t program, gl::enum_t programInterface, gl::enum_t pname, gl::int_t * params) {
      if ( GLAD_GL_ARB_program_interface_query ) {
        glGetProgramInterfaceiv(program, programInterface, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetProgramInterfaceiv' not available on this platform (extensions: GL_ARB_program_interface_query)");
      }
    }

    void get_program_local_parameter_iiv_nv(gl::enum_t target, gl::uint_t index, gl::int_t * params) {
      if ( GLAD_GL_NV_gpu_program4 ) {
        glGetProgramLocalParameterIivNV(target, index, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetProgramLocalParameterIivNV' not available on this platform (extensions: GL_NV_gpu_program4)");
      }
    }

    void get_program_local_parameter_iuiv_nv(gl::enum_t target, gl::uint_t index, gl::uint_t * params) {
      if ( GLAD_GL_NV_gpu_program4 ) {
        glGetProgramLocalParameterIuivNV(target, index, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetProgramLocalParameterIuivNV' not available on this platform (extensions: GL_NV_gpu_program4)");
      }
    }

    void get_program_local_parameterdv_arb(gl::enum_t target, gl::uint_t index, gl::double_t * params) {
      if ( GLAD_GL_ARB_fragment_program || GLAD_GL_ARB_vertex_program ) {
        glGetProgramLocalParameterdvARB(target, index, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetProgramLocalParameterdvARB' not available on this platform (extensions: GL_ARB_fragment_program, GL_ARB_vertex_program)");
      }
    }

    void get_program_local_parameterfv_arb(gl::enum_t target, gl::uint_t index, gl::float_t * params) {
      if ( GLAD_GL_ARB_fragment_program || GLAD_GL_ARB_vertex_program ) {
        glGetProgramLocalParameterfvARB(target, index, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetProgramLocalParameterfvARB' not available on this platform (extensions: GL_ARB_fragment_program, GL_ARB_vertex_program)");
      }
    }

    void get_program_named_parameterdv_nv(gl::uint_t id, gl::sizei_t len, const  gl::ubyte_t * name, gl::double_t * params) {
      if ( GLAD_GL_NV_fragment_program ) {
        glGetProgramNamedParameterdvNV(id, len, name, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetProgramNamedParameterdvNV' not available on this platform (extensions: GL_NV_fragment_program)");
      }
    }

    void get_program_named_parameterfv_nv(gl::uint_t id, gl::sizei_t len, const  gl::ubyte_t * name, gl::float_t * params) {
      if ( GLAD_GL_NV_fragment_program ) {
        glGetProgramNamedParameterfvNV(id, len, name, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetProgramNamedParameterfvNV' not available on this platform (extensions: GL_NV_fragment_program)");
      }
    }

    void get_program_parameterdv_nv(gl::enum_t target, gl::uint_t index, gl::enum_t pname, gl::double_t * params) {
      if ( GLAD_GL_NV_vertex_program ) {
        glGetProgramParameterdvNV(target, index, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetProgramParameterdvNV' not available on this platform (extensions: GL_NV_vertex_program)");
      }
    }

    void get_program_parameterfv_nv(gl::enum_t target, gl::uint_t index, gl::enum_t pname, gl::float_t * params) {
      if ( GLAD_GL_NV_vertex_program ) {
        glGetProgramParameterfvNV(target, index, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetProgramParameterfvNV' not available on this platform (extensions: GL_NV_vertex_program)");
      }
    }

    void get_program_pipeline_info_log(gl::uint_t pipeline, gl::sizei_t bufSize, gl::sizei_t * length, gl::char_t * infoLog) {
      if ( GLAD_GL_ARB_separate_shader_objects ) {
        glGetProgramPipelineInfoLog(pipeline, bufSize, length, infoLog);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetProgramPipelineInfoLog' not available on this platform (extensions: GL_ARB_separate_shader_objects)");
      }
    }

    void get_program_pipelineiv(gl::uint_t pipeline, gl::enum_t pname, gl::int_t * params) {
      if ( GLAD_GL_ARB_separate_shader_objects ) {
        glGetProgramPipelineiv(pipeline, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetProgramPipelineiv' not available on this platform (extensions: GL_ARB_separate_shader_objects)");
      }
    }

    gl::uint_t get_program_resource_index(gl::uint_t program, gl::enum_t programInterface, const  gl::char_t * name) {
      if ( GLAD_GL_ARB_program_interface_query ) {
        return glGetProgramResourceIndex(program, programInterface, name);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetProgramResourceIndex' not available on this platform (extensions: GL_ARB_program_interface_query)");
      }
    }

    gl::int_t get_program_resource_location(gl::uint_t program, gl::enum_t programInterface, const  gl::char_t * name) {
      if ( GLAD_GL_ARB_program_interface_query ) {
        return glGetProgramResourceLocation(program, programInterface, name);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetProgramResourceLocation' not available on this platform (extensions: GL_ARB_program_interface_query)");
      }
    }

    gl::int_t get_program_resource_location_index(gl::uint_t program, gl::enum_t programInterface, const  gl::char_t * name) {
      if ( GLAD_GL_ARB_program_interface_query ) {
        return glGetProgramResourceLocationIndex(program, programInterface, name);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetProgramResourceLocationIndex' not available on this platform (extensions: GL_ARB_program_interface_query)");
      }
    }

    void get_program_resource_name(gl::uint_t program, gl::enum_t programInterface, gl::uint_t index, gl::sizei_t bufSize, gl::sizei_t * length, gl::char_t * name) {
      if ( GLAD_GL_ARB_program_interface_query ) {
        glGetProgramResourceName(program, programInterface, index, bufSize, length, name);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetProgramResourceName' not available on this platform (extensions: GL_ARB_program_interface_query)");
      }
    }

    void get_program_resourcefv_nv(gl::uint_t program, gl::enum_t programInterface, gl::uint_t index, gl::sizei_t propCount, const  gl::enum_t * props, gl::sizei_t bufSize, gl::sizei_t * length, gl::float_t * params) {
      if ( GLAD_GL_NV_path_rendering ) {
        glGetProgramResourcefvNV(program, programInterface, index, propCount, props, bufSize, length, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetProgramResourcefvNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void get_program_resourceiv(gl::uint_t program, gl::enum_t programInterface, gl::uint_t index, gl::sizei_t propCount, const  gl::enum_t * props, gl::sizei_t bufSize, gl::sizei_t * length, gl::int_t * params) {
      if ( GLAD_GL_ARB_program_interface_query ) {
        glGetProgramResourceiv(program, programInterface, index, propCount, props, bufSize, length, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetProgramResourceiv' not available on this platform (extensions: GL_ARB_program_interface_query)");
      }
    }

    void get_program_stageiv(gl::uint_t program, gl::enum_t shadertype, gl::enum_t pname, gl::int_t * values) {
      if ( GLAD_GL_ARB_shader_subroutine ) {
        glGetProgramStageiv(program, shadertype, pname, values);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetProgramStageiv' not available on this platform (extensions: GL_ARB_shader_subroutine)");
      }
    }

    void get_program_string_arb(gl::enum_t target, gl::enum_t pname, void * string) {
      if ( GLAD_GL_ARB_fragment_program || GLAD_GL_ARB_vertex_program ) {
        glGetProgramStringARB(target, pname, string);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetProgramStringARB' not available on this platform (extensions: GL_ARB_fragment_program, GL_ARB_vertex_program)");
      }
    }

    void get_program_string_nv(gl::uint_t id, gl::enum_t pname, gl::ubyte_t * program) {
      if ( GLAD_GL_NV_vertex_program ) {
        glGetProgramStringNV(id, pname, program);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetProgramStringNV' not available on this platform (extensions: GL_NV_vertex_program)");
      }
    }

    void get_program_subroutine_parameteruiv_nv(gl::enum_t target, gl::uint_t index, gl::uint_t * param) {
      if ( GLAD_GL_NV_gpu_program5 ) {
        glGetProgramSubroutineParameteruivNV(target, index, param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetProgramSubroutineParameteruivNV' not available on this platform (extensions: GL_NV_gpu_program5)");
      }
    }

    void get_programiv_arb(gl::enum_t target, get_programiv_p_name_t pname, gl::int_t * params) {
      if ( GLAD_GL_ARB_fragment_program || GLAD_GL_ARB_vertex_program ) {
        glGetProgramivARB(target, static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetProgramivARB' not available on this platform (extensions: GL_ARB_fragment_program, GL_ARB_vertex_program)");
      }
    }

    void get_programiv_nv(gl::uint_t id, get_programiv_p_name_t pname, gl::int_t * params) {
      if ( GLAD_GL_NV_vertex_program ) {
        glGetProgramivNV(id, static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetProgramivNV' not available on this platform (extensions: GL_NV_vertex_program)");
      }
    }

    void get_query_buffer_objecti_64v(gl::uint_t id, gl::uint_t buffer, gl::enum_t pname, gl::intptr_t offset) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glGetQueryBufferObjecti64v(id, buffer, pname, offset);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetQueryBufferObjecti64v' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void get_query_buffer_objectiv(gl::uint_t id, gl::uint_t buffer, gl::enum_t pname, gl::intptr_t offset) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glGetQueryBufferObjectiv(id, buffer, pname, offset);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetQueryBufferObjectiv' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void get_query_buffer_objectui_64v(gl::uint_t id, gl::uint_t buffer, gl::enum_t pname, gl::intptr_t offset) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glGetQueryBufferObjectui64v(id, buffer, pname, offset);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetQueryBufferObjectui64v' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void get_query_buffer_objectuiv(gl::uint_t id, gl::uint_t buffer, gl::enum_t pname, gl::intptr_t offset) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glGetQueryBufferObjectuiv(id, buffer, pname, offset);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetQueryBufferObjectuiv' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void get_query_indexediv(gl::enum_t target, gl::uint_t index, gl::enum_t pname, gl::int_t * params) {
      if ( GLAD_GL_ARB_transform_feedback3 ) {
        glGetQueryIndexediv(target, index, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetQueryIndexediv' not available on this platform (extensions: GL_ARB_transform_feedback3)");
      }
    }

    void get_query_objecti_64v(gl::uint_t id, gl::enum_t pname, gl::int64_t * params) {
      if ( GLAD_GL_ARB_timer_query ) {
        glGetQueryObjecti64v(id, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetQueryObjecti64v' not available on this platform (extensions: GL_ARB_timer_query)");
      }
    }

    void get_query_objecti_64v_ext(gl::uint_t id, gl::enum_t pname, gl::int64_t * params) {
      if ( GLAD_GL_EXT_timer_query ) {
        glGetQueryObjecti64vEXT(id, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetQueryObjecti64vEXT' not available on this platform (extensions: GL_EXT_timer_query)");
      }
    }

    void get_query_objectiv_arb(gl::uint_t id, gl::enum_t pname, gl::int_t * params) {
      if ( GLAD_GL_ARB_occlusion_query ) {
        glGetQueryObjectivARB(id, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetQueryObjectivARB' not available on this platform (extensions: GL_ARB_occlusion_query)");
      }
    }

    void get_query_objectui_64v(gl::uint_t id, gl::enum_t pname, gl::uint64_t * params) {
      if ( GLAD_GL_ARB_timer_query ) {
        glGetQueryObjectui64v(id, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetQueryObjectui64v' not available on this platform (extensions: GL_ARB_timer_query)");
      }
    }

    void get_query_objectui_64v_ext(gl::uint_t id, gl::enum_t pname, gl::uint64_t * params) {
      if ( GLAD_GL_EXT_timer_query ) {
        glGetQueryObjectui64vEXT(id, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetQueryObjectui64vEXT' not available on this platform (extensions: GL_EXT_timer_query)");
      }
    }

    void get_query_objectuiv_arb(gl::uint_t id, gl::enum_t pname, gl::uint_t * params) {
      if ( GLAD_GL_ARB_occlusion_query ) {
        glGetQueryObjectuivARB(id, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetQueryObjectuivARB' not available on this platform (extensions: GL_ARB_occlusion_query)");
      }
    }

    void get_queryiv_arb(gl::enum_t target, gl::enum_t pname, gl::int_t * params) {
      if ( GLAD_GL_ARB_occlusion_query ) {
        glGetQueryivARB(target, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetQueryivARB' not available on this platform (extensions: GL_ARB_occlusion_query)");
      }
    }

    void get_renderbuffer_parameteriv(renderbuffer_target_t target, gl::enum_t pname, gl::int_t * params) {
      if ( GLAD_GL_ARB_framebuffer_object ) {
        glGetRenderbufferParameteriv(static_cast<GLenum>(target), pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetRenderbufferParameteriv' not available on this platform (extensions: GL_ARB_framebuffer_object)");
      }
    }

    void get_renderbuffer_parameteriv_ext(renderbuffer_target_t target, gl::enum_t pname, gl::int_t * params) {
      if ( GLAD_GL_EXT_framebuffer_object ) {
        glGetRenderbufferParameterivEXT(static_cast<GLenum>(target), pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetRenderbufferParameterivEXT' not available on this platform (extensions: GL_EXT_framebuffer_object)");
      }
    }

    void get_sampler_parameter_iiv(gl::uint_t sampler, gl::enum_t pname, gl::int_t * params) {
      if ( GLAD_GL_ARB_sampler_objects ) {
        glGetSamplerParameterIiv(sampler, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetSamplerParameterIiv' not available on this platform (extensions: GL_ARB_sampler_objects)");
      }
    }

    void get_sampler_parameter_iuiv(gl::uint_t sampler, gl::enum_t pname, gl::uint_t * params) {
      if ( GLAD_GL_ARB_sampler_objects ) {
        glGetSamplerParameterIuiv(sampler, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetSamplerParameterIuiv' not available on this platform (extensions: GL_ARB_sampler_objects)");
      }
    }

    void get_sampler_parameterfv(gl::uint_t sampler, gl::enum_t pname, gl::float_t * params) {
      if ( GLAD_GL_ARB_sampler_objects ) {
        glGetSamplerParameterfv(sampler, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetSamplerParameterfv' not available on this platform (extensions: GL_ARB_sampler_objects)");
      }
    }

    void get_sampler_parameteriv(gl::uint_t sampler, gl::enum_t pname, gl::int_t * params) {
      if ( GLAD_GL_ARB_sampler_objects ) {
        glGetSamplerParameteriv(sampler, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetSamplerParameteriv' not available on this platform (extensions: GL_ARB_sampler_objects)");
      }
    }

    void get_separable_filter(gl::enum_t target, pixel_format_t format, pixel_type_t type, void * row, void * column, void * span) {
      if ( GLAD_GL_ARB_imaging ) {
        glGetSeparableFilter(target, static_cast<GLenum>(format), static_cast<GLenum>(type), row, column, span);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetSeparableFilter' not available on this platform (extensions: GL_ARB_imaging)");
      }
    }

    void get_separable_filter_ext(separable_target_ext_t target, pixel_format_t format, pixel_type_t type, void * row, void * column, void * span) {
      if ( GLAD_GL_EXT_convolution ) {
        glGetSeparableFilterEXT(static_cast<GLenum>(target), static_cast<GLenum>(format), static_cast<GLenum>(type), row, column, span);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetSeparableFilterEXT' not available on this platform (extensions: GL_EXT_convolution)");
      }
    }

    void get_shader_precision_format(shader_type_t shadertype, precision_type_t precisiontype, gl::int_t * range, gl::int_t * precision) {
      if ( GLAD_GL_ARB_ES2_compatibility ) {
        glGetShaderPrecisionFormat(static_cast<GLenum>(shadertype), static_cast<GLenum>(precisiontype), range, precision);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetShaderPrecisionFormat' not available on this platform (extensions: GL_ARB_ES2_compatibility)");
      }
    }

    void get_shader_source_arb(gl::handleARB_t obj, gl::sizei_t maxLength, gl::sizei_t * length, gl::charARB_t * source) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glGetShaderSourceARB(obj, maxLength, length, source);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetShaderSourceARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void get_sharpen_tex_func_sgis(texture_target_t target, gl::float_t * points) {
      if ( GLAD_GL_SGIS_sharpen_texture ) {
        glGetSharpenTexFuncSGIS(static_cast<GLenum>(target), points);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetSharpenTexFuncSGIS' not available on this platform (extensions: GL_SGIS_sharpen_texture)");
      }
    }

    gl::uint_t get_subroutine_index(gl::uint_t program, gl::enum_t shadertype, const  gl::char_t * name) {
      if ( GLAD_GL_ARB_shader_subroutine ) {
        return glGetSubroutineIndex(program, shadertype, name);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetSubroutineIndex' not available on this platform (extensions: GL_ARB_shader_subroutine)");
      }
    }

    gl::int_t get_subroutine_uniform_location(gl::uint_t program, gl::enum_t shadertype, const  gl::char_t * name) {
      if ( GLAD_GL_ARB_shader_subroutine ) {
        return glGetSubroutineUniformLocation(program, shadertype, name);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetSubroutineUniformLocation' not available on this platform (extensions: GL_ARB_shader_subroutine)");
      }
    }

    void get_synciv(gl::sync_t sync, gl::enum_t pname, gl::sizei_t bufSize, gl::sizei_t * length, gl::int_t * values) {
      if ( GLAD_GL_ARB_sync ) {
        glGetSynciv(sync, pname, bufSize, length, values);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetSynciv' not available on this platform (extensions: GL_ARB_sync)");
      }
    }

    void get_tex_bump_parameterfv_ati(gl::enum_t pname, gl::float_t * param) {
      if ( GLAD_GL_ATI_envmap_bumpmap ) {
        glGetTexBumpParameterfvATI(pname, param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetTexBumpParameterfvATI' not available on this platform (extensions: GL_ATI_envmap_bumpmap)");
      }
    }

    void get_tex_bump_parameteriv_ati(gl::enum_t pname, gl::int_t * param) {
      if ( GLAD_GL_ATI_envmap_bumpmap ) {
        glGetTexBumpParameterivATI(pname, param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetTexBumpParameterivATI' not available on this platform (extensions: GL_ATI_envmap_bumpmap)");
      }
    }

    void get_tex_envxv_oes(gl::enum_t target, gl::enum_t pname, gl::fixed_t * params) {
      if ( GLAD_GL_OES_fixed_point ) {
        glGetTexEnvxvOES(target, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetTexEnvxvOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void get_tex_filter_func_sgis(texture_target_t target, gl::enum_t filter, gl::float_t * weights) {
      if ( GLAD_GL_SGIS_texture_filter4 ) {
        glGetTexFilterFuncSGIS(static_cast<GLenum>(target), filter, weights);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetTexFilterFuncSGIS' not available on this platform (extensions: GL_SGIS_texture_filter4)");
      }
    }

    void get_tex_genxv_oes(gl::enum_t coord, gl::enum_t pname, gl::fixed_t * params) {
      if ( GLAD_GL_OES_fixed_point ) {
        glGetTexGenxvOES(coord, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetTexGenxvOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void get_tex_level_parameterxv_oes(gl::enum_t target, gl::int_t level, gl::enum_t pname, gl::fixed_t * params) {
      if ( GLAD_GL_OES_fixed_point ) {
        glGetTexLevelParameterxvOES(target, level, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetTexLevelParameterxvOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void get_tex_parameter_iiv_ext(texture_target_t target, get_texture_parameter_t pname, gl::int_t * params) {
      if ( GLAD_GL_EXT_texture_integer ) {
        glGetTexParameterIivEXT(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetTexParameterIivEXT' not available on this platform (extensions: GL_EXT_texture_integer)");
      }
    }

    void get_tex_parameter_iuiv_ext(texture_target_t target, get_texture_parameter_t pname, gl::uint_t * params) {
      if ( GLAD_GL_EXT_texture_integer ) {
        glGetTexParameterIuivEXT(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetTexParameterIuivEXT' not available on this platform (extensions: GL_EXT_texture_integer)");
      }
    }

    void get_tex_parameter_pointerv_apple(gl::enum_t target, gl::enum_t pname, void ** params) {
      if ( GLAD_GL_APPLE_texture_range ) {
        glGetTexParameterPointervAPPLE(target, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetTexParameterPointervAPPLE' not available on this platform (extensions: GL_APPLE_texture_range)");
      }
    }

    void get_tex_parameterxv_oes(gl::enum_t target, gl::enum_t pname, gl::fixed_t * params) {
      if ( GLAD_GL_OES_fixed_point ) {
        glGetTexParameterxvOES(target, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetTexParameterxvOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    gl::uint64_t get_texture_handle_arb(gl::uint_t texture) {
      if ( GLAD_GL_ARB_bindless_texture ) {
        return glGetTextureHandleARB(texture);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetTextureHandleARB' not available on this platform (extensions: GL_ARB_bindless_texture)");
      }
    }

    gl::uint64_t get_texture_handle_nv(gl::uint_t texture) {
      if ( GLAD_GL_NV_bindless_texture ) {
        return glGetTextureHandleNV(texture);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetTextureHandleNV' not available on this platform (extensions: GL_NV_bindless_texture)");
      }
    }

    void get_texture_image(gl::uint_t texture, gl::int_t level, gl::enum_t format, gl::enum_t type, gl::sizei_t bufSize, void * pixels) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glGetTextureImage(texture, level, format, type, bufSize, pixels);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetTextureImage' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void get_texture_image_ext(gl::uint_t texture, texture_target_t target, gl::int_t level, pixel_format_t format, pixel_type_t type, void * pixels) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glGetTextureImageEXT(texture, static_cast<GLenum>(target), level, static_cast<GLenum>(format), static_cast<GLenum>(type), pixels);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetTextureImageEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void get_texture_level_parameterfv(gl::uint_t texture, gl::int_t level, gl::enum_t pname, gl::float_t * params) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glGetTextureLevelParameterfv(texture, level, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetTextureLevelParameterfv' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void get_texture_level_parameterfv_ext(gl::uint_t texture, texture_target_t target, gl::int_t level, get_texture_parameter_t pname, gl::float_t * params) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glGetTextureLevelParameterfvEXT(texture, static_cast<GLenum>(target), level, static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetTextureLevelParameterfvEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void get_texture_level_parameteriv(gl::uint_t texture, gl::int_t level, gl::enum_t pname, gl::int_t * params) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glGetTextureLevelParameteriv(texture, level, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetTextureLevelParameteriv' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void get_texture_level_parameteriv_ext(gl::uint_t texture, texture_target_t target, gl::int_t level, get_texture_parameter_t pname, gl::int_t * params) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glGetTextureLevelParameterivEXT(texture, static_cast<GLenum>(target), level, static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetTextureLevelParameterivEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void get_texture_parameter_iiv(gl::uint_t texture, gl::enum_t pname, gl::int_t * params) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glGetTextureParameterIiv(texture, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetTextureParameterIiv' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void get_texture_parameter_iiv_ext(gl::uint_t texture, texture_target_t target, get_texture_parameter_t pname, gl::int_t * params) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glGetTextureParameterIivEXT(texture, static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetTextureParameterIivEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void get_texture_parameter_iuiv(gl::uint_t texture, gl::enum_t pname, gl::uint_t * params) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glGetTextureParameterIuiv(texture, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetTextureParameterIuiv' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void get_texture_parameter_iuiv_ext(gl::uint_t texture, texture_target_t target, get_texture_parameter_t pname, gl::uint_t * params) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glGetTextureParameterIuivEXT(texture, static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetTextureParameterIuivEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void get_texture_parameterfv(gl::uint_t texture, gl::enum_t pname, gl::float_t * params) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glGetTextureParameterfv(texture, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetTextureParameterfv' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void get_texture_parameterfv_ext(gl::uint_t texture, texture_target_t target, get_texture_parameter_t pname, gl::float_t * params) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glGetTextureParameterfvEXT(texture, static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetTextureParameterfvEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void get_texture_parameteriv(gl::uint_t texture, gl::enum_t pname, gl::int_t * params) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glGetTextureParameteriv(texture, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetTextureParameteriv' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void get_texture_parameteriv_ext(gl::uint_t texture, texture_target_t target, get_texture_parameter_t pname, gl::int_t * params) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glGetTextureParameterivEXT(texture, static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetTextureParameterivEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    gl::uint64_t get_texture_sampler_handle_arb(gl::uint_t texture, gl::uint_t sampler) {
      if ( GLAD_GL_ARB_bindless_texture ) {
        return glGetTextureSamplerHandleARB(texture, sampler);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetTextureSamplerHandleARB' not available on this platform (extensions: GL_ARB_bindless_texture)");
      }
    }

    gl::uint64_t get_texture_sampler_handle_nv(gl::uint_t texture, gl::uint_t sampler) {
      if ( GLAD_GL_NV_bindless_texture ) {
        return glGetTextureSamplerHandleNV(texture, sampler);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetTextureSamplerHandleNV' not available on this platform (extensions: GL_NV_bindless_texture)");
      }
    }

    void get_texture_sub_image(gl::uint_t texture, gl::int_t level, gl::int_t xoffset, gl::int_t yoffset, gl::int_t zoffset, gl::sizei_t width, gl::sizei_t height, gl::sizei_t depth, gl::enum_t format, gl::enum_t type, gl::sizei_t bufSize, void * pixels) {
      if ( GLAD_GL_ARB_get_texture_sub_image ) {
        glGetTextureSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, bufSize, pixels);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetTextureSubImage' not available on this platform (extensions: GL_ARB_get_texture_sub_image)");
      }
    }

    void get_track_matrixiv_nv(gl::enum_t target, gl::uint_t address, gl::enum_t pname, gl::int_t * params) {
      if ( GLAD_GL_NV_vertex_program ) {
        glGetTrackMatrixivNV(target, address, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetTrackMatrixivNV' not available on this platform (extensions: GL_NV_vertex_program)");
      }
    }

    void get_transform_feedback_varying_ext(gl::uint_t program, gl::uint_t index, gl::sizei_t bufSize, gl::sizei_t * length, gl::sizei_t * size, gl::enum_t * type, gl::char_t * name) {
      if ( GLAD_GL_EXT_transform_feedback ) {
        glGetTransformFeedbackVaryingEXT(program, index, bufSize, length, size, type, name);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetTransformFeedbackVaryingEXT' not available on this platform (extensions: GL_EXT_transform_feedback)");
      }
    }

    void get_transform_feedback_varying_nv(gl::uint_t program, gl::uint_t index, gl::int_t * location) {
      if ( GLAD_GL_NV_transform_feedback ) {
        glGetTransformFeedbackVaryingNV(program, index, location);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetTransformFeedbackVaryingNV' not available on this platform (extensions: GL_NV_transform_feedback)");
      }
    }

    void get_transform_feedbacki_64_v(gl::uint_t xfb, gl::enum_t pname, gl::uint_t index, gl::int64_t * param) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glGetTransformFeedbacki64_v(xfb, pname, index, param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetTransformFeedbacki64_v' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void get_transform_feedbacki_v(gl::uint_t xfb, gl::enum_t pname, gl::uint_t index, gl::int_t * param) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glGetTransformFeedbacki_v(xfb, pname, index, param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetTransformFeedbacki_v' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void get_transform_feedbackiv(gl::uint_t xfb, gl::enum_t pname, gl::int_t * param) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glGetTransformFeedbackiv(xfb, pname, param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetTransformFeedbackiv' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    gl::uint_t get_uniform_block_index(gl::uint_t program, const  gl::char_t * uniformBlockName) {
      if ( GLAD_GL_ARB_uniform_buffer_object ) {
        return glGetUniformBlockIndex(program, uniformBlockName);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetUniformBlockIndex' not available on this platform (extensions: GL_ARB_uniform_buffer_object)");
      }
    }

    gl::int_t get_uniform_buffer_size_ext(gl::uint_t program, gl::int_t location) {
      if ( GLAD_GL_EXT_bindable_uniform ) {
        return glGetUniformBufferSizeEXT(program, location);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetUniformBufferSizeEXT' not available on this platform (extensions: GL_EXT_bindable_uniform)");
      }
    }

    void get_uniform_indices(gl::uint_t program, gl::sizei_t uniformCount, const  gl::char_t ** uniformNames, gl::uint_t * uniformIndices) {
      if ( GLAD_GL_ARB_uniform_buffer_object ) {
        glGetUniformIndices(program, uniformCount, uniformNames, uniformIndices);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetUniformIndices' not available on this platform (extensions: GL_ARB_uniform_buffer_object)");
      }
    }

    gl::int_t get_uniform_location_arb(gl::handleARB_t programObj, const  gl::charARB_t * name) {
      if ( GLAD_GL_ARB_shader_objects ) {
        return glGetUniformLocationARB(programObj, name);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetUniformLocationARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    gl::intptr_t get_uniform_offset_ext(gl::uint_t program, gl::int_t location) {
      if ( GLAD_GL_EXT_bindable_uniform ) {
        return glGetUniformOffsetEXT(program, location);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetUniformOffsetEXT' not available on this platform (extensions: GL_EXT_bindable_uniform)");
      }
    }

    void get_uniform_subroutineuiv(gl::enum_t shadertype, gl::int_t location, gl::uint_t * params) {
      if ( GLAD_GL_ARB_shader_subroutine ) {
        glGetUniformSubroutineuiv(shadertype, location, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetUniformSubroutineuiv' not available on this platform (extensions: GL_ARB_shader_subroutine)");
      }
    }

    void get_uniformdv(gl::uint_t program, gl::int_t location, gl::double_t * params) {
      if ( GLAD_GL_ARB_gpu_shader_fp64 ) {
        glGetUniformdv(program, location, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetUniformdv' not available on this platform (extensions: GL_ARB_gpu_shader_fp64)");
      }
    }

    void get_uniformfv_arb(gl::handleARB_t programObj, gl::int_t location, gl::float_t * params) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glGetUniformfvARB(programObj, location, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetUniformfvARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void get_uniformi_64v_nv(gl::uint_t program, gl::int_t location, gl::int64EXT_t * params) {
      if ( GLAD_GL_AMD_gpu_shader_int64 || GLAD_GL_NV_gpu_shader5 ) {
        glGetUniformi64vNV(program, location, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetUniformi64vNV' not available on this platform (extensions: GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5)");
      }
    }

    void get_uniformiv_arb(gl::handleARB_t programObj, gl::int_t location, gl::int_t * params) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glGetUniformivARB(programObj, location, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetUniformivARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void get_uniformui_64v_nv(gl::uint_t program, gl::int_t location, gl::uint64EXT_t * params) {
      if ( GLAD_GL_AMD_gpu_shader_int64 || GLAD_GL_NV_shader_buffer_load ) {
        glGetUniformui64vNV(program, location, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetUniformui64vNV' not available on this platform (extensions: GL_AMD_gpu_shader_int64, GL_NV_shader_buffer_load)");
      }
    }

    void get_uniformuiv_ext(gl::uint_t program, gl::int_t location, gl::uint_t * params) {
      if ( GLAD_GL_EXT_gpu_shader4 ) {
        glGetUniformuivEXT(program, location, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetUniformuivEXT' not available on this platform (extensions: GL_EXT_gpu_shader4)");
      }
    }

    void get_variant_array_objectfv_ati(gl::uint_t id, gl::enum_t pname, gl::float_t * params) {
      if ( GLAD_GL_ATI_vertex_array_object ) {
        glGetVariantArrayObjectfvATI(id, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetVariantArrayObjectfvATI' not available on this platform (extensions: GL_ATI_vertex_array_object)");
      }
    }

    void get_variant_array_objectiv_ati(gl::uint_t id, gl::enum_t pname, gl::int_t * params) {
      if ( GLAD_GL_ATI_vertex_array_object ) {
        glGetVariantArrayObjectivATI(id, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetVariantArrayObjectivATI' not available on this platform (extensions: GL_ATI_vertex_array_object)");
      }
    }

    void get_variant_booleanv_ext(gl::uint_t id, gl::enum_t value, gl::boolean_t * data) {
      if ( GLAD_GL_EXT_vertex_shader ) {
        glGetVariantBooleanvEXT(id, value, data);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetVariantBooleanvEXT' not available on this platform (extensions: GL_EXT_vertex_shader)");
      }
    }

    void get_variant_floatv_ext(gl::uint_t id, gl::enum_t value, gl::float_t * data) {
      if ( GLAD_GL_EXT_vertex_shader ) {
        glGetVariantFloatvEXT(id, value, data);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetVariantFloatvEXT' not available on this platform (extensions: GL_EXT_vertex_shader)");
      }
    }

    void get_variant_integerv_ext(gl::uint_t id, gl::enum_t value, gl::int_t * data) {
      if ( GLAD_GL_EXT_vertex_shader ) {
        glGetVariantIntegervEXT(id, value, data);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetVariantIntegervEXT' not available on this platform (extensions: GL_EXT_vertex_shader)");
      }
    }

    void get_variant_pointerv_ext(gl::uint_t id, gl::enum_t value, void ** data) {
      if ( GLAD_GL_EXT_vertex_shader ) {
        glGetVariantPointervEXT(id, value, data);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetVariantPointervEXT' not available on this platform (extensions: GL_EXT_vertex_shader)");
      }
    }

    gl::int_t get_varying_location_nv(gl::uint_t program, const  gl::char_t * name) {
      if ( GLAD_GL_NV_transform_feedback ) {
        return glGetVaryingLocationNV(program, name);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetVaryingLocationNV' not available on this platform (extensions: GL_NV_transform_feedback)");
      }
    }

    void get_vertex_array_indexed_64iv(gl::uint_t vaobj, gl::uint_t index, gl::enum_t pname, gl::int64_t * param) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glGetVertexArrayIndexed64iv(vaobj, index, pname, param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetVertexArrayIndexed64iv' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void get_vertex_array_indexediv(gl::uint_t vaobj, gl::uint_t index, gl::enum_t pname, gl::int_t * param) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glGetVertexArrayIndexediv(vaobj, index, pname, param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetVertexArrayIndexediv' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void get_vertex_array_integeri_v_ext(gl::uint_t vaobj, gl::uint_t index, gl::enum_t pname, gl::int_t * param) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glGetVertexArrayIntegeri_vEXT(vaobj, index, pname, param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetVertexArrayIntegeri_vEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void get_vertex_array_integerv_ext(gl::uint_t vaobj, gl::enum_t pname, gl::int_t * param) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glGetVertexArrayIntegervEXT(vaobj, pname, param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetVertexArrayIntegervEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void get_vertex_array_pointeri_v_ext(gl::uint_t vaobj, gl::uint_t index, gl::enum_t pname, void ** param) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glGetVertexArrayPointeri_vEXT(vaobj, index, pname, param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetVertexArrayPointeri_vEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void get_vertex_array_pointerv_ext(gl::uint_t vaobj, gl::enum_t pname, void ** param) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glGetVertexArrayPointervEXT(vaobj, pname, param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetVertexArrayPointervEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void get_vertex_arrayiv(gl::uint_t vaobj, gl::enum_t pname, gl::int_t * param) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glGetVertexArrayiv(vaobj, pname, param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetVertexArrayiv' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void get_vertex_attrib_array_objectfv_ati(gl::uint_t index, gl::enum_t pname, gl::float_t * params) {
      if ( GLAD_GL_ATI_vertex_attrib_array_object ) {
        glGetVertexAttribArrayObjectfvATI(index, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetVertexAttribArrayObjectfvATI' not available on this platform (extensions: GL_ATI_vertex_attrib_array_object)");
      }
    }

    void get_vertex_attrib_array_objectiv_ati(gl::uint_t index, gl::enum_t pname, gl::int_t * params) {
      if ( GLAD_GL_ATI_vertex_attrib_array_object ) {
        glGetVertexAttribArrayObjectivATI(index, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetVertexAttribArrayObjectivATI' not available on this platform (extensions: GL_ATI_vertex_attrib_array_object)");
      }
    }

    void get_vertex_attrib_iiv_ext(gl::uint_t index, gl::enum_t pname, gl::int_t * params) {
      if ( GLAD_GL_NV_vertex_program4 ) {
        glGetVertexAttribIivEXT(index, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetVertexAttribIivEXT' not available on this platform (extensions: GL_NV_vertex_program4)");
      }
    }

    void get_vertex_attrib_iuiv_ext(gl::uint_t index, gl::enum_t pname, gl::uint_t * params) {
      if ( GLAD_GL_NV_vertex_program4 ) {
        glGetVertexAttribIuivEXT(index, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetVertexAttribIuivEXT' not available on this platform (extensions: GL_NV_vertex_program4)");
      }
    }

    void get_vertex_attrib_ldv(gl::uint_t index, gl::enum_t pname, gl::double_t * params) {
      if ( GLAD_GL_ARB_vertex_attrib_64bit ) {
        glGetVertexAttribLdv(index, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetVertexAttribLdv' not available on this platform (extensions: GL_ARB_vertex_attrib_64bit)");
      }
    }

    void get_vertex_attrib_ldv_ext(gl::uint_t index, gl::enum_t pname, gl::double_t * params) {
      if ( GLAD_GL_EXT_vertex_attrib_64bit ) {
        glGetVertexAttribLdvEXT(index, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetVertexAttribLdvEXT' not available on this platform (extensions: GL_EXT_vertex_attrib_64bit)");
      }
    }

    void get_vertex_attrib_li_64v_nv(gl::uint_t index, gl::enum_t pname, gl::int64EXT_t * params) {
      if ( GLAD_GL_NV_vertex_attrib_integer_64bit ) {
        glGetVertexAttribLi64vNV(index, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetVertexAttribLi64vNV' not available on this platform (extensions: GL_NV_vertex_attrib_integer_64bit)");
      }
    }

    void get_vertex_attrib_lui_64v_arb(gl::uint_t index, gl::enum_t pname, gl::uint64EXT_t * params) {
      if ( GLAD_GL_ARB_bindless_texture ) {
        glGetVertexAttribLui64vARB(index, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetVertexAttribLui64vARB' not available on this platform (extensions: GL_ARB_bindless_texture)");
      }
    }

    void get_vertex_attrib_lui_64v_nv(gl::uint_t index, gl::enum_t pname, gl::uint64EXT_t * params) {
      if ( GLAD_GL_NV_vertex_attrib_integer_64bit ) {
        glGetVertexAttribLui64vNV(index, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetVertexAttribLui64vNV' not available on this platform (extensions: GL_NV_vertex_attrib_integer_64bit)");
      }
    }

    void get_vertex_attrib_pointerv_arb(gl::uint_t index, vertex_attrib_pointer_property_arb_t pname, void ** pointer) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glGetVertexAttribPointervARB(index, static_cast<GLenum>(pname), pointer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetVertexAttribPointervARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void get_vertex_attrib_pointerv_nv(gl::uint_t index, vertex_attrib_pointer_property_arb_t pname, void ** pointer) {
      if ( GLAD_GL_NV_vertex_program ) {
        glGetVertexAttribPointervNV(index, static_cast<GLenum>(pname), pointer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetVertexAttribPointervNV' not available on this platform (extensions: GL_NV_vertex_program)");
      }
    }

    void get_vertex_attribdv_arb(gl::uint_t index, vertex_attrib_property_arb_t pname, gl::double_t * params) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glGetVertexAttribdvARB(index, static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetVertexAttribdvARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void get_vertex_attribdv_nv(gl::uint_t index, vertex_attrib_property_arb_t pname, gl::double_t * params) {
      if ( GLAD_GL_NV_vertex_program ) {
        glGetVertexAttribdvNV(index, static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetVertexAttribdvNV' not available on this platform (extensions: GL_NV_vertex_program)");
      }
    }

    void get_vertex_attribfv_arb(gl::uint_t index, vertex_attrib_property_arb_t pname, gl::float_t * params) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glGetVertexAttribfvARB(index, static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetVertexAttribfvARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void get_vertex_attribfv_nv(gl::uint_t index, vertex_attrib_property_arb_t pname, gl::float_t * params) {
      if ( GLAD_GL_NV_vertex_program ) {
        glGetVertexAttribfvNV(index, static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetVertexAttribfvNV' not available on this platform (extensions: GL_NV_vertex_program)");
      }
    }

    void get_vertex_attribiv_arb(gl::uint_t index, vertex_attrib_property_arb_t pname, gl::int_t * params) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glGetVertexAttribivARB(index, static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetVertexAttribivARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void get_vertex_attribiv_nv(gl::uint_t index, vertex_attrib_property_arb_t pname, gl::int_t * params) {
      if ( GLAD_GL_NV_vertex_program ) {
        glGetVertexAttribivNV(index, static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetVertexAttribivNV' not available on this platform (extensions: GL_NV_vertex_program)");
      }
    }

    void get_video_capture_streamdv_nv(gl::uint_t video_capture_slot, gl::uint_t stream, gl::enum_t pname, gl::double_t * params) {
      if ( GLAD_GL_NV_video_capture ) {
        glGetVideoCaptureStreamdvNV(video_capture_slot, stream, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetVideoCaptureStreamdvNV' not available on this platform (extensions: GL_NV_video_capture)");
      }
    }

    void get_video_capture_streamfv_nv(gl::uint_t video_capture_slot, gl::uint_t stream, gl::enum_t pname, gl::float_t * params) {
      if ( GLAD_GL_NV_video_capture ) {
        glGetVideoCaptureStreamfvNV(video_capture_slot, stream, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetVideoCaptureStreamfvNV' not available on this platform (extensions: GL_NV_video_capture)");
      }
    }

    void get_video_capture_streamiv_nv(gl::uint_t video_capture_slot, gl::uint_t stream, gl::enum_t pname, gl::int_t * params) {
      if ( GLAD_GL_NV_video_capture ) {
        glGetVideoCaptureStreamivNV(video_capture_slot, stream, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetVideoCaptureStreamivNV' not available on this platform (extensions: GL_NV_video_capture)");
      }
    }

    void get_video_captureiv_nv(gl::uint_t video_capture_slot, gl::enum_t pname, gl::int_t * params) {
      if ( GLAD_GL_NV_video_capture ) {
        glGetVideoCaptureivNV(video_capture_slot, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetVideoCaptureivNV' not available on this platform (extensions: GL_NV_video_capture)");
      }
    }

    void get_videoi_64v_nv(gl::uint_t video_slot, gl::enum_t pname, gl::int64EXT_t * params) {
      if ( GLAD_GL_NV_present_video ) {
        glGetVideoi64vNV(video_slot, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetVideoi64vNV' not available on this platform (extensions: GL_NV_present_video)");
      }
    }

    void get_videoiv_nv(gl::uint_t video_slot, gl::enum_t pname, gl::int_t * params) {
      if ( GLAD_GL_NV_present_video ) {
        glGetVideoivNV(video_slot, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetVideoivNV' not available on this platform (extensions: GL_NV_present_video)");
      }
    }

    void get_videoui_64v_nv(gl::uint_t video_slot, gl::enum_t pname, gl::uint64EXT_t * params) {
      if ( GLAD_GL_NV_present_video ) {
        glGetVideoui64vNV(video_slot, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetVideoui64vNV' not available on this platform (extensions: GL_NV_present_video)");
      }
    }

    void get_videouiv_nv(gl::uint_t video_slot, gl::enum_t pname, gl::uint_t * params) {
      if ( GLAD_GL_NV_present_video ) {
        glGetVideouivNV(video_slot, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetVideouivNV' not available on this platform (extensions: GL_NV_present_video)");
      }
    }

    void getn_color_table_arb(gl::enum_t target, gl::enum_t format, gl::enum_t type, gl::sizei_t bufSize, void * table) {
      if ( GLAD_GL_ARB_robustness ) {
        glGetnColorTableARB(target, format, type, bufSize, table);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetnColorTableARB' not available on this platform (extensions: GL_ARB_robustness)");
      }
    }

    void getn_compressed_tex_image_arb(gl::enum_t target, gl::int_t lod, gl::sizei_t bufSize, void * img) {
      if ( GLAD_GL_ARB_robustness ) {
        glGetnCompressedTexImageARB(target, lod, bufSize, img);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetnCompressedTexImageARB' not available on this platform (extensions: GL_ARB_robustness)");
      }
    }

    void getn_convolution_filter_arb(gl::enum_t target, gl::enum_t format, gl::enum_t type, gl::sizei_t bufSize, void * image) {
      if ( GLAD_GL_ARB_robustness ) {
        glGetnConvolutionFilterARB(target, format, type, bufSize, image);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetnConvolutionFilterARB' not available on this platform (extensions: GL_ARB_robustness)");
      }
    }

    void getn_histogram_arb(gl::enum_t target, gl::boolean_t reset, gl::enum_t format, gl::enum_t type, gl::sizei_t bufSize, void * values) {
      if ( GLAD_GL_ARB_robustness ) {
        glGetnHistogramARB(target, reset, format, type, bufSize, values);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetnHistogramARB' not available on this platform (extensions: GL_ARB_robustness)");
      }
    }

    void getn_mapdv_arb(gl::enum_t target, gl::enum_t query, gl::sizei_t bufSize, gl::double_t * v) {
      if ( GLAD_GL_ARB_robustness ) {
        glGetnMapdvARB(target, query, bufSize, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetnMapdvARB' not available on this platform (extensions: GL_ARB_robustness)");
      }
    }

    void getn_mapfv_arb(gl::enum_t target, gl::enum_t query, gl::sizei_t bufSize, gl::float_t * v) {
      if ( GLAD_GL_ARB_robustness ) {
        glGetnMapfvARB(target, query, bufSize, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetnMapfvARB' not available on this platform (extensions: GL_ARB_robustness)");
      }
    }

    void getn_mapiv_arb(gl::enum_t target, gl::enum_t query, gl::sizei_t bufSize, gl::int_t * v) {
      if ( GLAD_GL_ARB_robustness ) {
        glGetnMapivARB(target, query, bufSize, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetnMapivARB' not available on this platform (extensions: GL_ARB_robustness)");
      }
    }

    void getn_minmax_arb(gl::enum_t target, gl::boolean_t reset, gl::enum_t format, gl::enum_t type, gl::sizei_t bufSize, void * values) {
      if ( GLAD_GL_ARB_robustness ) {
        glGetnMinmaxARB(target, reset, format, type, bufSize, values);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetnMinmaxARB' not available on this platform (extensions: GL_ARB_robustness)");
      }
    }

    void getn_pixel_mapfv_arb(gl::enum_t map, gl::sizei_t bufSize, gl::float_t * values) {
      if ( GLAD_GL_ARB_robustness ) {
        glGetnPixelMapfvARB(map, bufSize, values);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetnPixelMapfvARB' not available on this platform (extensions: GL_ARB_robustness)");
      }
    }

    void getn_pixel_mapuiv_arb(gl::enum_t map, gl::sizei_t bufSize, gl::uint_t * values) {
      if ( GLAD_GL_ARB_robustness ) {
        glGetnPixelMapuivARB(map, bufSize, values);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetnPixelMapuivARB' not available on this platform (extensions: GL_ARB_robustness)");
      }
    }

    void getn_pixel_mapusv_arb(gl::enum_t map, gl::sizei_t bufSize, gl::ushort_t * values) {
      if ( GLAD_GL_ARB_robustness ) {
        glGetnPixelMapusvARB(map, bufSize, values);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetnPixelMapusvARB' not available on this platform (extensions: GL_ARB_robustness)");
      }
    }

    void getn_polygon_stipple_arb(gl::sizei_t bufSize, gl::ubyte_t * pattern) {
      if ( GLAD_GL_ARB_robustness ) {
        glGetnPolygonStippleARB(bufSize, pattern);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetnPolygonStippleARB' not available on this platform (extensions: GL_ARB_robustness)");
      }
    }

    void getn_separable_filter_arb(gl::enum_t target, gl::enum_t format, gl::enum_t type, gl::sizei_t rowBufSize, void * row, gl::sizei_t columnBufSize, void * column, void * span) {
      if ( GLAD_GL_ARB_robustness ) {
        glGetnSeparableFilterARB(target, format, type, rowBufSize, row, columnBufSize, column, span);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetnSeparableFilterARB' not available on this platform (extensions: GL_ARB_robustness)");
      }
    }

    void getn_tex_image_arb(gl::enum_t target, gl::int_t level, gl::enum_t format, gl::enum_t type, gl::sizei_t bufSize, void * img) {
      if ( GLAD_GL_ARB_robustness ) {
        glGetnTexImageARB(target, level, format, type, bufSize, img);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetnTexImageARB' not available on this platform (extensions: GL_ARB_robustness)");
      }
    }

    void getn_uniformdv_arb(gl::uint_t program, gl::int_t location, gl::sizei_t bufSize, gl::double_t * params) {
      if ( GLAD_GL_ARB_robustness ) {
        glGetnUniformdvARB(program, location, bufSize, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetnUniformdvARB' not available on this platform (extensions: GL_ARB_robustness)");
      }
    }

    void getn_uniformfv(gl::uint_t program, gl::int_t location, gl::sizei_t bufSize, gl::float_t * params) {
      if ( GLAD_GL_KHR_robustness ) {
        glGetnUniformfv(program, location, bufSize, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetnUniformfv' not available on this platform (extensions: GL_KHR_robustness)");
      }
    }

    void getn_uniformfv_arb(gl::uint_t program, gl::int_t location, gl::sizei_t bufSize, gl::float_t * params) {
      if ( GLAD_GL_ARB_robustness ) {
        glGetnUniformfvARB(program, location, bufSize, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetnUniformfvARB' not available on this platform (extensions: GL_ARB_robustness)");
      }
    }

    void getn_uniformiv(gl::uint_t program, gl::int_t location, gl::sizei_t bufSize, gl::int_t * params) {
      if ( GLAD_GL_KHR_robustness ) {
        glGetnUniformiv(program, location, bufSize, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetnUniformiv' not available on this platform (extensions: GL_KHR_robustness)");
      }
    }

    void getn_uniformiv_arb(gl::uint_t program, gl::int_t location, gl::sizei_t bufSize, gl::int_t * params) {
      if ( GLAD_GL_ARB_robustness ) {
        glGetnUniformivARB(program, location, bufSize, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetnUniformivARB' not available on this platform (extensions: GL_ARB_robustness)");
      }
    }

    void getn_uniformuiv(gl::uint_t program, gl::int_t location, gl::sizei_t bufSize, gl::uint_t * params) {
      if ( GLAD_GL_KHR_robustness ) {
        glGetnUniformuiv(program, location, bufSize, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetnUniformuiv' not available on this platform (extensions: GL_KHR_robustness)");
      }
    }

    void getn_uniformuiv_arb(gl::uint_t program, gl::int_t location, gl::sizei_t bufSize, gl::uint_t * params) {
      if ( GLAD_GL_ARB_robustness ) {
        glGetnUniformuivARB(program, location, bufSize, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetnUniformuivARB' not available on this platform (extensions: GL_ARB_robustness)");
      }
    }

    void global_alpha_factorb_sun(gl::byte_t factor) {
      if ( GLAD_GL_SUN_global_alpha ) {
        glGlobalAlphaFactorbSUN(factor);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGlobalAlphaFactorbSUN' not available on this platform (extensions: GL_SUN_global_alpha)");
      }
    }

    void global_alpha_factord_sun(gl::double_t factor) {
      if ( GLAD_GL_SUN_global_alpha ) {
        glGlobalAlphaFactordSUN(factor);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGlobalAlphaFactordSUN' not available on this platform (extensions: GL_SUN_global_alpha)");
      }
    }

    void global_alpha_factorf_sun(gl::float_t factor) {
      if ( GLAD_GL_SUN_global_alpha ) {
        glGlobalAlphaFactorfSUN(factor);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGlobalAlphaFactorfSUN' not available on this platform (extensions: GL_SUN_global_alpha)");
      }
    }

    void global_alpha_factori_sun(gl::int_t factor) {
      if ( GLAD_GL_SUN_global_alpha ) {
        glGlobalAlphaFactoriSUN(factor);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGlobalAlphaFactoriSUN' not available on this platform (extensions: GL_SUN_global_alpha)");
      }
    }

    void global_alpha_factors_sun(gl::short_t factor) {
      if ( GLAD_GL_SUN_global_alpha ) {
        glGlobalAlphaFactorsSUN(factor);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGlobalAlphaFactorsSUN' not available on this platform (extensions: GL_SUN_global_alpha)");
      }
    }

    void global_alpha_factorub_sun(gl::ubyte_t factor) {
      if ( GLAD_GL_SUN_global_alpha ) {
        glGlobalAlphaFactorubSUN(factor);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGlobalAlphaFactorubSUN' not available on this platform (extensions: GL_SUN_global_alpha)");
      }
    }

    void global_alpha_factorui_sun(gl::uint_t factor) {
      if ( GLAD_GL_SUN_global_alpha ) {
        glGlobalAlphaFactoruiSUN(factor);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGlobalAlphaFactoruiSUN' not available on this platform (extensions: GL_SUN_global_alpha)");
      }
    }

    void global_alpha_factorus_sun(gl::ushort_t factor) {
      if ( GLAD_GL_SUN_global_alpha ) {
        glGlobalAlphaFactorusSUN(factor);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGlobalAlphaFactorusSUN' not available on this platform (extensions: GL_SUN_global_alpha)");
      }
    }

    void hint_pgi(gl::enum_t target, gl::int_t mode) {
      if ( GLAD_GL_PGI_misc_hints ) {
        glHintPGI(target, mode);
      }
      else {
        throw std::runtime_error("OpenGL command 'glHintPGI' not available on this platform (extensions: GL_PGI_misc_hints)");
      }
    }

    void histogram(gl::enum_t target, gl::sizei_t width, gl::enum_t internalformat, gl::boolean_t sink) {
      if ( GLAD_GL_ARB_imaging ) {
        glHistogram(target, width, internalformat, sink);
      }
      else {
        throw std::runtime_error("OpenGL command 'glHistogram' not available on this platform (extensions: GL_ARB_imaging)");
      }
    }

    void histogram_ext(histogram_target_ext_t target, gl::sizei_t width, gl::enum_t internalformat, gl::boolean_t sink) {
      if ( GLAD_GL_EXT_histogram ) {
        glHistogramEXT(static_cast<GLenum>(target), width, internalformat, sink);
      }
      else {
        throw std::runtime_error("OpenGL command 'glHistogramEXT' not available on this platform (extensions: GL_EXT_histogram)");
      }
    }

    void igloo_interface_sgix(gl::enum_t pname, const  void * params) {
      if ( GLAD_GL_SGIX_igloo_interface ) {
        glIglooInterfaceSGIX(pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glIglooInterfaceSGIX' not available on this platform (extensions: GL_SGIX_igloo_interface)");
      }
    }

    void image_transform_parameterf_hp(gl::enum_t target, gl::enum_t pname, gl::float_t param) {
      if ( GLAD_GL_HP_image_transform ) {
        glImageTransformParameterfHP(target, pname, param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glImageTransformParameterfHP' not available on this platform (extensions: GL_HP_image_transform)");
      }
    }

    void image_transform_parameterfv_hp(gl::enum_t target, gl::enum_t pname, const  gl::float_t * params) {
      if ( GLAD_GL_HP_image_transform ) {
        glImageTransformParameterfvHP(target, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glImageTransformParameterfvHP' not available on this platform (extensions: GL_HP_image_transform)");
      }
    }

    void image_transform_parameteri_hp(gl::enum_t target, gl::enum_t pname, gl::int_t param) {
      if ( GLAD_GL_HP_image_transform ) {
        glImageTransformParameteriHP(target, pname, param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glImageTransformParameteriHP' not available on this platform (extensions: GL_HP_image_transform)");
      }
    }

    void image_transform_parameteriv_hp(gl::enum_t target, gl::enum_t pname, const  gl::int_t * params) {
      if ( GLAD_GL_HP_image_transform ) {
        glImageTransformParameterivHP(target, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glImageTransformParameterivHP' not available on this platform (extensions: GL_HP_image_transform)");
      }
    }

    gl::sync_t import_sync_ext(gl::enum_t external_sync_type, gl::intptr_t external_sync, gl::bitfield_t flags) {
      if ( GLAD_GL_EXT_x11_sync_object ) {
        return glImportSyncEXT(external_sync_type, external_sync, flags);
      }
      else {
        throw std::runtime_error("OpenGL command 'glImportSyncEXT' not available on this platform (extensions: GL_EXT_x11_sync_object)");
      }
    }

    void index_format_nv(gl::enum_t type, gl::sizei_t stride) {
      if ( GLAD_GL_NV_vertex_buffer_unified_memory ) {
        glIndexFormatNV(type, stride);
      }
      else {
        throw std::runtime_error("OpenGL command 'glIndexFormatNV' not available on this platform (extensions: GL_NV_vertex_buffer_unified_memory)");
      }
    }

    void index_func_ext(gl::enum_t func, gl::clampf_t ref) {
      if ( GLAD_GL_EXT_index_func ) {
        glIndexFuncEXT(func, ref);
      }
      else {
        throw std::runtime_error("OpenGL command 'glIndexFuncEXT' not available on this platform (extensions: GL_EXT_index_func)");
      }
    }

    void index_material_ext(material_face_t face, gl::enum_t mode) {
      if ( GLAD_GL_EXT_index_material ) {
        glIndexMaterialEXT(static_cast<GLenum>(face), mode);
      }
      else {
        throw std::runtime_error("OpenGL command 'glIndexMaterialEXT' not available on this platform (extensions: GL_EXT_index_material)");
      }
    }

    void index_pointer_ext(index_pointer_type_t type, gl::sizei_t stride, gl::sizei_t count, const  void * pointer) {
      if ( GLAD_GL_EXT_vertex_array ) {
        glIndexPointerEXT(static_cast<GLenum>(type), stride, count, pointer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glIndexPointerEXT' not available on this platform (extensions: GL_EXT_vertex_array)");
      }
    }

    void index_pointer_list_ibm(index_pointer_type_t type, gl::int_t stride, const  void ** pointer, gl::int_t ptrstride) {
      if ( GLAD_GL_IBM_vertex_array_lists ) {
        glIndexPointerListIBM(static_cast<GLenum>(type), stride, pointer, ptrstride);
      }
      else {
        throw std::runtime_error("OpenGL command 'glIndexPointerListIBM' not available on this platform (extensions: GL_IBM_vertex_array_lists)");
      }
    }

    void indexx_oes(gl::fixed_t component) {
      if ( GLAD_GL_OES_fixed_point ) {
        glIndexxOES(component);
      }
      else {
        throw std::runtime_error("OpenGL command 'glIndexxOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void indexxv_oes(const  gl::fixed_t * component) {
      if ( GLAD_GL_OES_fixed_point ) {
        glIndexxvOES(component);
      }
      else {
        throw std::runtime_error("OpenGL command 'glIndexxvOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void insert_component_ext(gl::uint_t res, gl::uint_t src, gl::uint_t num) {
      if ( GLAD_GL_EXT_vertex_shader ) {
        glInsertComponentEXT(res, src, num);
      }
      else {
        throw std::runtime_error("OpenGL command 'glInsertComponentEXT' not available on this platform (extensions: GL_EXT_vertex_shader)");
      }
    }

    void insert_event_marker_ext(gl::sizei_t length, const  gl::char_t * marker) {
      if ( GLAD_GL_EXT_debug_marker ) {
        glInsertEventMarkerEXT(length, marker);
      }
      else {
        throw std::runtime_error("OpenGL command 'glInsertEventMarkerEXT' not available on this platform (extensions: GL_EXT_debug_marker)");
      }
    }

    void instruments_buffer_sgix(gl::sizei_t size, gl::int_t * buffer) {
      if ( GLAD_GL_SGIX_instruments ) {
        glInstrumentsBufferSGIX(size, buffer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glInstrumentsBufferSGIX' not available on this platform (extensions: GL_SGIX_instruments)");
      }
    }

    void interpolate_paths_nv(gl::uint_t resultPath, gl::uint_t pathA, gl::uint_t pathB, gl::float_t weight) {
      if ( GLAD_GL_NV_path_rendering ) {
        glInterpolatePathsNV(resultPath, pathA, pathB, weight);
      }
      else {
        throw std::runtime_error("OpenGL command 'glInterpolatePathsNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void invalidate_buffer_data(gl::uint_t buffer) {
      if ( GLAD_GL_ARB_invalidate_subdata ) {
        glInvalidateBufferData(buffer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glInvalidateBufferData' not available on this platform (extensions: GL_ARB_invalidate_subdata)");
      }
    }

    void invalidate_buffer_sub_data(gl::uint_t buffer, gl::intptr_t offset, gl::sizeiptr_t length) {
      if ( GLAD_GL_ARB_invalidate_subdata ) {
        glInvalidateBufferSubData(buffer, offset, length);
      }
      else {
        throw std::runtime_error("OpenGL command 'glInvalidateBufferSubData' not available on this platform (extensions: GL_ARB_invalidate_subdata)");
      }
    }

    void invalidate_framebuffer(gl::enum_t target, gl::sizei_t numAttachments, const  gl::enum_t * attachments) {
      if ( GLAD_GL_ARB_invalidate_subdata ) {
        glInvalidateFramebuffer(target, numAttachments, attachments);
      }
      else {
        throw std::runtime_error("OpenGL command 'glInvalidateFramebuffer' not available on this platform (extensions: GL_ARB_invalidate_subdata)");
      }
    }

    void invalidate_named_framebuffer_data(gl::uint_t framebuffer, gl::sizei_t numAttachments, const  gl::enum_t * attachments) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glInvalidateNamedFramebufferData(framebuffer, numAttachments, attachments);
      }
      else {
        throw std::runtime_error("OpenGL command 'glInvalidateNamedFramebufferData' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void invalidate_named_framebuffer_sub_data(gl::uint_t framebuffer, gl::sizei_t numAttachments, const  gl::enum_t * attachments, gl::int_t x, gl::int_t y, gl::sizei_t width, gl::sizei_t height) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glInvalidateNamedFramebufferSubData(framebuffer, numAttachments, attachments, x, y, width, height);
      }
      else {
        throw std::runtime_error("OpenGL command 'glInvalidateNamedFramebufferSubData' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void invalidate_sub_framebuffer(gl::enum_t target, gl::sizei_t numAttachments, const  gl::enum_t * attachments, gl::int_t x, gl::int_t y, gl::sizei_t width, gl::sizei_t height) {
      if ( GLAD_GL_ARB_invalidate_subdata ) {
        glInvalidateSubFramebuffer(target, numAttachments, attachments, x, y, width, height);
      }
      else {
        throw std::runtime_error("OpenGL command 'glInvalidateSubFramebuffer' not available on this platform (extensions: GL_ARB_invalidate_subdata)");
      }
    }

    void invalidate_tex_image(gl::uint_t texture, gl::int_t level) {
      if ( GLAD_GL_ARB_invalidate_subdata ) {
        glInvalidateTexImage(texture, level);
      }
      else {
        throw std::runtime_error("OpenGL command 'glInvalidateTexImage' not available on this platform (extensions: GL_ARB_invalidate_subdata)");
      }
    }

    void invalidate_tex_sub_image(gl::uint_t texture, gl::int_t level, gl::int_t xoffset, gl::int_t yoffset, gl::int_t zoffset, gl::sizei_t width, gl::sizei_t height, gl::sizei_t depth) {
      if ( GLAD_GL_ARB_invalidate_subdata ) {
        glInvalidateTexSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth);
      }
      else {
        throw std::runtime_error("OpenGL command 'glInvalidateTexSubImage' not available on this platform (extensions: GL_ARB_invalidate_subdata)");
      }
    }

    gl::boolean_t is_async_marker_sgix(gl::uint_t marker) {
      if ( GLAD_GL_SGIX_async ) {
        return glIsAsyncMarkerSGIX(marker);
      }
      else {
        throw std::runtime_error("OpenGL command 'glIsAsyncMarkerSGIX' not available on this platform (extensions: GL_SGIX_async)");
      }
    }

    gl::boolean_t is_buffer_arb(gl::uint_t buffer) {
      if ( GLAD_GL_ARB_vertex_buffer_object ) {
        return glIsBufferARB(buffer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glIsBufferARB' not available on this platform (extensions: GL_ARB_vertex_buffer_object)");
      }
    }

    gl::boolean_t is_buffer_resident_nv(gl::enum_t target) {
      if ( GLAD_GL_NV_shader_buffer_load ) {
        return glIsBufferResidentNV(target);
      }
      else {
        throw std::runtime_error("OpenGL command 'glIsBufferResidentNV' not available on this platform (extensions: GL_NV_shader_buffer_load)");
      }
    }

    gl::boolean_t is_enabled_indexed_ext(gl::enum_t target, gl::uint_t index) {
      if ( GLAD_GL_EXT_direct_state_access || GLAD_GL_EXT_draw_buffers2 ) {
        return glIsEnabledIndexedEXT(target, index);
      }
      else {
        throw std::runtime_error("OpenGL command 'glIsEnabledIndexedEXT' not available on this platform (extensions: GL_EXT_direct_state_access, GL_EXT_draw_buffers2)");
      }
    }

    gl::boolean_t is_fence_apple(gl::uint_t fence) {
      if ( GLAD_GL_APPLE_fence ) {
        return glIsFenceAPPLE(fence);
      }
      else {
        throw std::runtime_error("OpenGL command 'glIsFenceAPPLE' not available on this platform (extensions: GL_APPLE_fence)");
      }
    }

    gl::boolean_t is_fence_nv(gl::uint_t fence) {
      if ( GLAD_GL_NV_fence ) {
        return glIsFenceNV(fence);
      }
      else {
        throw std::runtime_error("OpenGL command 'glIsFenceNV' not available on this platform (extensions: GL_NV_fence)");
      }
    }

    gl::boolean_t is_framebuffer(gl::uint_t framebuffer) {
      if ( GLAD_GL_ARB_framebuffer_object ) {
        return glIsFramebuffer(framebuffer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glIsFramebuffer' not available on this platform (extensions: GL_ARB_framebuffer_object)");
      }
    }

    gl::boolean_t is_framebuffer_ext(gl::uint_t framebuffer) {
      if ( GLAD_GL_EXT_framebuffer_object ) {
        return glIsFramebufferEXT(framebuffer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glIsFramebufferEXT' not available on this platform (extensions: GL_EXT_framebuffer_object)");
      }
    }

    gl::boolean_t is_image_handle_resident_arb(gl::uint64_t handle) {
      if ( GLAD_GL_ARB_bindless_texture ) {
        return glIsImageHandleResidentARB(handle);
      }
      else {
        throw std::runtime_error("OpenGL command 'glIsImageHandleResidentARB' not available on this platform (extensions: GL_ARB_bindless_texture)");
      }
    }

    gl::boolean_t is_image_handle_resident_nv(gl::uint64_t handle) {
      if ( GLAD_GL_NV_bindless_texture ) {
        return glIsImageHandleResidentNV(handle);
      }
      else {
        throw std::runtime_error("OpenGL command 'glIsImageHandleResidentNV' not available on this platform (extensions: GL_NV_bindless_texture)");
      }
    }

    gl::boolean_t is_name_amd(gl::enum_t identifier, gl::uint_t name) {
      if ( GLAD_GL_AMD_name_gen_delete ) {
        return glIsNameAMD(identifier, name);
      }
      else {
        throw std::runtime_error("OpenGL command 'glIsNameAMD' not available on this platform (extensions: GL_AMD_name_gen_delete)");
      }
    }

    gl::boolean_t is_named_buffer_resident_nv(gl::uint_t buffer) {
      if ( GLAD_GL_NV_shader_buffer_load ) {
        return glIsNamedBufferResidentNV(buffer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glIsNamedBufferResidentNV' not available on this platform (extensions: GL_NV_shader_buffer_load)");
      }
    }

    gl::boolean_t is_named_string_arb(gl::int_t namelen, const  gl::char_t * name) {
      if ( GLAD_GL_ARB_shading_language_include ) {
        return glIsNamedStringARB(namelen, name);
      }
      else {
        throw std::runtime_error("OpenGL command 'glIsNamedStringARB' not available on this platform (extensions: GL_ARB_shading_language_include)");
      }
    }

    gl::boolean_t is_object_buffer_ati(gl::uint_t buffer) {
      if ( GLAD_GL_ATI_vertex_array_object ) {
        return glIsObjectBufferATI(buffer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glIsObjectBufferATI' not available on this platform (extensions: GL_ATI_vertex_array_object)");
      }
    }

    gl::boolean_t is_occlusion_query_nv(gl::uint_t id) {
      if ( GLAD_GL_NV_occlusion_query ) {
        return glIsOcclusionQueryNV(id);
      }
      else {
        throw std::runtime_error("OpenGL command 'glIsOcclusionQueryNV' not available on this platform (extensions: GL_NV_occlusion_query)");
      }
    }

    gl::boolean_t is_path_nv(gl::uint_t path) {
      if ( GLAD_GL_NV_path_rendering ) {
        return glIsPathNV(path);
      }
      else {
        throw std::runtime_error("OpenGL command 'glIsPathNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    gl::boolean_t is_point_in_fill_path_nv(gl::uint_t path, gl::uint_t mask, gl::float_t x, gl::float_t y) {
      if ( GLAD_GL_NV_path_rendering ) {
        return glIsPointInFillPathNV(path, mask, x, y);
      }
      else {
        throw std::runtime_error("OpenGL command 'glIsPointInFillPathNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    gl::boolean_t is_point_in_stroke_path_nv(gl::uint_t path, gl::float_t x, gl::float_t y) {
      if ( GLAD_GL_NV_path_rendering ) {
        return glIsPointInStrokePathNV(path, x, y);
      }
      else {
        throw std::runtime_error("OpenGL command 'glIsPointInStrokePathNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    gl::boolean_t is_program_arb(gl::uint_t program) {
      if ( GLAD_GL_ARB_fragment_program || GLAD_GL_ARB_vertex_program ) {
        return glIsProgramARB(program);
      }
      else {
        throw std::runtime_error("OpenGL command 'glIsProgramARB' not available on this platform (extensions: GL_ARB_fragment_program, GL_ARB_vertex_program)");
      }
    }

    gl::boolean_t is_program_nv(gl::uint_t id) {
      if ( GLAD_GL_NV_vertex_program ) {
        return glIsProgramNV(id);
      }
      else {
        throw std::runtime_error("OpenGL command 'glIsProgramNV' not available on this platform (extensions: GL_NV_vertex_program)");
      }
    }

    gl::boolean_t is_program_pipeline(gl::uint_t pipeline) {
      if ( GLAD_GL_ARB_separate_shader_objects ) {
        return glIsProgramPipeline(pipeline);
      }
      else {
        throw std::runtime_error("OpenGL command 'glIsProgramPipeline' not available on this platform (extensions: GL_ARB_separate_shader_objects)");
      }
    }

    gl::boolean_t is_query_arb(gl::uint_t id) {
      if ( GLAD_GL_ARB_occlusion_query ) {
        return glIsQueryARB(id);
      }
      else {
        throw std::runtime_error("OpenGL command 'glIsQueryARB' not available on this platform (extensions: GL_ARB_occlusion_query)");
      }
    }

    gl::boolean_t is_renderbuffer(gl::uint_t renderbuffer) {
      if ( GLAD_GL_ARB_framebuffer_object ) {
        return glIsRenderbuffer(renderbuffer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glIsRenderbuffer' not available on this platform (extensions: GL_ARB_framebuffer_object)");
      }
    }

    gl::boolean_t is_renderbuffer_ext(gl::uint_t renderbuffer) {
      if ( GLAD_GL_EXT_framebuffer_object ) {
        return glIsRenderbufferEXT(renderbuffer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glIsRenderbufferEXT' not available on this platform (extensions: GL_EXT_framebuffer_object)");
      }
    }

    gl::boolean_t is_sampler(gl::uint_t sampler) {
      if ( GLAD_GL_ARB_sampler_objects ) {
        return glIsSampler(sampler);
      }
      else {
        throw std::runtime_error("OpenGL command 'glIsSampler' not available on this platform (extensions: GL_ARB_sampler_objects)");
      }
    }

    gl::boolean_t is_sync(gl::sync_t sync) {
      if ( GLAD_GL_ARB_sync ) {
        return glIsSync(sync);
      }
      else {
        throw std::runtime_error("OpenGL command 'glIsSync' not available on this platform (extensions: GL_ARB_sync)");
      }
    }

    gl::boolean_t is_texture_ext(gl::uint_t texture) {
      if ( GLAD_GL_EXT_texture_object ) {
        return glIsTextureEXT(texture);
      }
      else {
        throw std::runtime_error("OpenGL command 'glIsTextureEXT' not available on this platform (extensions: GL_EXT_texture_object)");
      }
    }

    gl::boolean_t is_texture_handle_resident_arb(gl::uint64_t handle) {
      if ( GLAD_GL_ARB_bindless_texture ) {
        return glIsTextureHandleResidentARB(handle);
      }
      else {
        throw std::runtime_error("OpenGL command 'glIsTextureHandleResidentARB' not available on this platform (extensions: GL_ARB_bindless_texture)");
      }
    }

    gl::boolean_t is_texture_handle_resident_nv(gl::uint64_t handle) {
      if ( GLAD_GL_NV_bindless_texture ) {
        return glIsTextureHandleResidentNV(handle);
      }
      else {
        throw std::runtime_error("OpenGL command 'glIsTextureHandleResidentNV' not available on this platform (extensions: GL_NV_bindless_texture)");
      }
    }

    gl::boolean_t is_transform_feedback(gl::uint_t id) {
      if ( GLAD_GL_ARB_transform_feedback2 ) {
        return glIsTransformFeedback(id);
      }
      else {
        throw std::runtime_error("OpenGL command 'glIsTransformFeedback' not available on this platform (extensions: GL_ARB_transform_feedback2)");
      }
    }

    gl::boolean_t is_transform_feedback_nv(gl::uint_t id) {
      if ( GLAD_GL_NV_transform_feedback2 ) {
        return glIsTransformFeedbackNV(id);
      }
      else {
        throw std::runtime_error("OpenGL command 'glIsTransformFeedbackNV' not available on this platform (extensions: GL_NV_transform_feedback2)");
      }
    }

    gl::boolean_t is_variant_enabled_ext(gl::uint_t id, gl::enum_t cap) {
      if ( GLAD_GL_EXT_vertex_shader ) {
        return glIsVariantEnabledEXT(id, cap);
      }
      else {
        throw std::runtime_error("OpenGL command 'glIsVariantEnabledEXT' not available on this platform (extensions: GL_EXT_vertex_shader)");
      }
    }

    gl::boolean_t is_vertex_array(gl::uint_t array) {
      if ( GLAD_GL_ARB_vertex_array_object ) {
        return glIsVertexArray(array);
      }
      else {
        throw std::runtime_error("OpenGL command 'glIsVertexArray' not available on this platform (extensions: GL_ARB_vertex_array_object)");
      }
    }

    gl::boolean_t is_vertex_array_apple(gl::uint_t array) {
      if ( GLAD_GL_APPLE_vertex_array_object ) {
        return glIsVertexArrayAPPLE(array);
      }
      else {
        throw std::runtime_error("OpenGL command 'glIsVertexArrayAPPLE' not available on this platform (extensions: GL_APPLE_vertex_array_object)");
      }
    }

    gl::boolean_t is_vertex_attrib_enabled_apple(gl::uint_t index, gl::enum_t pname) {
      if ( GLAD_GL_APPLE_vertex_program_evaluators ) {
        return glIsVertexAttribEnabledAPPLE(index, pname);
      }
      else {
        throw std::runtime_error("OpenGL command 'glIsVertexAttribEnabledAPPLE' not available on this platform (extensions: GL_APPLE_vertex_program_evaluators)");
      }
    }

    void label_object_ext(gl::enum_t type, gl::uint_t object, gl::sizei_t length, const  gl::char_t * label) {
      if ( GLAD_GL_EXT_debug_label ) {
        glLabelObjectEXT(type, object, length, label);
      }
      else {
        throw std::runtime_error("OpenGL command 'glLabelObjectEXT' not available on this platform (extensions: GL_EXT_debug_label)");
      }
    }

    void light_envi_sgix(light_env_parameter_sgix_t pname, gl::int_t param) {
      if ( GLAD_GL_SGIX_fragment_lighting ) {
        glLightEnviSGIX(static_cast<GLenum>(pname), param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glLightEnviSGIX' not available on this platform (extensions: GL_SGIX_fragment_lighting)");
      }
    }

    void light_modelx_oes(gl::enum_t pname, gl::fixed_t param) {
      if ( GLAD_GL_OES_fixed_point ) {
        glLightModelxOES(pname, param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glLightModelxOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void light_modelxv_oes(gl::enum_t pname, const  gl::fixed_t * param) {
      if ( GLAD_GL_OES_fixed_point ) {
        glLightModelxvOES(pname, param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glLightModelxvOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void lightx_oes(gl::enum_t light, gl::enum_t pname, gl::fixed_t param) {
      if ( GLAD_GL_OES_fixed_point ) {
        glLightxOES(light, pname, param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glLightxOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void lightxv_oes(gl::enum_t light, gl::enum_t pname, const  gl::fixed_t * params) {
      if ( GLAD_GL_OES_fixed_point ) {
        glLightxvOES(light, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glLightxvOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void line_widthx_oes(gl::fixed_t width) {
      if ( GLAD_GL_OES_fixed_point ) {
        glLineWidthxOES(width);
      }
      else {
        throw std::runtime_error("OpenGL command 'glLineWidthxOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void link_program_arb(gl::handleARB_t programObj) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glLinkProgramARB(programObj);
      }
      else {
        throw std::runtime_error("OpenGL command 'glLinkProgramARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void list_parameterf_sgix(gl::uint_t list, list_parameter_name_t pname, gl::float_t param) {
      if ( GLAD_GL_SGIX_list_priority ) {
        glListParameterfSGIX(list, static_cast<GLenum>(pname), param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glListParameterfSGIX' not available on this platform (extensions: GL_SGIX_list_priority)");
      }
    }

    void list_parameterfv_sgix(gl::uint_t list, list_parameter_name_t pname, const  gl::float_t * params) {
      if ( GLAD_GL_SGIX_list_priority ) {
        glListParameterfvSGIX(list, static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glListParameterfvSGIX' not available on this platform (extensions: GL_SGIX_list_priority)");
      }
    }

    void list_parameteri_sgix(gl::uint_t list, list_parameter_name_t pname, gl::int_t param) {
      if ( GLAD_GL_SGIX_list_priority ) {
        glListParameteriSGIX(list, static_cast<GLenum>(pname), param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glListParameteriSGIX' not available on this platform (extensions: GL_SGIX_list_priority)");
      }
    }

    void list_parameteriv_sgix(gl::uint_t list, list_parameter_name_t pname, const  gl::int_t * params) {
      if ( GLAD_GL_SGIX_list_priority ) {
        glListParameterivSGIX(list, static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glListParameterivSGIX' not available on this platform (extensions: GL_SGIX_list_priority)");
      }
    }

    void load_identity_deformation_map_sgix(gl::bitmask<ffd_mask_sgix_flags_t> mask) {
      if ( GLAD_GL_SGIX_polynomial_ffd ) {
        glLoadIdentityDeformationMapSGIX(static_cast<GLbitfield>(mask.value));
      }
      else {
        throw std::runtime_error("OpenGL command 'glLoadIdentityDeformationMapSGIX' not available on this platform (extensions: GL_SGIX_polynomial_ffd)");
      }
    }

    void load_matrixx_oes(const  gl::fixed_t * m) {
      if ( GLAD_GL_OES_fixed_point ) {
        glLoadMatrixxOES(m);
      }
      else {
        throw std::runtime_error("OpenGL command 'glLoadMatrixxOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void load_program_nv(gl::enum_t target, gl::uint_t id, gl::sizei_t len, const  gl::ubyte_t * program) {
      if ( GLAD_GL_NV_vertex_program ) {
        glLoadProgramNV(target, id, len, program);
      }
      else {
        throw std::runtime_error("OpenGL command 'glLoadProgramNV' not available on this platform (extensions: GL_NV_vertex_program)");
      }
    }

    void load_transpose_matrixd_arb(const  gl::double_t * m) {
      if ( GLAD_GL_ARB_transpose_matrix ) {
        glLoadTransposeMatrixdARB(m);
      }
      else {
        throw std::runtime_error("OpenGL command 'glLoadTransposeMatrixdARB' not available on this platform (extensions: GL_ARB_transpose_matrix)");
      }
    }

    void load_transpose_matrixf_arb(const  gl::float_t * m) {
      if ( GLAD_GL_ARB_transpose_matrix ) {
        glLoadTransposeMatrixfARB(m);
      }
      else {
        throw std::runtime_error("OpenGL command 'glLoadTransposeMatrixfARB' not available on this platform (extensions: GL_ARB_transpose_matrix)");
      }
    }

    void load_transpose_matrixx_oes(const  gl::fixed_t * m) {
      if ( GLAD_GL_OES_fixed_point ) {
        glLoadTransposeMatrixxOES(m);
      }
      else {
        throw std::runtime_error("OpenGL command 'glLoadTransposeMatrixxOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void lock_arrays_ext(gl::int_t first, gl::sizei_t count) {
      if ( GLAD_GL_EXT_compiled_vertex_array ) {
        glLockArraysEXT(first, count);
      }
      else {
        throw std::runtime_error("OpenGL command 'glLockArraysEXT' not available on this platform (extensions: GL_EXT_compiled_vertex_array)");
      }
    }

    void make_buffer_non_resident_nv(gl::enum_t target) {
      if ( GLAD_GL_NV_shader_buffer_load ) {
        glMakeBufferNonResidentNV(target);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMakeBufferNonResidentNV' not available on this platform (extensions: GL_NV_shader_buffer_load)");
      }
    }

    void make_buffer_resident_nv(gl::enum_t target, gl::enum_t access) {
      if ( GLAD_GL_NV_shader_buffer_load ) {
        glMakeBufferResidentNV(target, access);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMakeBufferResidentNV' not available on this platform (extensions: GL_NV_shader_buffer_load)");
      }
    }

    void make_image_handle_non_resident_arb(gl::uint64_t handle) {
      if ( GLAD_GL_ARB_bindless_texture ) {
        glMakeImageHandleNonResidentARB(handle);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMakeImageHandleNonResidentARB' not available on this platform (extensions: GL_ARB_bindless_texture)");
      }
    }

    void make_image_handle_non_resident_nv(gl::uint64_t handle) {
      if ( GLAD_GL_NV_bindless_texture ) {
        glMakeImageHandleNonResidentNV(handle);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMakeImageHandleNonResidentNV' not available on this platform (extensions: GL_NV_bindless_texture)");
      }
    }

    void make_image_handle_resident_arb(gl::uint64_t handle, gl::enum_t access) {
      if ( GLAD_GL_ARB_bindless_texture ) {
        glMakeImageHandleResidentARB(handle, access);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMakeImageHandleResidentARB' not available on this platform (extensions: GL_ARB_bindless_texture)");
      }
    }

    void make_image_handle_resident_nv(gl::uint64_t handle, gl::enum_t access) {
      if ( GLAD_GL_NV_bindless_texture ) {
        glMakeImageHandleResidentNV(handle, access);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMakeImageHandleResidentNV' not available on this platform (extensions: GL_NV_bindless_texture)");
      }
    }

    void make_named_buffer_non_resident_nv(gl::uint_t buffer) {
      if ( GLAD_GL_NV_shader_buffer_load ) {
        glMakeNamedBufferNonResidentNV(buffer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMakeNamedBufferNonResidentNV' not available on this platform (extensions: GL_NV_shader_buffer_load)");
      }
    }

    void make_named_buffer_resident_nv(gl::uint_t buffer, gl::enum_t access) {
      if ( GLAD_GL_NV_shader_buffer_load ) {
        glMakeNamedBufferResidentNV(buffer, access);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMakeNamedBufferResidentNV' not available on this platform (extensions: GL_NV_shader_buffer_load)");
      }
    }

    void make_texture_handle_non_resident_arb(gl::uint64_t handle) {
      if ( GLAD_GL_ARB_bindless_texture ) {
        glMakeTextureHandleNonResidentARB(handle);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMakeTextureHandleNonResidentARB' not available on this platform (extensions: GL_ARB_bindless_texture)");
      }
    }

    void make_texture_handle_non_resident_nv(gl::uint64_t handle) {
      if ( GLAD_GL_NV_bindless_texture ) {
        glMakeTextureHandleNonResidentNV(handle);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMakeTextureHandleNonResidentNV' not available on this platform (extensions: GL_NV_bindless_texture)");
      }
    }

    void make_texture_handle_resident_arb(gl::uint64_t handle) {
      if ( GLAD_GL_ARB_bindless_texture ) {
        glMakeTextureHandleResidentARB(handle);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMakeTextureHandleResidentARB' not available on this platform (extensions: GL_ARB_bindless_texture)");
      }
    }

    void make_texture_handle_resident_nv(gl::uint64_t handle) {
      if ( GLAD_GL_NV_bindless_texture ) {
        glMakeTextureHandleResidentNV(handle);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMakeTextureHandleResidentNV' not available on this platform (extensions: GL_NV_bindless_texture)");
      }
    }

    void map_1x_oes(gl::enum_t target, gl::fixed_t u1, gl::fixed_t u2, gl::int_t stride, gl::int_t order, gl::fixed_t points) {
      if ( GLAD_GL_OES_fixed_point ) {
        glMap1xOES(target, u1, u2, stride, order, points);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMap1xOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void map_2x_oes(gl::enum_t target, gl::fixed_t u1, gl::fixed_t u2, gl::int_t ustride, gl::int_t uorder, gl::fixed_t v1, gl::fixed_t v2, gl::int_t vstride, gl::int_t vorder, gl::fixed_t points) {
      if ( GLAD_GL_OES_fixed_point ) {
        glMap2xOES(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMap2xOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void * map_buffer_arb(buffer_target_arb_t target, gl::enum_t access) {
      if ( GLAD_GL_ARB_vertex_buffer_object ) {
        return glMapBufferARB(static_cast<GLenum>(target), access);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMapBufferARB' not available on this platform (extensions: GL_ARB_vertex_buffer_object)");
      }
    }

    void * map_buffer_range(buffer_target_arb_t target, gl::intptr_t offset, gl::sizeiptr_t length, gl::bitfield_t access) {
      if ( GLAD_GL_ARB_map_buffer_range ) {
        return glMapBufferRange(static_cast<GLenum>(target), offset, length, access);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMapBufferRange' not available on this platform (extensions: GL_ARB_map_buffer_range)");
      }
    }

    void map_control_points_nv(gl::enum_t target, gl::uint_t index, gl::enum_t type, gl::sizei_t ustride, gl::sizei_t vstride, gl::int_t uorder, gl::int_t vorder, gl::boolean_t packed, const  void * points) {
      if ( GLAD_GL_NV_evaluators ) {
        glMapControlPointsNV(target, index, type, ustride, vstride, uorder, vorder, packed, points);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMapControlPointsNV' not available on this platform (extensions: GL_NV_evaluators)");
      }
    }

    void map_grid_1x_oes(gl::int_t n, gl::fixed_t u1, gl::fixed_t u2) {
      if ( GLAD_GL_OES_fixed_point ) {
        glMapGrid1xOES(n, u1, u2);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMapGrid1xOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void map_grid_2x_oes(gl::int_t n, gl::fixed_t u1, gl::fixed_t u2, gl::fixed_t v1, gl::fixed_t v2) {
      if ( GLAD_GL_OES_fixed_point ) {
        glMapGrid2xOES(n, u1, u2, v1, v2);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMapGrid2xOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void * map_named_buffer(gl::uint_t buffer, gl::enum_t access) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        return glMapNamedBuffer(buffer, access);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMapNamedBuffer' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void * map_named_buffer_ext(gl::uint_t buffer, gl::enum_t access) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        return glMapNamedBufferEXT(buffer, access);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMapNamedBufferEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void * map_named_buffer_range(gl::uint_t buffer, gl::intptr_t offset, gl::sizeiptr_t length, gl::bitfield_t access) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        return glMapNamedBufferRange(buffer, offset, length, access);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMapNamedBufferRange' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void * map_named_buffer_range_ext(gl::uint_t buffer, gl::intptr_t offset, gl::sizeiptr_t length, gl::bitfield_t access) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        return glMapNamedBufferRangeEXT(buffer, offset, length, access);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMapNamedBufferRangeEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void * map_object_buffer_ati(gl::uint_t buffer) {
      if ( GLAD_GL_ATI_map_object_buffer ) {
        return glMapObjectBufferATI(buffer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMapObjectBufferATI' not available on this platform (extensions: GL_ATI_map_object_buffer)");
      }
    }

    void map_parameterfv_nv(gl::enum_t target, gl::enum_t pname, const  gl::float_t * params) {
      if ( GLAD_GL_NV_evaluators ) {
        glMapParameterfvNV(target, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMapParameterfvNV' not available on this platform (extensions: GL_NV_evaluators)");
      }
    }

    void map_parameteriv_nv(gl::enum_t target, gl::enum_t pname, const  gl::int_t * params) {
      if ( GLAD_GL_NV_evaluators ) {
        glMapParameterivNV(target, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMapParameterivNV' not available on this platform (extensions: GL_NV_evaluators)");
      }
    }

    void * map_texture_2dintel(gl::uint_t texture, gl::int_t level, gl::bitfield_t access, gl::int_t * stride, gl::enum_t * layout) {
      if ( GLAD_GL_INTEL_map_texture ) {
        return glMapTexture2DINTEL(texture, level, access, stride, layout);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMapTexture2DINTEL' not available on this platform (extensions: GL_INTEL_map_texture)");
      }
    }

    void map_vertex_attrib_1d_apple(gl::uint_t index, gl::uint_t size, gl::double_t u1, gl::double_t u2, gl::int_t stride, gl::int_t order, const  gl::double_t * points) {
      if ( GLAD_GL_APPLE_vertex_program_evaluators ) {
        glMapVertexAttrib1dAPPLE(index, size, u1, u2, stride, order, points);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMapVertexAttrib1dAPPLE' not available on this platform (extensions: GL_APPLE_vertex_program_evaluators)");
      }
    }

    void map_vertex_attrib_1f_apple(gl::uint_t index, gl::uint_t size, gl::float_t u1, gl::float_t u2, gl::int_t stride, gl::int_t order, const  gl::float_t * points) {
      if ( GLAD_GL_APPLE_vertex_program_evaluators ) {
        glMapVertexAttrib1fAPPLE(index, size, u1, u2, stride, order, points);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMapVertexAttrib1fAPPLE' not available on this platform (extensions: GL_APPLE_vertex_program_evaluators)");
      }
    }

    void map_vertex_attrib_2d_apple(gl::uint_t index, gl::uint_t size, gl::double_t u1, gl::double_t u2, gl::int_t ustride, gl::int_t uorder, gl::double_t v1, gl::double_t v2, gl::int_t vstride, gl::int_t vorder, const  gl::double_t * points) {
      if ( GLAD_GL_APPLE_vertex_program_evaluators ) {
        glMapVertexAttrib2dAPPLE(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMapVertexAttrib2dAPPLE' not available on this platform (extensions: GL_APPLE_vertex_program_evaluators)");
      }
    }

    void map_vertex_attrib_2f_apple(gl::uint_t index, gl::uint_t size, gl::float_t u1, gl::float_t u2, gl::int_t ustride, gl::int_t uorder, gl::float_t v1, gl::float_t v2, gl::int_t vstride, gl::int_t vorder, const  gl::float_t * points) {
      if ( GLAD_GL_APPLE_vertex_program_evaluators ) {
        glMapVertexAttrib2fAPPLE(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMapVertexAttrib2fAPPLE' not available on this platform (extensions: GL_APPLE_vertex_program_evaluators)");
      }
    }

    void materialx_oes(gl::enum_t face, gl::enum_t pname, gl::fixed_t param) {
      if ( GLAD_GL_OES_fixed_point ) {
        glMaterialxOES(face, pname, param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMaterialxOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void materialxv_oes(gl::enum_t face, gl::enum_t pname, const  gl::fixed_t * param) {
      if ( GLAD_GL_OES_fixed_point ) {
        glMaterialxvOES(face, pname, param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMaterialxvOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void matrix_frustum_ext(matrix_mode_t mode, gl::double_t left, gl::double_t right, gl::double_t bottom, gl::double_t top, gl::double_t zNear, gl::double_t zFar) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glMatrixFrustumEXT(static_cast<GLenum>(mode), left, right, bottom, top, zNear, zFar);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMatrixFrustumEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void matrix_index_pointer_arb(gl::int_t size, gl::enum_t type, gl::sizei_t stride, const  void * pointer) {
      if ( GLAD_GL_ARB_matrix_palette ) {
        glMatrixIndexPointerARB(size, type, stride, pointer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMatrixIndexPointerARB' not available on this platform (extensions: GL_ARB_matrix_palette)");
      }
    }

    void matrix_indexubv_arb(gl::int_t size, const  gl::ubyte_t * indices) {
      if ( GLAD_GL_ARB_matrix_palette ) {
        glMatrixIndexubvARB(size, indices);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMatrixIndexubvARB' not available on this platform (extensions: GL_ARB_matrix_palette)");
      }
    }

    void matrix_indexuiv_arb(gl::int_t size, const  gl::uint_t * indices) {
      if ( GLAD_GL_ARB_matrix_palette ) {
        glMatrixIndexuivARB(size, indices);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMatrixIndexuivARB' not available on this platform (extensions: GL_ARB_matrix_palette)");
      }
    }

    void matrix_indexusv_arb(gl::int_t size, const  gl::ushort_t * indices) {
      if ( GLAD_GL_ARB_matrix_palette ) {
        glMatrixIndexusvARB(size, indices);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMatrixIndexusvARB' not available on this platform (extensions: GL_ARB_matrix_palette)");
      }
    }

    void matrix_load_3x_2f_nv(gl::enum_t matrixMode, const  gl::float_t * m) {
      if ( GLAD_GL_NV_path_rendering ) {
        glMatrixLoad3x2fNV(matrixMode, m);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMatrixLoad3x2fNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void matrix_load_3x_3f_nv(gl::enum_t matrixMode, const  gl::float_t * m) {
      if ( GLAD_GL_NV_path_rendering ) {
        glMatrixLoad3x3fNV(matrixMode, m);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMatrixLoad3x3fNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void matrix_load_identity_ext(matrix_mode_t mode) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glMatrixLoadIdentityEXT(static_cast<GLenum>(mode));
      }
      else {
        throw std::runtime_error("OpenGL command 'glMatrixLoadIdentityEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void matrix_load_transpose_3x_3f_nv(gl::enum_t matrixMode, const  gl::float_t * m) {
      if ( GLAD_GL_NV_path_rendering ) {
        glMatrixLoadTranspose3x3fNV(matrixMode, m);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMatrixLoadTranspose3x3fNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void matrix_load_transposed_ext(matrix_mode_t mode, const  gl::double_t * m) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glMatrixLoadTransposedEXT(static_cast<GLenum>(mode), m);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMatrixLoadTransposedEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void matrix_load_transposef_ext(matrix_mode_t mode, const  gl::float_t * m) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glMatrixLoadTransposefEXT(static_cast<GLenum>(mode), m);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMatrixLoadTransposefEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void matrix_loadd_ext(matrix_mode_t mode, const  gl::double_t * m) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glMatrixLoaddEXT(static_cast<GLenum>(mode), m);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMatrixLoaddEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void matrix_loadf_ext(matrix_mode_t mode, const  gl::float_t * m) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glMatrixLoadfEXT(static_cast<GLenum>(mode), m);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMatrixLoadfEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void matrix_mult_3x_2f_nv(gl::enum_t matrixMode, const  gl::float_t * m) {
      if ( GLAD_GL_NV_path_rendering ) {
        glMatrixMult3x2fNV(matrixMode, m);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMatrixMult3x2fNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void matrix_mult_3x_3f_nv(gl::enum_t matrixMode, const  gl::float_t * m) {
      if ( GLAD_GL_NV_path_rendering ) {
        glMatrixMult3x3fNV(matrixMode, m);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMatrixMult3x3fNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void matrix_mult_transpose_3x_3f_nv(gl::enum_t matrixMode, const  gl::float_t * m) {
      if ( GLAD_GL_NV_path_rendering ) {
        glMatrixMultTranspose3x3fNV(matrixMode, m);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMatrixMultTranspose3x3fNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void matrix_mult_transposed_ext(matrix_mode_t mode, const  gl::double_t * m) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glMatrixMultTransposedEXT(static_cast<GLenum>(mode), m);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMatrixMultTransposedEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void matrix_mult_transposef_ext(matrix_mode_t mode, const  gl::float_t * m) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glMatrixMultTransposefEXT(static_cast<GLenum>(mode), m);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMatrixMultTransposefEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void matrix_multd_ext(matrix_mode_t mode, const  gl::double_t * m) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glMatrixMultdEXT(static_cast<GLenum>(mode), m);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMatrixMultdEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void matrix_multf_ext(matrix_mode_t mode, const  gl::float_t * m) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glMatrixMultfEXT(static_cast<GLenum>(mode), m);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMatrixMultfEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void matrix_ortho_ext(matrix_mode_t mode, gl::double_t left, gl::double_t right, gl::double_t bottom, gl::double_t top, gl::double_t zNear, gl::double_t zFar) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glMatrixOrthoEXT(static_cast<GLenum>(mode), left, right, bottom, top, zNear, zFar);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMatrixOrthoEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void matrix_pop_ext(matrix_mode_t mode) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glMatrixPopEXT(static_cast<GLenum>(mode));
      }
      else {
        throw std::runtime_error("OpenGL command 'glMatrixPopEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void matrix_push_ext(matrix_mode_t mode) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glMatrixPushEXT(static_cast<GLenum>(mode));
      }
      else {
        throw std::runtime_error("OpenGL command 'glMatrixPushEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void matrix_rotated_ext(matrix_mode_t mode, gl::double_t angle, gl::double_t x, gl::double_t y, gl::double_t z) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glMatrixRotatedEXT(static_cast<GLenum>(mode), angle, x, y, z);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMatrixRotatedEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void matrix_rotatef_ext(matrix_mode_t mode, gl::float_t angle, gl::float_t x, gl::float_t y, gl::float_t z) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glMatrixRotatefEXT(static_cast<GLenum>(mode), angle, x, y, z);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMatrixRotatefEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void matrix_scaled_ext(matrix_mode_t mode, gl::double_t x, gl::double_t y, gl::double_t z) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glMatrixScaledEXT(static_cast<GLenum>(mode), x, y, z);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMatrixScaledEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void matrix_scalef_ext(matrix_mode_t mode, gl::float_t x, gl::float_t y, gl::float_t z) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glMatrixScalefEXT(static_cast<GLenum>(mode), x, y, z);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMatrixScalefEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void matrix_translated_ext(matrix_mode_t mode, gl::double_t x, gl::double_t y, gl::double_t z) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glMatrixTranslatedEXT(static_cast<GLenum>(mode), x, y, z);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMatrixTranslatedEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void matrix_translatef_ext(matrix_mode_t mode, gl::float_t x, gl::float_t y, gl::float_t z) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glMatrixTranslatefEXT(static_cast<GLenum>(mode), x, y, z);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMatrixTranslatefEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void memory_barrier(gl::bitfield_t barriers) {
      if ( GLAD_GL_ARB_shader_image_load_store ) {
        glMemoryBarrier(barriers);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMemoryBarrier' not available on this platform (extensions: GL_ARB_shader_image_load_store)");
      }
    }

    void memory_barrier_by_region(gl::bitfield_t barriers) {
      if ( GLAD_GL_ARB_ES3_1_compatibility ) {
        glMemoryBarrierByRegion(barriers);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMemoryBarrierByRegion' not available on this platform (extensions: GL_ARB_ES3_1_compatibility)");
      }
    }

    void memory_barrier_ext(gl::bitfield_t barriers) {
      if ( GLAD_GL_EXT_shader_image_load_store ) {
        glMemoryBarrierEXT(barriers);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMemoryBarrierEXT' not available on this platform (extensions: GL_EXT_shader_image_load_store)");
      }
    }

    void min_sample_shading_arb(gl::float_t value) {
      if ( GLAD_GL_ARB_sample_shading ) {
        glMinSampleShadingARB(value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMinSampleShadingARB' not available on this platform (extensions: GL_ARB_sample_shading)");
      }
    }

    void minmax(gl::enum_t target, gl::enum_t internalformat, gl::boolean_t sink) {
      if ( GLAD_GL_ARB_imaging ) {
        glMinmax(target, internalformat, sink);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMinmax' not available on this platform (extensions: GL_ARB_imaging)");
      }
    }

    void minmax_ext(minmax_target_ext_t target, gl::enum_t internalformat, gl::boolean_t sink) {
      if ( GLAD_GL_EXT_histogram ) {
        glMinmaxEXT(static_cast<GLenum>(target), internalformat, sink);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMinmaxEXT' not available on this platform (extensions: GL_EXT_histogram)");
      }
    }

    void mult_matrixx_oes(const  gl::fixed_t * m) {
      if ( GLAD_GL_OES_fixed_point ) {
        glMultMatrixxOES(m);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultMatrixxOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void mult_transpose_matrixd_arb(const  gl::double_t * m) {
      if ( GLAD_GL_ARB_transpose_matrix ) {
        glMultTransposeMatrixdARB(m);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultTransposeMatrixdARB' not available on this platform (extensions: GL_ARB_transpose_matrix)");
      }
    }

    void mult_transpose_matrixf_arb(const  gl::float_t * m) {
      if ( GLAD_GL_ARB_transpose_matrix ) {
        glMultTransposeMatrixfARB(m);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultTransposeMatrixfARB' not available on this platform (extensions: GL_ARB_transpose_matrix)");
      }
    }

    void mult_transpose_matrixx_oes(const  gl::fixed_t * m) {
      if ( GLAD_GL_OES_fixed_point ) {
        glMultTransposeMatrixxOES(m);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultTransposeMatrixxOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void multi_draw_arrays_ext(primitive_type_t mode, const  gl::int_t * first, const  gl::sizei_t * count, gl::sizei_t primcount) {
      if ( GLAD_GL_EXT_multi_draw_arrays ) {
        glMultiDrawArraysEXT(static_cast<GLenum>(mode), first, count, primcount);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiDrawArraysEXT' not available on this platform (extensions: GL_EXT_multi_draw_arrays)");
      }
    }

    void multi_draw_arrays_indirect(gl::enum_t mode, const  void * indirect, gl::sizei_t drawcount, gl::sizei_t stride) {
      if ( GLAD_GL_ARB_multi_draw_indirect ) {
        glMultiDrawArraysIndirect(mode, indirect, drawcount, stride);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiDrawArraysIndirect' not available on this platform (extensions: GL_ARB_multi_draw_indirect)");
      }
    }

    void multi_draw_arrays_indirect_amd(gl::enum_t mode, const  void * indirect, gl::sizei_t primcount, gl::sizei_t stride) {
      if ( GLAD_GL_AMD_multi_draw_indirect ) {
        glMultiDrawArraysIndirectAMD(mode, indirect, primcount, stride);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiDrawArraysIndirectAMD' not available on this platform (extensions: GL_AMD_multi_draw_indirect)");
      }
    }

    void multi_draw_arrays_indirect_bindless_count_nv(gl::enum_t mode, const  void * indirect, gl::sizei_t drawCount, gl::sizei_t maxDrawCount, gl::sizei_t stride, gl::int_t vertexBufferCount) {
      if ( GLAD_GL_NV_bindless_multi_draw_indirect_count ) {
        glMultiDrawArraysIndirectBindlessCountNV(mode, indirect, drawCount, maxDrawCount, stride, vertexBufferCount);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiDrawArraysIndirectBindlessCountNV' not available on this platform (extensions: GL_NV_bindless_multi_draw_indirect_count)");
      }
    }

    void multi_draw_arrays_indirect_bindless_nv(gl::enum_t mode, const  void * indirect, gl::sizei_t drawCount, gl::sizei_t stride, gl::int_t vertexBufferCount) {
      if ( GLAD_GL_NV_bindless_multi_draw_indirect ) {
        glMultiDrawArraysIndirectBindlessNV(mode, indirect, drawCount, stride, vertexBufferCount);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiDrawArraysIndirectBindlessNV' not available on this platform (extensions: GL_NV_bindless_multi_draw_indirect)");
      }
    }

    void multi_draw_arrays_indirect_count_arb(gl::enum_t mode, gl::intptr_t indirect, gl::intptr_t drawcount, gl::sizei_t maxdrawcount, gl::sizei_t stride) {
      if ( GLAD_GL_ARB_indirect_parameters ) {
        glMultiDrawArraysIndirectCountARB(mode, indirect, drawcount, maxdrawcount, stride);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiDrawArraysIndirectCountARB' not available on this platform (extensions: GL_ARB_indirect_parameters)");
      }
    }

    void multi_draw_element_array_apple(primitive_type_t mode, const  gl::int_t * first, const  gl::sizei_t * count, gl::sizei_t primcount) {
      if ( GLAD_GL_APPLE_element_array ) {
        glMultiDrawElementArrayAPPLE(static_cast<GLenum>(mode), first, count, primcount);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiDrawElementArrayAPPLE' not available on this platform (extensions: GL_APPLE_element_array)");
      }
    }

    void multi_draw_elements_base_vertex(gl::enum_t mode, const  gl::sizei_t * count, draw_elements_type_t type, const  void ** indices, gl::sizei_t drawcount, const  gl::int_t * basevertex) {
      if ( GLAD_GL_ARB_draw_elements_base_vertex ) {
        glMultiDrawElementsBaseVertex(mode, count, static_cast<GLenum>(type), indices, drawcount, basevertex);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiDrawElementsBaseVertex' not available on this platform (extensions: GL_ARB_draw_elements_base_vertex)");
      }
    }

    void multi_draw_elements_ext(primitive_type_t mode, const  gl::sizei_t * count, draw_elements_type_t type, const  void * * indices, gl::sizei_t primcount) {
      if ( GLAD_GL_EXT_multi_draw_arrays ) {
        glMultiDrawElementsEXT(static_cast<GLenum>(mode), count, static_cast<GLenum>(type), indices, primcount);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiDrawElementsEXT' not available on this platform (extensions: GL_EXT_multi_draw_arrays)");
      }
    }

    void multi_draw_elements_indirect(gl::enum_t mode, gl::enum_t type, const  void * indirect, gl::sizei_t drawcount, gl::sizei_t stride) {
      if ( GLAD_GL_ARB_multi_draw_indirect ) {
        glMultiDrawElementsIndirect(mode, type, indirect, drawcount, stride);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiDrawElementsIndirect' not available on this platform (extensions: GL_ARB_multi_draw_indirect)");
      }
    }

    void multi_draw_elements_indirect_amd(gl::enum_t mode, gl::enum_t type, const  void * indirect, gl::sizei_t primcount, gl::sizei_t stride) {
      if ( GLAD_GL_AMD_multi_draw_indirect ) {
        glMultiDrawElementsIndirectAMD(mode, type, indirect, primcount, stride);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiDrawElementsIndirectAMD' not available on this platform (extensions: GL_AMD_multi_draw_indirect)");
      }
    }

    void multi_draw_elements_indirect_bindless_count_nv(gl::enum_t mode, gl::enum_t type, const  void * indirect, gl::sizei_t drawCount, gl::sizei_t maxDrawCount, gl::sizei_t stride, gl::int_t vertexBufferCount) {
      if ( GLAD_GL_NV_bindless_multi_draw_indirect_count ) {
        glMultiDrawElementsIndirectBindlessCountNV(mode, type, indirect, drawCount, maxDrawCount, stride, vertexBufferCount);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiDrawElementsIndirectBindlessCountNV' not available on this platform (extensions: GL_NV_bindless_multi_draw_indirect_count)");
      }
    }

    void multi_draw_elements_indirect_bindless_nv(gl::enum_t mode, gl::enum_t type, const  void * indirect, gl::sizei_t drawCount, gl::sizei_t stride, gl::int_t vertexBufferCount) {
      if ( GLAD_GL_NV_bindless_multi_draw_indirect ) {
        glMultiDrawElementsIndirectBindlessNV(mode, type, indirect, drawCount, stride, vertexBufferCount);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiDrawElementsIndirectBindlessNV' not available on this platform (extensions: GL_NV_bindless_multi_draw_indirect)");
      }
    }

    void multi_draw_elements_indirect_count_arb(gl::enum_t mode, gl::enum_t type, gl::intptr_t indirect, gl::intptr_t drawcount, gl::sizei_t maxdrawcount, gl::sizei_t stride) {
      if ( GLAD_GL_ARB_indirect_parameters ) {
        glMultiDrawElementsIndirectCountARB(mode, type, indirect, drawcount, maxdrawcount, stride);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiDrawElementsIndirectCountARB' not available on this platform (extensions: GL_ARB_indirect_parameters)");
      }
    }

    void multi_draw_range_element_array_apple(primitive_type_t mode, gl::uint_t start, gl::uint_t end, const  gl::int_t * first, const  gl::sizei_t * count, gl::sizei_t primcount) {
      if ( GLAD_GL_APPLE_element_array ) {
        glMultiDrawRangeElementArrayAPPLE(static_cast<GLenum>(mode), start, end, first, count, primcount);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiDrawRangeElementArrayAPPLE' not available on this platform (extensions: GL_APPLE_element_array)");
      }
    }

    void multi_mode_draw_arrays_ibm(const  primitive_type_t * mode, const  gl::int_t * first, const  gl::sizei_t * count, gl::sizei_t primcount, gl::int_t modestride) {
      if ( GLAD_GL_IBM_multimode_draw_arrays ) {
        glMultiModeDrawArraysIBM(reinterpret_cast<const  GLenum *>(mode), first, count, primcount, modestride);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiModeDrawArraysIBM' not available on this platform (extensions: GL_IBM_multimode_draw_arrays)");
      }
    }

    void multi_mode_draw_elements_ibm(const  primitive_type_t * mode, const  gl::sizei_t * count, draw_elements_type_t type, const  void ** indices, gl::sizei_t primcount, gl::int_t modestride) {
      if ( GLAD_GL_IBM_multimode_draw_arrays ) {
        glMultiModeDrawElementsIBM(reinterpret_cast<const  GLenum *>(mode), count, static_cast<GLenum>(type), indices, primcount, modestride);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiModeDrawElementsIBM' not available on this platform (extensions: GL_IBM_multimode_draw_arrays)");
      }
    }

    void multi_tex_buffer_ext(texture_unit_t texunit, texture_target_t target, gl::enum_t internalformat, gl::uint_t buffer) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glMultiTexBufferEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(target), internalformat, buffer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexBufferEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void multi_tex_coord_1b_oes(gl::enum_t texture, gl::byte_t s) {
      if ( GLAD_GL_OES_byte_coordinates ) {
        glMultiTexCoord1bOES(texture, s);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord1bOES' not available on this platform (extensions: GL_OES_byte_coordinates)");
      }
    }

    void multi_tex_coord_1bv_oes(gl::enum_t texture, const  gl::byte_t * coords) {
      if ( GLAD_GL_OES_byte_coordinates ) {
        glMultiTexCoord1bvOES(texture, coords);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord1bvOES' not available on this platform (extensions: GL_OES_byte_coordinates)");
      }
    }

    void multi_tex_coord_1d_arb(texture_unit_t target, gl::double_t s) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord1dARB(static_cast<GLenum>(target), s);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord1dARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_1dv_arb(texture_unit_t target, const  gl::double_t * v) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord1dvARB(static_cast<GLenum>(target), v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord1dvARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_1f_arb(texture_unit_t target, gl::float_t s) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord1fARB(static_cast<GLenum>(target), s);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord1fARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_1fv_arb(texture_unit_t target, const  gl::float_t * v) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord1fvARB(static_cast<GLenum>(target), v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord1fvARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_1h_nv(texture_unit_t target, gl::halfNV_t s) {
      if ( GLAD_GL_NV_half_float ) {
        glMultiTexCoord1hNV(static_cast<GLenum>(target), s);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord1hNV' not available on this platform (extensions: GL_NV_half_float)");
      }
    }

    void multi_tex_coord_1hv_nv(texture_unit_t target, const  gl::halfNV_t * v) {
      if ( GLAD_GL_NV_half_float ) {
        glMultiTexCoord1hvNV(static_cast<GLenum>(target), v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord1hvNV' not available on this platform (extensions: GL_NV_half_float)");
      }
    }

    void multi_tex_coord_1i_arb(texture_unit_t target, gl::int_t s) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord1iARB(static_cast<GLenum>(target), s);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord1iARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_1iv_arb(texture_unit_t target, const  gl::int_t * v) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord1ivARB(static_cast<GLenum>(target), v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord1ivARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_1s_arb(texture_unit_t target, gl::short_t s) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord1sARB(static_cast<GLenum>(target), s);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord1sARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_1sv_arb(texture_unit_t target, const  gl::short_t * v) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord1svARB(static_cast<GLenum>(target), v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord1svARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_1x_oes(gl::enum_t texture, gl::fixed_t s) {
      if ( GLAD_GL_OES_fixed_point ) {
        glMultiTexCoord1xOES(texture, s);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord1xOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void multi_tex_coord_1xv_oes(gl::enum_t texture, const  gl::fixed_t * coords) {
      if ( GLAD_GL_OES_fixed_point ) {
        glMultiTexCoord1xvOES(texture, coords);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord1xvOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void multi_tex_coord_2b_oes(gl::enum_t texture, gl::byte_t s, gl::byte_t t) {
      if ( GLAD_GL_OES_byte_coordinates ) {
        glMultiTexCoord2bOES(texture, s, t);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord2bOES' not available on this platform (extensions: GL_OES_byte_coordinates)");
      }
    }

    void multi_tex_coord_2bv_oes(gl::enum_t texture, const  gl::byte_t * coords) {
      if ( GLAD_GL_OES_byte_coordinates ) {
        glMultiTexCoord2bvOES(texture, coords);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord2bvOES' not available on this platform (extensions: GL_OES_byte_coordinates)");
      }
    }

    void multi_tex_coord_2d_arb(texture_unit_t target, gl::double_t s, gl::double_t t) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord2dARB(static_cast<GLenum>(target), s, t);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord2dARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_2dv_arb(texture_unit_t target, const  gl::double_t * v) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord2dvARB(static_cast<GLenum>(target), v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord2dvARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_2f_arb(texture_unit_t target, gl::float_t s, gl::float_t t) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord2fARB(static_cast<GLenum>(target), s, t);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord2fARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_2fv_arb(texture_unit_t target, const  gl::float_t * v) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord2fvARB(static_cast<GLenum>(target), v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord2fvARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_2h_nv(texture_unit_t target, gl::halfNV_t s, gl::halfNV_t t) {
      if ( GLAD_GL_NV_half_float ) {
        glMultiTexCoord2hNV(static_cast<GLenum>(target), s, t);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord2hNV' not available on this platform (extensions: GL_NV_half_float)");
      }
    }

    void multi_tex_coord_2hv_nv(texture_unit_t target, const  gl::halfNV_t * v) {
      if ( GLAD_GL_NV_half_float ) {
        glMultiTexCoord2hvNV(static_cast<GLenum>(target), v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord2hvNV' not available on this platform (extensions: GL_NV_half_float)");
      }
    }

    void multi_tex_coord_2i_arb(texture_unit_t target, gl::int_t s, gl::int_t t) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord2iARB(static_cast<GLenum>(target), s, t);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord2iARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_2iv_arb(texture_unit_t target, const  gl::int_t * v) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord2ivARB(static_cast<GLenum>(target), v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord2ivARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_2s_arb(texture_unit_t target, gl::short_t s, gl::short_t t) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord2sARB(static_cast<GLenum>(target), s, t);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord2sARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_2sv_arb(texture_unit_t target, const  gl::short_t * v) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord2svARB(static_cast<GLenum>(target), v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord2svARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_2x_oes(gl::enum_t texture, gl::fixed_t s, gl::fixed_t t) {
      if ( GLAD_GL_OES_fixed_point ) {
        glMultiTexCoord2xOES(texture, s, t);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord2xOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void multi_tex_coord_2xv_oes(gl::enum_t texture, const  gl::fixed_t * coords) {
      if ( GLAD_GL_OES_fixed_point ) {
        glMultiTexCoord2xvOES(texture, coords);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord2xvOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void multi_tex_coord_3b_oes(gl::enum_t texture, gl::byte_t s, gl::byte_t t, gl::byte_t r) {
      if ( GLAD_GL_OES_byte_coordinates ) {
        glMultiTexCoord3bOES(texture, s, t, r);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord3bOES' not available on this platform (extensions: GL_OES_byte_coordinates)");
      }
    }

    void multi_tex_coord_3bv_oes(gl::enum_t texture, const  gl::byte_t * coords) {
      if ( GLAD_GL_OES_byte_coordinates ) {
        glMultiTexCoord3bvOES(texture, coords);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord3bvOES' not available on this platform (extensions: GL_OES_byte_coordinates)");
      }
    }

    void multi_tex_coord_3d_arb(texture_unit_t target, gl::double_t s, gl::double_t t, gl::double_t r) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord3dARB(static_cast<GLenum>(target), s, t, r);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord3dARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_3dv_arb(texture_unit_t target, const  gl::double_t * v) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord3dvARB(static_cast<GLenum>(target), v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord3dvARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_3f_arb(texture_unit_t target, gl::float_t s, gl::float_t t, gl::float_t r) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord3fARB(static_cast<GLenum>(target), s, t, r);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord3fARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_3fv_arb(texture_unit_t target, const  gl::float_t * v) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord3fvARB(static_cast<GLenum>(target), v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord3fvARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_3h_nv(texture_unit_t target, gl::halfNV_t s, gl::halfNV_t t, gl::halfNV_t r) {
      if ( GLAD_GL_NV_half_float ) {
        glMultiTexCoord3hNV(static_cast<GLenum>(target), s, t, r);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord3hNV' not available on this platform (extensions: GL_NV_half_float)");
      }
    }

    void multi_tex_coord_3hv_nv(texture_unit_t target, const  gl::halfNV_t * v) {
      if ( GLAD_GL_NV_half_float ) {
        glMultiTexCoord3hvNV(static_cast<GLenum>(target), v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord3hvNV' not available on this platform (extensions: GL_NV_half_float)");
      }
    }

    void multi_tex_coord_3i_arb(texture_unit_t target, gl::int_t s, gl::int_t t, gl::int_t r) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord3iARB(static_cast<GLenum>(target), s, t, r);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord3iARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_3iv_arb(texture_unit_t target, const  gl::int_t * v) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord3ivARB(static_cast<GLenum>(target), v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord3ivARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_3s_arb(texture_unit_t target, gl::short_t s, gl::short_t t, gl::short_t r) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord3sARB(static_cast<GLenum>(target), s, t, r);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord3sARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_3sv_arb(texture_unit_t target, const  gl::short_t * v) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord3svARB(static_cast<GLenum>(target), v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord3svARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_3x_oes(gl::enum_t texture, gl::fixed_t s, gl::fixed_t t, gl::fixed_t r) {
      if ( GLAD_GL_OES_fixed_point ) {
        glMultiTexCoord3xOES(texture, s, t, r);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord3xOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void multi_tex_coord_3xv_oes(gl::enum_t texture, const  gl::fixed_t * coords) {
      if ( GLAD_GL_OES_fixed_point ) {
        glMultiTexCoord3xvOES(texture, coords);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord3xvOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void multi_tex_coord_4b_oes(gl::enum_t texture, gl::byte_t s, gl::byte_t t, gl::byte_t r, gl::byte_t q) {
      if ( GLAD_GL_OES_byte_coordinates ) {
        glMultiTexCoord4bOES(texture, s, t, r, q);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord4bOES' not available on this platform (extensions: GL_OES_byte_coordinates)");
      }
    }

    void multi_tex_coord_4bv_oes(gl::enum_t texture, const  gl::byte_t * coords) {
      if ( GLAD_GL_OES_byte_coordinates ) {
        glMultiTexCoord4bvOES(texture, coords);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord4bvOES' not available on this platform (extensions: GL_OES_byte_coordinates)");
      }
    }

    void multi_tex_coord_4d_arb(texture_unit_t target, gl::double_t s, gl::double_t t, gl::double_t r, gl::double_t q) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord4dARB(static_cast<GLenum>(target), s, t, r, q);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord4dARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_4dv_arb(texture_unit_t target, const  gl::double_t * v) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord4dvARB(static_cast<GLenum>(target), v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord4dvARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_4f_arb(texture_unit_t target, gl::float_t s, gl::float_t t, gl::float_t r, gl::float_t q) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord4fARB(static_cast<GLenum>(target), s, t, r, q);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord4fARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_4fv_arb(texture_unit_t target, const  gl::float_t * v) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord4fvARB(static_cast<GLenum>(target), v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord4fvARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_4h_nv(texture_unit_t target, gl::halfNV_t s, gl::halfNV_t t, gl::halfNV_t r, gl::halfNV_t q) {
      if ( GLAD_GL_NV_half_float ) {
        glMultiTexCoord4hNV(static_cast<GLenum>(target), s, t, r, q);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord4hNV' not available on this platform (extensions: GL_NV_half_float)");
      }
    }

    void multi_tex_coord_4hv_nv(texture_unit_t target, const  gl::halfNV_t * v) {
      if ( GLAD_GL_NV_half_float ) {
        glMultiTexCoord4hvNV(static_cast<GLenum>(target), v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord4hvNV' not available on this platform (extensions: GL_NV_half_float)");
      }
    }

    void multi_tex_coord_4i_arb(texture_unit_t target, gl::int_t s, gl::int_t t, gl::int_t r, gl::int_t q) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord4iARB(static_cast<GLenum>(target), s, t, r, q);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord4iARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_4iv_arb(texture_unit_t target, const  gl::int_t * v) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord4ivARB(static_cast<GLenum>(target), v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord4ivARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_4s_arb(texture_unit_t target, gl::short_t s, gl::short_t t, gl::short_t r, gl::short_t q) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord4sARB(static_cast<GLenum>(target), s, t, r, q);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord4sARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_4sv_arb(texture_unit_t target, const  gl::short_t * v) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord4svARB(static_cast<GLenum>(target), v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord4svARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_4x_oes(gl::enum_t texture, gl::fixed_t s, gl::fixed_t t, gl::fixed_t r, gl::fixed_t q) {
      if ( GLAD_GL_OES_fixed_point ) {
        glMultiTexCoord4xOES(texture, s, t, r, q);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord4xOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void multi_tex_coord_4xv_oes(gl::enum_t texture, const  gl::fixed_t * coords) {
      if ( GLAD_GL_OES_fixed_point ) {
        glMultiTexCoord4xvOES(texture, coords);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord4xvOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void multi_tex_coord_p1ui(gl::enum_t texture, gl::enum_t type, gl::uint_t coords) {
      if ( GLAD_GL_ARB_vertex_type_2_10_10_10_rev ) {
        glMultiTexCoordP1ui(texture, type, coords);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoordP1ui' not available on this platform (extensions: GL_ARB_vertex_type_2_10_10_10_rev)");
      }
    }

    void multi_tex_coord_p1uiv(gl::enum_t texture, gl::enum_t type, const  gl::uint_t * coords) {
      if ( GLAD_GL_ARB_vertex_type_2_10_10_10_rev ) {
        glMultiTexCoordP1uiv(texture, type, coords);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoordP1uiv' not available on this platform (extensions: GL_ARB_vertex_type_2_10_10_10_rev)");
      }
    }

    void multi_tex_coord_p2ui(gl::enum_t texture, gl::enum_t type, gl::uint_t coords) {
      if ( GLAD_GL_ARB_vertex_type_2_10_10_10_rev ) {
        glMultiTexCoordP2ui(texture, type, coords);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoordP2ui' not available on this platform (extensions: GL_ARB_vertex_type_2_10_10_10_rev)");
      }
    }

    void multi_tex_coord_p2uiv(gl::enum_t texture, gl::enum_t type, const  gl::uint_t * coords) {
      if ( GLAD_GL_ARB_vertex_type_2_10_10_10_rev ) {
        glMultiTexCoordP2uiv(texture, type, coords);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoordP2uiv' not available on this platform (extensions: GL_ARB_vertex_type_2_10_10_10_rev)");
      }
    }

    void multi_tex_coord_p3ui(gl::enum_t texture, gl::enum_t type, gl::uint_t coords) {
      if ( GLAD_GL_ARB_vertex_type_2_10_10_10_rev ) {
        glMultiTexCoordP3ui(texture, type, coords);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoordP3ui' not available on this platform (extensions: GL_ARB_vertex_type_2_10_10_10_rev)");
      }
    }

    void multi_tex_coord_p3uiv(gl::enum_t texture, gl::enum_t type, const  gl::uint_t * coords) {
      if ( GLAD_GL_ARB_vertex_type_2_10_10_10_rev ) {
        glMultiTexCoordP3uiv(texture, type, coords);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoordP3uiv' not available on this platform (extensions: GL_ARB_vertex_type_2_10_10_10_rev)");
      }
    }

    void multi_tex_coord_p4ui(gl::enum_t texture, gl::enum_t type, gl::uint_t coords) {
      if ( GLAD_GL_ARB_vertex_type_2_10_10_10_rev ) {
        glMultiTexCoordP4ui(texture, type, coords);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoordP4ui' not available on this platform (extensions: GL_ARB_vertex_type_2_10_10_10_rev)");
      }
    }

    void multi_tex_coord_p4uiv(gl::enum_t texture, gl::enum_t type, const  gl::uint_t * coords) {
      if ( GLAD_GL_ARB_vertex_type_2_10_10_10_rev ) {
        glMultiTexCoordP4uiv(texture, type, coords);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoordP4uiv' not available on this platform (extensions: GL_ARB_vertex_type_2_10_10_10_rev)");
      }
    }

    void multi_tex_coord_pointer_ext(texture_unit_t texunit, gl::int_t size, tex_coord_pointer_type_t type, gl::sizei_t stride, const  void * pointer) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glMultiTexCoordPointerEXT(static_cast<GLenum>(texunit), size, static_cast<GLenum>(type), stride, pointer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoordPointerEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void multi_tex_envf_ext(texture_unit_t texunit, texture_env_target_t target, texture_env_parameter_t pname, gl::float_t param) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glMultiTexEnvfEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(target), static_cast<GLenum>(pname), param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexEnvfEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void multi_tex_envfv_ext(texture_unit_t texunit, texture_env_target_t target, texture_env_parameter_t pname, const  gl::float_t * params) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glMultiTexEnvfvEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexEnvfvEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void multi_tex_envi_ext(texture_unit_t texunit, texture_env_target_t target, texture_env_parameter_t pname, gl::int_t param) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glMultiTexEnviEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(target), static_cast<GLenum>(pname), param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexEnviEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void multi_tex_enviv_ext(texture_unit_t texunit, texture_env_target_t target, texture_env_parameter_t pname, const  gl::int_t * params) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glMultiTexEnvivEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexEnvivEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void multi_tex_gend_ext(texture_unit_t texunit, texture_coord_name_t coord, texture_gen_parameter_t pname, gl::double_t param) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glMultiTexGendEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(coord), static_cast<GLenum>(pname), param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexGendEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void multi_tex_gendv_ext(texture_unit_t texunit, texture_coord_name_t coord, texture_gen_parameter_t pname, const  gl::double_t * params) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glMultiTexGendvEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(coord), static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexGendvEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void multi_tex_genf_ext(texture_unit_t texunit, texture_coord_name_t coord, texture_gen_parameter_t pname, gl::float_t param) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glMultiTexGenfEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(coord), static_cast<GLenum>(pname), param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexGenfEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void multi_tex_genfv_ext(texture_unit_t texunit, texture_coord_name_t coord, texture_gen_parameter_t pname, const  gl::float_t * params) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glMultiTexGenfvEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(coord), static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexGenfvEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void multi_tex_geni_ext(texture_unit_t texunit, texture_coord_name_t coord, texture_gen_parameter_t pname, gl::int_t param) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glMultiTexGeniEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(coord), static_cast<GLenum>(pname), param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexGeniEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void multi_tex_geniv_ext(texture_unit_t texunit, texture_coord_name_t coord, texture_gen_parameter_t pname, const  gl::int_t * params) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glMultiTexGenivEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(coord), static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexGenivEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void multi_tex_image_1dext(texture_unit_t texunit, texture_target_t target, gl::int_t level, texture_component_count_t internalformat, gl::sizei_t width, gl::int_t border, pixel_format_t format, pixel_type_t type, const  void * pixels) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glMultiTexImage1DEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(target), level, static_cast<GLint>(internalformat), width, border, static_cast<GLenum>(format), static_cast<GLenum>(type), pixels);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexImage1DEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void multi_tex_image_2dext(texture_unit_t texunit, texture_target_t target, gl::int_t level, texture_component_count_t internalformat, gl::sizei_t width, gl::sizei_t height, gl::int_t border, pixel_format_t format, pixel_type_t type, const  void * pixels) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glMultiTexImage2DEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(target), level, static_cast<GLint>(internalformat), width, height, border, static_cast<GLenum>(format), static_cast<GLenum>(type), pixels);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexImage2DEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void multi_tex_image_3dext(texture_unit_t texunit, texture_target_t target, gl::int_t level, texture_component_count_t internalformat, gl::sizei_t width, gl::sizei_t height, gl::sizei_t depth, gl::int_t border, pixel_format_t format, pixel_type_t type, const  void * pixels) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glMultiTexImage3DEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(target), level, static_cast<GLint>(internalformat), width, height, depth, border, static_cast<GLenum>(format), static_cast<GLenum>(type), pixels);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexImage3DEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void multi_tex_parameter_iiv_ext(texture_unit_t texunit, texture_target_t target, texture_parameter_name_t pname, const  gl::int_t * params) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glMultiTexParameterIivEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexParameterIivEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void multi_tex_parameter_iuiv_ext(texture_unit_t texunit, texture_target_t target, texture_parameter_name_t pname, const  gl::uint_t * params) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glMultiTexParameterIuivEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexParameterIuivEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void multi_tex_parameterf_ext(texture_unit_t texunit, texture_target_t target, texture_parameter_name_t pname, gl::float_t param) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glMultiTexParameterfEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(target), static_cast<GLenum>(pname), param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexParameterfEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void multi_tex_parameterfv_ext(texture_unit_t texunit, texture_target_t target, texture_parameter_name_t pname, const  gl::float_t * params) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glMultiTexParameterfvEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexParameterfvEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void multi_tex_parameteri_ext(texture_unit_t texunit, texture_target_t target, texture_parameter_name_t pname, gl::int_t param) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glMultiTexParameteriEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(target), static_cast<GLenum>(pname), param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexParameteriEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void multi_tex_parameteriv_ext(texture_unit_t texunit, texture_target_t target, texture_parameter_name_t pname, const  gl::int_t * params) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glMultiTexParameterivEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexParameterivEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void multi_tex_renderbuffer_ext(texture_unit_t texunit, texture_target_t target, gl::uint_t renderbuffer) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glMultiTexRenderbufferEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(target), renderbuffer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexRenderbufferEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void multi_tex_sub_image_1dext(texture_unit_t texunit, texture_target_t target, gl::int_t level, gl::int_t xoffset, gl::sizei_t width, pixel_format_t format, pixel_type_t type, const  void * pixels) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glMultiTexSubImage1DEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(target), level, xoffset, width, static_cast<GLenum>(format), static_cast<GLenum>(type), pixels);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexSubImage1DEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void multi_tex_sub_image_2dext(texture_unit_t texunit, texture_target_t target, gl::int_t level, gl::int_t xoffset, gl::int_t yoffset, gl::sizei_t width, gl::sizei_t height, pixel_format_t format, pixel_type_t type, const  void * pixels) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glMultiTexSubImage2DEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(target), level, xoffset, yoffset, width, height, static_cast<GLenum>(format), static_cast<GLenum>(type), pixels);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexSubImage2DEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void multi_tex_sub_image_3dext(texture_unit_t texunit, texture_target_t target, gl::int_t level, gl::int_t xoffset, gl::int_t yoffset, gl::int_t zoffset, gl::sizei_t width, gl::sizei_t height, gl::sizei_t depth, pixel_format_t format, pixel_type_t type, const  void * pixels) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glMultiTexSubImage3DEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(target), level, xoffset, yoffset, zoffset, width, height, depth, static_cast<GLenum>(format), static_cast<GLenum>(type), pixels);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexSubImage3DEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void named_buffer_data(gl::uint_t buffer, gl::sizeiptr_t size, const  void * data, gl::enum_t usage) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glNamedBufferData(buffer, size, data, usage);
      }
      else {
        throw std::runtime_error("OpenGL command 'glNamedBufferData' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void named_buffer_data_ext(gl::uint_t buffer, gl::sizeiptr_t size, const  void * data, gl::enum_t usage) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glNamedBufferDataEXT(buffer, size, data, usage);
      }
      else {
        throw std::runtime_error("OpenGL command 'glNamedBufferDataEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void named_buffer_page_commitment_arb(gl::uint_t buffer, gl::intptr_t offset, gl::sizeiptr_t size, gl::boolean_t commit) {
      if ( GLAD_GL_ARB_sparse_buffer ) {
        glNamedBufferPageCommitmentARB(buffer, offset, size, commit);
      }
      else {
        throw std::runtime_error("OpenGL command 'glNamedBufferPageCommitmentARB' not available on this platform (extensions: GL_ARB_sparse_buffer)");
      }
    }

    void named_buffer_page_commitment_ext(gl::uint_t buffer, gl::intptr_t offset, gl::sizeiptr_t size, gl::boolean_t commit) {
      if ( GLAD_GL_ARB_sparse_buffer ) {
        glNamedBufferPageCommitmentEXT(buffer, offset, size, commit);
      }
      else {
        throw std::runtime_error("OpenGL command 'glNamedBufferPageCommitmentEXT' not available on this platform (extensions: GL_ARB_sparse_buffer)");
      }
    }

    void named_buffer_storage(gl::uint_t buffer, gl::sizeiptr_t size, const  void * data, gl::bitfield_t flags) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glNamedBufferStorage(buffer, size, data, flags);
      }
      else {
        throw std::runtime_error("OpenGL command 'glNamedBufferStorage' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void named_buffer_storage_ext(gl::uint_t buffer, gl::sizeiptr_t size, const  void * data, gl::bitfield_t flags) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glNamedBufferStorageEXT(buffer, size, data, flags);
      }
      else {
        throw std::runtime_error("OpenGL command 'glNamedBufferStorageEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void named_buffer_sub_data(gl::uint_t buffer, gl::intptr_t offset, gl::sizeiptr_t size, const  void * data) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glNamedBufferSubData(buffer, offset, size, data);
      }
      else {
        throw std::runtime_error("OpenGL command 'glNamedBufferSubData' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void named_buffer_sub_data_ext(gl::uint_t buffer, gl::intptr_t offset, gl::sizeiptr_t size, const  void * data) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glNamedBufferSubDataEXT(buffer, offset, size, data);
      }
      else {
        throw std::runtime_error("OpenGL command 'glNamedBufferSubDataEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void named_copy_buffer_sub_data_ext(gl::uint_t readBuffer, gl::uint_t writeBuffer, gl::intptr_t readOffset, gl::intptr_t writeOffset, gl::sizeiptr_t size) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glNamedCopyBufferSubDataEXT(readBuffer, writeBuffer, readOffset, writeOffset, size);
      }
      else {
        throw std::runtime_error("OpenGL command 'glNamedCopyBufferSubDataEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void named_framebuffer_draw_buffer(gl::uint_t framebuffer, gl::enum_t buf) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glNamedFramebufferDrawBuffer(framebuffer, buf);
      }
      else {
        throw std::runtime_error("OpenGL command 'glNamedFramebufferDrawBuffer' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void named_framebuffer_draw_buffers(gl::uint_t framebuffer, gl::sizei_t n, const  gl::enum_t * bufs) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glNamedFramebufferDrawBuffers(framebuffer, n, bufs);
      }
      else {
        throw std::runtime_error("OpenGL command 'glNamedFramebufferDrawBuffers' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void named_framebuffer_parameteri(gl::uint_t framebuffer, gl::enum_t pname, gl::int_t param) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glNamedFramebufferParameteri(framebuffer, pname, param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glNamedFramebufferParameteri' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void named_framebuffer_parameteri_ext(gl::uint_t framebuffer, gl::enum_t pname, gl::int_t param) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glNamedFramebufferParameteriEXT(framebuffer, pname, param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glNamedFramebufferParameteriEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void named_framebuffer_read_buffer(gl::uint_t framebuffer, gl::enum_t src) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glNamedFramebufferReadBuffer(framebuffer, src);
      }
      else {
        throw std::runtime_error("OpenGL command 'glNamedFramebufferReadBuffer' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void named_framebuffer_renderbuffer(gl::uint_t framebuffer, gl::enum_t attachment, gl::enum_t renderbuffertarget, gl::uint_t renderbuffer) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glNamedFramebufferRenderbuffer(framebuffer, attachment, renderbuffertarget, renderbuffer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glNamedFramebufferRenderbuffer' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void named_framebuffer_renderbuffer_ext(gl::uint_t framebuffer, framebuffer_attachment_t attachment, renderbuffer_target_t renderbuffertarget, gl::uint_t renderbuffer) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glNamedFramebufferRenderbufferEXT(framebuffer, static_cast<GLenum>(attachment), static_cast<GLenum>(renderbuffertarget), renderbuffer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glNamedFramebufferRenderbufferEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void named_framebuffer_sample_locationsfv_nv(gl::uint_t framebuffer, gl::uint_t start, gl::sizei_t count, const  gl::float_t * v) {
      if ( GLAD_GL_NV_sample_locations ) {
        glNamedFramebufferSampleLocationsfvNV(framebuffer, start, count, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glNamedFramebufferSampleLocationsfvNV' not available on this platform (extensions: GL_NV_sample_locations)");
      }
    }

    void named_framebuffer_texture(gl::uint_t framebuffer, gl::enum_t attachment, gl::uint_t texture, gl::int_t level) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glNamedFramebufferTexture(framebuffer, attachment, texture, level);
      }
      else {
        throw std::runtime_error("OpenGL command 'glNamedFramebufferTexture' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void named_framebuffer_texture_1dext(gl::uint_t framebuffer, framebuffer_attachment_t attachment, texture_target_t textarget, gl::uint_t texture, gl::int_t level) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glNamedFramebufferTexture1DEXT(framebuffer, static_cast<GLenum>(attachment), static_cast<GLenum>(textarget), texture, level);
      }
      else {
        throw std::runtime_error("OpenGL command 'glNamedFramebufferTexture1DEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void named_framebuffer_texture_2dext(gl::uint_t framebuffer, framebuffer_attachment_t attachment, texture_target_t textarget, gl::uint_t texture, gl::int_t level) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glNamedFramebufferTexture2DEXT(framebuffer, static_cast<GLenum>(attachment), static_cast<GLenum>(textarget), texture, level);
      }
      else {
        throw std::runtime_error("OpenGL command 'glNamedFramebufferTexture2DEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void named_framebuffer_texture_3dext(gl::uint_t framebuffer, framebuffer_attachment_t attachment, texture_target_t textarget, gl::uint_t texture, gl::int_t level, gl::int_t zoffset) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glNamedFramebufferTexture3DEXT(framebuffer, static_cast<GLenum>(attachment), static_cast<GLenum>(textarget), texture, level, zoffset);
      }
      else {
        throw std::runtime_error("OpenGL command 'glNamedFramebufferTexture3DEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void named_framebuffer_texture_ext(gl::uint_t framebuffer, framebuffer_attachment_t attachment, gl::uint_t texture, gl::int_t level) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glNamedFramebufferTextureEXT(framebuffer, static_cast<GLenum>(attachment), texture, level);
      }
      else {
        throw std::runtime_error("OpenGL command 'glNamedFramebufferTextureEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void named_framebuffer_texture_face_ext(gl::uint_t framebuffer, framebuffer_attachment_t attachment, gl::uint_t texture, gl::int_t level, texture_target_t face) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glNamedFramebufferTextureFaceEXT(framebuffer, static_cast<GLenum>(attachment), texture, level, static_cast<GLenum>(face));
      }
      else {
        throw std::runtime_error("OpenGL command 'glNamedFramebufferTextureFaceEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void named_framebuffer_texture_layer(gl::uint_t framebuffer, gl::enum_t attachment, gl::uint_t texture, gl::int_t level, gl::int_t layer) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glNamedFramebufferTextureLayer(framebuffer, attachment, texture, level, layer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glNamedFramebufferTextureLayer' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void named_framebuffer_texture_layer_ext(gl::uint_t framebuffer, framebuffer_attachment_t attachment, gl::uint_t texture, gl::int_t level, gl::int_t layer) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glNamedFramebufferTextureLayerEXT(framebuffer, static_cast<GLenum>(attachment), texture, level, layer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glNamedFramebufferTextureLayerEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void named_program_local_parameter_4d_ext(gl::uint_t program, gl::enum_t target, gl::uint_t index, gl::double_t x, gl::double_t y, gl::double_t z, gl::double_t w) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glNamedProgramLocalParameter4dEXT(program, target, index, x, y, z, w);
      }
      else {
        throw std::runtime_error("OpenGL command 'glNamedProgramLocalParameter4dEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void named_program_local_parameter_4dv_ext(gl::uint_t program, gl::enum_t target, gl::uint_t index, const  gl::double_t * params) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glNamedProgramLocalParameter4dvEXT(program, target, index, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glNamedProgramLocalParameter4dvEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void named_program_local_parameter_4f_ext(gl::uint_t program, gl::enum_t target, gl::uint_t index, gl::float_t x, gl::float_t y, gl::float_t z, gl::float_t w) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glNamedProgramLocalParameter4fEXT(program, target, index, x, y, z, w);
      }
      else {
        throw std::runtime_error("OpenGL command 'glNamedProgramLocalParameter4fEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void named_program_local_parameter_4fv_ext(gl::uint_t program, gl::enum_t target, gl::uint_t index, const  gl::float_t * params) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glNamedProgramLocalParameter4fvEXT(program, target, index, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glNamedProgramLocalParameter4fvEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void named_program_local_parameter_i4i_ext(gl::uint_t program, gl::enum_t target, gl::uint_t index, gl::int_t x, gl::int_t y, gl::int_t z, gl::int_t w) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glNamedProgramLocalParameterI4iEXT(program, target, index, x, y, z, w);
      }
      else {
        throw std::runtime_error("OpenGL command 'glNamedProgramLocalParameterI4iEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void named_program_local_parameter_i4iv_ext(gl::uint_t program, gl::enum_t target, gl::uint_t index, const  gl::int_t * params) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glNamedProgramLocalParameterI4ivEXT(program, target, index, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glNamedProgramLocalParameterI4ivEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void named_program_local_parameter_i4ui_ext(gl::uint_t program, gl::enum_t target, gl::uint_t index, gl::uint_t x, gl::uint_t y, gl::uint_t z, gl::uint_t w) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glNamedProgramLocalParameterI4uiEXT(program, target, index, x, y, z, w);
      }
      else {
        throw std::runtime_error("OpenGL command 'glNamedProgramLocalParameterI4uiEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void named_program_local_parameter_i4uiv_ext(gl::uint_t program, gl::enum_t target, gl::uint_t index, const  gl::uint_t * params) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glNamedProgramLocalParameterI4uivEXT(program, target, index, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glNamedProgramLocalParameterI4uivEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void named_program_local_parameters_4fv_ext(gl::uint_t program, gl::enum_t target, gl::uint_t index, gl::sizei_t count, const  gl::float_t * params) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glNamedProgramLocalParameters4fvEXT(program, target, index, count, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glNamedProgramLocalParameters4fvEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void named_program_local_parameters_i4iv_ext(gl::uint_t program, gl::enum_t target, gl::uint_t index, gl::sizei_t count, const  gl::int_t * params) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glNamedProgramLocalParametersI4ivEXT(program, target, index, count, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glNamedProgramLocalParametersI4ivEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void named_program_local_parameters_i4uiv_ext(gl::uint_t program, gl::enum_t target, gl::uint_t index, gl::sizei_t count, const  gl::uint_t * params) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glNamedProgramLocalParametersI4uivEXT(program, target, index, count, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glNamedProgramLocalParametersI4uivEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void named_program_string_ext(gl::uint_t program, gl::enum_t target, gl::enum_t format, gl::sizei_t len, const  void * string) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glNamedProgramStringEXT(program, target, format, len, string);
      }
      else {
        throw std::runtime_error("OpenGL command 'glNamedProgramStringEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void named_renderbuffer_storage(gl::uint_t renderbuffer, gl::enum_t internalformat, gl::sizei_t width, gl::sizei_t height) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glNamedRenderbufferStorage(renderbuffer, internalformat, width, height);
      }
      else {
        throw std::runtime_error("OpenGL command 'glNamedRenderbufferStorage' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void named_renderbuffer_storage_ext(gl::uint_t renderbuffer, gl::enum_t internalformat, gl::sizei_t width, gl::sizei_t height) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glNamedRenderbufferStorageEXT(renderbuffer, internalformat, width, height);
      }
      else {
        throw std::runtime_error("OpenGL command 'glNamedRenderbufferStorageEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void named_renderbuffer_storage_multisample(gl::uint_t renderbuffer, gl::sizei_t samples, gl::enum_t internalformat, gl::sizei_t width, gl::sizei_t height) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glNamedRenderbufferStorageMultisample(renderbuffer, samples, internalformat, width, height);
      }
      else {
        throw std::runtime_error("OpenGL command 'glNamedRenderbufferStorageMultisample' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void named_renderbuffer_storage_multisample_coverage_ext(gl::uint_t renderbuffer, gl::sizei_t coverageSamples, gl::sizei_t colorSamples, gl::enum_t internalformat, gl::sizei_t width, gl::sizei_t height) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glNamedRenderbufferStorageMultisampleCoverageEXT(renderbuffer, coverageSamples, colorSamples, internalformat, width, height);
      }
      else {
        throw std::runtime_error("OpenGL command 'glNamedRenderbufferStorageMultisampleCoverageEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void named_renderbuffer_storage_multisample_ext(gl::uint_t renderbuffer, gl::sizei_t samples, gl::enum_t internalformat, gl::sizei_t width, gl::sizei_t height) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glNamedRenderbufferStorageMultisampleEXT(renderbuffer, samples, internalformat, width, height);
      }
      else {
        throw std::runtime_error("OpenGL command 'glNamedRenderbufferStorageMultisampleEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void named_string_arb(gl::enum_t type, gl::int_t namelen, const  gl::char_t * name, gl::int_t stringlen, const  gl::char_t * string) {
      if ( GLAD_GL_ARB_shading_language_include ) {
        glNamedStringARB(type, namelen, name, stringlen, string);
      }
      else {
        throw std::runtime_error("OpenGL command 'glNamedStringARB' not available on this platform (extensions: GL_ARB_shading_language_include)");
      }
    }

    gl::uint_t new_object_buffer_ati(gl::sizei_t size, const  void * pointer, gl::enum_t usage) {
      if ( GLAD_GL_ATI_vertex_array_object ) {
        return glNewObjectBufferATI(size, pointer, usage);
      }
      else {
        throw std::runtime_error("OpenGL command 'glNewObjectBufferATI' not available on this platform (extensions: GL_ATI_vertex_array_object)");
      }
    }

    void normal_3f_vertex_3f_sun(gl::float_t nx, gl::float_t ny, gl::float_t nz, gl::float_t x, gl::float_t y, gl::float_t z) {
      if ( GLAD_GL_SUN_vertex ) {
        glNormal3fVertex3fSUN(nx, ny, nz, x, y, z);
      }
      else {
        throw std::runtime_error("OpenGL command 'glNormal3fVertex3fSUN' not available on this platform (extensions: GL_SUN_vertex)");
      }
    }

    void normal_3f_vertex_3fv_sun(const  gl::float_t * n, const  gl::float_t * v) {
      if ( GLAD_GL_SUN_vertex ) {
        glNormal3fVertex3fvSUN(n, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glNormal3fVertex3fvSUN' not available on this platform (extensions: GL_SUN_vertex)");
      }
    }

    void normal_3h_nv(gl::halfNV_t nx, gl::halfNV_t ny, gl::halfNV_t nz) {
      if ( GLAD_GL_NV_half_float ) {
        glNormal3hNV(nx, ny, nz);
      }
      else {
        throw std::runtime_error("OpenGL command 'glNormal3hNV' not available on this platform (extensions: GL_NV_half_float)");
      }
    }

    void normal_3hv_nv(const  gl::halfNV_t * v) {
      if ( GLAD_GL_NV_half_float ) {
        glNormal3hvNV(v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glNormal3hvNV' not available on this platform (extensions: GL_NV_half_float)");
      }
    }

    void normal_3x_oes(gl::fixed_t nx, gl::fixed_t ny, gl::fixed_t nz) {
      if ( GLAD_GL_OES_fixed_point ) {
        glNormal3xOES(nx, ny, nz);
      }
      else {
        throw std::runtime_error("OpenGL command 'glNormal3xOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void normal_3xv_oes(const  gl::fixed_t * coords) {
      if ( GLAD_GL_OES_fixed_point ) {
        glNormal3xvOES(coords);
      }
      else {
        throw std::runtime_error("OpenGL command 'glNormal3xvOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void normal_format_nv(gl::enum_t type, gl::sizei_t stride) {
      if ( GLAD_GL_NV_vertex_buffer_unified_memory ) {
        glNormalFormatNV(type, stride);
      }
      else {
        throw std::runtime_error("OpenGL command 'glNormalFormatNV' not available on this platform (extensions: GL_NV_vertex_buffer_unified_memory)");
      }
    }

    void normal_p3ui(gl::enum_t type, gl::uint_t coords) {
      if ( GLAD_GL_ARB_vertex_type_2_10_10_10_rev ) {
        glNormalP3ui(type, coords);
      }
      else {
        throw std::runtime_error("OpenGL command 'glNormalP3ui' not available on this platform (extensions: GL_ARB_vertex_type_2_10_10_10_rev)");
      }
    }

    void normal_p3uiv(gl::enum_t type, const  gl::uint_t * coords) {
      if ( GLAD_GL_ARB_vertex_type_2_10_10_10_rev ) {
        glNormalP3uiv(type, coords);
      }
      else {
        throw std::runtime_error("OpenGL command 'glNormalP3uiv' not available on this platform (extensions: GL_ARB_vertex_type_2_10_10_10_rev)");
      }
    }

    void normal_pointer_ext(normal_pointer_type_t type, gl::sizei_t stride, gl::sizei_t count, const  void * pointer) {
      if ( GLAD_GL_EXT_vertex_array ) {
        glNormalPointerEXT(static_cast<GLenum>(type), stride, count, pointer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glNormalPointerEXT' not available on this platform (extensions: GL_EXT_vertex_array)");
      }
    }

    void normal_pointer_list_ibm(normal_pointer_type_t type, gl::int_t stride, const  void ** pointer, gl::int_t ptrstride) {
      if ( GLAD_GL_IBM_vertex_array_lists ) {
        glNormalPointerListIBM(static_cast<GLenum>(type), stride, pointer, ptrstride);
      }
      else {
        throw std::runtime_error("OpenGL command 'glNormalPointerListIBM' not available on this platform (extensions: GL_IBM_vertex_array_lists)");
      }
    }

    void normal_pointerv_intel(normal_pointer_type_t type, const  void ** pointer) {
      if ( GLAD_GL_INTEL_parallel_arrays ) {
        glNormalPointervINTEL(static_cast<GLenum>(type), pointer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glNormalPointervINTEL' not available on this platform (extensions: GL_INTEL_parallel_arrays)");
      }
    }

    void normal_stream_3b_ati(gl::enum_t stream, gl::byte_t nx, gl::byte_t ny, gl::byte_t nz) {
      if ( GLAD_GL_ATI_vertex_streams ) {
        glNormalStream3bATI(stream, nx, ny, nz);
      }
      else {
        throw std::runtime_error("OpenGL command 'glNormalStream3bATI' not available on this platform (extensions: GL_ATI_vertex_streams)");
      }
    }

    void normal_stream_3bv_ati(gl::enum_t stream, const  gl::byte_t * coords) {
      if ( GLAD_GL_ATI_vertex_streams ) {
        glNormalStream3bvATI(stream, coords);
      }
      else {
        throw std::runtime_error("OpenGL command 'glNormalStream3bvATI' not available on this platform (extensions: GL_ATI_vertex_streams)");
      }
    }

    void normal_stream_3d_ati(gl::enum_t stream, gl::double_t nx, gl::double_t ny, gl::double_t nz) {
      if ( GLAD_GL_ATI_vertex_streams ) {
        glNormalStream3dATI(stream, nx, ny, nz);
      }
      else {
        throw std::runtime_error("OpenGL command 'glNormalStream3dATI' not available on this platform (extensions: GL_ATI_vertex_streams)");
      }
    }

    void normal_stream_3dv_ati(gl::enum_t stream, const  gl::double_t * coords) {
      if ( GLAD_GL_ATI_vertex_streams ) {
        glNormalStream3dvATI(stream, coords);
      }
      else {
        throw std::runtime_error("OpenGL command 'glNormalStream3dvATI' not available on this platform (extensions: GL_ATI_vertex_streams)");
      }
    }

    void normal_stream_3f_ati(gl::enum_t stream, gl::float_t nx, gl::float_t ny, gl::float_t nz) {
      if ( GLAD_GL_ATI_vertex_streams ) {
        glNormalStream3fATI(stream, nx, ny, nz);
      }
      else {
        throw std::runtime_error("OpenGL command 'glNormalStream3fATI' not available on this platform (extensions: GL_ATI_vertex_streams)");
      }
    }

    void normal_stream_3fv_ati(gl::enum_t stream, const  gl::float_t * coords) {
      if ( GLAD_GL_ATI_vertex_streams ) {
        glNormalStream3fvATI(stream, coords);
      }
      else {
        throw std::runtime_error("OpenGL command 'glNormalStream3fvATI' not available on this platform (extensions: GL_ATI_vertex_streams)");
      }
    }

    void normal_stream_3i_ati(gl::enum_t stream, gl::int_t nx, gl::int_t ny, gl::int_t nz) {
      if ( GLAD_GL_ATI_vertex_streams ) {
        glNormalStream3iATI(stream, nx, ny, nz);
      }
      else {
        throw std::runtime_error("OpenGL command 'glNormalStream3iATI' not available on this platform (extensions: GL_ATI_vertex_streams)");
      }
    }

    void normal_stream_3iv_ati(gl::enum_t stream, const  gl::int_t * coords) {
      if ( GLAD_GL_ATI_vertex_streams ) {
        glNormalStream3ivATI(stream, coords);
      }
      else {
        throw std::runtime_error("OpenGL command 'glNormalStream3ivATI' not available on this platform (extensions: GL_ATI_vertex_streams)");
      }
    }

    void normal_stream_3s_ati(gl::enum_t stream, gl::short_t nx, gl::short_t ny, gl::short_t nz) {
      if ( GLAD_GL_ATI_vertex_streams ) {
        glNormalStream3sATI(stream, nx, ny, nz);
      }
      else {
        throw std::runtime_error("OpenGL command 'glNormalStream3sATI' not available on this platform (extensions: GL_ATI_vertex_streams)");
      }
    }

    void normal_stream_3sv_ati(gl::enum_t stream, const  gl::short_t * coords) {
      if ( GLAD_GL_ATI_vertex_streams ) {
        glNormalStream3svATI(stream, coords);
      }
      else {
        throw std::runtime_error("OpenGL command 'glNormalStream3svATI' not available on this platform (extensions: GL_ATI_vertex_streams)");
      }
    }

    void object_label(gl::enum_t identifier, gl::uint_t name, gl::sizei_t length, const  gl::char_t * label) {
      if ( GLAD_GL_KHR_debug ) {
        glObjectLabel(identifier, name, length, label);
      }
      else {
        throw std::runtime_error("OpenGL command 'glObjectLabel' not available on this platform (extensions: GL_KHR_debug)");
      }
    }

    void object_ptr_label(const  void * ptr, gl::sizei_t length, const  gl::char_t * label) {
      if ( GLAD_GL_KHR_debug ) {
        glObjectPtrLabel(ptr, length, label);
      }
      else {
        throw std::runtime_error("OpenGL command 'glObjectPtrLabel' not available on this platform (extensions: GL_KHR_debug)");
      }
    }

    gl::enum_t object_purgeable_apple(gl::enum_t objectType, gl::uint_t name, gl::enum_t option) {
      if ( GLAD_GL_APPLE_object_purgeable ) {
        return glObjectPurgeableAPPLE(objectType, name, option);
      }
      else {
        throw std::runtime_error("OpenGL command 'glObjectPurgeableAPPLE' not available on this platform (extensions: GL_APPLE_object_purgeable)");
      }
    }

    gl::enum_t object_unpurgeable_apple(gl::enum_t objectType, gl::uint_t name, gl::enum_t option) {
      if ( GLAD_GL_APPLE_object_purgeable ) {
        return glObjectUnpurgeableAPPLE(objectType, name, option);
      }
      else {
        throw std::runtime_error("OpenGL command 'glObjectUnpurgeableAPPLE' not available on this platform (extensions: GL_APPLE_object_purgeable)");
      }
    }

    void orthof_oes(gl::float_t l, gl::float_t r, gl::float_t b, gl::float_t t, gl::float_t n, gl::float_t f) {
      if ( GLAD_GL_OES_single_precision ) {
        glOrthofOES(l, r, b, t, n, f);
      }
      else {
        throw std::runtime_error("OpenGL command 'glOrthofOES' not available on this platform (extensions: GL_OES_single_precision)");
      }
    }

    void orthox_oes(gl::fixed_t l, gl::fixed_t r, gl::fixed_t b, gl::fixed_t t, gl::fixed_t n, gl::fixed_t f) {
      if ( GLAD_GL_OES_fixed_point ) {
        glOrthoxOES(l, r, b, t, n, f);
      }
      else {
        throw std::runtime_error("OpenGL command 'glOrthoxOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void pn_trianglesf_ati(gl::enum_t pname, gl::float_t param) {
      if ( GLAD_GL_ATI_pn_triangles ) {
        glPNTrianglesfATI(pname, param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPNTrianglesfATI' not available on this platform (extensions: GL_ATI_pn_triangles)");
      }
    }

    void pn_trianglesi_ati(gl::enum_t pname, gl::int_t param) {
      if ( GLAD_GL_ATI_pn_triangles ) {
        glPNTrianglesiATI(pname, param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPNTrianglesiATI' not available on this platform (extensions: GL_ATI_pn_triangles)");
      }
    }

    void pass_tex_coord_ati(gl::uint_t dst, gl::uint_t coord, gl::enum_t swizzle) {
      if ( GLAD_GL_ATI_fragment_shader ) {
        glPassTexCoordATI(dst, coord, swizzle);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPassTexCoordATI' not available on this platform (extensions: GL_ATI_fragment_shader)");
      }
    }

    void pass_throughx_oes(gl::fixed_t token) {
      if ( GLAD_GL_OES_fixed_point ) {
        glPassThroughxOES(token);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPassThroughxOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void patch_parameterfv(gl::enum_t pname, const  gl::float_t * values) {
      if ( GLAD_GL_ARB_tessellation_shader ) {
        glPatchParameterfv(pname, values);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPatchParameterfv' not available on this platform (extensions: GL_ARB_tessellation_shader)");
      }
    }

    void patch_parameteri(gl::enum_t pname, gl::int_t value) {
      if ( GLAD_GL_ARB_tessellation_shader ) {
        glPatchParameteri(pname, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPatchParameteri' not available on this platform (extensions: GL_ARB_tessellation_shader)");
      }
    }

    void path_color_gen_nv(gl::enum_t color, gl::enum_t genMode, gl::enum_t colorFormat, const  gl::float_t * coeffs) {
      if ( GLAD_GL_NV_path_rendering ) {
        glPathColorGenNV(color, genMode, colorFormat, coeffs);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPathColorGenNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void path_commands_nv(gl::uint_t path, gl::sizei_t numCommands, const  gl::ubyte_t * commands, gl::sizei_t numCoords, gl::enum_t coordType, const  void * coords) {
      if ( GLAD_GL_NV_path_rendering ) {
        glPathCommandsNV(path, numCommands, commands, numCoords, coordType, coords);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPathCommandsNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void path_coords_nv(gl::uint_t path, gl::sizei_t numCoords, gl::enum_t coordType, const  void * coords) {
      if ( GLAD_GL_NV_path_rendering ) {
        glPathCoordsNV(path, numCoords, coordType, coords);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPathCoordsNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void path_cover_depth_func_nv(depth_function_t func) {
      if ( GLAD_GL_NV_path_rendering ) {
        glPathCoverDepthFuncNV(static_cast<GLenum>(func));
      }
      else {
        throw std::runtime_error("OpenGL command 'glPathCoverDepthFuncNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void path_dash_array_nv(gl::uint_t path, gl::sizei_t dashCount, const  gl::float_t * dashArray) {
      if ( GLAD_GL_NV_path_rendering ) {
        glPathDashArrayNV(path, dashCount, dashArray);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPathDashArrayNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void path_fog_gen_nv(gl::enum_t genMode) {
      if ( GLAD_GL_NV_path_rendering ) {
        glPathFogGenNV(genMode);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPathFogGenNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    gl::enum_t path_glyph_index_array_nv(gl::uint_t firstPathName, gl::enum_t fontTarget, const  void * fontName, gl::bitfield_t fontStyle, gl::uint_t firstGlyphIndex, gl::sizei_t numGlyphs, gl::uint_t pathParameterTemplate, gl::float_t emScale) {
      if ( GLAD_GL_NV_path_rendering ) {
        return glPathGlyphIndexArrayNV(firstPathName, fontTarget, fontName, fontStyle, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPathGlyphIndexArrayNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    gl::enum_t path_glyph_index_range_nv(gl::enum_t fontTarget, const  void * fontName, gl::bitfield_t fontStyle, gl::uint_t pathParameterTemplate, gl::float_t emScale, gl::uint_t * baseAndCount) {
      if ( GLAD_GL_NV_path_rendering ) {
        return glPathGlyphIndexRangeNV(fontTarget, fontName, fontStyle, pathParameterTemplate, emScale, baseAndCount);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPathGlyphIndexRangeNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void path_glyph_range_nv(gl::uint_t firstPathName, gl::enum_t fontTarget, const  void * fontName, gl::bitfield_t fontStyle, gl::uint_t firstGlyph, gl::sizei_t numGlyphs, gl::enum_t handleMissingGlyphs, gl::uint_t pathParameterTemplate, gl::float_t emScale) {
      if ( GLAD_GL_NV_path_rendering ) {
        glPathGlyphRangeNV(firstPathName, fontTarget, fontName, fontStyle, firstGlyph, numGlyphs, handleMissingGlyphs, pathParameterTemplate, emScale);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPathGlyphRangeNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void path_glyphs_nv(gl::uint_t firstPathName, gl::enum_t fontTarget, const  void * fontName, gl::bitfield_t fontStyle, gl::sizei_t numGlyphs, gl::enum_t type, const  void * charcodes, gl::enum_t handleMissingGlyphs, gl::uint_t pathParameterTemplate, gl::float_t emScale) {
      if ( GLAD_GL_NV_path_rendering ) {
        glPathGlyphsNV(firstPathName, fontTarget, fontName, fontStyle, numGlyphs, type, charcodes, handleMissingGlyphs, pathParameterTemplate, emScale);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPathGlyphsNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    gl::enum_t path_memory_glyph_index_array_nv(gl::uint_t firstPathName, gl::enum_t fontTarget, gl::sizeiptr_t fontSize, const  void * fontData, gl::sizei_t faceIndex, gl::uint_t firstGlyphIndex, gl::sizei_t numGlyphs, gl::uint_t pathParameterTemplate, gl::float_t emScale) {
      if ( GLAD_GL_NV_path_rendering ) {
        return glPathMemoryGlyphIndexArrayNV(firstPathName, fontTarget, fontSize, fontData, faceIndex, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPathMemoryGlyphIndexArrayNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void path_parameterf_nv(gl::uint_t path, gl::enum_t pname, gl::float_t value) {
      if ( GLAD_GL_NV_path_rendering ) {
        glPathParameterfNV(path, pname, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPathParameterfNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void path_parameterfv_nv(gl::uint_t path, gl::enum_t pname, const  gl::float_t * value) {
      if ( GLAD_GL_NV_path_rendering ) {
        glPathParameterfvNV(path, pname, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPathParameterfvNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void path_parameteri_nv(gl::uint_t path, gl::enum_t pname, gl::int_t value) {
      if ( GLAD_GL_NV_path_rendering ) {
        glPathParameteriNV(path, pname, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPathParameteriNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void path_parameteriv_nv(gl::uint_t path, gl::enum_t pname, const  gl::int_t * value) {
      if ( GLAD_GL_NV_path_rendering ) {
        glPathParameterivNV(path, pname, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPathParameterivNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void path_stencil_depth_offset_nv(gl::float_t factor, gl::float_t units) {
      if ( GLAD_GL_NV_path_rendering ) {
        glPathStencilDepthOffsetNV(factor, units);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPathStencilDepthOffsetNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void path_stencil_func_nv(stencil_function_t func, gl::int_t ref, gl::uint_t mask) {
      if ( GLAD_GL_NV_path_rendering ) {
        glPathStencilFuncNV(static_cast<GLenum>(func), ref, mask);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPathStencilFuncNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void path_string_nv(gl::uint_t path, gl::enum_t format, gl::sizei_t length, const  void * pathString) {
      if ( GLAD_GL_NV_path_rendering ) {
        glPathStringNV(path, format, length, pathString);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPathStringNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void path_sub_commands_nv(gl::uint_t path, gl::sizei_t commandStart, gl::sizei_t commandsToDelete, gl::sizei_t numCommands, const  gl::ubyte_t * commands, gl::sizei_t numCoords, gl::enum_t coordType, const  void * coords) {
      if ( GLAD_GL_NV_path_rendering ) {
        glPathSubCommandsNV(path, commandStart, commandsToDelete, numCommands, commands, numCoords, coordType, coords);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPathSubCommandsNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void path_sub_coords_nv(gl::uint_t path, gl::sizei_t coordStart, gl::sizei_t numCoords, gl::enum_t coordType, const  void * coords) {
      if ( GLAD_GL_NV_path_rendering ) {
        glPathSubCoordsNV(path, coordStart, numCoords, coordType, coords);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPathSubCoordsNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void path_tex_gen_nv(gl::enum_t texCoordSet, gl::enum_t genMode, gl::int_t components, const  gl::float_t * coeffs) {
      if ( GLAD_GL_NV_path_rendering ) {
        glPathTexGenNV(texCoordSet, genMode, components, coeffs);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPathTexGenNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void pause_transform_feedback() {
      if ( GLAD_GL_ARB_transform_feedback2 ) {
        glPauseTransformFeedback();
      }
      else {
        throw std::runtime_error("OpenGL command 'glPauseTransformFeedback' not available on this platform (extensions: GL_ARB_transform_feedback2)");
      }
    }

    void pause_transform_feedback_nv() {
      if ( GLAD_GL_NV_transform_feedback2 ) {
        glPauseTransformFeedbackNV();
      }
      else {
        throw std::runtime_error("OpenGL command 'glPauseTransformFeedbackNV' not available on this platform (extensions: GL_NV_transform_feedback2)");
      }
    }

    void pixel_data_range_nv(gl::enum_t target, gl::sizei_t length, const  void * pointer) {
      if ( GLAD_GL_NV_pixel_data_range ) {
        glPixelDataRangeNV(target, length, pointer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPixelDataRangeNV' not available on this platform (extensions: GL_NV_pixel_data_range)");
      }
    }

    void pixel_mapx(gl::enum_t map, gl::int_t size, const  gl::fixed_t * values) {
      if ( GLAD_GL_OES_fixed_point ) {
        glPixelMapx(map, size, values);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPixelMapx' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void pixel_storex(gl::enum_t pname, gl::fixed_t param) {
      if ( GLAD_GL_OES_fixed_point ) {
        glPixelStorex(pname, param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPixelStorex' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void pixel_tex_gen_parameterf_sgis(pixel_tex_gen_parameter_name_sgis_t pname, gl::float_t param) {
      if ( GLAD_GL_SGIS_pixel_texture ) {
        glPixelTexGenParameterfSGIS(static_cast<GLenum>(pname), param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPixelTexGenParameterfSGIS' not available on this platform (extensions: GL_SGIS_pixel_texture)");
      }
    }

    void pixel_tex_gen_parameterfv_sgis(pixel_tex_gen_parameter_name_sgis_t pname, const  gl::float_t * params) {
      if ( GLAD_GL_SGIS_pixel_texture ) {
        glPixelTexGenParameterfvSGIS(static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPixelTexGenParameterfvSGIS' not available on this platform (extensions: GL_SGIS_pixel_texture)");
      }
    }

    void pixel_tex_gen_parameteri_sgis(pixel_tex_gen_parameter_name_sgis_t pname, gl::int_t param) {
      if ( GLAD_GL_SGIS_pixel_texture ) {
        glPixelTexGenParameteriSGIS(static_cast<GLenum>(pname), param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPixelTexGenParameteriSGIS' not available on this platform (extensions: GL_SGIS_pixel_texture)");
      }
    }

    void pixel_tex_gen_parameteriv_sgis(pixel_tex_gen_parameter_name_sgis_t pname, const  gl::int_t * params) {
      if ( GLAD_GL_SGIS_pixel_texture ) {
        glPixelTexGenParameterivSGIS(static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPixelTexGenParameterivSGIS' not available on this platform (extensions: GL_SGIS_pixel_texture)");
      }
    }

    void pixel_tex_gen_sgix(gl::enum_t mode) {
      if ( GLAD_GL_SGIX_pixel_texture ) {
        glPixelTexGenSGIX(mode);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPixelTexGenSGIX' not available on this platform (extensions: GL_SGIX_pixel_texture)");
      }
    }

    void pixel_transferx_oes(gl::enum_t pname, gl::fixed_t param) {
      if ( GLAD_GL_OES_fixed_point ) {
        glPixelTransferxOES(pname, param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPixelTransferxOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void pixel_transform_parameterf_ext(gl::enum_t target, gl::enum_t pname, gl::float_t param) {
      if ( GLAD_GL_EXT_pixel_transform ) {
        glPixelTransformParameterfEXT(target, pname, param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPixelTransformParameterfEXT' not available on this platform (extensions: GL_EXT_pixel_transform)");
      }
    }

    void pixel_transform_parameterfv_ext(gl::enum_t target, gl::enum_t pname, const  gl::float_t * params) {
      if ( GLAD_GL_EXT_pixel_transform ) {
        glPixelTransformParameterfvEXT(target, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPixelTransformParameterfvEXT' not available on this platform (extensions: GL_EXT_pixel_transform)");
      }
    }

    void pixel_transform_parameteri_ext(gl::enum_t target, gl::enum_t pname, gl::int_t param) {
      if ( GLAD_GL_EXT_pixel_transform ) {
        glPixelTransformParameteriEXT(target, pname, param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPixelTransformParameteriEXT' not available on this platform (extensions: GL_EXT_pixel_transform)");
      }
    }

    void pixel_transform_parameteriv_ext(gl::enum_t target, gl::enum_t pname, const  gl::int_t * params) {
      if ( GLAD_GL_EXT_pixel_transform ) {
        glPixelTransformParameterivEXT(target, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPixelTransformParameterivEXT' not available on this platform (extensions: GL_EXT_pixel_transform)");
      }
    }

    void pixel_zoomx_oes(gl::fixed_t xfactor, gl::fixed_t yfactor) {
      if ( GLAD_GL_OES_fixed_point ) {
        glPixelZoomxOES(xfactor, yfactor);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPixelZoomxOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    gl::boolean_t point_along_path_nv(gl::uint_t path, gl::sizei_t startSegment, gl::sizei_t numSegments, gl::float_t distance, gl::float_t * x, gl::float_t * y, gl::float_t * tangentX, gl::float_t * tangentY) {
      if ( GLAD_GL_NV_path_rendering ) {
        return glPointAlongPathNV(path, startSegment, numSegments, distance, x, y, tangentX, tangentY);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPointAlongPathNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void point_parameterf_arb(gl::enum_t pname, gl::float_t param) {
      if ( GLAD_GL_ARB_point_parameters ) {
        glPointParameterfARB(pname, param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPointParameterfARB' not available on this platform (extensions: GL_ARB_point_parameters)");
      }
    }

    void point_parameterf_ext(gl::enum_t pname, gl::float_t param) {
      if ( GLAD_GL_EXT_point_parameters ) {
        glPointParameterfEXT(pname, param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPointParameterfEXT' not available on this platform (extensions: GL_EXT_point_parameters)");
      }
    }

    void point_parameterf_sgis(gl::enum_t pname, gl::float_t param) {
      if ( GLAD_GL_SGIS_point_parameters ) {
        glPointParameterfSGIS(pname, param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPointParameterfSGIS' not available on this platform (extensions: GL_SGIS_point_parameters)");
      }
    }

    void point_parameterfv_arb(gl::enum_t pname, const  gl::float_t * params) {
      if ( GLAD_GL_ARB_point_parameters ) {
        glPointParameterfvARB(pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPointParameterfvARB' not available on this platform (extensions: GL_ARB_point_parameters)");
      }
    }

    void point_parameterfv_ext(gl::enum_t pname, const  gl::float_t * params) {
      if ( GLAD_GL_EXT_point_parameters ) {
        glPointParameterfvEXT(pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPointParameterfvEXT' not available on this platform (extensions: GL_EXT_point_parameters)");
      }
    }

    void point_parameterfv_sgis(gl::enum_t pname, const  gl::float_t * params) {
      if ( GLAD_GL_SGIS_point_parameters ) {
        glPointParameterfvSGIS(pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPointParameterfvSGIS' not available on this platform (extensions: GL_SGIS_point_parameters)");
      }
    }

    void point_parameteri_nv(gl::enum_t pname, gl::int_t param) {
      if ( GLAD_GL_NV_point_sprite ) {
        glPointParameteriNV(pname, param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPointParameteriNV' not available on this platform (extensions: GL_NV_point_sprite)");
      }
    }

    void point_parameteriv_nv(gl::enum_t pname, const  gl::int_t * params) {
      if ( GLAD_GL_NV_point_sprite ) {
        glPointParameterivNV(pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPointParameterivNV' not available on this platform (extensions: GL_NV_point_sprite)");
      }
    }

    void point_parameterxv_oes(gl::enum_t pname, const  gl::fixed_t * params) {
      if ( GLAD_GL_OES_fixed_point ) {
        glPointParameterxvOES(pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPointParameterxvOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void point_sizex_oes(gl::fixed_t size) {
      if ( GLAD_GL_OES_fixed_point ) {
        glPointSizexOES(size);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPointSizexOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    gl::int_t poll_async_sgix(gl::uint_t * markerp) {
      if ( GLAD_GL_SGIX_async ) {
        return glPollAsyncSGIX(markerp);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPollAsyncSGIX' not available on this platform (extensions: GL_SGIX_async)");
      }
    }

    gl::int_t poll_instruments_sgix(gl::int_t * marker_p) {
      if ( GLAD_GL_SGIX_instruments ) {
        return glPollInstrumentsSGIX(marker_p);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPollInstrumentsSGIX' not available on this platform (extensions: GL_SGIX_instruments)");
      }
    }

    void polygon_offset_clamp_ext(gl::float_t factor, gl::float_t units, gl::float_t clamp) {
      if ( GLAD_GL_EXT_polygon_offset_clamp ) {
        glPolygonOffsetClampEXT(factor, units, clamp);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPolygonOffsetClampEXT' not available on this platform (extensions: GL_EXT_polygon_offset_clamp)");
      }
    }

    void polygon_offset_ext(gl::float_t factor, gl::float_t bias) {
      if ( GLAD_GL_EXT_polygon_offset ) {
        glPolygonOffsetEXT(factor, bias);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPolygonOffsetEXT' not available on this platform (extensions: GL_EXT_polygon_offset)");
      }
    }

    void polygon_offsetx_oes(gl::fixed_t factor, gl::fixed_t units) {
      if ( GLAD_GL_OES_fixed_point ) {
        glPolygonOffsetxOES(factor, units);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPolygonOffsetxOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void pop_debug_group() {
      if ( GLAD_GL_KHR_debug ) {
        glPopDebugGroup();
      }
      else {
        throw std::runtime_error("OpenGL command 'glPopDebugGroup' not available on this platform (extensions: GL_KHR_debug)");
      }
    }

    void pop_group_marker_ext() {
      if ( GLAD_GL_EXT_debug_marker ) {
        glPopGroupMarkerEXT();
      }
      else {
        throw std::runtime_error("OpenGL command 'glPopGroupMarkerEXT' not available on this platform (extensions: GL_EXT_debug_marker)");
      }
    }

    void present_frame_dual_fill_nv(gl::uint_t video_slot, gl::uint64EXT_t minPresentTime, gl::uint_t beginPresentTimeId, gl::uint_t presentDurationId, gl::enum_t type, gl::enum_t target0, gl::uint_t fill0, gl::enum_t target1, gl::uint_t fill1, gl::enum_t target2, gl::uint_t fill2, gl::enum_t target3, gl::uint_t fill3) {
      if ( GLAD_GL_NV_present_video ) {
        glPresentFrameDualFillNV(video_slot, minPresentTime, beginPresentTimeId, presentDurationId, type, target0, fill0, target1, fill1, target2, fill2, target3, fill3);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPresentFrameDualFillNV' not available on this platform (extensions: GL_NV_present_video)");
      }
    }

    void present_frame_keyed_nv(gl::uint_t video_slot, gl::uint64EXT_t minPresentTime, gl::uint_t beginPresentTimeId, gl::uint_t presentDurationId, gl::enum_t type, gl::enum_t target0, gl::uint_t fill0, gl::uint_t key0, gl::enum_t target1, gl::uint_t fill1, gl::uint_t key1) {
      if ( GLAD_GL_NV_present_video ) {
        glPresentFrameKeyedNV(video_slot, minPresentTime, beginPresentTimeId, presentDurationId, type, target0, fill0, key0, target1, fill1, key1);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPresentFrameKeyedNV' not available on this platform (extensions: GL_NV_present_video)");
      }
    }

    void primitive_restart_index_nv(gl::uint_t index) {
      if ( GLAD_GL_NV_primitive_restart ) {
        glPrimitiveRestartIndexNV(index);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPrimitiveRestartIndexNV' not available on this platform (extensions: GL_NV_primitive_restart)");
      }
    }

    void primitive_restart_nv() {
      if ( GLAD_GL_NV_primitive_restart ) {
        glPrimitiveRestartNV();
      }
      else {
        throw std::runtime_error("OpenGL command 'glPrimitiveRestartNV' not available on this platform (extensions: GL_NV_primitive_restart)");
      }
    }

    void prioritize_textures_ext(gl::sizei_t n, const  gl::uint_t * textures, const  gl::clampf_t * priorities) {
      if ( GLAD_GL_EXT_texture_object ) {
        glPrioritizeTexturesEXT(n, textures, priorities);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPrioritizeTexturesEXT' not available on this platform (extensions: GL_EXT_texture_object)");
      }
    }

    void prioritize_texturesx_oes(gl::sizei_t n, const  gl::uint_t * textures, const  gl::fixed_t * priorities) {
      if ( GLAD_GL_OES_fixed_point ) {
        glPrioritizeTexturesxOES(n, textures, priorities);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPrioritizeTexturesxOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void program_binary(gl::uint_t program, gl::enum_t binaryFormat, const  void * binary, gl::sizei_t length) {
      if ( GLAD_GL_ARB_get_program_binary ) {
        glProgramBinary(program, binaryFormat, binary, length);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramBinary' not available on this platform (extensions: GL_ARB_get_program_binary)");
      }
    }

    void program_buffer_parameters_iiv_nv(gl::enum_t target, gl::uint_t bindingIndex, gl::uint_t wordIndex, gl::sizei_t count, const  gl::int_t * params) {
      if ( GLAD_GL_NV_parameter_buffer_object ) {
        glProgramBufferParametersIivNV(target, bindingIndex, wordIndex, count, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramBufferParametersIivNV' not available on this platform (extensions: GL_NV_parameter_buffer_object)");
      }
    }

    void program_buffer_parameters_iuiv_nv(gl::enum_t target, gl::uint_t bindingIndex, gl::uint_t wordIndex, gl::sizei_t count, const  gl::uint_t * params) {
      if ( GLAD_GL_NV_parameter_buffer_object ) {
        glProgramBufferParametersIuivNV(target, bindingIndex, wordIndex, count, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramBufferParametersIuivNV' not available on this platform (extensions: GL_NV_parameter_buffer_object)");
      }
    }

    void program_buffer_parametersfv_nv(gl::enum_t target, gl::uint_t bindingIndex, gl::uint_t wordIndex, gl::sizei_t count, const  gl::float_t * params) {
      if ( GLAD_GL_NV_parameter_buffer_object ) {
        glProgramBufferParametersfvNV(target, bindingIndex, wordIndex, count, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramBufferParametersfvNV' not available on this platform (extensions: GL_NV_parameter_buffer_object)");
      }
    }

    void program_env_parameter_4d_arb(gl::enum_t target, gl::uint_t index, gl::double_t x, gl::double_t y, gl::double_t z, gl::double_t w) {
      if ( GLAD_GL_ARB_fragment_program || GLAD_GL_ARB_vertex_program ) {
        glProgramEnvParameter4dARB(target, index, x, y, z, w);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramEnvParameter4dARB' not available on this platform (extensions: GL_ARB_fragment_program, GL_ARB_vertex_program)");
      }
    }

    void program_env_parameter_4dv_arb(gl::enum_t target, gl::uint_t index, const  gl::double_t * params) {
      if ( GLAD_GL_ARB_fragment_program || GLAD_GL_ARB_vertex_program ) {
        glProgramEnvParameter4dvARB(target, index, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramEnvParameter4dvARB' not available on this platform (extensions: GL_ARB_fragment_program, GL_ARB_vertex_program)");
      }
    }

    void program_env_parameter_4f_arb(gl::enum_t target, gl::uint_t index, gl::float_t x, gl::float_t y, gl::float_t z, gl::float_t w) {
      if ( GLAD_GL_ARB_fragment_program || GLAD_GL_ARB_vertex_program ) {
        glProgramEnvParameter4fARB(target, index, x, y, z, w);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramEnvParameter4fARB' not available on this platform (extensions: GL_ARB_fragment_program, GL_ARB_vertex_program)");
      }
    }

    void program_env_parameter_4fv_arb(gl::enum_t target, gl::uint_t index, const  gl::float_t * params) {
      if ( GLAD_GL_ARB_fragment_program || GLAD_GL_ARB_vertex_program ) {
        glProgramEnvParameter4fvARB(target, index, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramEnvParameter4fvARB' not available on this platform (extensions: GL_ARB_fragment_program, GL_ARB_vertex_program)");
      }
    }

    void program_env_parameter_i4i_nv(gl::enum_t target, gl::uint_t index, gl::int_t x, gl::int_t y, gl::int_t z, gl::int_t w) {
      if ( GLAD_GL_NV_gpu_program4 ) {
        glProgramEnvParameterI4iNV(target, index, x, y, z, w);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramEnvParameterI4iNV' not available on this platform (extensions: GL_NV_gpu_program4)");
      }
    }

    void program_env_parameter_i4iv_nv(gl::enum_t target, gl::uint_t index, const  gl::int_t * params) {
      if ( GLAD_GL_NV_gpu_program4 ) {
        glProgramEnvParameterI4ivNV(target, index, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramEnvParameterI4ivNV' not available on this platform (extensions: GL_NV_gpu_program4)");
      }
    }

    void program_env_parameter_i4ui_nv(gl::enum_t target, gl::uint_t index, gl::uint_t x, gl::uint_t y, gl::uint_t z, gl::uint_t w) {
      if ( GLAD_GL_NV_gpu_program4 ) {
        glProgramEnvParameterI4uiNV(target, index, x, y, z, w);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramEnvParameterI4uiNV' not available on this platform (extensions: GL_NV_gpu_program4)");
      }
    }

    void program_env_parameter_i4uiv_nv(gl::enum_t target, gl::uint_t index, const  gl::uint_t * params) {
      if ( GLAD_GL_NV_gpu_program4 ) {
        glProgramEnvParameterI4uivNV(target, index, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramEnvParameterI4uivNV' not available on this platform (extensions: GL_NV_gpu_program4)");
      }
    }

    void program_env_parameters_4fv_ext(gl::enum_t target, gl::uint_t index, gl::sizei_t count, const  gl::float_t * params) {
      if ( GLAD_GL_EXT_gpu_program_parameters ) {
        glProgramEnvParameters4fvEXT(target, index, count, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramEnvParameters4fvEXT' not available on this platform (extensions: GL_EXT_gpu_program_parameters)");
      }
    }

    void program_env_parameters_i4iv_nv(gl::enum_t target, gl::uint_t index, gl::sizei_t count, const  gl::int_t * params) {
      if ( GLAD_GL_NV_gpu_program4 ) {
        glProgramEnvParametersI4ivNV(target, index, count, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramEnvParametersI4ivNV' not available on this platform (extensions: GL_NV_gpu_program4)");
      }
    }

    void program_env_parameters_i4uiv_nv(gl::enum_t target, gl::uint_t index, gl::sizei_t count, const  gl::uint_t * params) {
      if ( GLAD_GL_NV_gpu_program4 ) {
        glProgramEnvParametersI4uivNV(target, index, count, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramEnvParametersI4uivNV' not available on this platform (extensions: GL_NV_gpu_program4)");
      }
    }

    void program_local_parameter_4d_arb(gl::enum_t target, gl::uint_t index, gl::double_t x, gl::double_t y, gl::double_t z, gl::double_t w) {
      if ( GLAD_GL_ARB_fragment_program || GLAD_GL_ARB_vertex_program ) {
        glProgramLocalParameter4dARB(target, index, x, y, z, w);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramLocalParameter4dARB' not available on this platform (extensions: GL_ARB_fragment_program, GL_ARB_vertex_program)");
      }
    }

    void program_local_parameter_4dv_arb(gl::enum_t target, gl::uint_t index, const  gl::double_t * params) {
      if ( GLAD_GL_ARB_fragment_program || GLAD_GL_ARB_vertex_program ) {
        glProgramLocalParameter4dvARB(target, index, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramLocalParameter4dvARB' not available on this platform (extensions: GL_ARB_fragment_program, GL_ARB_vertex_program)");
      }
    }

    void program_local_parameter_4f_arb(gl::enum_t target, gl::uint_t index, gl::float_t x, gl::float_t y, gl::float_t z, gl::float_t w) {
      if ( GLAD_GL_ARB_fragment_program || GLAD_GL_ARB_vertex_program ) {
        glProgramLocalParameter4fARB(target, index, x, y, z, w);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramLocalParameter4fARB' not available on this platform (extensions: GL_ARB_fragment_program, GL_ARB_vertex_program)");
      }
    }

    void program_local_parameter_4fv_arb(gl::enum_t target, gl::uint_t index, const  gl::float_t * params) {
      if ( GLAD_GL_ARB_fragment_program || GLAD_GL_ARB_vertex_program ) {
        glProgramLocalParameter4fvARB(target, index, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramLocalParameter4fvARB' not available on this platform (extensions: GL_ARB_fragment_program, GL_ARB_vertex_program)");
      }
    }

    void program_local_parameter_i4i_nv(gl::enum_t target, gl::uint_t index, gl::int_t x, gl::int_t y, gl::int_t z, gl::int_t w) {
      if ( GLAD_GL_NV_gpu_program4 ) {
        glProgramLocalParameterI4iNV(target, index, x, y, z, w);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramLocalParameterI4iNV' not available on this platform (extensions: GL_NV_gpu_program4)");
      }
    }

    void program_local_parameter_i4iv_nv(gl::enum_t target, gl::uint_t index, const  gl::int_t * params) {
      if ( GLAD_GL_NV_gpu_program4 ) {
        glProgramLocalParameterI4ivNV(target, index, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramLocalParameterI4ivNV' not available on this platform (extensions: GL_NV_gpu_program4)");
      }
    }

    void program_local_parameter_i4ui_nv(gl::enum_t target, gl::uint_t index, gl::uint_t x, gl::uint_t y, gl::uint_t z, gl::uint_t w) {
      if ( GLAD_GL_NV_gpu_program4 ) {
        glProgramLocalParameterI4uiNV(target, index, x, y, z, w);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramLocalParameterI4uiNV' not available on this platform (extensions: GL_NV_gpu_program4)");
      }
    }

    void program_local_parameter_i4uiv_nv(gl::enum_t target, gl::uint_t index, const  gl::uint_t * params) {
      if ( GLAD_GL_NV_gpu_program4 ) {
        glProgramLocalParameterI4uivNV(target, index, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramLocalParameterI4uivNV' not available on this platform (extensions: GL_NV_gpu_program4)");
      }
    }

    void program_local_parameters_4fv_ext(gl::enum_t target, gl::uint_t index, gl::sizei_t count, const  gl::float_t * params) {
      if ( GLAD_GL_EXT_gpu_program_parameters ) {
        glProgramLocalParameters4fvEXT(target, index, count, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramLocalParameters4fvEXT' not available on this platform (extensions: GL_EXT_gpu_program_parameters)");
      }
    }

    void program_local_parameters_i4iv_nv(gl::enum_t target, gl::uint_t index, gl::sizei_t count, const  gl::int_t * params) {
      if ( GLAD_GL_NV_gpu_program4 ) {
        glProgramLocalParametersI4ivNV(target, index, count, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramLocalParametersI4ivNV' not available on this platform (extensions: GL_NV_gpu_program4)");
      }
    }

    void program_local_parameters_i4uiv_nv(gl::enum_t target, gl::uint_t index, gl::sizei_t count, const  gl::uint_t * params) {
      if ( GLAD_GL_NV_gpu_program4 ) {
        glProgramLocalParametersI4uivNV(target, index, count, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramLocalParametersI4uivNV' not available on this platform (extensions: GL_NV_gpu_program4)");
      }
    }

    void program_named_parameter_4d_nv(gl::uint_t id, gl::sizei_t len, const  gl::ubyte_t * name, gl::double_t x, gl::double_t y, gl::double_t z, gl::double_t w) {
      if ( GLAD_GL_NV_fragment_program ) {
        glProgramNamedParameter4dNV(id, len, name, x, y, z, w);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramNamedParameter4dNV' not available on this platform (extensions: GL_NV_fragment_program)");
      }
    }

    void program_named_parameter_4dv_nv(gl::uint_t id, gl::sizei_t len, const  gl::ubyte_t * name, const  gl::double_t * v) {
      if ( GLAD_GL_NV_fragment_program ) {
        glProgramNamedParameter4dvNV(id, len, name, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramNamedParameter4dvNV' not available on this platform (extensions: GL_NV_fragment_program)");
      }
    }

    void program_named_parameter_4f_nv(gl::uint_t id, gl::sizei_t len, const  gl::ubyte_t * name, gl::float_t x, gl::float_t y, gl::float_t z, gl::float_t w) {
      if ( GLAD_GL_NV_fragment_program ) {
        glProgramNamedParameter4fNV(id, len, name, x, y, z, w);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramNamedParameter4fNV' not available on this platform (extensions: GL_NV_fragment_program)");
      }
    }

    void program_named_parameter_4fv_nv(gl::uint_t id, gl::sizei_t len, const  gl::ubyte_t * name, const  gl::float_t * v) {
      if ( GLAD_GL_NV_fragment_program ) {
        glProgramNamedParameter4fvNV(id, len, name, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramNamedParameter4fvNV' not available on this platform (extensions: GL_NV_fragment_program)");
      }
    }

    void program_parameter_4d_nv(gl::enum_t target, gl::uint_t index, gl::double_t x, gl::double_t y, gl::double_t z, gl::double_t w) {
      if ( GLAD_GL_NV_vertex_program ) {
        glProgramParameter4dNV(target, index, x, y, z, w);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramParameter4dNV' not available on this platform (extensions: GL_NV_vertex_program)");
      }
    }

    void program_parameter_4dv_nv(gl::enum_t target, gl::uint_t index, const  gl::double_t * v) {
      if ( GLAD_GL_NV_vertex_program ) {
        glProgramParameter4dvNV(target, index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramParameter4dvNV' not available on this platform (extensions: GL_NV_vertex_program)");
      }
    }

    void program_parameter_4f_nv(gl::enum_t target, gl::uint_t index, gl::float_t x, gl::float_t y, gl::float_t z, gl::float_t w) {
      if ( GLAD_GL_NV_vertex_program ) {
        glProgramParameter4fNV(target, index, x, y, z, w);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramParameter4fNV' not available on this platform (extensions: GL_NV_vertex_program)");
      }
    }

    void program_parameter_4fv_nv(gl::enum_t target, gl::uint_t index, const  gl::float_t * v) {
      if ( GLAD_GL_NV_vertex_program ) {
        glProgramParameter4fvNV(target, index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramParameter4fvNV' not available on this platform (extensions: GL_NV_vertex_program)");
      }
    }

    void program_parameteri(gl::uint_t program, gl::enum_t pname, gl::int_t value) {
      if ( GLAD_GL_ARB_get_program_binary ) {
        glProgramParameteri(program, pname, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramParameteri' not available on this platform (extensions: GL_ARB_get_program_binary)");
      }
    }

    void program_parameteri_arb(gl::uint_t program, gl::enum_t pname, gl::int_t value) {
      if ( GLAD_GL_ARB_geometry_shader4 ) {
        glProgramParameteriARB(program, pname, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramParameteriARB' not available on this platform (extensions: GL_ARB_geometry_shader4)");
      }
    }

    void program_parameteri_ext(gl::uint_t program, gl::enum_t pname, gl::int_t value) {
      if ( GLAD_GL_EXT_geometry_shader4 ) {
        glProgramParameteriEXT(program, pname, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramParameteriEXT' not available on this platform (extensions: GL_EXT_geometry_shader4)");
      }
    }

    void program_parameters_4dv_nv(gl::enum_t target, gl::uint_t index, gl::sizei_t count, const  gl::double_t * v) {
      if ( GLAD_GL_NV_vertex_program ) {
        glProgramParameters4dvNV(target, index, count, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramParameters4dvNV' not available on this platform (extensions: GL_NV_vertex_program)");
      }
    }

    void program_parameters_4fv_nv(gl::enum_t target, gl::uint_t index, gl::sizei_t count, const  gl::float_t * v) {
      if ( GLAD_GL_NV_vertex_program ) {
        glProgramParameters4fvNV(target, index, count, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramParameters4fvNV' not available on this platform (extensions: GL_NV_vertex_program)");
      }
    }

    void program_path_fragment_input_gen_nv(gl::uint_t program, gl::int_t location, gl::enum_t genMode, gl::int_t components, const  gl::float_t * coeffs) {
      if ( GLAD_GL_NV_path_rendering ) {
        glProgramPathFragmentInputGenNV(program, location, genMode, components, coeffs);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramPathFragmentInputGenNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void program_string_arb(gl::enum_t target, gl::enum_t format, gl::sizei_t len, const  void * string) {
      if ( GLAD_GL_ARB_fragment_program || GLAD_GL_ARB_vertex_program ) {
        glProgramStringARB(target, format, len, string);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramStringARB' not available on this platform (extensions: GL_ARB_fragment_program, GL_ARB_vertex_program)");
      }
    }

    void program_subroutine_parametersuiv_nv(gl::enum_t target, gl::sizei_t count, const  gl::uint_t * params) {
      if ( GLAD_GL_NV_gpu_program5 ) {
        glProgramSubroutineParametersuivNV(target, count, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramSubroutineParametersuivNV' not available on this platform (extensions: GL_NV_gpu_program5)");
      }
    }

    void program_uniform_1d(gl::uint_t program, gl::int_t location, gl::double_t v0) {
      if ( GLAD_GL_ARB_separate_shader_objects ) {
        glProgramUniform1d(program, location, v0);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform1d' not available on this platform (extensions: GL_ARB_separate_shader_objects)");
      }
    }

    void program_uniform_1d_ext(gl::uint_t program, gl::int_t location, gl::double_t x) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glProgramUniform1dEXT(program, location, x);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform1dEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void program_uniform_1dv(gl::uint_t program, gl::int_t location, gl::sizei_t count, const  gl::double_t * value) {
      if ( GLAD_GL_ARB_separate_shader_objects ) {
        glProgramUniform1dv(program, location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform1dv' not available on this platform (extensions: GL_ARB_separate_shader_objects)");
      }
    }

    void program_uniform_1dv_ext(gl::uint_t program, gl::int_t location, gl::sizei_t count, const  gl::double_t * value) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glProgramUniform1dvEXT(program, location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform1dvEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void program_uniform_1f(gl::uint_t program, gl::int_t location, gl::float_t v0) {
      if ( GLAD_GL_ARB_separate_shader_objects ) {
        glProgramUniform1f(program, location, v0);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform1f' not available on this platform (extensions: GL_ARB_separate_shader_objects)");
      }
    }

    void program_uniform_1f_ext(gl::uint_t program, gl::int_t location, gl::float_t v0) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glProgramUniform1fEXT(program, location, v0);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform1fEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void program_uniform_1fv(gl::uint_t program, gl::int_t location, gl::sizei_t count, const  gl::float_t * value) {
      if ( GLAD_GL_ARB_separate_shader_objects ) {
        glProgramUniform1fv(program, location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform1fv' not available on this platform (extensions: GL_ARB_separate_shader_objects)");
      }
    }

    void program_uniform_1fv_ext(gl::uint_t program, gl::int_t location, gl::sizei_t count, const  gl::float_t * value) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glProgramUniform1fvEXT(program, location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform1fvEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void program_uniform_1i(gl::uint_t program, gl::int_t location, gl::int_t v0) {
      if ( GLAD_GL_ARB_separate_shader_objects ) {
        glProgramUniform1i(program, location, v0);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform1i' not available on this platform (extensions: GL_ARB_separate_shader_objects)");
      }
    }

    void program_uniform_1i_64nv(gl::uint_t program, gl::int_t location, gl::int64EXT_t x) {
      if ( GLAD_GL_AMD_gpu_shader_int64 || GLAD_GL_NV_gpu_shader5 ) {
        glProgramUniform1i64NV(program, location, x);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform1i64NV' not available on this platform (extensions: GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5)");
      }
    }

    void program_uniform_1i_64v_nv(gl::uint_t program, gl::int_t location, gl::sizei_t count, const  gl::int64EXT_t * value) {
      if ( GLAD_GL_AMD_gpu_shader_int64 || GLAD_GL_NV_gpu_shader5 ) {
        glProgramUniform1i64vNV(program, location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform1i64vNV' not available on this platform (extensions: GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5)");
      }
    }

    void program_uniform_1i_ext(gl::uint_t program, gl::int_t location, gl::int_t v0) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glProgramUniform1iEXT(program, location, v0);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform1iEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void program_uniform_1iv(gl::uint_t program, gl::int_t location, gl::sizei_t count, const  gl::int_t * value) {
      if ( GLAD_GL_ARB_separate_shader_objects ) {
        glProgramUniform1iv(program, location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform1iv' not available on this platform (extensions: GL_ARB_separate_shader_objects)");
      }
    }

    void program_uniform_1iv_ext(gl::uint_t program, gl::int_t location, gl::sizei_t count, const  gl::int_t * value) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glProgramUniform1ivEXT(program, location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform1ivEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void program_uniform_1ui(gl::uint_t program, gl::int_t location, gl::uint_t v0) {
      if ( GLAD_GL_ARB_separate_shader_objects ) {
        glProgramUniform1ui(program, location, v0);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform1ui' not available on this platform (extensions: GL_ARB_separate_shader_objects)");
      }
    }

    void program_uniform_1ui_64nv(gl::uint_t program, gl::int_t location, gl::uint64EXT_t x) {
      if ( GLAD_GL_AMD_gpu_shader_int64 || GLAD_GL_NV_gpu_shader5 ) {
        glProgramUniform1ui64NV(program, location, x);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform1ui64NV' not available on this platform (extensions: GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5)");
      }
    }

    void program_uniform_1ui_64v_nv(gl::uint_t program, gl::int_t location, gl::sizei_t count, const  gl::uint64EXT_t * value) {
      if ( GLAD_GL_AMD_gpu_shader_int64 || GLAD_GL_NV_gpu_shader5 ) {
        glProgramUniform1ui64vNV(program, location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform1ui64vNV' not available on this platform (extensions: GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5)");
      }
    }

    void program_uniform_1ui_ext(gl::uint_t program, gl::int_t location, gl::uint_t v0) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glProgramUniform1uiEXT(program, location, v0);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform1uiEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void program_uniform_1uiv(gl::uint_t program, gl::int_t location, gl::sizei_t count, const  gl::uint_t * value) {
      if ( GLAD_GL_ARB_separate_shader_objects ) {
        glProgramUniform1uiv(program, location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform1uiv' not available on this platform (extensions: GL_ARB_separate_shader_objects)");
      }
    }

    void program_uniform_1uiv_ext(gl::uint_t program, gl::int_t location, gl::sizei_t count, const  gl::uint_t * value) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glProgramUniform1uivEXT(program, location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform1uivEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void program_uniform_2d(gl::uint_t program, gl::int_t location, gl::double_t v0, gl::double_t v1) {
      if ( GLAD_GL_ARB_separate_shader_objects ) {
        glProgramUniform2d(program, location, v0, v1);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform2d' not available on this platform (extensions: GL_ARB_separate_shader_objects)");
      }
    }

    void program_uniform_2d_ext(gl::uint_t program, gl::int_t location, gl::double_t x, gl::double_t y) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glProgramUniform2dEXT(program, location, x, y);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform2dEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void program_uniform_2dv(gl::uint_t program, gl::int_t location, gl::sizei_t count, const  gl::double_t * value) {
      if ( GLAD_GL_ARB_separate_shader_objects ) {
        glProgramUniform2dv(program, location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform2dv' not available on this platform (extensions: GL_ARB_separate_shader_objects)");
      }
    }

    void program_uniform_2dv_ext(gl::uint_t program, gl::int_t location, gl::sizei_t count, const  gl::double_t * value) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glProgramUniform2dvEXT(program, location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform2dvEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void program_uniform_2f(gl::uint_t program, gl::int_t location, gl::float_t v0, gl::float_t v1) {
      if ( GLAD_GL_ARB_separate_shader_objects ) {
        glProgramUniform2f(program, location, v0, v1);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform2f' not available on this platform (extensions: GL_ARB_separate_shader_objects)");
      }
    }

    void program_uniform_2f_ext(gl::uint_t program, gl::int_t location, gl::float_t v0, gl::float_t v1) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glProgramUniform2fEXT(program, location, v0, v1);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform2fEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void program_uniform_2fv(gl::uint_t program, gl::int_t location, gl::sizei_t count, const  gl::float_t * value) {
      if ( GLAD_GL_ARB_separate_shader_objects ) {
        glProgramUniform2fv(program, location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform2fv' not available on this platform (extensions: GL_ARB_separate_shader_objects)");
      }
    }

    void program_uniform_2fv_ext(gl::uint_t program, gl::int_t location, gl::sizei_t count, const  gl::float_t * value) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glProgramUniform2fvEXT(program, location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform2fvEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void program_uniform_2i(gl::uint_t program, gl::int_t location, gl::int_t v0, gl::int_t v1) {
      if ( GLAD_GL_ARB_separate_shader_objects ) {
        glProgramUniform2i(program, location, v0, v1);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform2i' not available on this platform (extensions: GL_ARB_separate_shader_objects)");
      }
    }

    void program_uniform_2i_64nv(gl::uint_t program, gl::int_t location, gl::int64EXT_t x, gl::int64EXT_t y) {
      if ( GLAD_GL_AMD_gpu_shader_int64 || GLAD_GL_NV_gpu_shader5 ) {
        glProgramUniform2i64NV(program, location, x, y);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform2i64NV' not available on this platform (extensions: GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5)");
      }
    }

    void program_uniform_2i_64v_nv(gl::uint_t program, gl::int_t location, gl::sizei_t count, const  gl::int64EXT_t * value) {
      if ( GLAD_GL_AMD_gpu_shader_int64 || GLAD_GL_NV_gpu_shader5 ) {
        glProgramUniform2i64vNV(program, location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform2i64vNV' not available on this platform (extensions: GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5)");
      }
    }

    void program_uniform_2i_ext(gl::uint_t program, gl::int_t location, gl::int_t v0, gl::int_t v1) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glProgramUniform2iEXT(program, location, v0, v1);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform2iEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void program_uniform_2iv(gl::uint_t program, gl::int_t location, gl::sizei_t count, const  gl::int_t * value) {
      if ( GLAD_GL_ARB_separate_shader_objects ) {
        glProgramUniform2iv(program, location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform2iv' not available on this platform (extensions: GL_ARB_separate_shader_objects)");
      }
    }

    void program_uniform_2iv_ext(gl::uint_t program, gl::int_t location, gl::sizei_t count, const  gl::int_t * value) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glProgramUniform2ivEXT(program, location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform2ivEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void program_uniform_2ui(gl::uint_t program, gl::int_t location, gl::uint_t v0, gl::uint_t v1) {
      if ( GLAD_GL_ARB_separate_shader_objects ) {
        glProgramUniform2ui(program, location, v0, v1);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform2ui' not available on this platform (extensions: GL_ARB_separate_shader_objects)");
      }
    }

    void program_uniform_2ui_64nv(gl::uint_t program, gl::int_t location, gl::uint64EXT_t x, gl::uint64EXT_t y) {
      if ( GLAD_GL_AMD_gpu_shader_int64 || GLAD_GL_NV_gpu_shader5 ) {
        glProgramUniform2ui64NV(program, location, x, y);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform2ui64NV' not available on this platform (extensions: GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5)");
      }
    }

    void program_uniform_2ui_64v_nv(gl::uint_t program, gl::int_t location, gl::sizei_t count, const  gl::uint64EXT_t * value) {
      if ( GLAD_GL_AMD_gpu_shader_int64 || GLAD_GL_NV_gpu_shader5 ) {
        glProgramUniform2ui64vNV(program, location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform2ui64vNV' not available on this platform (extensions: GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5)");
      }
    }

    void program_uniform_2ui_ext(gl::uint_t program, gl::int_t location, gl::uint_t v0, gl::uint_t v1) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glProgramUniform2uiEXT(program, location, v0, v1);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform2uiEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void program_uniform_2uiv(gl::uint_t program, gl::int_t location, gl::sizei_t count, const  gl::uint_t * value) {
      if ( GLAD_GL_ARB_separate_shader_objects ) {
        glProgramUniform2uiv(program, location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform2uiv' not available on this platform (extensions: GL_ARB_separate_shader_objects)");
      }
    }

    void program_uniform_2uiv_ext(gl::uint_t program, gl::int_t location, gl::sizei_t count, const  gl::uint_t * value) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glProgramUniform2uivEXT(program, location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform2uivEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void program_uniform_3d(gl::uint_t program, gl::int_t location, gl::double_t v0, gl::double_t v1, gl::double_t v2) {
      if ( GLAD_GL_ARB_separate_shader_objects ) {
        glProgramUniform3d(program, location, v0, v1, v2);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform3d' not available on this platform (extensions: GL_ARB_separate_shader_objects)");
      }
    }

    void program_uniform_3d_ext(gl::uint_t program, gl::int_t location, gl::double_t x, gl::double_t y, gl::double_t z) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glProgramUniform3dEXT(program, location, x, y, z);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform3dEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void program_uniform_3dv(gl::uint_t program, gl::int_t location, gl::sizei_t count, const  gl::double_t * value) {
      if ( GLAD_GL_ARB_separate_shader_objects ) {
        glProgramUniform3dv(program, location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform3dv' not available on this platform (extensions: GL_ARB_separate_shader_objects)");
      }
    }

    void program_uniform_3dv_ext(gl::uint_t program, gl::int_t location, gl::sizei_t count, const  gl::double_t * value) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glProgramUniform3dvEXT(program, location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform3dvEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void program_uniform_3f(gl::uint_t program, gl::int_t location, gl::float_t v0, gl::float_t v1, gl::float_t v2) {
      if ( GLAD_GL_ARB_separate_shader_objects ) {
        glProgramUniform3f(program, location, v0, v1, v2);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform3f' not available on this platform (extensions: GL_ARB_separate_shader_objects)");
      }
    }

    void program_uniform_3f_ext(gl::uint_t program, gl::int_t location, gl::float_t v0, gl::float_t v1, gl::float_t v2) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glProgramUniform3fEXT(program, location, v0, v1, v2);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform3fEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void program_uniform_3fv(gl::uint_t program, gl::int_t location, gl::sizei_t count, const  gl::float_t * value) {
      if ( GLAD_GL_ARB_separate_shader_objects ) {
        glProgramUniform3fv(program, location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform3fv' not available on this platform (extensions: GL_ARB_separate_shader_objects)");
      }
    }

    void program_uniform_3fv_ext(gl::uint_t program, gl::int_t location, gl::sizei_t count, const  gl::float_t * value) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glProgramUniform3fvEXT(program, location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform3fvEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void program_uniform_3i(gl::uint_t program, gl::int_t location, gl::int_t v0, gl::int_t v1, gl::int_t v2) {
      if ( GLAD_GL_ARB_separate_shader_objects ) {
        glProgramUniform3i(program, location, v0, v1, v2);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform3i' not available on this platform (extensions: GL_ARB_separate_shader_objects)");
      }
    }

    void program_uniform_3i_64nv(gl::uint_t program, gl::int_t location, gl::int64EXT_t x, gl::int64EXT_t y, gl::int64EXT_t z) {
      if ( GLAD_GL_AMD_gpu_shader_int64 || GLAD_GL_NV_gpu_shader5 ) {
        glProgramUniform3i64NV(program, location, x, y, z);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform3i64NV' not available on this platform (extensions: GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5)");
      }
    }

    void program_uniform_3i_64v_nv(gl::uint_t program, gl::int_t location, gl::sizei_t count, const  gl::int64EXT_t * value) {
      if ( GLAD_GL_AMD_gpu_shader_int64 || GLAD_GL_NV_gpu_shader5 ) {
        glProgramUniform3i64vNV(program, location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform3i64vNV' not available on this platform (extensions: GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5)");
      }
    }

    void program_uniform_3i_ext(gl::uint_t program, gl::int_t location, gl::int_t v0, gl::int_t v1, gl::int_t v2) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glProgramUniform3iEXT(program, location, v0, v1, v2);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform3iEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void program_uniform_3iv(gl::uint_t program, gl::int_t location, gl::sizei_t count, const  gl::int_t * value) {
      if ( GLAD_GL_ARB_separate_shader_objects ) {
        glProgramUniform3iv(program, location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform3iv' not available on this platform (extensions: GL_ARB_separate_shader_objects)");
      }
    }

    void program_uniform_3iv_ext(gl::uint_t program, gl::int_t location, gl::sizei_t count, const  gl::int_t * value) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glProgramUniform3ivEXT(program, location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform3ivEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void program_uniform_3ui(gl::uint_t program, gl::int_t location, gl::uint_t v0, gl::uint_t v1, gl::uint_t v2) {
      if ( GLAD_GL_ARB_separate_shader_objects ) {
        glProgramUniform3ui(program, location, v0, v1, v2);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform3ui' not available on this platform (extensions: GL_ARB_separate_shader_objects)");
      }
    }

    void program_uniform_3ui_64nv(gl::uint_t program, gl::int_t location, gl::uint64EXT_t x, gl::uint64EXT_t y, gl::uint64EXT_t z) {
      if ( GLAD_GL_AMD_gpu_shader_int64 || GLAD_GL_NV_gpu_shader5 ) {
        glProgramUniform3ui64NV(program, location, x, y, z);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform3ui64NV' not available on this platform (extensions: GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5)");
      }
    }

    void program_uniform_3ui_64v_nv(gl::uint_t program, gl::int_t location, gl::sizei_t count, const  gl::uint64EXT_t * value) {
      if ( GLAD_GL_AMD_gpu_shader_int64 || GLAD_GL_NV_gpu_shader5 ) {
        glProgramUniform3ui64vNV(program, location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform3ui64vNV' not available on this platform (extensions: GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5)");
      }
    }

    void program_uniform_3ui_ext(gl::uint_t program, gl::int_t location, gl::uint_t v0, gl::uint_t v1, gl::uint_t v2) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glProgramUniform3uiEXT(program, location, v0, v1, v2);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform3uiEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void program_uniform_3uiv(gl::uint_t program, gl::int_t location, gl::sizei_t count, const  gl::uint_t * value) {
      if ( GLAD_GL_ARB_separate_shader_objects ) {
        glProgramUniform3uiv(program, location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform3uiv' not available on this platform (extensions: GL_ARB_separate_shader_objects)");
      }
    }

    void program_uniform_3uiv_ext(gl::uint_t program, gl::int_t location, gl::sizei_t count, const  gl::uint_t * value) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glProgramUniform3uivEXT(program, location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform3uivEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void program_uniform_4d(gl::uint_t program, gl::int_t location, gl::double_t v0, gl::double_t v1, gl::double_t v2, gl::double_t v3) {
      if ( GLAD_GL_ARB_separate_shader_objects ) {
        glProgramUniform4d(program, location, v0, v1, v2, v3);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform4d' not available on this platform (extensions: GL_ARB_separate_shader_objects)");
      }
    }

    void program_uniform_4d_ext(gl::uint_t program, gl::int_t location, gl::double_t x, gl::double_t y, gl::double_t z, gl::double_t w) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glProgramUniform4dEXT(program, location, x, y, z, w);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform4dEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void program_uniform_4dv(gl::uint_t program, gl::int_t location, gl::sizei_t count, const  gl::double_t * value) {
      if ( GLAD_GL_ARB_separate_shader_objects ) {
        glProgramUniform4dv(program, location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform4dv' not available on this platform (extensions: GL_ARB_separate_shader_objects)");
      }
    }

    void program_uniform_4dv_ext(gl::uint_t program, gl::int_t location, gl::sizei_t count, const  gl::double_t * value) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glProgramUniform4dvEXT(program, location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform4dvEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void program_uniform_4f(gl::uint_t program, gl::int_t location, gl::float_t v0, gl::float_t v1, gl::float_t v2, gl::float_t v3) {
      if ( GLAD_GL_ARB_separate_shader_objects ) {
        glProgramUniform4f(program, location, v0, v1, v2, v3);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform4f' not available on this platform (extensions: GL_ARB_separate_shader_objects)");
      }
    }

    void program_uniform_4f_ext(gl::uint_t program, gl::int_t location, gl::float_t v0, gl::float_t v1, gl::float_t v2, gl::float_t v3) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glProgramUniform4fEXT(program, location, v0, v1, v2, v3);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform4fEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void program_uniform_4fv(gl::uint_t program, gl::int_t location, gl::sizei_t count, const  gl::float_t * value) {
      if ( GLAD_GL_ARB_separate_shader_objects ) {
        glProgramUniform4fv(program, location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform4fv' not available on this platform (extensions: GL_ARB_separate_shader_objects)");
      }
    }

    void program_uniform_4fv_ext(gl::uint_t program, gl::int_t location, gl::sizei_t count, const  gl::float_t * value) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glProgramUniform4fvEXT(program, location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform4fvEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void program_uniform_4i(gl::uint_t program, gl::int_t location, gl::int_t v0, gl::int_t v1, gl::int_t v2, gl::int_t v3) {
      if ( GLAD_GL_ARB_separate_shader_objects ) {
        glProgramUniform4i(program, location, v0, v1, v2, v3);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform4i' not available on this platform (extensions: GL_ARB_separate_shader_objects)");
      }
    }

    void program_uniform_4i_64nv(gl::uint_t program, gl::int_t location, gl::int64EXT_t x, gl::int64EXT_t y, gl::int64EXT_t z, gl::int64EXT_t w) {
      if ( GLAD_GL_AMD_gpu_shader_int64 || GLAD_GL_NV_gpu_shader5 ) {
        glProgramUniform4i64NV(program, location, x, y, z, w);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform4i64NV' not available on this platform (extensions: GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5)");
      }
    }

    void program_uniform_4i_64v_nv(gl::uint_t program, gl::int_t location, gl::sizei_t count, const  gl::int64EXT_t * value) {
      if ( GLAD_GL_AMD_gpu_shader_int64 || GLAD_GL_NV_gpu_shader5 ) {
        glProgramUniform4i64vNV(program, location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform4i64vNV' not available on this platform (extensions: GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5)");
      }
    }

    void program_uniform_4i_ext(gl::uint_t program, gl::int_t location, gl::int_t v0, gl::int_t v1, gl::int_t v2, gl::int_t v3) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glProgramUniform4iEXT(program, location, v0, v1, v2, v3);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform4iEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void program_uniform_4iv(gl::uint_t program, gl::int_t location, gl::sizei_t count, const  gl::int_t * value) {
      if ( GLAD_GL_ARB_separate_shader_objects ) {
        glProgramUniform4iv(program, location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform4iv' not available on this platform (extensions: GL_ARB_separate_shader_objects)");
      }
    }

    void program_uniform_4iv_ext(gl::uint_t program, gl::int_t location, gl::sizei_t count, const  gl::int_t * value) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glProgramUniform4ivEXT(program, location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform4ivEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void program_uniform_4ui(gl::uint_t program, gl::int_t location, gl::uint_t v0, gl::uint_t v1, gl::uint_t v2, gl::uint_t v3) {
      if ( GLAD_GL_ARB_separate_shader_objects ) {
        glProgramUniform4ui(program, location, v0, v1, v2, v3);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform4ui' not available on this platform (extensions: GL_ARB_separate_shader_objects)");
      }
    }

    void program_uniform_4ui_64nv(gl::uint_t program, gl::int_t location, gl::uint64EXT_t x, gl::uint64EXT_t y, gl::uint64EXT_t z, gl::uint64EXT_t w) {
      if ( GLAD_GL_AMD_gpu_shader_int64 || GLAD_GL_NV_gpu_shader5 ) {
        glProgramUniform4ui64NV(program, location, x, y, z, w);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform4ui64NV' not available on this platform (extensions: GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5)");
      }
    }

    void program_uniform_4ui_64v_nv(gl::uint_t program, gl::int_t location, gl::sizei_t count, const  gl::uint64EXT_t * value) {
      if ( GLAD_GL_AMD_gpu_shader_int64 || GLAD_GL_NV_gpu_shader5 ) {
        glProgramUniform4ui64vNV(program, location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform4ui64vNV' not available on this platform (extensions: GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5)");
      }
    }

    void program_uniform_4ui_ext(gl::uint_t program, gl::int_t location, gl::uint_t v0, gl::uint_t v1, gl::uint_t v2, gl::uint_t v3) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glProgramUniform4uiEXT(program, location, v0, v1, v2, v3);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform4uiEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void program_uniform_4uiv(gl::uint_t program, gl::int_t location, gl::sizei_t count, const  gl::uint_t * value) {
      if ( GLAD_GL_ARB_separate_shader_objects ) {
        glProgramUniform4uiv(program, location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform4uiv' not available on this platform (extensions: GL_ARB_separate_shader_objects)");
      }
    }

    void program_uniform_4uiv_ext(gl::uint_t program, gl::int_t location, gl::sizei_t count, const  gl::uint_t * value) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glProgramUniform4uivEXT(program, location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniform4uivEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void program_uniform_handleui_64arb(gl::uint_t program, gl::int_t location, gl::uint64_t value) {
      if ( GLAD_GL_ARB_bindless_texture ) {
        glProgramUniformHandleui64ARB(program, location, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniformHandleui64ARB' not available on this platform (extensions: GL_ARB_bindless_texture)");
      }
    }

    void program_uniform_handleui_64nv(gl::uint_t program, gl::int_t location, gl::uint64_t value) {
      if ( GLAD_GL_NV_bindless_texture ) {
        glProgramUniformHandleui64NV(program, location, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniformHandleui64NV' not available on this platform (extensions: GL_NV_bindless_texture)");
      }
    }

    void program_uniform_handleui_64v_arb(gl::uint_t program, gl::int_t location, gl::sizei_t count, const  gl::uint64_t * values) {
      if ( GLAD_GL_ARB_bindless_texture ) {
        glProgramUniformHandleui64vARB(program, location, count, values);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniformHandleui64vARB' not available on this platform (extensions: GL_ARB_bindless_texture)");
      }
    }

    void program_uniform_handleui_64v_nv(gl::uint_t program, gl::int_t location, gl::sizei_t count, const  gl::uint64_t * values) {
      if ( GLAD_GL_NV_bindless_texture ) {
        glProgramUniformHandleui64vNV(program, location, count, values);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniformHandleui64vNV' not available on this platform (extensions: GL_NV_bindless_texture)");
      }
    }

    void program_uniform_matrix_2dv(gl::uint_t program, gl::int_t location, gl::sizei_t count, gl::boolean_t transpose, const  gl::double_t * value) {
      if ( GLAD_GL_ARB_separate_shader_objects ) {
        glProgramUniformMatrix2dv(program, location, count, transpose, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniformMatrix2dv' not available on this platform (extensions: GL_ARB_separate_shader_objects)");
      }
    }

    void program_uniform_matrix_2dv_ext(gl::uint_t program, gl::int_t location, gl::sizei_t count, gl::boolean_t transpose, const  gl::double_t * value) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glProgramUniformMatrix2dvEXT(program, location, count, transpose, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniformMatrix2dvEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void program_uniform_matrix_2fv(gl::uint_t program, gl::int_t location, gl::sizei_t count, gl::boolean_t transpose, const  gl::float_t * value) {
      if ( GLAD_GL_ARB_separate_shader_objects ) {
        glProgramUniformMatrix2fv(program, location, count, transpose, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniformMatrix2fv' not available on this platform (extensions: GL_ARB_separate_shader_objects)");
      }
    }

    void program_uniform_matrix_2fv_ext(gl::uint_t program, gl::int_t location, gl::sizei_t count, gl::boolean_t transpose, const  gl::float_t * value) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glProgramUniformMatrix2fvEXT(program, location, count, transpose, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniformMatrix2fvEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void program_uniform_matrix_2x_3dv(gl::uint_t program, gl::int_t location, gl::sizei_t count, gl::boolean_t transpose, const  gl::double_t * value) {
      if ( GLAD_GL_ARB_separate_shader_objects ) {
        glProgramUniformMatrix2x3dv(program, location, count, transpose, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniformMatrix2x3dv' not available on this platform (extensions: GL_ARB_separate_shader_objects)");
      }
    }

    void program_uniform_matrix_2x_3dv_ext(gl::uint_t program, gl::int_t location, gl::sizei_t count, gl::boolean_t transpose, const  gl::double_t * value) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glProgramUniformMatrix2x3dvEXT(program, location, count, transpose, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniformMatrix2x3dvEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void program_uniform_matrix_2x_3fv(gl::uint_t program, gl::int_t location, gl::sizei_t count, gl::boolean_t transpose, const  gl::float_t * value) {
      if ( GLAD_GL_ARB_separate_shader_objects ) {
        glProgramUniformMatrix2x3fv(program, location, count, transpose, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniformMatrix2x3fv' not available on this platform (extensions: GL_ARB_separate_shader_objects)");
      }
    }

    void program_uniform_matrix_2x_3fv_ext(gl::uint_t program, gl::int_t location, gl::sizei_t count, gl::boolean_t transpose, const  gl::float_t * value) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glProgramUniformMatrix2x3fvEXT(program, location, count, transpose, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniformMatrix2x3fvEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void program_uniform_matrix_2x_4dv(gl::uint_t program, gl::int_t location, gl::sizei_t count, gl::boolean_t transpose, const  gl::double_t * value) {
      if ( GLAD_GL_ARB_separate_shader_objects ) {
        glProgramUniformMatrix2x4dv(program, location, count, transpose, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniformMatrix2x4dv' not available on this platform (extensions: GL_ARB_separate_shader_objects)");
      }
    }

    void program_uniform_matrix_2x_4dv_ext(gl::uint_t program, gl::int_t location, gl::sizei_t count, gl::boolean_t transpose, const  gl::double_t * value) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glProgramUniformMatrix2x4dvEXT(program, location, count, transpose, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniformMatrix2x4dvEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void program_uniform_matrix_2x_4fv(gl::uint_t program, gl::int_t location, gl::sizei_t count, gl::boolean_t transpose, const  gl::float_t * value) {
      if ( GLAD_GL_ARB_separate_shader_objects ) {
        glProgramUniformMatrix2x4fv(program, location, count, transpose, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniformMatrix2x4fv' not available on this platform (extensions: GL_ARB_separate_shader_objects)");
      }
    }

    void program_uniform_matrix_2x_4fv_ext(gl::uint_t program, gl::int_t location, gl::sizei_t count, gl::boolean_t transpose, const  gl::float_t * value) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glProgramUniformMatrix2x4fvEXT(program, location, count, transpose, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniformMatrix2x4fvEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void program_uniform_matrix_3dv(gl::uint_t program, gl::int_t location, gl::sizei_t count, gl::boolean_t transpose, const  gl::double_t * value) {
      if ( GLAD_GL_ARB_separate_shader_objects ) {
        glProgramUniformMatrix3dv(program, location, count, transpose, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniformMatrix3dv' not available on this platform (extensions: GL_ARB_separate_shader_objects)");
      }
    }

    void program_uniform_matrix_3dv_ext(gl::uint_t program, gl::int_t location, gl::sizei_t count, gl::boolean_t transpose, const  gl::double_t * value) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glProgramUniformMatrix3dvEXT(program, location, count, transpose, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniformMatrix3dvEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void program_uniform_matrix_3fv(gl::uint_t program, gl::int_t location, gl::sizei_t count, gl::boolean_t transpose, const  gl::float_t * value) {
      if ( GLAD_GL_ARB_separate_shader_objects ) {
        glProgramUniformMatrix3fv(program, location, count, transpose, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniformMatrix3fv' not available on this platform (extensions: GL_ARB_separate_shader_objects)");
      }
    }

    void program_uniform_matrix_3fv_ext(gl::uint_t program, gl::int_t location, gl::sizei_t count, gl::boolean_t transpose, const  gl::float_t * value) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glProgramUniformMatrix3fvEXT(program, location, count, transpose, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniformMatrix3fvEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void program_uniform_matrix_3x_2dv(gl::uint_t program, gl::int_t location, gl::sizei_t count, gl::boolean_t transpose, const  gl::double_t * value) {
      if ( GLAD_GL_ARB_separate_shader_objects ) {
        glProgramUniformMatrix3x2dv(program, location, count, transpose, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniformMatrix3x2dv' not available on this platform (extensions: GL_ARB_separate_shader_objects)");
      }
    }

    void program_uniform_matrix_3x_2dv_ext(gl::uint_t program, gl::int_t location, gl::sizei_t count, gl::boolean_t transpose, const  gl::double_t * value) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glProgramUniformMatrix3x2dvEXT(program, location, count, transpose, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniformMatrix3x2dvEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void program_uniform_matrix_3x_2fv(gl::uint_t program, gl::int_t location, gl::sizei_t count, gl::boolean_t transpose, const  gl::float_t * value) {
      if ( GLAD_GL_ARB_separate_shader_objects ) {
        glProgramUniformMatrix3x2fv(program, location, count, transpose, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniformMatrix3x2fv' not available on this platform (extensions: GL_ARB_separate_shader_objects)");
      }
    }

    void program_uniform_matrix_3x_2fv_ext(gl::uint_t program, gl::int_t location, gl::sizei_t count, gl::boolean_t transpose, const  gl::float_t * value) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glProgramUniformMatrix3x2fvEXT(program, location, count, transpose, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniformMatrix3x2fvEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void program_uniform_matrix_3x_4dv(gl::uint_t program, gl::int_t location, gl::sizei_t count, gl::boolean_t transpose, const  gl::double_t * value) {
      if ( GLAD_GL_ARB_separate_shader_objects ) {
        glProgramUniformMatrix3x4dv(program, location, count, transpose, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniformMatrix3x4dv' not available on this platform (extensions: GL_ARB_separate_shader_objects)");
      }
    }

    void program_uniform_matrix_3x_4dv_ext(gl::uint_t program, gl::int_t location, gl::sizei_t count, gl::boolean_t transpose, const  gl::double_t * value) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glProgramUniformMatrix3x4dvEXT(program, location, count, transpose, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniformMatrix3x4dvEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void program_uniform_matrix_3x_4fv(gl::uint_t program, gl::int_t location, gl::sizei_t count, gl::boolean_t transpose, const  gl::float_t * value) {
      if ( GLAD_GL_ARB_separate_shader_objects ) {
        glProgramUniformMatrix3x4fv(program, location, count, transpose, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniformMatrix3x4fv' not available on this platform (extensions: GL_ARB_separate_shader_objects)");
      }
    }

    void program_uniform_matrix_3x_4fv_ext(gl::uint_t program, gl::int_t location, gl::sizei_t count, gl::boolean_t transpose, const  gl::float_t * value) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glProgramUniformMatrix3x4fvEXT(program, location, count, transpose, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniformMatrix3x4fvEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void program_uniform_matrix_4dv(gl::uint_t program, gl::int_t location, gl::sizei_t count, gl::boolean_t transpose, const  gl::double_t * value) {
      if ( GLAD_GL_ARB_separate_shader_objects ) {
        glProgramUniformMatrix4dv(program, location, count, transpose, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniformMatrix4dv' not available on this platform (extensions: GL_ARB_separate_shader_objects)");
      }
    }

    void program_uniform_matrix_4dv_ext(gl::uint_t program, gl::int_t location, gl::sizei_t count, gl::boolean_t transpose, const  gl::double_t * value) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glProgramUniformMatrix4dvEXT(program, location, count, transpose, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniformMatrix4dvEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void program_uniform_matrix_4fv(gl::uint_t program, gl::int_t location, gl::sizei_t count, gl::boolean_t transpose, const  gl::float_t * value) {
      if ( GLAD_GL_ARB_separate_shader_objects ) {
        glProgramUniformMatrix4fv(program, location, count, transpose, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniformMatrix4fv' not available on this platform (extensions: GL_ARB_separate_shader_objects)");
      }
    }

    void program_uniform_matrix_4fv_ext(gl::uint_t program, gl::int_t location, gl::sizei_t count, gl::boolean_t transpose, const  gl::float_t * value) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glProgramUniformMatrix4fvEXT(program, location, count, transpose, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniformMatrix4fvEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void program_uniform_matrix_4x_2dv(gl::uint_t program, gl::int_t location, gl::sizei_t count, gl::boolean_t transpose, const  gl::double_t * value) {
      if ( GLAD_GL_ARB_separate_shader_objects ) {
        glProgramUniformMatrix4x2dv(program, location, count, transpose, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniformMatrix4x2dv' not available on this platform (extensions: GL_ARB_separate_shader_objects)");
      }
    }

    void program_uniform_matrix_4x_2dv_ext(gl::uint_t program, gl::int_t location, gl::sizei_t count, gl::boolean_t transpose, const  gl::double_t * value) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glProgramUniformMatrix4x2dvEXT(program, location, count, transpose, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniformMatrix4x2dvEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void program_uniform_matrix_4x_2fv(gl::uint_t program, gl::int_t location, gl::sizei_t count, gl::boolean_t transpose, const  gl::float_t * value) {
      if ( GLAD_GL_ARB_separate_shader_objects ) {
        glProgramUniformMatrix4x2fv(program, location, count, transpose, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniformMatrix4x2fv' not available on this platform (extensions: GL_ARB_separate_shader_objects)");
      }
    }

    void program_uniform_matrix_4x_2fv_ext(gl::uint_t program, gl::int_t location, gl::sizei_t count, gl::boolean_t transpose, const  gl::float_t * value) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glProgramUniformMatrix4x2fvEXT(program, location, count, transpose, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniformMatrix4x2fvEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void program_uniform_matrix_4x_3dv(gl::uint_t program, gl::int_t location, gl::sizei_t count, gl::boolean_t transpose, const  gl::double_t * value) {
      if ( GLAD_GL_ARB_separate_shader_objects ) {
        glProgramUniformMatrix4x3dv(program, location, count, transpose, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniformMatrix4x3dv' not available on this platform (extensions: GL_ARB_separate_shader_objects)");
      }
    }

    void program_uniform_matrix_4x_3dv_ext(gl::uint_t program, gl::int_t location, gl::sizei_t count, gl::boolean_t transpose, const  gl::double_t * value) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glProgramUniformMatrix4x3dvEXT(program, location, count, transpose, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniformMatrix4x3dvEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void program_uniform_matrix_4x_3fv(gl::uint_t program, gl::int_t location, gl::sizei_t count, gl::boolean_t transpose, const  gl::float_t * value) {
      if ( GLAD_GL_ARB_separate_shader_objects ) {
        glProgramUniformMatrix4x3fv(program, location, count, transpose, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniformMatrix4x3fv' not available on this platform (extensions: GL_ARB_separate_shader_objects)");
      }
    }

    void program_uniform_matrix_4x_3fv_ext(gl::uint_t program, gl::int_t location, gl::sizei_t count, gl::boolean_t transpose, const  gl::float_t * value) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glProgramUniformMatrix4x3fvEXT(program, location, count, transpose, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniformMatrix4x3fvEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void program_uniformui_64nv(gl::uint_t program, gl::int_t location, gl::uint64EXT_t value) {
      if ( GLAD_GL_NV_shader_buffer_load ) {
        glProgramUniformui64NV(program, location, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniformui64NV' not available on this platform (extensions: GL_NV_shader_buffer_load)");
      }
    }

    void program_uniformui_64v_nv(gl::uint_t program, gl::int_t location, gl::sizei_t count, const  gl::uint64EXT_t * value) {
      if ( GLAD_GL_NV_shader_buffer_load ) {
        glProgramUniformui64vNV(program, location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramUniformui64vNV' not available on this platform (extensions: GL_NV_shader_buffer_load)");
      }
    }

    void program_vertex_limit_nv(gl::enum_t target, gl::int_t limit) {
      if ( GLAD_GL_NV_geometry_program4 ) {
        glProgramVertexLimitNV(target, limit);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramVertexLimitNV' not available on this platform (extensions: GL_NV_geometry_program4)");
      }
    }

    void provoking_vertex(gl::enum_t mode) {
      if ( GLAD_GL_ARB_provoking_vertex ) {
        glProvokingVertex(mode);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProvokingVertex' not available on this platform (extensions: GL_ARB_provoking_vertex)");
      }
    }

    void provoking_vertex_ext(gl::enum_t mode) {
      if ( GLAD_GL_EXT_provoking_vertex ) {
        glProvokingVertexEXT(mode);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProvokingVertexEXT' not available on this platform (extensions: GL_EXT_provoking_vertex)");
      }
    }

    void push_client_attrib_default_ext(gl::bitmask<client_attrib_flags_t> mask) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glPushClientAttribDefaultEXT(static_cast<GLbitfield>(mask.value));
      }
      else {
        throw std::runtime_error("OpenGL command 'glPushClientAttribDefaultEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void push_debug_group(gl::enum_t source, gl::uint_t id, gl::sizei_t length, const  gl::char_t * message) {
      if ( GLAD_GL_KHR_debug ) {
        glPushDebugGroup(source, id, length, message);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPushDebugGroup' not available on this platform (extensions: GL_KHR_debug)");
      }
    }

    void push_group_marker_ext(gl::sizei_t length, const  gl::char_t * marker) {
      if ( GLAD_GL_EXT_debug_marker ) {
        glPushGroupMarkerEXT(length, marker);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPushGroupMarkerEXT' not available on this platform (extensions: GL_EXT_debug_marker)");
      }
    }

    void query_counter(gl::uint_t id, gl::enum_t target) {
      if ( GLAD_GL_ARB_timer_query ) {
        glQueryCounter(id, target);
      }
      else {
        throw std::runtime_error("OpenGL command 'glQueryCounter' not available on this platform (extensions: GL_ARB_timer_query)");
      }
    }

    gl::bitfield_t query_matrixx_oes(gl::fixed_t * mantissa, gl::int_t * exponent) {
      if ( GLAD_GL_OES_query_matrix ) {
        return glQueryMatrixxOES(mantissa, exponent);
      }
      else {
        throw std::runtime_error("OpenGL command 'glQueryMatrixxOES' not available on this platform (extensions: GL_OES_query_matrix)");
      }
    }

    void query_object_parameterui_amd(gl::enum_t target, gl::uint_t id, gl::enum_t pname, occlusion_query_event_mask_amd_t param) {
      if ( GLAD_GL_AMD_occlusion_query_event ) {
        glQueryObjectParameteruiAMD(target, id, pname, static_cast<GLuint>(param));
      }
      else {
        throw std::runtime_error("OpenGL command 'glQueryObjectParameteruiAMD' not available on this platform (extensions: GL_AMD_occlusion_query_event)");
      }
    }

    void raster_pos_2x_oes(gl::fixed_t x, gl::fixed_t y) {
      if ( GLAD_GL_OES_fixed_point ) {
        glRasterPos2xOES(x, y);
      }
      else {
        throw std::runtime_error("OpenGL command 'glRasterPos2xOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void raster_pos_2xv_oes(const  gl::fixed_t * coords) {
      if ( GLAD_GL_OES_fixed_point ) {
        glRasterPos2xvOES(coords);
      }
      else {
        throw std::runtime_error("OpenGL command 'glRasterPos2xvOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void raster_pos_3x_oes(gl::fixed_t x, gl::fixed_t y, gl::fixed_t z) {
      if ( GLAD_GL_OES_fixed_point ) {
        glRasterPos3xOES(x, y, z);
      }
      else {
        throw std::runtime_error("OpenGL command 'glRasterPos3xOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void raster_pos_3xv_oes(const  gl::fixed_t * coords) {
      if ( GLAD_GL_OES_fixed_point ) {
        glRasterPos3xvOES(coords);
      }
      else {
        throw std::runtime_error("OpenGL command 'glRasterPos3xvOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void raster_pos_4x_oes(gl::fixed_t x, gl::fixed_t y, gl::fixed_t z, gl::fixed_t w) {
      if ( GLAD_GL_OES_fixed_point ) {
        glRasterPos4xOES(x, y, z, w);
      }
      else {
        throw std::runtime_error("OpenGL command 'glRasterPos4xOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void raster_pos_4xv_oes(const  gl::fixed_t * coords) {
      if ( GLAD_GL_OES_fixed_point ) {
        glRasterPos4xvOES(coords);
      }
      else {
        throw std::runtime_error("OpenGL command 'glRasterPos4xvOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void raster_samples_ext(gl::uint_t samples, gl::boolean_t fixedsamplelocations) {
      if ( GLAD_GL_EXT_raster_multisample || GLAD_GL_EXT_texture_filter_minmax || GLAD_GL_NV_framebuffer_mixed_samples ) {
        glRasterSamplesEXT(samples, fixedsamplelocations);
      }
      else {
        throw std::runtime_error("OpenGL command 'glRasterSamplesEXT' not available on this platform (extensions: GL_EXT_raster_multisample, GL_EXT_texture_filter_minmax, GL_NV_framebuffer_mixed_samples)");
      }
    }

    void read_instruments_sgix(gl::int_t marker) {
      if ( GLAD_GL_SGIX_instruments ) {
        glReadInstrumentsSGIX(marker);
      }
      else {
        throw std::runtime_error("OpenGL command 'glReadInstrumentsSGIX' not available on this platform (extensions: GL_SGIX_instruments)");
      }
    }

    void readn_pixels(gl::int_t x, gl::int_t y, gl::sizei_t width, gl::sizei_t height, gl::enum_t format, gl::enum_t type, gl::sizei_t bufSize, void * data) {
      if ( GLAD_GL_KHR_robustness ) {
        glReadnPixels(x, y, width, height, format, type, bufSize, data);
      }
      else {
        throw std::runtime_error("OpenGL command 'glReadnPixels' not available on this platform (extensions: GL_KHR_robustness)");
      }
    }

    void readn_pixels_arb(gl::int_t x, gl::int_t y, gl::sizei_t width, gl::sizei_t height, gl::enum_t format, gl::enum_t type, gl::sizei_t bufSize, void * data) {
      if ( GLAD_GL_ARB_robustness ) {
        glReadnPixelsARB(x, y, width, height, format, type, bufSize, data);
      }
      else {
        throw std::runtime_error("OpenGL command 'glReadnPixelsARB' not available on this platform (extensions: GL_ARB_robustness)");
      }
    }

    void rectx_oes(gl::fixed_t x1, gl::fixed_t y1, gl::fixed_t x2, gl::fixed_t y2) {
      if ( GLAD_GL_OES_fixed_point ) {
        glRectxOES(x1, y1, x2, y2);
      }
      else {
        throw std::runtime_error("OpenGL command 'glRectxOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void rectxv_oes(const  gl::fixed_t * v1, const  gl::fixed_t * v2) {
      if ( GLAD_GL_OES_fixed_point ) {
        glRectxvOES(v1, v2);
      }
      else {
        throw std::runtime_error("OpenGL command 'glRectxvOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void reference_plane_sgix(const  gl::double_t * equation) {
      if ( GLAD_GL_SGIX_reference_plane ) {
        glReferencePlaneSGIX(equation);
      }
      else {
        throw std::runtime_error("OpenGL command 'glReferencePlaneSGIX' not available on this platform (extensions: GL_SGIX_reference_plane)");
      }
    }

    void release_shader_compiler() {
      if ( GLAD_GL_ARB_ES2_compatibility ) {
        glReleaseShaderCompiler();
      }
      else {
        throw std::runtime_error("OpenGL command 'glReleaseShaderCompiler' not available on this platform (extensions: GL_ARB_ES2_compatibility)");
      }
    }

    void renderbuffer_storage(renderbuffer_target_t target, internal_format_t internalformat, gl::sizei_t width, gl::sizei_t height) {
      if ( GLAD_GL_ARB_framebuffer_object ) {
        glRenderbufferStorage(static_cast<GLenum>(target), static_cast<GLenum>(internalformat), width, height);
      }
      else {
        throw std::runtime_error("OpenGL command 'glRenderbufferStorage' not available on this platform (extensions: GL_ARB_framebuffer_object)");
      }
    }

    void renderbuffer_storage_ext(renderbuffer_target_t target, internal_format_t internalformat, gl::sizei_t width, gl::sizei_t height) {
      if ( GLAD_GL_EXT_framebuffer_object ) {
        glRenderbufferStorageEXT(static_cast<GLenum>(target), static_cast<GLenum>(internalformat), width, height);
      }
      else {
        throw std::runtime_error("OpenGL command 'glRenderbufferStorageEXT' not available on this platform (extensions: GL_EXT_framebuffer_object)");
      }
    }

    void renderbuffer_storage_multisample(renderbuffer_target_t target, gl::sizei_t samples, internal_format_t internalformat, gl::sizei_t width, gl::sizei_t height) {
      if ( GLAD_GL_ARB_framebuffer_object ) {
        glRenderbufferStorageMultisample(static_cast<GLenum>(target), samples, static_cast<GLenum>(internalformat), width, height);
      }
      else {
        throw std::runtime_error("OpenGL command 'glRenderbufferStorageMultisample' not available on this platform (extensions: GL_ARB_framebuffer_object)");
      }
    }

    void renderbuffer_storage_multisample_coverage_nv(renderbuffer_target_t target, gl::sizei_t coverageSamples, gl::sizei_t colorSamples, gl::enum_t internalformat, gl::sizei_t width, gl::sizei_t height) {
      if ( GLAD_GL_NV_framebuffer_multisample_coverage ) {
        glRenderbufferStorageMultisampleCoverageNV(static_cast<GLenum>(target), coverageSamples, colorSamples, internalformat, width, height);
      }
      else {
        throw std::runtime_error("OpenGL command 'glRenderbufferStorageMultisampleCoverageNV' not available on this platform (extensions: GL_NV_framebuffer_multisample_coverage)");
      }
    }

    void renderbuffer_storage_multisample_ext(renderbuffer_target_t target, gl::sizei_t samples, internal_format_t internalformat, gl::sizei_t width, gl::sizei_t height) {
      if ( GLAD_GL_EXT_framebuffer_multisample ) {
        glRenderbufferStorageMultisampleEXT(static_cast<GLenum>(target), samples, static_cast<GLenum>(internalformat), width, height);
      }
      else {
        throw std::runtime_error("OpenGL command 'glRenderbufferStorageMultisampleEXT' not available on this platform (extensions: GL_EXT_framebuffer_multisample)");
      }
    }

    void replacement_code_pointer_sun(gl::enum_t type, gl::sizei_t stride, const  void ** pointer) {
      if ( GLAD_GL_SUN_triangle_list ) {
        glReplacementCodePointerSUN(type, stride, pointer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glReplacementCodePointerSUN' not available on this platform (extensions: GL_SUN_triangle_list)");
      }
    }

    void replacement_codeub_sun(gl::ubyte_t code) {
      if ( GLAD_GL_SUN_triangle_list ) {
        glReplacementCodeubSUN(code);
      }
      else {
        throw std::runtime_error("OpenGL command 'glReplacementCodeubSUN' not available on this platform (extensions: GL_SUN_triangle_list)");
      }
    }

    void replacement_codeubv_sun(const  gl::ubyte_t * code) {
      if ( GLAD_GL_SUN_triangle_list ) {
        glReplacementCodeubvSUN(code);
      }
      else {
        throw std::runtime_error("OpenGL command 'glReplacementCodeubvSUN' not available on this platform (extensions: GL_SUN_triangle_list)");
      }
    }

    void replacement_codeui_color_3f_vertex_3f_sun(gl::uint_t rc, gl::float_t r, gl::float_t g, gl::float_t b, gl::float_t x, gl::float_t y, gl::float_t z) {
      if ( GLAD_GL_SUN_vertex ) {
        glReplacementCodeuiColor3fVertex3fSUN(rc, r, g, b, x, y, z);
      }
      else {
        throw std::runtime_error("OpenGL command 'glReplacementCodeuiColor3fVertex3fSUN' not available on this platform (extensions: GL_SUN_vertex)");
      }
    }

    void replacement_codeui_color_3f_vertex_3fv_sun(const  gl::uint_t * rc, const  gl::float_t * c, const  gl::float_t * v) {
      if ( GLAD_GL_SUN_vertex ) {
        glReplacementCodeuiColor3fVertex3fvSUN(rc, c, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glReplacementCodeuiColor3fVertex3fvSUN' not available on this platform (extensions: GL_SUN_vertex)");
      }
    }

    void replacement_codeui_color_4f_normal_3f_vertex_3f_sun(gl::uint_t rc, gl::float_t r, gl::float_t g, gl::float_t b, gl::float_t a, gl::float_t nx, gl::float_t ny, gl::float_t nz, gl::float_t x, gl::float_t y, gl::float_t z) {
      if ( GLAD_GL_SUN_vertex ) {
        glReplacementCodeuiColor4fNormal3fVertex3fSUN(rc, r, g, b, a, nx, ny, nz, x, y, z);
      }
      else {
        throw std::runtime_error("OpenGL command 'glReplacementCodeuiColor4fNormal3fVertex3fSUN' not available on this platform (extensions: GL_SUN_vertex)");
      }
    }

    void replacement_codeui_color_4f_normal_3f_vertex_3fv_sun(const  gl::uint_t * rc, const  gl::float_t * c, const  gl::float_t * n, const  gl::float_t * v) {
      if ( GLAD_GL_SUN_vertex ) {
        glReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc, c, n, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glReplacementCodeuiColor4fNormal3fVertex3fvSUN' not available on this platform (extensions: GL_SUN_vertex)");
      }
    }

    void replacement_codeui_color_4ub_vertex_3f_sun(gl::uint_t rc, gl::ubyte_t r, gl::ubyte_t g, gl::ubyte_t b, gl::ubyte_t a, gl::float_t x, gl::float_t y, gl::float_t z) {
      if ( GLAD_GL_SUN_vertex ) {
        glReplacementCodeuiColor4ubVertex3fSUN(rc, r, g, b, a, x, y, z);
      }
      else {
        throw std::runtime_error("OpenGL command 'glReplacementCodeuiColor4ubVertex3fSUN' not available on this platform (extensions: GL_SUN_vertex)");
      }
    }

    void replacement_codeui_color_4ub_vertex_3fv_sun(const  gl::uint_t * rc, const  gl::ubyte_t * c, const  gl::float_t * v) {
      if ( GLAD_GL_SUN_vertex ) {
        glReplacementCodeuiColor4ubVertex3fvSUN(rc, c, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glReplacementCodeuiColor4ubVertex3fvSUN' not available on this platform (extensions: GL_SUN_vertex)");
      }
    }

    void replacement_codeui_normal_3f_vertex_3f_sun(gl::uint_t rc, gl::float_t nx, gl::float_t ny, gl::float_t nz, gl::float_t x, gl::float_t y, gl::float_t z) {
      if ( GLAD_GL_SUN_vertex ) {
        glReplacementCodeuiNormal3fVertex3fSUN(rc, nx, ny, nz, x, y, z);
      }
      else {
        throw std::runtime_error("OpenGL command 'glReplacementCodeuiNormal3fVertex3fSUN' not available on this platform (extensions: GL_SUN_vertex)");
      }
    }

    void replacement_codeui_normal_3f_vertex_3fv_sun(const  gl::uint_t * rc, const  gl::float_t * n, const  gl::float_t * v) {
      if ( GLAD_GL_SUN_vertex ) {
        glReplacementCodeuiNormal3fVertex3fvSUN(rc, n, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glReplacementCodeuiNormal3fVertex3fvSUN' not available on this platform (extensions: GL_SUN_vertex)");
      }
    }

    void replacement_codeui_sun(gl::uint_t code) {
      if ( GLAD_GL_SUN_triangle_list ) {
        glReplacementCodeuiSUN(code);
      }
      else {
        throw std::runtime_error("OpenGL command 'glReplacementCodeuiSUN' not available on this platform (extensions: GL_SUN_triangle_list)");
      }
    }

    void replacement_codeui_tex_coord_2f_color_4f_normal_3f_vertex_3f_sun(gl::uint_t rc, gl::float_t s, gl::float_t t, gl::float_t r, gl::float_t g, gl::float_t b, gl::float_t a, gl::float_t nx, gl::float_t ny, gl::float_t nz, gl::float_t x, gl::float_t y, gl::float_t z) {
      if ( GLAD_GL_SUN_vertex ) {
        glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN(rc, s, t, r, g, b, a, nx, ny, nz, x, y, z);
      }
      else {
        throw std::runtime_error("OpenGL command 'glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN' not available on this platform (extensions: GL_SUN_vertex)");
      }
    }

    void replacement_codeui_tex_coord_2f_color_4f_normal_3f_vertex_3fv_sun(const  gl::uint_t * rc, const  gl::float_t * tc, const  gl::float_t * c, const  gl::float_t * n, const  gl::float_t * v) {
      if ( GLAD_GL_SUN_vertex ) {
        glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, tc, c, n, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN' not available on this platform (extensions: GL_SUN_vertex)");
      }
    }

    void replacement_codeui_tex_coord_2f_normal_3f_vertex_3f_sun(gl::uint_t rc, gl::float_t s, gl::float_t t, gl::float_t nx, gl::float_t ny, gl::float_t nz, gl::float_t x, gl::float_t y, gl::float_t z) {
      if ( GLAD_GL_SUN_vertex ) {
        glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN(rc, s, t, nx, ny, nz, x, y, z);
      }
      else {
        throw std::runtime_error("OpenGL command 'glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN' not available on this platform (extensions: GL_SUN_vertex)");
      }
    }

    void replacement_codeui_tex_coord_2f_normal_3f_vertex_3fv_sun(const  gl::uint_t * rc, const  gl::float_t * tc, const  gl::float_t * n, const  gl::float_t * v) {
      if ( GLAD_GL_SUN_vertex ) {
        glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc, tc, n, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN' not available on this platform (extensions: GL_SUN_vertex)");
      }
    }

    void replacement_codeui_tex_coord_2f_vertex_3f_sun(gl::uint_t rc, gl::float_t s, gl::float_t t, gl::float_t x, gl::float_t y, gl::float_t z) {
      if ( GLAD_GL_SUN_vertex ) {
        glReplacementCodeuiTexCoord2fVertex3fSUN(rc, s, t, x, y, z);
      }
      else {
        throw std::runtime_error("OpenGL command 'glReplacementCodeuiTexCoord2fVertex3fSUN' not available on this platform (extensions: GL_SUN_vertex)");
      }
    }

    void replacement_codeui_tex_coord_2f_vertex_3fv_sun(const  gl::uint_t * rc, const  gl::float_t * tc, const  gl::float_t * v) {
      if ( GLAD_GL_SUN_vertex ) {
        glReplacementCodeuiTexCoord2fVertex3fvSUN(rc, tc, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glReplacementCodeuiTexCoord2fVertex3fvSUN' not available on this platform (extensions: GL_SUN_vertex)");
      }
    }

    void replacement_codeui_vertex_3f_sun(gl::uint_t rc, gl::float_t x, gl::float_t y, gl::float_t z) {
      if ( GLAD_GL_SUN_vertex ) {
        glReplacementCodeuiVertex3fSUN(rc, x, y, z);
      }
      else {
        throw std::runtime_error("OpenGL command 'glReplacementCodeuiVertex3fSUN' not available on this platform (extensions: GL_SUN_vertex)");
      }
    }

    void replacement_codeui_vertex_3fv_sun(const  gl::uint_t * rc, const  gl::float_t * v) {
      if ( GLAD_GL_SUN_vertex ) {
        glReplacementCodeuiVertex3fvSUN(rc, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glReplacementCodeuiVertex3fvSUN' not available on this platform (extensions: GL_SUN_vertex)");
      }
    }

    void replacement_codeuiv_sun(const  gl::uint_t * code) {
      if ( GLAD_GL_SUN_triangle_list ) {
        glReplacementCodeuivSUN(code);
      }
      else {
        throw std::runtime_error("OpenGL command 'glReplacementCodeuivSUN' not available on this platform (extensions: GL_SUN_triangle_list)");
      }
    }

    void replacement_codeus_sun(gl::ushort_t code) {
      if ( GLAD_GL_SUN_triangle_list ) {
        glReplacementCodeusSUN(code);
      }
      else {
        throw std::runtime_error("OpenGL command 'glReplacementCodeusSUN' not available on this platform (extensions: GL_SUN_triangle_list)");
      }
    }

    void replacement_codeusv_sun(const  gl::ushort_t * code) {
      if ( GLAD_GL_SUN_triangle_list ) {
        glReplacementCodeusvSUN(code);
      }
      else {
        throw std::runtime_error("OpenGL command 'glReplacementCodeusvSUN' not available on this platform (extensions: GL_SUN_triangle_list)");
      }
    }

    void request_resident_programs_nv(gl::sizei_t n, const  gl::uint_t * programs) {
      if ( GLAD_GL_NV_vertex_program ) {
        glRequestResidentProgramsNV(n, programs);
      }
      else {
        throw std::runtime_error("OpenGL command 'glRequestResidentProgramsNV' not available on this platform (extensions: GL_NV_vertex_program)");
      }
    }

    void reset_histogram(gl::enum_t target) {
      if ( GLAD_GL_ARB_imaging ) {
        glResetHistogram(target);
      }
      else {
        throw std::runtime_error("OpenGL command 'glResetHistogram' not available on this platform (extensions: GL_ARB_imaging)");
      }
    }

    void reset_histogram_ext(histogram_target_ext_t target) {
      if ( GLAD_GL_EXT_histogram ) {
        glResetHistogramEXT(static_cast<GLenum>(target));
      }
      else {
        throw std::runtime_error("OpenGL command 'glResetHistogramEXT' not available on this platform (extensions: GL_EXT_histogram)");
      }
    }

    void reset_minmax(gl::enum_t target) {
      if ( GLAD_GL_ARB_imaging ) {
        glResetMinmax(target);
      }
      else {
        throw std::runtime_error("OpenGL command 'glResetMinmax' not available on this platform (extensions: GL_ARB_imaging)");
      }
    }

    void reset_minmax_ext(minmax_target_ext_t target) {
      if ( GLAD_GL_EXT_histogram ) {
        glResetMinmaxEXT(static_cast<GLenum>(target));
      }
      else {
        throw std::runtime_error("OpenGL command 'glResetMinmaxEXT' not available on this platform (extensions: GL_EXT_histogram)");
      }
    }

    void resize_buffers_mesa() {
      if ( GLAD_GL_MESA_resize_buffers ) {
        glResizeBuffersMESA();
      }
      else {
        throw std::runtime_error("OpenGL command 'glResizeBuffersMESA' not available on this platform (extensions: GL_MESA_resize_buffers)");
      }
    }

    void resolve_depth_values_nv() {
      if ( GLAD_GL_NV_sample_locations ) {
        glResolveDepthValuesNV();
      }
      else {
        throw std::runtime_error("OpenGL command 'glResolveDepthValuesNV' not available on this platform (extensions: GL_NV_sample_locations)");
      }
    }

    void resume_transform_feedback() {
      if ( GLAD_GL_ARB_transform_feedback2 ) {
        glResumeTransformFeedback();
      }
      else {
        throw std::runtime_error("OpenGL command 'glResumeTransformFeedback' not available on this platform (extensions: GL_ARB_transform_feedback2)");
      }
    }

    void resume_transform_feedback_nv() {
      if ( GLAD_GL_NV_transform_feedback2 ) {
        glResumeTransformFeedbackNV();
      }
      else {
        throw std::runtime_error("OpenGL command 'glResumeTransformFeedbackNV' not available on this platform (extensions: GL_NV_transform_feedback2)");
      }
    }

    void rotatex_oes(gl::fixed_t angle, gl::fixed_t x, gl::fixed_t y, gl::fixed_t z) {
      if ( GLAD_GL_OES_fixed_point ) {
        glRotatexOES(angle, x, y, z);
      }
      else {
        throw std::runtime_error("OpenGL command 'glRotatexOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void sample_coverage_arb(gl::float_t value, gl::boolean_t invert) {
      if ( GLAD_GL_ARB_multisample ) {
        glSampleCoverageARB(value, invert);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSampleCoverageARB' not available on this platform (extensions: GL_ARB_multisample)");
      }
    }

    void sample_coverage_oes(gl::fixed_t value, gl::boolean_t invert) {
      if ( GLAD_GL_OES_fixed_point ) {
        glSampleCoverageOES(value, invert);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSampleCoverageOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void sample_map_ati(gl::uint_t dst, gl::uint_t interp, gl::enum_t swizzle) {
      if ( GLAD_GL_ATI_fragment_shader ) {
        glSampleMapATI(dst, interp, swizzle);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSampleMapATI' not available on this platform (extensions: GL_ATI_fragment_shader)");
      }
    }

    void sample_mask_ext(gl::clampf_t value, gl::boolean_t invert) {
      if ( GLAD_GL_EXT_multisample ) {
        glSampleMaskEXT(value, invert);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSampleMaskEXT' not available on this platform (extensions: GL_EXT_multisample)");
      }
    }

    void sample_mask_indexed_nv(gl::uint_t index, gl::bitfield_t mask) {
      if ( GLAD_GL_NV_explicit_multisample ) {
        glSampleMaskIndexedNV(index, mask);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSampleMaskIndexedNV' not available on this platform (extensions: GL_NV_explicit_multisample)");
      }
    }

    void sample_mask_sgis(gl::clampf_t value, gl::boolean_t invert) {
      if ( GLAD_GL_SGIS_multisample ) {
        glSampleMaskSGIS(value, invert);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSampleMaskSGIS' not available on this platform (extensions: GL_SGIS_multisample)");
      }
    }

    void sample_maski(gl::uint_t maskNumber, gl::bitfield_t mask) {
      if ( GLAD_GL_ARB_texture_multisample ) {
        glSampleMaski(maskNumber, mask);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSampleMaski' not available on this platform (extensions: GL_ARB_texture_multisample)");
      }
    }

    void sample_pattern_ext(gl::enum_t pattern) {
      if ( GLAD_GL_EXT_multisample ) {
        glSamplePatternEXT(pattern);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSamplePatternEXT' not available on this platform (extensions: GL_EXT_multisample)");
      }
    }

    void sample_pattern_sgis(sample_pattern_sgis_t pattern) {
      if ( GLAD_GL_SGIS_multisample ) {
        glSamplePatternSGIS(static_cast<GLenum>(pattern));
      }
      else {
        throw std::runtime_error("OpenGL command 'glSamplePatternSGIS' not available on this platform (extensions: GL_SGIS_multisample)");
      }
    }

    void sampler_parameter_iiv(gl::uint_t sampler, gl::enum_t pname, const  gl::int_t * param) {
      if ( GLAD_GL_ARB_sampler_objects ) {
        glSamplerParameterIiv(sampler, pname, param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSamplerParameterIiv' not available on this platform (extensions: GL_ARB_sampler_objects)");
      }
    }

    void sampler_parameter_iuiv(gl::uint_t sampler, gl::enum_t pname, const  gl::uint_t * param) {
      if ( GLAD_GL_ARB_sampler_objects ) {
        glSamplerParameterIuiv(sampler, pname, param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSamplerParameterIuiv' not available on this platform (extensions: GL_ARB_sampler_objects)");
      }
    }

    void sampler_parameterf(gl::uint_t sampler, gl::enum_t pname, gl::float_t param) {
      if ( GLAD_GL_ARB_sampler_objects ) {
        glSamplerParameterf(sampler, pname, param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSamplerParameterf' not available on this platform (extensions: GL_ARB_sampler_objects)");
      }
    }

    void sampler_parameterfv(gl::uint_t sampler, gl::enum_t pname, const  gl::float_t * param) {
      if ( GLAD_GL_ARB_sampler_objects ) {
        glSamplerParameterfv(sampler, pname, param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSamplerParameterfv' not available on this platform (extensions: GL_ARB_sampler_objects)");
      }
    }

    void sampler_parameteri(gl::uint_t sampler, gl::enum_t pname, gl::int_t param) {
      if ( GLAD_GL_ARB_sampler_objects ) {
        glSamplerParameteri(sampler, pname, param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSamplerParameteri' not available on this platform (extensions: GL_ARB_sampler_objects)");
      }
    }

    void sampler_parameteriv(gl::uint_t sampler, gl::enum_t pname, const  gl::int_t * param) {
      if ( GLAD_GL_ARB_sampler_objects ) {
        glSamplerParameteriv(sampler, pname, param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSamplerParameteriv' not available on this platform (extensions: GL_ARB_sampler_objects)");
      }
    }

    void scalex_oes(gl::fixed_t x, gl::fixed_t y, gl::fixed_t z) {
      if ( GLAD_GL_OES_fixed_point ) {
        glScalexOES(x, y, z);
      }
      else {
        throw std::runtime_error("OpenGL command 'glScalexOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void scissor_arrayv(gl::uint_t first, gl::sizei_t count, const  gl::int_t * v) {
      if ( GLAD_GL_ARB_viewport_array ) {
        glScissorArrayv(first, count, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glScissorArrayv' not available on this platform (extensions: GL_ARB_viewport_array)");
      }
    }

    void scissor_indexed(gl::uint_t index, gl::int_t left, gl::int_t bottom, gl::sizei_t width, gl::sizei_t height) {
      if ( GLAD_GL_ARB_viewport_array ) {
        glScissorIndexed(index, left, bottom, width, height);
      }
      else {
        throw std::runtime_error("OpenGL command 'glScissorIndexed' not available on this platform (extensions: GL_ARB_viewport_array)");
      }
    }

    void scissor_indexedv(gl::uint_t index, const  gl::int_t * v) {
      if ( GLAD_GL_ARB_viewport_array ) {
        glScissorIndexedv(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glScissorIndexedv' not available on this platform (extensions: GL_ARB_viewport_array)");
      }
    }

    void secondary_color_3b_ext(gl::byte_t red, gl::byte_t green, gl::byte_t blue) {
      if ( GLAD_GL_EXT_secondary_color ) {
        glSecondaryColor3bEXT(red, green, blue);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSecondaryColor3bEXT' not available on this platform (extensions: GL_EXT_secondary_color)");
      }
    }

    void secondary_color_3bv_ext(const  gl::byte_t * v) {
      if ( GLAD_GL_EXT_secondary_color ) {
        glSecondaryColor3bvEXT(v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSecondaryColor3bvEXT' not available on this platform (extensions: GL_EXT_secondary_color)");
      }
    }

    void secondary_color_3d_ext(gl::double_t red, gl::double_t green, gl::double_t blue) {
      if ( GLAD_GL_EXT_secondary_color ) {
        glSecondaryColor3dEXT(red, green, blue);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSecondaryColor3dEXT' not available on this platform (extensions: GL_EXT_secondary_color)");
      }
    }

    void secondary_color_3dv_ext(const  gl::double_t * v) {
      if ( GLAD_GL_EXT_secondary_color ) {
        glSecondaryColor3dvEXT(v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSecondaryColor3dvEXT' not available on this platform (extensions: GL_EXT_secondary_color)");
      }
    }

    void secondary_color_3f_ext(gl::float_t red, gl::float_t green, gl::float_t blue) {
      if ( GLAD_GL_EXT_secondary_color ) {
        glSecondaryColor3fEXT(red, green, blue);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSecondaryColor3fEXT' not available on this platform (extensions: GL_EXT_secondary_color)");
      }
    }

    void secondary_color_3fv_ext(const  gl::float_t * v) {
      if ( GLAD_GL_EXT_secondary_color ) {
        glSecondaryColor3fvEXT(v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSecondaryColor3fvEXT' not available on this platform (extensions: GL_EXT_secondary_color)");
      }
    }

    void secondary_color_3h_nv(gl::halfNV_t red, gl::halfNV_t green, gl::halfNV_t blue) {
      if ( GLAD_GL_NV_half_float ) {
        glSecondaryColor3hNV(red, green, blue);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSecondaryColor3hNV' not available on this platform (extensions: GL_NV_half_float)");
      }
    }

    void secondary_color_3hv_nv(const  gl::halfNV_t * v) {
      if ( GLAD_GL_NV_half_float ) {
        glSecondaryColor3hvNV(v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSecondaryColor3hvNV' not available on this platform (extensions: GL_NV_half_float)");
      }
    }

    void secondary_color_3i_ext(gl::int_t red, gl::int_t green, gl::int_t blue) {
      if ( GLAD_GL_EXT_secondary_color ) {
        glSecondaryColor3iEXT(red, green, blue);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSecondaryColor3iEXT' not available on this platform (extensions: GL_EXT_secondary_color)");
      }
    }

    void secondary_color_3iv_ext(const  gl::int_t * v) {
      if ( GLAD_GL_EXT_secondary_color ) {
        glSecondaryColor3ivEXT(v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSecondaryColor3ivEXT' not available on this platform (extensions: GL_EXT_secondary_color)");
      }
    }

    void secondary_color_3s_ext(gl::short_t red, gl::short_t green, gl::short_t blue) {
      if ( GLAD_GL_EXT_secondary_color ) {
        glSecondaryColor3sEXT(red, green, blue);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSecondaryColor3sEXT' not available on this platform (extensions: GL_EXT_secondary_color)");
      }
    }

    void secondary_color_3sv_ext(const  gl::short_t * v) {
      if ( GLAD_GL_EXT_secondary_color ) {
        glSecondaryColor3svEXT(v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSecondaryColor3svEXT' not available on this platform (extensions: GL_EXT_secondary_color)");
      }
    }

    void secondary_color_3ub_ext(gl::ubyte_t red, gl::ubyte_t green, gl::ubyte_t blue) {
      if ( GLAD_GL_EXT_secondary_color ) {
        glSecondaryColor3ubEXT(red, green, blue);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSecondaryColor3ubEXT' not available on this platform (extensions: GL_EXT_secondary_color)");
      }
    }

    void secondary_color_3ubv_ext(const  gl::ubyte_t * v) {
      if ( GLAD_GL_EXT_secondary_color ) {
        glSecondaryColor3ubvEXT(v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSecondaryColor3ubvEXT' not available on this platform (extensions: GL_EXT_secondary_color)");
      }
    }

    void secondary_color_3ui_ext(gl::uint_t red, gl::uint_t green, gl::uint_t blue) {
      if ( GLAD_GL_EXT_secondary_color ) {
        glSecondaryColor3uiEXT(red, green, blue);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSecondaryColor3uiEXT' not available on this platform (extensions: GL_EXT_secondary_color)");
      }
    }

    void secondary_color_3uiv_ext(const  gl::uint_t * v) {
      if ( GLAD_GL_EXT_secondary_color ) {
        glSecondaryColor3uivEXT(v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSecondaryColor3uivEXT' not available on this platform (extensions: GL_EXT_secondary_color)");
      }
    }

    void secondary_color_3us_ext(gl::ushort_t red, gl::ushort_t green, gl::ushort_t blue) {
      if ( GLAD_GL_EXT_secondary_color ) {
        glSecondaryColor3usEXT(red, green, blue);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSecondaryColor3usEXT' not available on this platform (extensions: GL_EXT_secondary_color)");
      }
    }

    void secondary_color_3usv_ext(const  gl::ushort_t * v) {
      if ( GLAD_GL_EXT_secondary_color ) {
        glSecondaryColor3usvEXT(v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSecondaryColor3usvEXT' not available on this platform (extensions: GL_EXT_secondary_color)");
      }
    }

    void secondary_color_format_nv(gl::int_t size, gl::enum_t type, gl::sizei_t stride) {
      if ( GLAD_GL_NV_vertex_buffer_unified_memory ) {
        glSecondaryColorFormatNV(size, type, stride);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSecondaryColorFormatNV' not available on this platform (extensions: GL_NV_vertex_buffer_unified_memory)");
      }
    }

    void secondary_color_p3ui(gl::enum_t type, gl::uint_t color) {
      if ( GLAD_GL_ARB_vertex_type_2_10_10_10_rev ) {
        glSecondaryColorP3ui(type, color);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSecondaryColorP3ui' not available on this platform (extensions: GL_ARB_vertex_type_2_10_10_10_rev)");
      }
    }

    void secondary_color_p3uiv(gl::enum_t type, const  gl::uint_t * color) {
      if ( GLAD_GL_ARB_vertex_type_2_10_10_10_rev ) {
        glSecondaryColorP3uiv(type, color);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSecondaryColorP3uiv' not available on this platform (extensions: GL_ARB_vertex_type_2_10_10_10_rev)");
      }
    }

    void secondary_color_pointer_ext(gl::int_t size, color_pointer_type_t type, gl::sizei_t stride, const  void * pointer) {
      if ( GLAD_GL_EXT_secondary_color ) {
        glSecondaryColorPointerEXT(size, static_cast<GLenum>(type), stride, pointer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSecondaryColorPointerEXT' not available on this platform (extensions: GL_EXT_secondary_color)");
      }
    }

    void secondary_color_pointer_list_ibm(gl::int_t size, gl::enum_t type, gl::int_t stride, const  void ** pointer, gl::int_t ptrstride) {
      if ( GLAD_GL_IBM_vertex_array_lists ) {
        glSecondaryColorPointerListIBM(size, type, stride, pointer, ptrstride);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSecondaryColorPointerListIBM' not available on this platform (extensions: GL_IBM_vertex_array_lists)");
      }
    }

    void select_perf_monitor_counters_amd(gl::uint_t monitor, gl::boolean_t enable, gl::uint_t group, gl::int_t numCounters, gl::uint_t * counterList) {
      if ( GLAD_GL_AMD_performance_monitor ) {
        glSelectPerfMonitorCountersAMD(monitor, enable, group, numCounters, counterList);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSelectPerfMonitorCountersAMD' not available on this platform (extensions: GL_AMD_performance_monitor)");
      }
    }

    void separable_filter_2d(gl::enum_t target, gl::enum_t internalformat, gl::sizei_t width, gl::sizei_t height, pixel_format_t format, pixel_type_t type, const  void * row, const  void * column) {
      if ( GLAD_GL_ARB_imaging ) {
        glSeparableFilter2D(target, internalformat, width, height, static_cast<GLenum>(format), static_cast<GLenum>(type), row, column);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSeparableFilter2D' not available on this platform (extensions: GL_ARB_imaging)");
      }
    }

    void separable_filter_2dext(separable_target_ext_t target, gl::enum_t internalformat, gl::sizei_t width, gl::sizei_t height, pixel_format_t format, pixel_type_t type, const  void * row, const  void * column) {
      if ( GLAD_GL_EXT_convolution ) {
        glSeparableFilter2DEXT(static_cast<GLenum>(target), internalformat, width, height, static_cast<GLenum>(format), static_cast<GLenum>(type), row, column);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSeparableFilter2DEXT' not available on this platform (extensions: GL_EXT_convolution)");
      }
    }

    void set_fence_apple(gl::uint_t fence) {
      if ( GLAD_GL_APPLE_fence ) {
        glSetFenceAPPLE(fence);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSetFenceAPPLE' not available on this platform (extensions: GL_APPLE_fence)");
      }
    }

    void set_fence_nv(gl::uint_t fence, gl::enum_t condition) {
      if ( GLAD_GL_NV_fence ) {
        glSetFenceNV(fence, condition);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSetFenceNV' not available on this platform (extensions: GL_NV_fence)");
      }
    }

    void set_fragment_shader_constant_ati(gl::uint_t dst, const  gl::float_t * value) {
      if ( GLAD_GL_ATI_fragment_shader ) {
        glSetFragmentShaderConstantATI(dst, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSetFragmentShaderConstantATI' not available on this platform (extensions: GL_ATI_fragment_shader)");
      }
    }

    void set_invariant_ext(gl::uint_t id, gl::enum_t type, const  void * addr) {
      if ( GLAD_GL_EXT_vertex_shader ) {
        glSetInvariantEXT(id, type, addr);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSetInvariantEXT' not available on this platform (extensions: GL_EXT_vertex_shader)");
      }
    }

    void set_local_constant_ext(gl::uint_t id, gl::enum_t type, const  void * addr) {
      if ( GLAD_GL_EXT_vertex_shader ) {
        glSetLocalConstantEXT(id, type, addr);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSetLocalConstantEXT' not available on this platform (extensions: GL_EXT_vertex_shader)");
      }
    }

    void set_multisamplefv_amd(gl::enum_t pname, gl::uint_t index, const  gl::float_t * val) {
      if ( GLAD_GL_AMD_sample_positions ) {
        glSetMultisamplefvAMD(pname, index, val);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSetMultisamplefvAMD' not available on this platform (extensions: GL_AMD_sample_positions)");
      }
    }

    void shader_binary(gl::sizei_t count, const  gl::uint_t * shaders, gl::enum_t binaryformat, const  void * binary, gl::sizei_t length) {
      if ( GLAD_GL_ARB_ES2_compatibility ) {
        glShaderBinary(count, shaders, binaryformat, binary, length);
      }
      else {
        throw std::runtime_error("OpenGL command 'glShaderBinary' not available on this platform (extensions: GL_ARB_ES2_compatibility)");
      }
    }

    void shader_op_1ext(gl::enum_t op, gl::uint_t res, gl::uint_t arg1) {
      if ( GLAD_GL_EXT_vertex_shader ) {
        glShaderOp1EXT(op, res, arg1);
      }
      else {
        throw std::runtime_error("OpenGL command 'glShaderOp1EXT' not available on this platform (extensions: GL_EXT_vertex_shader)");
      }
    }

    void shader_op_2ext(gl::enum_t op, gl::uint_t res, gl::uint_t arg1, gl::uint_t arg2) {
      if ( GLAD_GL_EXT_vertex_shader ) {
        glShaderOp2EXT(op, res, arg1, arg2);
      }
      else {
        throw std::runtime_error("OpenGL command 'glShaderOp2EXT' not available on this platform (extensions: GL_EXT_vertex_shader)");
      }
    }

    void shader_op_3ext(gl::enum_t op, gl::uint_t res, gl::uint_t arg1, gl::uint_t arg2, gl::uint_t arg3) {
      if ( GLAD_GL_EXT_vertex_shader ) {
        glShaderOp3EXT(op, res, arg1, arg2, arg3);
      }
      else {
        throw std::runtime_error("OpenGL command 'glShaderOp3EXT' not available on this platform (extensions: GL_EXT_vertex_shader)");
      }
    }

    void shader_source_arb(gl::handleARB_t shaderObj, gl::sizei_t count, const  gl::charARB_t ** string, const  gl::int_t * length) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glShaderSourceARB(shaderObj, count, string, length);
      }
      else {
        throw std::runtime_error("OpenGL command 'glShaderSourceARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void shader_storage_block_binding(gl::uint_t program, gl::uint_t storageBlockIndex, gl::uint_t storageBlockBinding) {
      if ( GLAD_GL_ARB_shader_storage_buffer_object ) {
        glShaderStorageBlockBinding(program, storageBlockIndex, storageBlockBinding);
      }
      else {
        throw std::runtime_error("OpenGL command 'glShaderStorageBlockBinding' not available on this platform (extensions: GL_ARB_shader_storage_buffer_object)");
      }
    }

    void sharpen_tex_func_sgis(texture_target_t target, gl::sizei_t n, const  gl::float_t * points) {
      if ( GLAD_GL_SGIS_sharpen_texture ) {
        glSharpenTexFuncSGIS(static_cast<GLenum>(target), n, points);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSharpenTexFuncSGIS' not available on this platform (extensions: GL_SGIS_sharpen_texture)");
      }
    }

    void sprite_parameterf_sgix(gl::enum_t pname, gl::float_t param) {
      if ( GLAD_GL_SGIX_sprite ) {
        glSpriteParameterfSGIX(pname, param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSpriteParameterfSGIX' not available on this platform (extensions: GL_SGIX_sprite)");
      }
    }

    void sprite_parameterfv_sgix(gl::enum_t pname, const  gl::float_t * params) {
      if ( GLAD_GL_SGIX_sprite ) {
        glSpriteParameterfvSGIX(pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSpriteParameterfvSGIX' not available on this platform (extensions: GL_SGIX_sprite)");
      }
    }

    void sprite_parameteri_sgix(gl::enum_t pname, gl::int_t param) {
      if ( GLAD_GL_SGIX_sprite ) {
        glSpriteParameteriSGIX(pname, param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSpriteParameteriSGIX' not available on this platform (extensions: GL_SGIX_sprite)");
      }
    }

    void sprite_parameteriv_sgix(gl::enum_t pname, const  gl::int_t * params) {
      if ( GLAD_GL_SGIX_sprite ) {
        glSpriteParameterivSGIX(pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSpriteParameterivSGIX' not available on this platform (extensions: GL_SGIX_sprite)");
      }
    }

    void start_instruments_sgix() {
      if ( GLAD_GL_SGIX_instruments ) {
        glStartInstrumentsSGIX();
      }
      else {
        throw std::runtime_error("OpenGL command 'glStartInstrumentsSGIX' not available on this platform (extensions: GL_SGIX_instruments)");
      }
    }

    void stencil_clear_tag_ext(gl::sizei_t stencilTagBits, gl::uint_t stencilClearTag) {
      if ( GLAD_GL_EXT_stencil_clear_tag ) {
        glStencilClearTagEXT(stencilTagBits, stencilClearTag);
      }
      else {
        throw std::runtime_error("OpenGL command 'glStencilClearTagEXT' not available on this platform (extensions: GL_EXT_stencil_clear_tag)");
      }
    }

    void stencil_fill_path_instanced_nv(gl::sizei_t numPaths, gl::enum_t pathNameType, const  void * paths, gl::uint_t pathBase, gl::enum_t fillMode, gl::uint_t mask, gl::enum_t transformType, const  gl::float_t * transformValues) {
      if ( GLAD_GL_NV_path_rendering ) {
        glStencilFillPathInstancedNV(numPaths, pathNameType, paths, pathBase, fillMode, mask, transformType, transformValues);
      }
      else {
        throw std::runtime_error("OpenGL command 'glStencilFillPathInstancedNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void stencil_fill_path_nv(gl::uint_t path, gl::enum_t fillMode, gl::uint_t mask) {
      if ( GLAD_GL_NV_path_rendering ) {
        glStencilFillPathNV(path, fillMode, mask);
      }
      else {
        throw std::runtime_error("OpenGL command 'glStencilFillPathNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void stencil_func_separate_ati(stencil_function_t frontfunc, stencil_function_t backfunc, gl::int_t ref, gl::uint_t mask) {
      if ( GLAD_GL_ATI_separate_stencil ) {
        glStencilFuncSeparateATI(static_cast<GLenum>(frontfunc), static_cast<GLenum>(backfunc), ref, mask);
      }
      else {
        throw std::runtime_error("OpenGL command 'glStencilFuncSeparateATI' not available on this platform (extensions: GL_ATI_separate_stencil)");
      }
    }

    void stencil_op_separate_ati(stencil_face_direction_t face, stencil_op_t sfail, stencil_op_t dpfail, stencil_op_t dppass) {
      if ( GLAD_GL_ATI_separate_stencil ) {
        glStencilOpSeparateATI(static_cast<GLenum>(face), static_cast<GLenum>(sfail), static_cast<GLenum>(dpfail), static_cast<GLenum>(dppass));
      }
      else {
        throw std::runtime_error("OpenGL command 'glStencilOpSeparateATI' not available on this platform (extensions: GL_ATI_separate_stencil)");
      }
    }

    void stencil_op_value_amd(stencil_face_direction_t face, gl::uint_t value) {
      if ( GLAD_GL_AMD_stencil_operation_extended ) {
        glStencilOpValueAMD(static_cast<GLenum>(face), value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glStencilOpValueAMD' not available on this platform (extensions: GL_AMD_stencil_operation_extended)");
      }
    }

    void stencil_stroke_path_instanced_nv(gl::sizei_t numPaths, gl::enum_t pathNameType, const  void * paths, gl::uint_t pathBase, gl::int_t reference, gl::uint_t mask, gl::enum_t transformType, const  gl::float_t * transformValues) {
      if ( GLAD_GL_NV_path_rendering ) {
        glStencilStrokePathInstancedNV(numPaths, pathNameType, paths, pathBase, reference, mask, transformType, transformValues);
      }
      else {
        throw std::runtime_error("OpenGL command 'glStencilStrokePathInstancedNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void stencil_stroke_path_nv(gl::uint_t path, gl::int_t reference, gl::uint_t mask) {
      if ( GLAD_GL_NV_path_rendering ) {
        glStencilStrokePathNV(path, reference, mask);
      }
      else {
        throw std::runtime_error("OpenGL command 'glStencilStrokePathNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void stencil_then_cover_fill_path_instanced_nv(gl::sizei_t numPaths, gl::enum_t pathNameType, const  void * paths, gl::uint_t pathBase, gl::enum_t fillMode, gl::uint_t mask, gl::enum_t coverMode, gl::enum_t transformType, const  gl::float_t * transformValues) {
      if ( GLAD_GL_NV_path_rendering ) {
        glStencilThenCoverFillPathInstancedNV(numPaths, pathNameType, paths, pathBase, fillMode, mask, coverMode, transformType, transformValues);
      }
      else {
        throw std::runtime_error("OpenGL command 'glStencilThenCoverFillPathInstancedNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void stencil_then_cover_fill_path_nv(gl::uint_t path, gl::enum_t fillMode, gl::uint_t mask, gl::enum_t coverMode) {
      if ( GLAD_GL_NV_path_rendering ) {
        glStencilThenCoverFillPathNV(path, fillMode, mask, coverMode);
      }
      else {
        throw std::runtime_error("OpenGL command 'glStencilThenCoverFillPathNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void stencil_then_cover_stroke_path_instanced_nv(gl::sizei_t numPaths, gl::enum_t pathNameType, const  void * paths, gl::uint_t pathBase, gl::int_t reference, gl::uint_t mask, gl::enum_t coverMode, gl::enum_t transformType, const  gl::float_t * transformValues) {
      if ( GLAD_GL_NV_path_rendering ) {
        glStencilThenCoverStrokePathInstancedNV(numPaths, pathNameType, paths, pathBase, reference, mask, coverMode, transformType, transformValues);
      }
      else {
        throw std::runtime_error("OpenGL command 'glStencilThenCoverStrokePathInstancedNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void stencil_then_cover_stroke_path_nv(gl::uint_t path, gl::int_t reference, gl::uint_t mask, gl::enum_t coverMode) {
      if ( GLAD_GL_NV_path_rendering ) {
        glStencilThenCoverStrokePathNV(path, reference, mask, coverMode);
      }
      else {
        throw std::runtime_error("OpenGL command 'glStencilThenCoverStrokePathNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void stop_instruments_sgix(gl::int_t marker) {
      if ( GLAD_GL_SGIX_instruments ) {
        glStopInstrumentsSGIX(marker);
      }
      else {
        throw std::runtime_error("OpenGL command 'glStopInstrumentsSGIX' not available on this platform (extensions: GL_SGIX_instruments)");
      }
    }

    void string_marker_gremedy(gl::sizei_t len, const  void * string) {
      if ( GLAD_GL_GREMEDY_string_marker ) {
        glStringMarkerGREMEDY(len, string);
      }
      else {
        throw std::runtime_error("OpenGL command 'glStringMarkerGREMEDY' not available on this platform (extensions: GL_GREMEDY_string_marker)");
      }
    }

    void subpixel_precision_bias_nv(gl::uint_t xbits, gl::uint_t ybits) {
      if ( GLAD_GL_NV_conservative_raster ) {
        glSubpixelPrecisionBiasNV(xbits, ybits);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSubpixelPrecisionBiasNV' not available on this platform (extensions: GL_NV_conservative_raster)");
      }
    }

    void swizzle_ext(gl::uint_t res, gl::uint_t in, gl::enum_t outX, gl::enum_t outY, gl::enum_t outZ, gl::enum_t outW) {
      if ( GLAD_GL_EXT_vertex_shader ) {
        glSwizzleEXT(res, in, outX, outY, outZ, outW);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSwizzleEXT' not available on this platform (extensions: GL_EXT_vertex_shader)");
      }
    }

    void sync_texture_intel(gl::uint_t texture) {
      if ( GLAD_GL_INTEL_map_texture ) {
        glSyncTextureINTEL(texture);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSyncTextureINTEL' not available on this platform (extensions: GL_INTEL_map_texture)");
      }
    }

    void tag_sample_buffer_sgix() {
      if ( GLAD_GL_SGIX_tag_sample_buffer ) {
        glTagSampleBufferSGIX();
      }
      else {
        throw std::runtime_error("OpenGL command 'glTagSampleBufferSGIX' not available on this platform (extensions: GL_SGIX_tag_sample_buffer)");
      }
    }

    void tangent_3b_ext(gl::byte_t tx, gl::byte_t ty, gl::byte_t tz) {
      if ( GLAD_GL_EXT_coordinate_frame ) {
        glTangent3bEXT(tx, ty, tz);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTangent3bEXT' not available on this platform (extensions: GL_EXT_coordinate_frame)");
      }
    }

    void tangent_3bv_ext(const  gl::byte_t * v) {
      if ( GLAD_GL_EXT_coordinate_frame ) {
        glTangent3bvEXT(v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTangent3bvEXT' not available on this platform (extensions: GL_EXT_coordinate_frame)");
      }
    }

    void tangent_3d_ext(gl::double_t tx, gl::double_t ty, gl::double_t tz) {
      if ( GLAD_GL_EXT_coordinate_frame ) {
        glTangent3dEXT(tx, ty, tz);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTangent3dEXT' not available on this platform (extensions: GL_EXT_coordinate_frame)");
      }
    }

    void tangent_3dv_ext(const  gl::double_t * v) {
      if ( GLAD_GL_EXT_coordinate_frame ) {
        glTangent3dvEXT(v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTangent3dvEXT' not available on this platform (extensions: GL_EXT_coordinate_frame)");
      }
    }

    void tangent_3f_ext(gl::float_t tx, gl::float_t ty, gl::float_t tz) {
      if ( GLAD_GL_EXT_coordinate_frame ) {
        glTangent3fEXT(tx, ty, tz);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTangent3fEXT' not available on this platform (extensions: GL_EXT_coordinate_frame)");
      }
    }

    void tangent_3fv_ext(const  gl::float_t * v) {
      if ( GLAD_GL_EXT_coordinate_frame ) {
        glTangent3fvEXT(v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTangent3fvEXT' not available on this platform (extensions: GL_EXT_coordinate_frame)");
      }
    }

    void tangent_3i_ext(gl::int_t tx, gl::int_t ty, gl::int_t tz) {
      if ( GLAD_GL_EXT_coordinate_frame ) {
        glTangent3iEXT(tx, ty, tz);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTangent3iEXT' not available on this platform (extensions: GL_EXT_coordinate_frame)");
      }
    }

    void tangent_3iv_ext(const  gl::int_t * v) {
      if ( GLAD_GL_EXT_coordinate_frame ) {
        glTangent3ivEXT(v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTangent3ivEXT' not available on this platform (extensions: GL_EXT_coordinate_frame)");
      }
    }

    void tangent_3s_ext(gl::short_t tx, gl::short_t ty, gl::short_t tz) {
      if ( GLAD_GL_EXT_coordinate_frame ) {
        glTangent3sEXT(tx, ty, tz);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTangent3sEXT' not available on this platform (extensions: GL_EXT_coordinate_frame)");
      }
    }

    void tangent_3sv_ext(const  gl::short_t * v) {
      if ( GLAD_GL_EXT_coordinate_frame ) {
        glTangent3svEXT(v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTangent3svEXT' not available on this platform (extensions: GL_EXT_coordinate_frame)");
      }
    }

    void tangent_pointer_ext(gl::enum_t type, gl::sizei_t stride, const  void * pointer) {
      if ( GLAD_GL_EXT_coordinate_frame ) {
        glTangentPointerEXT(type, stride, pointer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTangentPointerEXT' not available on this platform (extensions: GL_EXT_coordinate_frame)");
      }
    }

    void tbuffer_mask_3dfx(gl::uint_t mask) {
      if ( GLAD_GL_3DFX_tbuffer ) {
        glTbufferMask3DFX(mask);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTbufferMask3DFX' not available on this platform (extensions: GL_3DFX_tbuffer)");
      }
    }

    void tessellation_factor_amd(gl::float_t factor) {
      if ( GLAD_GL_AMD_vertex_shader_tessellator ) {
        glTessellationFactorAMD(factor);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTessellationFactorAMD' not available on this platform (extensions: GL_AMD_vertex_shader_tessellator)");
      }
    }

    void tessellation_mode_amd(gl::enum_t mode) {
      if ( GLAD_GL_AMD_vertex_shader_tessellator ) {
        glTessellationModeAMD(mode);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTessellationModeAMD' not available on this platform (extensions: GL_AMD_vertex_shader_tessellator)");
      }
    }

    gl::boolean_t test_fence_apple(gl::uint_t fence) {
      if ( GLAD_GL_APPLE_fence ) {
        return glTestFenceAPPLE(fence);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTestFenceAPPLE' not available on this platform (extensions: GL_APPLE_fence)");
      }
    }

    gl::boolean_t test_fence_nv(gl::uint_t fence) {
      if ( GLAD_GL_NV_fence ) {
        return glTestFenceNV(fence);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTestFenceNV' not available on this platform (extensions: GL_NV_fence)");
      }
    }

    gl::boolean_t test_object_apple(gl::enum_t object, gl::uint_t name) {
      if ( GLAD_GL_APPLE_fence ) {
        return glTestObjectAPPLE(object, name);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTestObjectAPPLE' not available on this platform (extensions: GL_APPLE_fence)");
      }
    }

    void tex_buffer_arb(texture_target_t target, gl::enum_t internalformat, gl::uint_t buffer) {
      if ( GLAD_GL_ARB_texture_buffer_object ) {
        glTexBufferARB(static_cast<GLenum>(target), internalformat, buffer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexBufferARB' not available on this platform (extensions: GL_ARB_texture_buffer_object)");
      }
    }

    void tex_buffer_ext(texture_target_t target, gl::enum_t internalformat, gl::uint_t buffer) {
      if ( GLAD_GL_EXT_texture_buffer_object ) {
        glTexBufferEXT(static_cast<GLenum>(target), internalformat, buffer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexBufferEXT' not available on this platform (extensions: GL_EXT_texture_buffer_object)");
      }
    }

    void tex_buffer_range(gl::enum_t target, gl::enum_t internalformat, gl::uint_t buffer, gl::intptr_t offset, gl::sizeiptr_t size) {
      if ( GLAD_GL_ARB_texture_buffer_range ) {
        glTexBufferRange(target, internalformat, buffer, offset, size);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexBufferRange' not available on this platform (extensions: GL_ARB_texture_buffer_range)");
      }
    }

    void tex_bump_parameterfv_ati(gl::enum_t pname, const  gl::float_t * param) {
      if ( GLAD_GL_ATI_envmap_bumpmap ) {
        glTexBumpParameterfvATI(pname, param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexBumpParameterfvATI' not available on this platform (extensions: GL_ATI_envmap_bumpmap)");
      }
    }

    void tex_bump_parameteriv_ati(gl::enum_t pname, const  gl::int_t * param) {
      if ( GLAD_GL_ATI_envmap_bumpmap ) {
        glTexBumpParameterivATI(pname, param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexBumpParameterivATI' not available on this platform (extensions: GL_ATI_envmap_bumpmap)");
      }
    }

    void tex_coord_1b_oes(gl::byte_t s) {
      if ( GLAD_GL_OES_byte_coordinates ) {
        glTexCoord1bOES(s);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexCoord1bOES' not available on this platform (extensions: GL_OES_byte_coordinates)");
      }
    }

    void tex_coord_1bv_oes(const  gl::byte_t * coords) {
      if ( GLAD_GL_OES_byte_coordinates ) {
        glTexCoord1bvOES(coords);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexCoord1bvOES' not available on this platform (extensions: GL_OES_byte_coordinates)");
      }
    }

    void tex_coord_1h_nv(gl::halfNV_t s) {
      if ( GLAD_GL_NV_half_float ) {
        glTexCoord1hNV(s);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexCoord1hNV' not available on this platform (extensions: GL_NV_half_float)");
      }
    }

    void tex_coord_1hv_nv(const  gl::halfNV_t * v) {
      if ( GLAD_GL_NV_half_float ) {
        glTexCoord1hvNV(v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexCoord1hvNV' not available on this platform (extensions: GL_NV_half_float)");
      }
    }

    void tex_coord_1x_oes(gl::fixed_t s) {
      if ( GLAD_GL_OES_fixed_point ) {
        glTexCoord1xOES(s);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexCoord1xOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void tex_coord_1xv_oes(const  gl::fixed_t * coords) {
      if ( GLAD_GL_OES_fixed_point ) {
        glTexCoord1xvOES(coords);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexCoord1xvOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void tex_coord_2b_oes(gl::byte_t s, gl::byte_t t) {
      if ( GLAD_GL_OES_byte_coordinates ) {
        glTexCoord2bOES(s, t);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexCoord2bOES' not available on this platform (extensions: GL_OES_byte_coordinates)");
      }
    }

    void tex_coord_2bv_oes(const  gl::byte_t * coords) {
      if ( GLAD_GL_OES_byte_coordinates ) {
        glTexCoord2bvOES(coords);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexCoord2bvOES' not available on this platform (extensions: GL_OES_byte_coordinates)");
      }
    }

    void tex_coord_2f_color_3f_vertex_3f_sun(gl::float_t s, gl::float_t t, gl::float_t r, gl::float_t g, gl::float_t b, gl::float_t x, gl::float_t y, gl::float_t z) {
      if ( GLAD_GL_SUN_vertex ) {
        glTexCoord2fColor3fVertex3fSUN(s, t, r, g, b, x, y, z);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexCoord2fColor3fVertex3fSUN' not available on this platform (extensions: GL_SUN_vertex)");
      }
    }

    void tex_coord_2f_color_3f_vertex_3fv_sun(const  gl::float_t * tc, const  gl::float_t * c, const  gl::float_t * v) {
      if ( GLAD_GL_SUN_vertex ) {
        glTexCoord2fColor3fVertex3fvSUN(tc, c, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexCoord2fColor3fVertex3fvSUN' not available on this platform (extensions: GL_SUN_vertex)");
      }
    }

    void tex_coord_2f_color_4f_normal_3f_vertex_3f_sun(gl::float_t s, gl::float_t t, gl::float_t r, gl::float_t g, gl::float_t b, gl::float_t a, gl::float_t nx, gl::float_t ny, gl::float_t nz, gl::float_t x, gl::float_t y, gl::float_t z) {
      if ( GLAD_GL_SUN_vertex ) {
        glTexCoord2fColor4fNormal3fVertex3fSUN(s, t, r, g, b, a, nx, ny, nz, x, y, z);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexCoord2fColor4fNormal3fVertex3fSUN' not available on this platform (extensions: GL_SUN_vertex)");
      }
    }

    void tex_coord_2f_color_4f_normal_3f_vertex_3fv_sun(const  gl::float_t * tc, const  gl::float_t * c, const  gl::float_t * n, const  gl::float_t * v) {
      if ( GLAD_GL_SUN_vertex ) {
        glTexCoord2fColor4fNormal3fVertex3fvSUN(tc, c, n, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexCoord2fColor4fNormal3fVertex3fvSUN' not available on this platform (extensions: GL_SUN_vertex)");
      }
    }

    void tex_coord_2f_color_4ub_vertex_3f_sun(gl::float_t s, gl::float_t t, gl::ubyte_t r, gl::ubyte_t g, gl::ubyte_t b, gl::ubyte_t a, gl::float_t x, gl::float_t y, gl::float_t z) {
      if ( GLAD_GL_SUN_vertex ) {
        glTexCoord2fColor4ubVertex3fSUN(s, t, r, g, b, a, x, y, z);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexCoord2fColor4ubVertex3fSUN' not available on this platform (extensions: GL_SUN_vertex)");
      }
    }

    void tex_coord_2f_color_4ub_vertex_3fv_sun(const  gl::float_t * tc, const  gl::ubyte_t * c, const  gl::float_t * v) {
      if ( GLAD_GL_SUN_vertex ) {
        glTexCoord2fColor4ubVertex3fvSUN(tc, c, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexCoord2fColor4ubVertex3fvSUN' not available on this platform (extensions: GL_SUN_vertex)");
      }
    }

    void tex_coord_2f_normal_3f_vertex_3f_sun(gl::float_t s, gl::float_t t, gl::float_t nx, gl::float_t ny, gl::float_t nz, gl::float_t x, gl::float_t y, gl::float_t z) {
      if ( GLAD_GL_SUN_vertex ) {
        glTexCoord2fNormal3fVertex3fSUN(s, t, nx, ny, nz, x, y, z);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexCoord2fNormal3fVertex3fSUN' not available on this platform (extensions: GL_SUN_vertex)");
      }
    }

    void tex_coord_2f_normal_3f_vertex_3fv_sun(const  gl::float_t * tc, const  gl::float_t * n, const  gl::float_t * v) {
      if ( GLAD_GL_SUN_vertex ) {
        glTexCoord2fNormal3fVertex3fvSUN(tc, n, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexCoord2fNormal3fVertex3fvSUN' not available on this platform (extensions: GL_SUN_vertex)");
      }
    }

    void tex_coord_2f_vertex_3f_sun(gl::float_t s, gl::float_t t, gl::float_t x, gl::float_t y, gl::float_t z) {
      if ( GLAD_GL_SUN_vertex ) {
        glTexCoord2fVertex3fSUN(s, t, x, y, z);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexCoord2fVertex3fSUN' not available on this platform (extensions: GL_SUN_vertex)");
      }
    }

    void tex_coord_2f_vertex_3fv_sun(const  gl::float_t * tc, const  gl::float_t * v) {
      if ( GLAD_GL_SUN_vertex ) {
        glTexCoord2fVertex3fvSUN(tc, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexCoord2fVertex3fvSUN' not available on this platform (extensions: GL_SUN_vertex)");
      }
    }

    void tex_coord_2h_nv(gl::halfNV_t s, gl::halfNV_t t) {
      if ( GLAD_GL_NV_half_float ) {
        glTexCoord2hNV(s, t);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexCoord2hNV' not available on this platform (extensions: GL_NV_half_float)");
      }
    }

    void tex_coord_2hv_nv(const  gl::halfNV_t * v) {
      if ( GLAD_GL_NV_half_float ) {
        glTexCoord2hvNV(v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexCoord2hvNV' not available on this platform (extensions: GL_NV_half_float)");
      }
    }

    void tex_coord_2x_oes(gl::fixed_t s, gl::fixed_t t) {
      if ( GLAD_GL_OES_fixed_point ) {
        glTexCoord2xOES(s, t);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexCoord2xOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void tex_coord_2xv_oes(const  gl::fixed_t * coords) {
      if ( GLAD_GL_OES_fixed_point ) {
        glTexCoord2xvOES(coords);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexCoord2xvOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void tex_coord_3b_oes(gl::byte_t s, gl::byte_t t, gl::byte_t r) {
      if ( GLAD_GL_OES_byte_coordinates ) {
        glTexCoord3bOES(s, t, r);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexCoord3bOES' not available on this platform (extensions: GL_OES_byte_coordinates)");
      }
    }

    void tex_coord_3bv_oes(const  gl::byte_t * coords) {
      if ( GLAD_GL_OES_byte_coordinates ) {
        glTexCoord3bvOES(coords);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexCoord3bvOES' not available on this platform (extensions: GL_OES_byte_coordinates)");
      }
    }

    void tex_coord_3h_nv(gl::halfNV_t s, gl::halfNV_t t, gl::halfNV_t r) {
      if ( GLAD_GL_NV_half_float ) {
        glTexCoord3hNV(s, t, r);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexCoord3hNV' not available on this platform (extensions: GL_NV_half_float)");
      }
    }

    void tex_coord_3hv_nv(const  gl::halfNV_t * v) {
      if ( GLAD_GL_NV_half_float ) {
        glTexCoord3hvNV(v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexCoord3hvNV' not available on this platform (extensions: GL_NV_half_float)");
      }
    }

    void tex_coord_3x_oes(gl::fixed_t s, gl::fixed_t t, gl::fixed_t r) {
      if ( GLAD_GL_OES_fixed_point ) {
        glTexCoord3xOES(s, t, r);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexCoord3xOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void tex_coord_3xv_oes(const  gl::fixed_t * coords) {
      if ( GLAD_GL_OES_fixed_point ) {
        glTexCoord3xvOES(coords);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexCoord3xvOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void tex_coord_4b_oes(gl::byte_t s, gl::byte_t t, gl::byte_t r, gl::byte_t q) {
      if ( GLAD_GL_OES_byte_coordinates ) {
        glTexCoord4bOES(s, t, r, q);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexCoord4bOES' not available on this platform (extensions: GL_OES_byte_coordinates)");
      }
    }

    void tex_coord_4bv_oes(const  gl::byte_t * coords) {
      if ( GLAD_GL_OES_byte_coordinates ) {
        glTexCoord4bvOES(coords);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexCoord4bvOES' not available on this platform (extensions: GL_OES_byte_coordinates)");
      }
    }

    void tex_coord_4f_color_4f_normal_3f_vertex_4f_sun(gl::float_t s, gl::float_t t, gl::float_t p, gl::float_t q, gl::float_t r, gl::float_t g, gl::float_t b, gl::float_t a, gl::float_t nx, gl::float_t ny, gl::float_t nz, gl::float_t x, gl::float_t y, gl::float_t z, gl::float_t w) {
      if ( GLAD_GL_SUN_vertex ) {
        glTexCoord4fColor4fNormal3fVertex4fSUN(s, t, p, q, r, g, b, a, nx, ny, nz, x, y, z, w);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexCoord4fColor4fNormal3fVertex4fSUN' not available on this platform (extensions: GL_SUN_vertex)");
      }
    }

    void tex_coord_4f_color_4f_normal_3f_vertex_4fv_sun(const  gl::float_t * tc, const  gl::float_t * c, const  gl::float_t * n, const  gl::float_t * v) {
      if ( GLAD_GL_SUN_vertex ) {
        glTexCoord4fColor4fNormal3fVertex4fvSUN(tc, c, n, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexCoord4fColor4fNormal3fVertex4fvSUN' not available on this platform (extensions: GL_SUN_vertex)");
      }
    }

    void tex_coord_4f_vertex_4f_sun(gl::float_t s, gl::float_t t, gl::float_t p, gl::float_t q, gl::float_t x, gl::float_t y, gl::float_t z, gl::float_t w) {
      if ( GLAD_GL_SUN_vertex ) {
        glTexCoord4fVertex4fSUN(s, t, p, q, x, y, z, w);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexCoord4fVertex4fSUN' not available on this platform (extensions: GL_SUN_vertex)");
      }
    }

    void tex_coord_4f_vertex_4fv_sun(const  gl::float_t * tc, const  gl::float_t * v) {
      if ( GLAD_GL_SUN_vertex ) {
        glTexCoord4fVertex4fvSUN(tc, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexCoord4fVertex4fvSUN' not available on this platform (extensions: GL_SUN_vertex)");
      }
    }

    void tex_coord_4h_nv(gl::halfNV_t s, gl::halfNV_t t, gl::halfNV_t r, gl::halfNV_t q) {
      if ( GLAD_GL_NV_half_float ) {
        glTexCoord4hNV(s, t, r, q);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexCoord4hNV' not available on this platform (extensions: GL_NV_half_float)");
      }
    }

    void tex_coord_4hv_nv(const  gl::halfNV_t * v) {
      if ( GLAD_GL_NV_half_float ) {
        glTexCoord4hvNV(v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexCoord4hvNV' not available on this platform (extensions: GL_NV_half_float)");
      }
    }

    void tex_coord_4x_oes(gl::fixed_t s, gl::fixed_t t, gl::fixed_t r, gl::fixed_t q) {
      if ( GLAD_GL_OES_fixed_point ) {
        glTexCoord4xOES(s, t, r, q);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexCoord4xOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void tex_coord_4xv_oes(const  gl::fixed_t * coords) {
      if ( GLAD_GL_OES_fixed_point ) {
        glTexCoord4xvOES(coords);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexCoord4xvOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void tex_coord_format_nv(gl::int_t size, gl::enum_t type, gl::sizei_t stride) {
      if ( GLAD_GL_NV_vertex_buffer_unified_memory ) {
        glTexCoordFormatNV(size, type, stride);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexCoordFormatNV' not available on this platform (extensions: GL_NV_vertex_buffer_unified_memory)");
      }
    }

    void tex_coord_p1ui(gl::enum_t type, gl::uint_t coords) {
      if ( GLAD_GL_ARB_vertex_type_2_10_10_10_rev ) {
        glTexCoordP1ui(type, coords);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexCoordP1ui' not available on this platform (extensions: GL_ARB_vertex_type_2_10_10_10_rev)");
      }
    }

    void tex_coord_p1uiv(gl::enum_t type, const  gl::uint_t * coords) {
      if ( GLAD_GL_ARB_vertex_type_2_10_10_10_rev ) {
        glTexCoordP1uiv(type, coords);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexCoordP1uiv' not available on this platform (extensions: GL_ARB_vertex_type_2_10_10_10_rev)");
      }
    }

    void tex_coord_p2ui(gl::enum_t type, gl::uint_t coords) {
      if ( GLAD_GL_ARB_vertex_type_2_10_10_10_rev ) {
        glTexCoordP2ui(type, coords);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexCoordP2ui' not available on this platform (extensions: GL_ARB_vertex_type_2_10_10_10_rev)");
      }
    }

    void tex_coord_p2uiv(gl::enum_t type, const  gl::uint_t * coords) {
      if ( GLAD_GL_ARB_vertex_type_2_10_10_10_rev ) {
        glTexCoordP2uiv(type, coords);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexCoordP2uiv' not available on this platform (extensions: GL_ARB_vertex_type_2_10_10_10_rev)");
      }
    }

    void tex_coord_p3ui(gl::enum_t type, gl::uint_t coords) {
      if ( GLAD_GL_ARB_vertex_type_2_10_10_10_rev ) {
        glTexCoordP3ui(type, coords);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexCoordP3ui' not available on this platform (extensions: GL_ARB_vertex_type_2_10_10_10_rev)");
      }
    }

    void tex_coord_p3uiv(gl::enum_t type, const  gl::uint_t * coords) {
      if ( GLAD_GL_ARB_vertex_type_2_10_10_10_rev ) {
        glTexCoordP3uiv(type, coords);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexCoordP3uiv' not available on this platform (extensions: GL_ARB_vertex_type_2_10_10_10_rev)");
      }
    }

    void tex_coord_p4ui(gl::enum_t type, gl::uint_t coords) {
      if ( GLAD_GL_ARB_vertex_type_2_10_10_10_rev ) {
        glTexCoordP4ui(type, coords);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexCoordP4ui' not available on this platform (extensions: GL_ARB_vertex_type_2_10_10_10_rev)");
      }
    }

    void tex_coord_p4uiv(gl::enum_t type, const  gl::uint_t * coords) {
      if ( GLAD_GL_ARB_vertex_type_2_10_10_10_rev ) {
        glTexCoordP4uiv(type, coords);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexCoordP4uiv' not available on this platform (extensions: GL_ARB_vertex_type_2_10_10_10_rev)");
      }
    }

    void tex_coord_pointer_ext(gl::int_t size, tex_coord_pointer_type_t type, gl::sizei_t stride, gl::sizei_t count, const  void * pointer) {
      if ( GLAD_GL_EXT_vertex_array ) {
        glTexCoordPointerEXT(size, static_cast<GLenum>(type), stride, count, pointer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexCoordPointerEXT' not available on this platform (extensions: GL_EXT_vertex_array)");
      }
    }

    void tex_coord_pointer_list_ibm(gl::int_t size, tex_coord_pointer_type_t type, gl::int_t stride, const  void ** pointer, gl::int_t ptrstride) {
      if ( GLAD_GL_IBM_vertex_array_lists ) {
        glTexCoordPointerListIBM(size, static_cast<GLenum>(type), stride, pointer, ptrstride);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexCoordPointerListIBM' not available on this platform (extensions: GL_IBM_vertex_array_lists)");
      }
    }

    void tex_coord_pointerv_intel(gl::int_t size, vertex_pointer_type_t type, const  void ** pointer) {
      if ( GLAD_GL_INTEL_parallel_arrays ) {
        glTexCoordPointervINTEL(size, static_cast<GLenum>(type), pointer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexCoordPointervINTEL' not available on this platform (extensions: GL_INTEL_parallel_arrays)");
      }
    }

    void tex_envx_oes(gl::enum_t target, gl::enum_t pname, gl::fixed_t param) {
      if ( GLAD_GL_OES_fixed_point ) {
        glTexEnvxOES(target, pname, param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexEnvxOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void tex_envxv_oes(gl::enum_t target, gl::enum_t pname, const  gl::fixed_t * params) {
      if ( GLAD_GL_OES_fixed_point ) {
        glTexEnvxvOES(target, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexEnvxvOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void tex_filter_func_sgis(texture_target_t target, gl::enum_t filter, gl::sizei_t n, const  gl::float_t * weights) {
      if ( GLAD_GL_SGIS_texture_filter4 ) {
        glTexFilterFuncSGIS(static_cast<GLenum>(target), filter, n, weights);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexFilterFuncSGIS' not available on this platform (extensions: GL_SGIS_texture_filter4)");
      }
    }

    void tex_genx_oes(gl::enum_t coord, gl::enum_t pname, gl::fixed_t param) {
      if ( GLAD_GL_OES_fixed_point ) {
        glTexGenxOES(coord, pname, param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexGenxOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void tex_genxv_oes(gl::enum_t coord, gl::enum_t pname, const  gl::fixed_t * params) {
      if ( GLAD_GL_OES_fixed_point ) {
        glTexGenxvOES(coord, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexGenxvOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void tex_image_2d_multisample(gl::enum_t target, gl::sizei_t samples, gl::enum_t internalformat, gl::sizei_t width, gl::sizei_t height, gl::boolean_t fixedsamplelocations) {
      if ( GLAD_GL_ARB_texture_multisample ) {
        glTexImage2DMultisample(target, samples, internalformat, width, height, fixedsamplelocations);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexImage2DMultisample' not available on this platform (extensions: GL_ARB_texture_multisample)");
      }
    }

    void tex_image_2d_multisample_coverage_nv(gl::enum_t target, gl::sizei_t coverageSamples, gl::sizei_t colorSamples, gl::int_t internalFormat, gl::sizei_t width, gl::sizei_t height, gl::boolean_t fixedSampleLocations) {
      if ( GLAD_GL_NV_texture_multisample ) {
        glTexImage2DMultisampleCoverageNV(target, coverageSamples, colorSamples, internalFormat, width, height, fixedSampleLocations);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexImage2DMultisampleCoverageNV' not available on this platform (extensions: GL_NV_texture_multisample)");
      }
    }

    void tex_image_3dext(texture_target_t target, gl::int_t level, gl::enum_t internalformat, gl::sizei_t width, gl::sizei_t height, gl::sizei_t depth, gl::int_t border, pixel_format_t format, pixel_type_t type, const  void * pixels) {
      if ( GLAD_GL_EXT_texture3D ) {
        glTexImage3DEXT(static_cast<GLenum>(target), level, internalformat, width, height, depth, border, static_cast<GLenum>(format), static_cast<GLenum>(type), pixels);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexImage3DEXT' not available on this platform (extensions: GL_EXT_texture3D)");
      }
    }

    void tex_image_3d_multisample(gl::enum_t target, gl::sizei_t samples, gl::enum_t internalformat, gl::sizei_t width, gl::sizei_t height, gl::sizei_t depth, gl::boolean_t fixedsamplelocations) {
      if ( GLAD_GL_ARB_texture_multisample ) {
        glTexImage3DMultisample(target, samples, internalformat, width, height, depth, fixedsamplelocations);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexImage3DMultisample' not available on this platform (extensions: GL_ARB_texture_multisample)");
      }
    }

    void tex_image_3d_multisample_coverage_nv(gl::enum_t target, gl::sizei_t coverageSamples, gl::sizei_t colorSamples, gl::int_t internalFormat, gl::sizei_t width, gl::sizei_t height, gl::sizei_t depth, gl::boolean_t fixedSampleLocations) {
      if ( GLAD_GL_NV_texture_multisample ) {
        glTexImage3DMultisampleCoverageNV(target, coverageSamples, colorSamples, internalFormat, width, height, depth, fixedSampleLocations);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexImage3DMultisampleCoverageNV' not available on this platform (extensions: GL_NV_texture_multisample)");
      }
    }

    void tex_image_4dsgis(texture_target_t target, gl::int_t level, gl::enum_t internalformat, gl::sizei_t width, gl::sizei_t height, gl::sizei_t depth, gl::sizei_t size4d, gl::int_t border, pixel_format_t format, pixel_type_t type, const  void * pixels) {
      if ( GLAD_GL_SGIS_texture4D ) {
        glTexImage4DSGIS(static_cast<GLenum>(target), level, internalformat, width, height, depth, size4d, border, static_cast<GLenum>(format), static_cast<GLenum>(type), pixels);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexImage4DSGIS' not available on this platform (extensions: GL_SGIS_texture4D)");
      }
    }

    void tex_page_commitment_arb(gl::enum_t target, gl::int_t level, gl::int_t xoffset, gl::int_t yoffset, gl::int_t zoffset, gl::sizei_t width, gl::sizei_t height, gl::sizei_t depth, gl::boolean_t resident) {
      if ( GLAD_GL_ARB_sparse_texture ) {
        glTexPageCommitmentARB(target, level, xoffset, yoffset, zoffset, width, height, depth, resident);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexPageCommitmentARB' not available on this platform (extensions: GL_ARB_sparse_texture)");
      }
    }

    void tex_parameter_iiv_ext(texture_target_t target, texture_parameter_name_t pname, const  gl::int_t * params) {
      if ( GLAD_GL_EXT_texture_integer ) {
        glTexParameterIivEXT(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexParameterIivEXT' not available on this platform (extensions: GL_EXT_texture_integer)");
      }
    }

    void tex_parameter_iuiv_ext(texture_target_t target, texture_parameter_name_t pname, const  gl::uint_t * params) {
      if ( GLAD_GL_EXT_texture_integer ) {
        glTexParameterIuivEXT(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexParameterIuivEXT' not available on this platform (extensions: GL_EXT_texture_integer)");
      }
    }

    void tex_parameterx_oes(gl::enum_t target, gl::enum_t pname, gl::fixed_t param) {
      if ( GLAD_GL_OES_fixed_point ) {
        glTexParameterxOES(target, pname, param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexParameterxOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void tex_parameterxv_oes(gl::enum_t target, gl::enum_t pname, const  gl::fixed_t * params) {
      if ( GLAD_GL_OES_fixed_point ) {
        glTexParameterxvOES(target, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexParameterxvOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void tex_renderbuffer_nv(texture_target_t target, gl::uint_t renderbuffer) {
      if ( GLAD_GL_NV_explicit_multisample ) {
        glTexRenderbufferNV(static_cast<GLenum>(target), renderbuffer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexRenderbufferNV' not available on this platform (extensions: GL_NV_explicit_multisample)");
      }
    }

    void tex_storage_1d(gl::enum_t target, gl::sizei_t levels, gl::enum_t internalformat, gl::sizei_t width) {
      if ( GLAD_GL_ARB_texture_storage ) {
        glTexStorage1D(target, levels, internalformat, width);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexStorage1D' not available on this platform (extensions: GL_ARB_texture_storage)");
      }
    }

    void tex_storage_2d(gl::enum_t target, gl::sizei_t levels, gl::enum_t internalformat, gl::sizei_t width, gl::sizei_t height) {
      if ( GLAD_GL_ARB_texture_storage ) {
        glTexStorage2D(target, levels, internalformat, width, height);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexStorage2D' not available on this platform (extensions: GL_ARB_texture_storage)");
      }
    }

    void tex_storage_2d_multisample(gl::enum_t target, gl::sizei_t samples, gl::enum_t internalformat, gl::sizei_t width, gl::sizei_t height, gl::boolean_t fixedsamplelocations) {
      if ( GLAD_GL_ARB_texture_storage_multisample ) {
        glTexStorage2DMultisample(target, samples, internalformat, width, height, fixedsamplelocations);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexStorage2DMultisample' not available on this platform (extensions: GL_ARB_texture_storage_multisample)");
      }
    }

    void tex_storage_3d(gl::enum_t target, gl::sizei_t levels, gl::enum_t internalformat, gl::sizei_t width, gl::sizei_t height, gl::sizei_t depth) {
      if ( GLAD_GL_ARB_texture_storage ) {
        glTexStorage3D(target, levels, internalformat, width, height, depth);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexStorage3D' not available on this platform (extensions: GL_ARB_texture_storage)");
      }
    }

    void tex_storage_3d_multisample(gl::enum_t target, gl::sizei_t samples, gl::enum_t internalformat, gl::sizei_t width, gl::sizei_t height, gl::sizei_t depth, gl::boolean_t fixedsamplelocations) {
      if ( GLAD_GL_ARB_texture_storage_multisample ) {
        glTexStorage3DMultisample(target, samples, internalformat, width, height, depth, fixedsamplelocations);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexStorage3DMultisample' not available on this platform (extensions: GL_ARB_texture_storage_multisample)");
      }
    }

    void tex_storage_sparse_amd(gl::enum_t target, gl::enum_t internalFormat, gl::sizei_t width, gl::sizei_t height, gl::sizei_t depth, gl::sizei_t layers, gl::bitfield_t flags) {
      if ( GLAD_GL_AMD_sparse_texture ) {
        glTexStorageSparseAMD(target, internalFormat, width, height, depth, layers, flags);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexStorageSparseAMD' not available on this platform (extensions: GL_AMD_sparse_texture)");
      }
    }

    void tex_sub_image_1dext(texture_target_t target, gl::int_t level, gl::int_t xoffset, gl::sizei_t width, pixel_format_t format, pixel_type_t type, const  void * pixels) {
      if ( GLAD_GL_EXT_subtexture ) {
        glTexSubImage1DEXT(static_cast<GLenum>(target), level, xoffset, width, static_cast<GLenum>(format), static_cast<GLenum>(type), pixels);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexSubImage1DEXT' not available on this platform (extensions: GL_EXT_subtexture)");
      }
    }

    void tex_sub_image_2dext(texture_target_t target, gl::int_t level, gl::int_t xoffset, gl::int_t yoffset, gl::sizei_t width, gl::sizei_t height, pixel_format_t format, pixel_type_t type, const  void * pixels) {
      if ( GLAD_GL_EXT_subtexture ) {
        glTexSubImage2DEXT(static_cast<GLenum>(target), level, xoffset, yoffset, width, height, static_cast<GLenum>(format), static_cast<GLenum>(type), pixels);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexSubImage2DEXT' not available on this platform (extensions: GL_EXT_subtexture)");
      }
    }

    void tex_sub_image_3dext(texture_target_t target, gl::int_t level, gl::int_t xoffset, gl::int_t yoffset, gl::int_t zoffset, gl::sizei_t width, gl::sizei_t height, gl::sizei_t depth, pixel_format_t format, pixel_type_t type, const  void * pixels) {
      if ( GLAD_GL_EXT_texture3D ) {
        glTexSubImage3DEXT(static_cast<GLenum>(target), level, xoffset, yoffset, zoffset, width, height, depth, static_cast<GLenum>(format), static_cast<GLenum>(type), pixels);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexSubImage3DEXT' not available on this platform (extensions: GL_EXT_texture3D)");
      }
    }

    void tex_sub_image_4dsgis(texture_target_t target, gl::int_t level, gl::int_t xoffset, gl::int_t yoffset, gl::int_t zoffset, gl::int_t woffset, gl::sizei_t width, gl::sizei_t height, gl::sizei_t depth, gl::sizei_t size4d, pixel_format_t format, pixel_type_t type, const  void * pixels) {
      if ( GLAD_GL_SGIS_texture4D ) {
        glTexSubImage4DSGIS(static_cast<GLenum>(target), level, xoffset, yoffset, zoffset, woffset, width, height, depth, size4d, static_cast<GLenum>(format), static_cast<GLenum>(type), pixels);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexSubImage4DSGIS' not available on this platform (extensions: GL_SGIS_texture4D)");
      }
    }

    void texture_barrier() {
      if ( GLAD_GL_ARB_texture_barrier ) {
        glTextureBarrier();
      }
      else {
        throw std::runtime_error("OpenGL command 'glTextureBarrier' not available on this platform (extensions: GL_ARB_texture_barrier)");
      }
    }

    void texture_barrier_nv() {
      if ( GLAD_GL_NV_texture_barrier ) {
        glTextureBarrierNV();
      }
      else {
        throw std::runtime_error("OpenGL command 'glTextureBarrierNV' not available on this platform (extensions: GL_NV_texture_barrier)");
      }
    }

    void texture_buffer(gl::uint_t texture, gl::enum_t internalformat, gl::uint_t buffer) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glTextureBuffer(texture, internalformat, buffer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTextureBuffer' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void texture_buffer_ext(gl::uint_t texture, texture_target_t target, gl::enum_t internalformat, gl::uint_t buffer) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glTextureBufferEXT(texture, static_cast<GLenum>(target), internalformat, buffer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTextureBufferEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void texture_buffer_range(gl::uint_t texture, gl::enum_t internalformat, gl::uint_t buffer, gl::intptr_t offset, gl::sizeiptr_t size) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glTextureBufferRange(texture, internalformat, buffer, offset, size);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTextureBufferRange' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void texture_buffer_range_ext(gl::uint_t texture, texture_target_t target, gl::enum_t internalformat, gl::uint_t buffer, gl::intptr_t offset, gl::sizeiptr_t size) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glTextureBufferRangeEXT(texture, static_cast<GLenum>(target), internalformat, buffer, offset, size);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTextureBufferRangeEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void texture_color_mask_sgis(gl::boolean_t red, gl::boolean_t green, gl::boolean_t blue, gl::boolean_t alpha) {
      if ( GLAD_GL_SGIS_texture_color_mask ) {
        glTextureColorMaskSGIS(red, green, blue, alpha);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTextureColorMaskSGIS' not available on this platform (extensions: GL_SGIS_texture_color_mask)");
      }
    }

    void texture_image_1dext(gl::uint_t texture, texture_target_t target, gl::int_t level, texture_component_count_t internalformat, gl::sizei_t width, gl::int_t border, pixel_format_t format, pixel_type_t type, const  void * pixels) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glTextureImage1DEXT(texture, static_cast<GLenum>(target), level, static_cast<GLint>(internalformat), width, border, static_cast<GLenum>(format), static_cast<GLenum>(type), pixels);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTextureImage1DEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void texture_image_2dext(gl::uint_t texture, texture_target_t target, gl::int_t level, texture_component_count_t internalformat, gl::sizei_t width, gl::sizei_t height, gl::int_t border, pixel_format_t format, pixel_type_t type, const  void * pixels) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glTextureImage2DEXT(texture, static_cast<GLenum>(target), level, static_cast<GLint>(internalformat), width, height, border, static_cast<GLenum>(format), static_cast<GLenum>(type), pixels);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTextureImage2DEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void texture_image_2d_multisample_coverage_nv(gl::uint_t texture, gl::enum_t target, gl::sizei_t coverageSamples, gl::sizei_t colorSamples, gl::int_t internalFormat, gl::sizei_t width, gl::sizei_t height, gl::boolean_t fixedSampleLocations) {
      if ( GLAD_GL_NV_texture_multisample ) {
        glTextureImage2DMultisampleCoverageNV(texture, target, coverageSamples, colorSamples, internalFormat, width, height, fixedSampleLocations);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTextureImage2DMultisampleCoverageNV' not available on this platform (extensions: GL_NV_texture_multisample)");
      }
    }

    void texture_image_2d_multisample_nv(gl::uint_t texture, gl::enum_t target, gl::sizei_t samples, gl::int_t internalFormat, gl::sizei_t width, gl::sizei_t height, gl::boolean_t fixedSampleLocations) {
      if ( GLAD_GL_NV_texture_multisample ) {
        glTextureImage2DMultisampleNV(texture, target, samples, internalFormat, width, height, fixedSampleLocations);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTextureImage2DMultisampleNV' not available on this platform (extensions: GL_NV_texture_multisample)");
      }
    }

    void texture_image_3dext(gl::uint_t texture, texture_target_t target, gl::int_t level, texture_component_count_t internalformat, gl::sizei_t width, gl::sizei_t height, gl::sizei_t depth, gl::int_t border, pixel_format_t format, pixel_type_t type, const  void * pixels) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glTextureImage3DEXT(texture, static_cast<GLenum>(target), level, static_cast<GLint>(internalformat), width, height, depth, border, static_cast<GLenum>(format), static_cast<GLenum>(type), pixels);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTextureImage3DEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void texture_image_3d_multisample_coverage_nv(gl::uint_t texture, gl::enum_t target, gl::sizei_t coverageSamples, gl::sizei_t colorSamples, gl::int_t internalFormat, gl::sizei_t width, gl::sizei_t height, gl::sizei_t depth, gl::boolean_t fixedSampleLocations) {
      if ( GLAD_GL_NV_texture_multisample ) {
        glTextureImage3DMultisampleCoverageNV(texture, target, coverageSamples, colorSamples, internalFormat, width, height, depth, fixedSampleLocations);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTextureImage3DMultisampleCoverageNV' not available on this platform (extensions: GL_NV_texture_multisample)");
      }
    }

    void texture_image_3d_multisample_nv(gl::uint_t texture, gl::enum_t target, gl::sizei_t samples, gl::int_t internalFormat, gl::sizei_t width, gl::sizei_t height, gl::sizei_t depth, gl::boolean_t fixedSampleLocations) {
      if ( GLAD_GL_NV_texture_multisample ) {
        glTextureImage3DMultisampleNV(texture, target, samples, internalFormat, width, height, depth, fixedSampleLocations);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTextureImage3DMultisampleNV' not available on this platform (extensions: GL_NV_texture_multisample)");
      }
    }

    void texture_light_ext(gl::enum_t pname) {
      if ( GLAD_GL_EXT_light_texture ) {
        glTextureLightEXT(pname);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTextureLightEXT' not available on this platform (extensions: GL_EXT_light_texture)");
      }
    }

    void texture_material_ext(material_face_t face, material_parameter_t mode) {
      if ( GLAD_GL_EXT_light_texture ) {
        glTextureMaterialEXT(static_cast<GLenum>(face), static_cast<GLenum>(mode));
      }
      else {
        throw std::runtime_error("OpenGL command 'glTextureMaterialEXT' not available on this platform (extensions: GL_EXT_light_texture)");
      }
    }

    void texture_normal_ext(gl::enum_t mode) {
      if ( GLAD_GL_EXT_texture_perturb_normal ) {
        glTextureNormalEXT(mode);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTextureNormalEXT' not available on this platform (extensions: GL_EXT_texture_perturb_normal)");
      }
    }

    void texture_page_commitment_ext(gl::uint_t texture, gl::int_t level, gl::int_t xoffset, gl::int_t yoffset, gl::int_t zoffset, gl::sizei_t width, gl::sizei_t height, gl::sizei_t depth, gl::boolean_t resident) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glTexturePageCommitmentEXT(texture, level, xoffset, yoffset, zoffset, width, height, depth, resident);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexturePageCommitmentEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void texture_parameter_iiv(gl::uint_t texture, gl::enum_t pname, const  gl::int_t * params) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glTextureParameterIiv(texture, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTextureParameterIiv' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void texture_parameter_iiv_ext(gl::uint_t texture, texture_target_t target, texture_parameter_name_t pname, const  gl::int_t * params) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glTextureParameterIivEXT(texture, static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTextureParameterIivEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void texture_parameter_iuiv(gl::uint_t texture, gl::enum_t pname, const  gl::uint_t * params) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glTextureParameterIuiv(texture, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTextureParameterIuiv' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void texture_parameter_iuiv_ext(gl::uint_t texture, texture_target_t target, texture_parameter_name_t pname, const  gl::uint_t * params) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glTextureParameterIuivEXT(texture, static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTextureParameterIuivEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void texture_parameterf(gl::uint_t texture, gl::enum_t pname, gl::float_t param) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glTextureParameterf(texture, pname, param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTextureParameterf' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void texture_parameterf_ext(gl::uint_t texture, texture_target_t target, texture_parameter_name_t pname, gl::float_t param) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glTextureParameterfEXT(texture, static_cast<GLenum>(target), static_cast<GLenum>(pname), param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTextureParameterfEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void texture_parameterfv(gl::uint_t texture, gl::enum_t pname, const  gl::float_t * param) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glTextureParameterfv(texture, pname, param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTextureParameterfv' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void texture_parameterfv_ext(gl::uint_t texture, texture_target_t target, texture_parameter_name_t pname, const  gl::float_t * params) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glTextureParameterfvEXT(texture, static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTextureParameterfvEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void texture_parameteri(gl::uint_t texture, gl::enum_t pname, gl::int_t param) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glTextureParameteri(texture, pname, param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTextureParameteri' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void texture_parameteri_ext(gl::uint_t texture, texture_target_t target, texture_parameter_name_t pname, gl::int_t param) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glTextureParameteriEXT(texture, static_cast<GLenum>(target), static_cast<GLenum>(pname), param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTextureParameteriEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void texture_parameteriv(gl::uint_t texture, gl::enum_t pname, const  gl::int_t * param) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glTextureParameteriv(texture, pname, param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTextureParameteriv' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void texture_parameteriv_ext(gl::uint_t texture, texture_target_t target, texture_parameter_name_t pname, const  gl::int_t * params) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glTextureParameterivEXT(texture, static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTextureParameterivEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void texture_range_apple(gl::enum_t target, gl::sizei_t length, const  void * pointer) {
      if ( GLAD_GL_APPLE_texture_range ) {
        glTextureRangeAPPLE(target, length, pointer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTextureRangeAPPLE' not available on this platform (extensions: GL_APPLE_texture_range)");
      }
    }

    void texture_renderbuffer_ext(gl::uint_t texture, texture_target_t target, gl::uint_t renderbuffer) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glTextureRenderbufferEXT(texture, static_cast<GLenum>(target), renderbuffer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTextureRenderbufferEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void texture_storage_1d(gl::uint_t texture, gl::sizei_t levels, gl::enum_t internalformat, gl::sizei_t width) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glTextureStorage1D(texture, levels, internalformat, width);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTextureStorage1D' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void texture_storage_1dext(gl::uint_t texture, gl::enum_t target, gl::sizei_t levels, gl::enum_t internalformat, gl::sizei_t width) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glTextureStorage1DEXT(texture, target, levels, internalformat, width);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTextureStorage1DEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void texture_storage_2d(gl::uint_t texture, gl::sizei_t levels, gl::enum_t internalformat, gl::sizei_t width, gl::sizei_t height) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glTextureStorage2D(texture, levels, internalformat, width, height);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTextureStorage2D' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void texture_storage_2dext(gl::uint_t texture, gl::enum_t target, gl::sizei_t levels, gl::enum_t internalformat, gl::sizei_t width, gl::sizei_t height) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glTextureStorage2DEXT(texture, target, levels, internalformat, width, height);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTextureStorage2DEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void texture_storage_2d_multisample(gl::uint_t texture, gl::sizei_t samples, gl::enum_t internalformat, gl::sizei_t width, gl::sizei_t height, gl::boolean_t fixedsamplelocations) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glTextureStorage2DMultisample(texture, samples, internalformat, width, height, fixedsamplelocations);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTextureStorage2DMultisample' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void texture_storage_2d_multisample_ext(gl::uint_t texture, texture_target_t target, gl::sizei_t samples, gl::enum_t internalformat, gl::sizei_t width, gl::sizei_t height, gl::boolean_t fixedsamplelocations) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glTextureStorage2DMultisampleEXT(texture, static_cast<GLenum>(target), samples, internalformat, width, height, fixedsamplelocations);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTextureStorage2DMultisampleEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void texture_storage_3d(gl::uint_t texture, gl::sizei_t levels, gl::enum_t internalformat, gl::sizei_t width, gl::sizei_t height, gl::sizei_t depth) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glTextureStorage3D(texture, levels, internalformat, width, height, depth);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTextureStorage3D' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void texture_storage_3dext(gl::uint_t texture, gl::enum_t target, gl::sizei_t levels, gl::enum_t internalformat, gl::sizei_t width, gl::sizei_t height, gl::sizei_t depth) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glTextureStorage3DEXT(texture, target, levels, internalformat, width, height, depth);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTextureStorage3DEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void texture_storage_3d_multisample(gl::uint_t texture, gl::sizei_t samples, gl::enum_t internalformat, gl::sizei_t width, gl::sizei_t height, gl::sizei_t depth, gl::boolean_t fixedsamplelocations) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glTextureStorage3DMultisample(texture, samples, internalformat, width, height, depth, fixedsamplelocations);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTextureStorage3DMultisample' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void texture_storage_3d_multisample_ext(gl::uint_t texture, gl::enum_t target, gl::sizei_t samples, gl::enum_t internalformat, gl::sizei_t width, gl::sizei_t height, gl::sizei_t depth, gl::boolean_t fixedsamplelocations) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glTextureStorage3DMultisampleEXT(texture, target, samples, internalformat, width, height, depth, fixedsamplelocations);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTextureStorage3DMultisampleEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void texture_storage_sparse_amd(gl::uint_t texture, gl::enum_t target, gl::enum_t internalFormat, gl::sizei_t width, gl::sizei_t height, gl::sizei_t depth, gl::sizei_t layers, gl::bitfield_t flags) {
      if ( GLAD_GL_AMD_sparse_texture ) {
        glTextureStorageSparseAMD(texture, target, internalFormat, width, height, depth, layers, flags);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTextureStorageSparseAMD' not available on this platform (extensions: GL_AMD_sparse_texture)");
      }
    }

    void texture_sub_image_1d(gl::uint_t texture, gl::int_t level, gl::int_t xoffset, gl::sizei_t width, gl::enum_t format, gl::enum_t type, const  void * pixels) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glTextureSubImage1D(texture, level, xoffset, width, format, type, pixels);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTextureSubImage1D' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void texture_sub_image_1dext(gl::uint_t texture, texture_target_t target, gl::int_t level, gl::int_t xoffset, gl::sizei_t width, pixel_format_t format, pixel_type_t type, const  void * pixels) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glTextureSubImage1DEXT(texture, static_cast<GLenum>(target), level, xoffset, width, static_cast<GLenum>(format), static_cast<GLenum>(type), pixels);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTextureSubImage1DEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void texture_sub_image_2d(gl::uint_t texture, gl::int_t level, gl::int_t xoffset, gl::int_t yoffset, gl::sizei_t width, gl::sizei_t height, gl::enum_t format, gl::enum_t type, const  void * pixels) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glTextureSubImage2D(texture, level, xoffset, yoffset, width, height, format, type, pixels);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTextureSubImage2D' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void texture_sub_image_2dext(gl::uint_t texture, texture_target_t target, gl::int_t level, gl::int_t xoffset, gl::int_t yoffset, gl::sizei_t width, gl::sizei_t height, pixel_format_t format, pixel_type_t type, const  void * pixels) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glTextureSubImage2DEXT(texture, static_cast<GLenum>(target), level, xoffset, yoffset, width, height, static_cast<GLenum>(format), static_cast<GLenum>(type), pixels);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTextureSubImage2DEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void texture_sub_image_3d(gl::uint_t texture, gl::int_t level, gl::int_t xoffset, gl::int_t yoffset, gl::int_t zoffset, gl::sizei_t width, gl::sizei_t height, gl::sizei_t depth, gl::enum_t format, gl::enum_t type, const  void * pixels) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glTextureSubImage3D(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTextureSubImage3D' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void texture_sub_image_3dext(gl::uint_t texture, texture_target_t target, gl::int_t level, gl::int_t xoffset, gl::int_t yoffset, gl::int_t zoffset, gl::sizei_t width, gl::sizei_t height, gl::sizei_t depth, pixel_format_t format, pixel_type_t type, const  void * pixels) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glTextureSubImage3DEXT(texture, static_cast<GLenum>(target), level, xoffset, yoffset, zoffset, width, height, depth, static_cast<GLenum>(format), static_cast<GLenum>(type), pixels);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTextureSubImage3DEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void texture_view(gl::uint_t texture, gl::enum_t target, gl::uint_t origtexture, gl::enum_t internalformat, gl::uint_t minlevel, gl::uint_t numlevels, gl::uint_t minlayer, gl::uint_t numlayers) {
      if ( GLAD_GL_ARB_texture_view ) {
        glTextureView(texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTextureView' not available on this platform (extensions: GL_ARB_texture_view)");
      }
    }

    void track_matrix_nv(gl::enum_t target, gl::uint_t address, gl::enum_t matrix, gl::enum_t transform) {
      if ( GLAD_GL_NV_vertex_program ) {
        glTrackMatrixNV(target, address, matrix, transform);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTrackMatrixNV' not available on this platform (extensions: GL_NV_vertex_program)");
      }
    }

    void transform_feedback_attribs_nv(gl::sizei_t count, const  gl::int_t * attribs, gl::enum_t bufferMode) {
      if ( GLAD_GL_NV_transform_feedback ) {
        glTransformFeedbackAttribsNV(count, attribs, bufferMode);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTransformFeedbackAttribsNV' not available on this platform (extensions: GL_NV_transform_feedback)");
      }
    }

    void transform_feedback_buffer_base(gl::uint_t xfb, gl::uint_t index, gl::uint_t buffer) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glTransformFeedbackBufferBase(xfb, index, buffer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTransformFeedbackBufferBase' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void transform_feedback_buffer_range(gl::uint_t xfb, gl::uint_t index, gl::uint_t buffer, gl::intptr_t offset, gl::sizeiptr_t size) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glTransformFeedbackBufferRange(xfb, index, buffer, offset, size);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTransformFeedbackBufferRange' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void transform_feedback_stream_attribs_nv(gl::sizei_t count, const  gl::int_t * attribs, gl::sizei_t nbuffers, const  gl::int_t * bufstreams, gl::enum_t bufferMode) {
      if ( GLAD_GL_NV_transform_feedback ) {
        glTransformFeedbackStreamAttribsNV(count, attribs, nbuffers, bufstreams, bufferMode);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTransformFeedbackStreamAttribsNV' not available on this platform (extensions: GL_NV_transform_feedback)");
      }
    }

    void transform_feedback_varyings_ext(gl::uint_t program, gl::sizei_t count, const  gl::char_t ** varyings, gl::enum_t bufferMode) {
      if ( GLAD_GL_EXT_transform_feedback ) {
        glTransformFeedbackVaryingsEXT(program, count, varyings, bufferMode);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTransformFeedbackVaryingsEXT' not available on this platform (extensions: GL_EXT_transform_feedback)");
      }
    }

    void transform_feedback_varyings_nv(gl::uint_t program, gl::sizei_t count, const  gl::int_t * locations, gl::enum_t bufferMode) {
      if ( GLAD_GL_NV_transform_feedback ) {
        glTransformFeedbackVaryingsNV(program, count, locations, bufferMode);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTransformFeedbackVaryingsNV' not available on this platform (extensions: GL_NV_transform_feedback)");
      }
    }

    void transform_path_nv(gl::uint_t resultPath, gl::uint_t srcPath, gl::enum_t transformType, const  gl::float_t * transformValues) {
      if ( GLAD_GL_NV_path_rendering ) {
        glTransformPathNV(resultPath, srcPath, transformType, transformValues);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTransformPathNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void translatex_oes(gl::fixed_t x, gl::fixed_t y, gl::fixed_t z) {
      if ( GLAD_GL_OES_fixed_point ) {
        glTranslatexOES(x, y, z);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTranslatexOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void uniform_1d(gl::int_t location, gl::double_t x) {
      if ( GLAD_GL_ARB_gpu_shader_fp64 ) {
        glUniform1d(location, x);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform1d' not available on this platform (extensions: GL_ARB_gpu_shader_fp64)");
      }
    }

    void uniform_1dv(gl::int_t location, gl::sizei_t count, const  gl::double_t * value) {
      if ( GLAD_GL_ARB_gpu_shader_fp64 ) {
        glUniform1dv(location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform1dv' not available on this platform (extensions: GL_ARB_gpu_shader_fp64)");
      }
    }

    void uniform_1f_arb(gl::int_t location, gl::float_t v0) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glUniform1fARB(location, v0);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform1fARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void uniform_1fv_arb(gl::int_t location, gl::sizei_t count, const  gl::float_t * value) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glUniform1fvARB(location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform1fvARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void uniform_1i_64nv(gl::int_t location, gl::int64EXT_t x) {
      if ( GLAD_GL_AMD_gpu_shader_int64 || GLAD_GL_NV_gpu_shader5 ) {
        glUniform1i64NV(location, x);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform1i64NV' not available on this platform (extensions: GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5)");
      }
    }

    void uniform_1i_64v_nv(gl::int_t location, gl::sizei_t count, const  gl::int64EXT_t * value) {
      if ( GLAD_GL_AMD_gpu_shader_int64 || GLAD_GL_NV_gpu_shader5 ) {
        glUniform1i64vNV(location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform1i64vNV' not available on this platform (extensions: GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5)");
      }
    }

    void uniform_1i_arb(gl::int_t location, gl::int_t v0) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glUniform1iARB(location, v0);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform1iARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void uniform_1iv_arb(gl::int_t location, gl::sizei_t count, const  gl::int_t * value) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glUniform1ivARB(location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform1ivARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void uniform_1ui_64nv(gl::int_t location, gl::uint64EXT_t x) {
      if ( GLAD_GL_AMD_gpu_shader_int64 || GLAD_GL_NV_gpu_shader5 ) {
        glUniform1ui64NV(location, x);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform1ui64NV' not available on this platform (extensions: GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5)");
      }
    }

    void uniform_1ui_64v_nv(gl::int_t location, gl::sizei_t count, const  gl::uint64EXT_t * value) {
      if ( GLAD_GL_AMD_gpu_shader_int64 || GLAD_GL_NV_gpu_shader5 ) {
        glUniform1ui64vNV(location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform1ui64vNV' not available on this platform (extensions: GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5)");
      }
    }

    void uniform_1ui_ext(gl::int_t location, gl::uint_t v0) {
      if ( GLAD_GL_EXT_gpu_shader4 ) {
        glUniform1uiEXT(location, v0);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform1uiEXT' not available on this platform (extensions: GL_EXT_gpu_shader4)");
      }
    }

    void uniform_1uiv_ext(gl::int_t location, gl::sizei_t count, const  gl::uint_t * value) {
      if ( GLAD_GL_EXT_gpu_shader4 ) {
        glUniform1uivEXT(location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform1uivEXT' not available on this platform (extensions: GL_EXT_gpu_shader4)");
      }
    }

    void uniform_2d(gl::int_t location, gl::double_t x, gl::double_t y) {
      if ( GLAD_GL_ARB_gpu_shader_fp64 ) {
        glUniform2d(location, x, y);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform2d' not available on this platform (extensions: GL_ARB_gpu_shader_fp64)");
      }
    }

    void uniform_2dv(gl::int_t location, gl::sizei_t count, const  gl::double_t * value) {
      if ( GLAD_GL_ARB_gpu_shader_fp64 ) {
        glUniform2dv(location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform2dv' not available on this platform (extensions: GL_ARB_gpu_shader_fp64)");
      }
    }

    void uniform_2f_arb(gl::int_t location, gl::float_t v0, gl::float_t v1) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glUniform2fARB(location, v0, v1);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform2fARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void uniform_2fv_arb(gl::int_t location, gl::sizei_t count, const  gl::float_t * value) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glUniform2fvARB(location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform2fvARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void uniform_2i_64nv(gl::int_t location, gl::int64EXT_t x, gl::int64EXT_t y) {
      if ( GLAD_GL_AMD_gpu_shader_int64 || GLAD_GL_NV_gpu_shader5 ) {
        glUniform2i64NV(location, x, y);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform2i64NV' not available on this platform (extensions: GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5)");
      }
    }

    void uniform_2i_64v_nv(gl::int_t location, gl::sizei_t count, const  gl::int64EXT_t * value) {
      if ( GLAD_GL_AMD_gpu_shader_int64 || GLAD_GL_NV_gpu_shader5 ) {
        glUniform2i64vNV(location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform2i64vNV' not available on this platform (extensions: GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5)");
      }
    }

    void uniform_2i_arb(gl::int_t location, gl::int_t v0, gl::int_t v1) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glUniform2iARB(location, v0, v1);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform2iARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void uniform_2iv_arb(gl::int_t location, gl::sizei_t count, const  gl::int_t * value) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glUniform2ivARB(location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform2ivARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void uniform_2ui_64nv(gl::int_t location, gl::uint64EXT_t x, gl::uint64EXT_t y) {
      if ( GLAD_GL_AMD_gpu_shader_int64 || GLAD_GL_NV_gpu_shader5 ) {
        glUniform2ui64NV(location, x, y);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform2ui64NV' not available on this platform (extensions: GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5)");
      }
    }

    void uniform_2ui_64v_nv(gl::int_t location, gl::sizei_t count, const  gl::uint64EXT_t * value) {
      if ( GLAD_GL_AMD_gpu_shader_int64 || GLAD_GL_NV_gpu_shader5 ) {
        glUniform2ui64vNV(location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform2ui64vNV' not available on this platform (extensions: GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5)");
      }
    }

    void uniform_2ui_ext(gl::int_t location, gl::uint_t v0, gl::uint_t v1) {
      if ( GLAD_GL_EXT_gpu_shader4 ) {
        glUniform2uiEXT(location, v0, v1);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform2uiEXT' not available on this platform (extensions: GL_EXT_gpu_shader4)");
      }
    }

    void uniform_2uiv_ext(gl::int_t location, gl::sizei_t count, const  gl::uint_t * value) {
      if ( GLAD_GL_EXT_gpu_shader4 ) {
        glUniform2uivEXT(location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform2uivEXT' not available on this platform (extensions: GL_EXT_gpu_shader4)");
      }
    }

    void uniform_3d(gl::int_t location, gl::double_t x, gl::double_t y, gl::double_t z) {
      if ( GLAD_GL_ARB_gpu_shader_fp64 ) {
        glUniform3d(location, x, y, z);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform3d' not available on this platform (extensions: GL_ARB_gpu_shader_fp64)");
      }
    }

    void uniform_3dv(gl::int_t location, gl::sizei_t count, const  gl::double_t * value) {
      if ( GLAD_GL_ARB_gpu_shader_fp64 ) {
        glUniform3dv(location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform3dv' not available on this platform (extensions: GL_ARB_gpu_shader_fp64)");
      }
    }

    void uniform_3f_arb(gl::int_t location, gl::float_t v0, gl::float_t v1, gl::float_t v2) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glUniform3fARB(location, v0, v1, v2);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform3fARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void uniform_3fv_arb(gl::int_t location, gl::sizei_t count, const  gl::float_t * value) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glUniform3fvARB(location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform3fvARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void uniform_3i_64nv(gl::int_t location, gl::int64EXT_t x, gl::int64EXT_t y, gl::int64EXT_t z) {
      if ( GLAD_GL_AMD_gpu_shader_int64 || GLAD_GL_NV_gpu_shader5 ) {
        glUniform3i64NV(location, x, y, z);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform3i64NV' not available on this platform (extensions: GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5)");
      }
    }

    void uniform_3i_64v_nv(gl::int_t location, gl::sizei_t count, const  gl::int64EXT_t * value) {
      if ( GLAD_GL_AMD_gpu_shader_int64 || GLAD_GL_NV_gpu_shader5 ) {
        glUniform3i64vNV(location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform3i64vNV' not available on this platform (extensions: GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5)");
      }
    }

    void uniform_3i_arb(gl::int_t location, gl::int_t v0, gl::int_t v1, gl::int_t v2) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glUniform3iARB(location, v0, v1, v2);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform3iARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void uniform_3iv_arb(gl::int_t location, gl::sizei_t count, const  gl::int_t * value) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glUniform3ivARB(location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform3ivARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void uniform_3ui_64nv(gl::int_t location, gl::uint64EXT_t x, gl::uint64EXT_t y, gl::uint64EXT_t z) {
      if ( GLAD_GL_AMD_gpu_shader_int64 || GLAD_GL_NV_gpu_shader5 ) {
        glUniform3ui64NV(location, x, y, z);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform3ui64NV' not available on this platform (extensions: GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5)");
      }
    }

    void uniform_3ui_64v_nv(gl::int_t location, gl::sizei_t count, const  gl::uint64EXT_t * value) {
      if ( GLAD_GL_AMD_gpu_shader_int64 || GLAD_GL_NV_gpu_shader5 ) {
        glUniform3ui64vNV(location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform3ui64vNV' not available on this platform (extensions: GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5)");
      }
    }

    void uniform_3ui_ext(gl::int_t location, gl::uint_t v0, gl::uint_t v1, gl::uint_t v2) {
      if ( GLAD_GL_EXT_gpu_shader4 ) {
        glUniform3uiEXT(location, v0, v1, v2);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform3uiEXT' not available on this platform (extensions: GL_EXT_gpu_shader4)");
      }
    }

    void uniform_3uiv_ext(gl::int_t location, gl::sizei_t count, const  gl::uint_t * value) {
      if ( GLAD_GL_EXT_gpu_shader4 ) {
        glUniform3uivEXT(location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform3uivEXT' not available on this platform (extensions: GL_EXT_gpu_shader4)");
      }
    }

    void uniform_4d(gl::int_t location, gl::double_t x, gl::double_t y, gl::double_t z, gl::double_t w) {
      if ( GLAD_GL_ARB_gpu_shader_fp64 ) {
        glUniform4d(location, x, y, z, w);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform4d' not available on this platform (extensions: GL_ARB_gpu_shader_fp64)");
      }
    }

    void uniform_4dv(gl::int_t location, gl::sizei_t count, const  gl::double_t * value) {
      if ( GLAD_GL_ARB_gpu_shader_fp64 ) {
        glUniform4dv(location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform4dv' not available on this platform (extensions: GL_ARB_gpu_shader_fp64)");
      }
    }

    void uniform_4f_arb(gl::int_t location, gl::float_t v0, gl::float_t v1, gl::float_t v2, gl::float_t v3) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glUniform4fARB(location, v0, v1, v2, v3);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform4fARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void uniform_4fv_arb(gl::int_t location, gl::sizei_t count, const  gl::float_t * value) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glUniform4fvARB(location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform4fvARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void uniform_4i_64nv(gl::int_t location, gl::int64EXT_t x, gl::int64EXT_t y, gl::int64EXT_t z, gl::int64EXT_t w) {
      if ( GLAD_GL_AMD_gpu_shader_int64 || GLAD_GL_NV_gpu_shader5 ) {
        glUniform4i64NV(location, x, y, z, w);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform4i64NV' not available on this platform (extensions: GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5)");
      }
    }

    void uniform_4i_64v_nv(gl::int_t location, gl::sizei_t count, const  gl::int64EXT_t * value) {
      if ( GLAD_GL_AMD_gpu_shader_int64 || GLAD_GL_NV_gpu_shader5 ) {
        glUniform4i64vNV(location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform4i64vNV' not available on this platform (extensions: GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5)");
      }
    }

    void uniform_4i_arb(gl::int_t location, gl::int_t v0, gl::int_t v1, gl::int_t v2, gl::int_t v3) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glUniform4iARB(location, v0, v1, v2, v3);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform4iARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void uniform_4iv_arb(gl::int_t location, gl::sizei_t count, const  gl::int_t * value) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glUniform4ivARB(location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform4ivARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void uniform_4ui_64nv(gl::int_t location, gl::uint64EXT_t x, gl::uint64EXT_t y, gl::uint64EXT_t z, gl::uint64EXT_t w) {
      if ( GLAD_GL_AMD_gpu_shader_int64 || GLAD_GL_NV_gpu_shader5 ) {
        glUniform4ui64NV(location, x, y, z, w);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform4ui64NV' not available on this platform (extensions: GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5)");
      }
    }

    void uniform_4ui_64v_nv(gl::int_t location, gl::sizei_t count, const  gl::uint64EXT_t * value) {
      if ( GLAD_GL_AMD_gpu_shader_int64 || GLAD_GL_NV_gpu_shader5 ) {
        glUniform4ui64vNV(location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform4ui64vNV' not available on this platform (extensions: GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5)");
      }
    }

    void uniform_4ui_ext(gl::int_t location, gl::uint_t v0, gl::uint_t v1, gl::uint_t v2, gl::uint_t v3) {
      if ( GLAD_GL_EXT_gpu_shader4 ) {
        glUniform4uiEXT(location, v0, v1, v2, v3);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform4uiEXT' not available on this platform (extensions: GL_EXT_gpu_shader4)");
      }
    }

    void uniform_4uiv_ext(gl::int_t location, gl::sizei_t count, const  gl::uint_t * value) {
      if ( GLAD_GL_EXT_gpu_shader4 ) {
        glUniform4uivEXT(location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform4uivEXT' not available on this platform (extensions: GL_EXT_gpu_shader4)");
      }
    }

    void uniform_block_binding(gl::uint_t program, gl::uint_t uniformBlockIndex, gl::uint_t uniformBlockBinding) {
      if ( GLAD_GL_ARB_uniform_buffer_object ) {
        glUniformBlockBinding(program, uniformBlockIndex, uniformBlockBinding);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniformBlockBinding' not available on this platform (extensions: GL_ARB_uniform_buffer_object)");
      }
    }

    void uniform_buffer_ext(gl::uint_t program, gl::int_t location, gl::uint_t buffer) {
      if ( GLAD_GL_EXT_bindable_uniform ) {
        glUniformBufferEXT(program, location, buffer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniformBufferEXT' not available on this platform (extensions: GL_EXT_bindable_uniform)");
      }
    }

    void uniform_handleui_64arb(gl::int_t location, gl::uint64_t value) {
      if ( GLAD_GL_ARB_bindless_texture ) {
        glUniformHandleui64ARB(location, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniformHandleui64ARB' not available on this platform (extensions: GL_ARB_bindless_texture)");
      }
    }

    void uniform_handleui_64nv(gl::int_t location, gl::uint64_t value) {
      if ( GLAD_GL_NV_bindless_texture ) {
        glUniformHandleui64NV(location, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniformHandleui64NV' not available on this platform (extensions: GL_NV_bindless_texture)");
      }
    }

    void uniform_handleui_64v_arb(gl::int_t location, gl::sizei_t count, const  gl::uint64_t * value) {
      if ( GLAD_GL_ARB_bindless_texture ) {
        glUniformHandleui64vARB(location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniformHandleui64vARB' not available on this platform (extensions: GL_ARB_bindless_texture)");
      }
    }

    void uniform_handleui_64v_nv(gl::int_t location, gl::sizei_t count, const  gl::uint64_t * value) {
      if ( GLAD_GL_NV_bindless_texture ) {
        glUniformHandleui64vNV(location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniformHandleui64vNV' not available on this platform (extensions: GL_NV_bindless_texture)");
      }
    }

    void uniform_matrix_2dv(gl::int_t location, gl::sizei_t count, gl::boolean_t transpose, const  gl::double_t * value) {
      if ( GLAD_GL_ARB_gpu_shader_fp64 ) {
        glUniformMatrix2dv(location, count, transpose, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniformMatrix2dv' not available on this platform (extensions: GL_ARB_gpu_shader_fp64)");
      }
    }

    void uniform_matrix_2fv_arb(gl::int_t location, gl::sizei_t count, gl::boolean_t transpose, const  gl::float_t * value) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glUniformMatrix2fvARB(location, count, transpose, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniformMatrix2fvARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void uniform_matrix_2x_3dv(gl::int_t location, gl::sizei_t count, gl::boolean_t transpose, const  gl::double_t * value) {
      if ( GLAD_GL_ARB_gpu_shader_fp64 ) {
        glUniformMatrix2x3dv(location, count, transpose, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniformMatrix2x3dv' not available on this platform (extensions: GL_ARB_gpu_shader_fp64)");
      }
    }

    void uniform_matrix_2x_4dv(gl::int_t location, gl::sizei_t count, gl::boolean_t transpose, const  gl::double_t * value) {
      if ( GLAD_GL_ARB_gpu_shader_fp64 ) {
        glUniformMatrix2x4dv(location, count, transpose, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniformMatrix2x4dv' not available on this platform (extensions: GL_ARB_gpu_shader_fp64)");
      }
    }

    void uniform_matrix_3dv(gl::int_t location, gl::sizei_t count, gl::boolean_t transpose, const  gl::double_t * value) {
      if ( GLAD_GL_ARB_gpu_shader_fp64 ) {
        glUniformMatrix3dv(location, count, transpose, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniformMatrix3dv' not available on this platform (extensions: GL_ARB_gpu_shader_fp64)");
      }
    }

    void uniform_matrix_3fv_arb(gl::int_t location, gl::sizei_t count, gl::boolean_t transpose, const  gl::float_t * value) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glUniformMatrix3fvARB(location, count, transpose, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniformMatrix3fvARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void uniform_matrix_3x_2dv(gl::int_t location, gl::sizei_t count, gl::boolean_t transpose, const  gl::double_t * value) {
      if ( GLAD_GL_ARB_gpu_shader_fp64 ) {
        glUniformMatrix3x2dv(location, count, transpose, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniformMatrix3x2dv' not available on this platform (extensions: GL_ARB_gpu_shader_fp64)");
      }
    }

    void uniform_matrix_3x_4dv(gl::int_t location, gl::sizei_t count, gl::boolean_t transpose, const  gl::double_t * value) {
      if ( GLAD_GL_ARB_gpu_shader_fp64 ) {
        glUniformMatrix3x4dv(location, count, transpose, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniformMatrix3x4dv' not available on this platform (extensions: GL_ARB_gpu_shader_fp64)");
      }
    }

    void uniform_matrix_4dv(gl::int_t location, gl::sizei_t count, gl::boolean_t transpose, const  gl::double_t * value) {
      if ( GLAD_GL_ARB_gpu_shader_fp64 ) {
        glUniformMatrix4dv(location, count, transpose, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniformMatrix4dv' not available on this platform (extensions: GL_ARB_gpu_shader_fp64)");
      }
    }

    void uniform_matrix_4fv_arb(gl::int_t location, gl::sizei_t count, gl::boolean_t transpose, const  gl::float_t * value) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glUniformMatrix4fvARB(location, count, transpose, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniformMatrix4fvARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void uniform_matrix_4x_2dv(gl::int_t location, gl::sizei_t count, gl::boolean_t transpose, const  gl::double_t * value) {
      if ( GLAD_GL_ARB_gpu_shader_fp64 ) {
        glUniformMatrix4x2dv(location, count, transpose, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniformMatrix4x2dv' not available on this platform (extensions: GL_ARB_gpu_shader_fp64)");
      }
    }

    void uniform_matrix_4x_3dv(gl::int_t location, gl::sizei_t count, gl::boolean_t transpose, const  gl::double_t * value) {
      if ( GLAD_GL_ARB_gpu_shader_fp64 ) {
        glUniformMatrix4x3dv(location, count, transpose, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniformMatrix4x3dv' not available on this platform (extensions: GL_ARB_gpu_shader_fp64)");
      }
    }

    void uniform_subroutinesuiv(gl::enum_t shadertype, gl::sizei_t count, const  gl::uint_t * indices) {
      if ( GLAD_GL_ARB_shader_subroutine ) {
        glUniformSubroutinesuiv(shadertype, count, indices);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniformSubroutinesuiv' not available on this platform (extensions: GL_ARB_shader_subroutine)");
      }
    }

    void uniformui_64nv(gl::int_t location, gl::uint64EXT_t value) {
      if ( GLAD_GL_NV_shader_buffer_load ) {
        glUniformui64NV(location, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniformui64NV' not available on this platform (extensions: GL_NV_shader_buffer_load)");
      }
    }

    void uniformui_64v_nv(gl::int_t location, gl::sizei_t count, const  gl::uint64EXT_t * value) {
      if ( GLAD_GL_NV_shader_buffer_load ) {
        glUniformui64vNV(location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniformui64vNV' not available on this platform (extensions: GL_NV_shader_buffer_load)");
      }
    }

    void unlock_arrays_ext() {
      if ( GLAD_GL_EXT_compiled_vertex_array ) {
        glUnlockArraysEXT();
      }
      else {
        throw std::runtime_error("OpenGL command 'glUnlockArraysEXT' not available on this platform (extensions: GL_EXT_compiled_vertex_array)");
      }
    }

    gl::boolean_t unmap_buffer_arb(buffer_target_arb_t target) {
      if ( GLAD_GL_ARB_vertex_buffer_object ) {
        return glUnmapBufferARB(static_cast<GLenum>(target));
      }
      else {
        throw std::runtime_error("OpenGL command 'glUnmapBufferARB' not available on this platform (extensions: GL_ARB_vertex_buffer_object)");
      }
    }

    gl::boolean_t unmap_named_buffer(gl::uint_t buffer) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        return glUnmapNamedBuffer(buffer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUnmapNamedBuffer' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    gl::boolean_t unmap_named_buffer_ext(gl::uint_t buffer) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        return glUnmapNamedBufferEXT(buffer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUnmapNamedBufferEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void unmap_object_buffer_ati(gl::uint_t buffer) {
      if ( GLAD_GL_ATI_map_object_buffer ) {
        glUnmapObjectBufferATI(buffer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUnmapObjectBufferATI' not available on this platform (extensions: GL_ATI_map_object_buffer)");
      }
    }

    void unmap_texture_2dintel(gl::uint_t texture, gl::int_t level) {
      if ( GLAD_GL_INTEL_map_texture ) {
        glUnmapTexture2DINTEL(texture, level);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUnmapTexture2DINTEL' not available on this platform (extensions: GL_INTEL_map_texture)");
      }
    }

    void update_object_buffer_ati(gl::uint_t buffer, gl::uint_t offset, gl::sizei_t size, const  void * pointer, gl::enum_t preserve) {
      if ( GLAD_GL_ATI_vertex_array_object ) {
        glUpdateObjectBufferATI(buffer, offset, size, pointer, preserve);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUpdateObjectBufferATI' not available on this platform (extensions: GL_ATI_vertex_array_object)");
      }
    }

    void use_program_object_arb(gl::handleARB_t programObj) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glUseProgramObjectARB(programObj);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUseProgramObjectARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void use_program_stages(gl::uint_t pipeline, gl::bitmask<use_program_stage_flags_t> stages, gl::uint_t program) {
      if ( GLAD_GL_ARB_separate_shader_objects ) {
        glUseProgramStages(pipeline, static_cast<GLbitfield>(stages.value), program);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUseProgramStages' not available on this platform (extensions: GL_ARB_separate_shader_objects)");
      }
    }

    void use_shader_program_ext(gl::enum_t type, gl::uint_t program) {
      if ( GLAD_GL_EXT_separate_shader_objects ) {
        glUseShaderProgramEXT(type, program);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUseShaderProgramEXT' not available on this platform (extensions: GL_EXT_separate_shader_objects)");
      }
    }

    void vdpau_fini_nv() {
      if ( GLAD_GL_NV_vdpau_interop ) {
        glVDPAUFiniNV();
      }
      else {
        throw std::runtime_error("OpenGL command 'glVDPAUFiniNV' not available on this platform (extensions: GL_NV_vdpau_interop)");
      }
    }

    void vdpau_get_surfaceiv_nv(gl::vdpauSurfaceNV_t surface, gl::enum_t pname, gl::sizei_t bufSize, gl::sizei_t * length, gl::int_t * values) {
      if ( GLAD_GL_NV_vdpau_interop ) {
        glVDPAUGetSurfaceivNV(surface, pname, bufSize, length, values);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVDPAUGetSurfaceivNV' not available on this platform (extensions: GL_NV_vdpau_interop)");
      }
    }

    void vdpau_init_nv(const  void * vdpDevice, const  void * getProcAddress) {
      if ( GLAD_GL_NV_vdpau_interop ) {
        glVDPAUInitNV(vdpDevice, getProcAddress);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVDPAUInitNV' not available on this platform (extensions: GL_NV_vdpau_interop)");
      }
    }

    gl::boolean_t vdpau_is_surface_nv(gl::vdpauSurfaceNV_t surface) {
      if ( GLAD_GL_NV_vdpau_interop ) {
        return glVDPAUIsSurfaceNV(surface);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVDPAUIsSurfaceNV' not available on this platform (extensions: GL_NV_vdpau_interop)");
      }
    }

    void vdpau_map_surfaces_nv(gl::sizei_t numSurfaces, const  gl::vdpauSurfaceNV_t * surfaces) {
      if ( GLAD_GL_NV_vdpau_interop ) {
        glVDPAUMapSurfacesNV(numSurfaces, surfaces);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVDPAUMapSurfacesNV' not available on this platform (extensions: GL_NV_vdpau_interop)");
      }
    }

    gl::vdpauSurfaceNV_t vdpau_register_output_surface_nv(const  void * vdpSurface, gl::enum_t target, gl::sizei_t numTextureNames, const  gl::uint_t * textureNames) {
      if ( GLAD_GL_NV_vdpau_interop ) {
        return glVDPAURegisterOutputSurfaceNV(vdpSurface, target, numTextureNames, textureNames);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVDPAURegisterOutputSurfaceNV' not available on this platform (extensions: GL_NV_vdpau_interop)");
      }
    }

    gl::vdpauSurfaceNV_t vdpau_register_video_surface_nv(const  void * vdpSurface, gl::enum_t target, gl::sizei_t numTextureNames, const  gl::uint_t * textureNames) {
      if ( GLAD_GL_NV_vdpau_interop ) {
        return glVDPAURegisterVideoSurfaceNV(vdpSurface, target, numTextureNames, textureNames);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVDPAURegisterVideoSurfaceNV' not available on this platform (extensions: GL_NV_vdpau_interop)");
      }
    }

    void vdpau_surface_access_nv(gl::vdpauSurfaceNV_t surface, gl::enum_t access) {
      if ( GLAD_GL_NV_vdpau_interop ) {
        glVDPAUSurfaceAccessNV(surface, access);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVDPAUSurfaceAccessNV' not available on this platform (extensions: GL_NV_vdpau_interop)");
      }
    }

    void vdpau_unmap_surfaces_nv(gl::sizei_t numSurface, const  gl::vdpauSurfaceNV_t * surfaces) {
      if ( GLAD_GL_NV_vdpau_interop ) {
        glVDPAUUnmapSurfacesNV(numSurface, surfaces);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVDPAUUnmapSurfacesNV' not available on this platform (extensions: GL_NV_vdpau_interop)");
      }
    }

    void vdpau_unregister_surface_nv(gl::vdpauSurfaceNV_t surface) {
      if ( GLAD_GL_NV_vdpau_interop ) {
        glVDPAUUnregisterSurfaceNV(surface);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVDPAUUnregisterSurfaceNV' not available on this platform (extensions: GL_NV_vdpau_interop)");
      }
    }

    void validate_program_arb(gl::handleARB_t programObj) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glValidateProgramARB(programObj);
      }
      else {
        throw std::runtime_error("OpenGL command 'glValidateProgramARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void validate_program_pipeline(gl::uint_t pipeline) {
      if ( GLAD_GL_ARB_separate_shader_objects ) {
        glValidateProgramPipeline(pipeline);
      }
      else {
        throw std::runtime_error("OpenGL command 'glValidateProgramPipeline' not available on this platform (extensions: GL_ARB_separate_shader_objects)");
      }
    }

    void variant_array_object_ati(gl::uint_t id, gl::enum_t type, gl::sizei_t stride, gl::uint_t buffer, gl::uint_t offset) {
      if ( GLAD_GL_ATI_vertex_array_object ) {
        glVariantArrayObjectATI(id, type, stride, buffer, offset);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVariantArrayObjectATI' not available on this platform (extensions: GL_ATI_vertex_array_object)");
      }
    }

    void variant_pointer_ext(gl::uint_t id, gl::enum_t type, gl::uint_t stride, const  void * addr) {
      if ( GLAD_GL_EXT_vertex_shader ) {
        glVariantPointerEXT(id, type, stride, addr);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVariantPointerEXT' not available on this platform (extensions: GL_EXT_vertex_shader)");
      }
    }

    void variantbv_ext(gl::uint_t id, const  gl::byte_t * addr) {
      if ( GLAD_GL_EXT_vertex_shader ) {
        glVariantbvEXT(id, addr);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVariantbvEXT' not available on this platform (extensions: GL_EXT_vertex_shader)");
      }
    }

    void variantdv_ext(gl::uint_t id, const  gl::double_t * addr) {
      if ( GLAD_GL_EXT_vertex_shader ) {
        glVariantdvEXT(id, addr);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVariantdvEXT' not available on this platform (extensions: GL_EXT_vertex_shader)");
      }
    }

    void variantfv_ext(gl::uint_t id, const  gl::float_t * addr) {
      if ( GLAD_GL_EXT_vertex_shader ) {
        glVariantfvEXT(id, addr);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVariantfvEXT' not available on this platform (extensions: GL_EXT_vertex_shader)");
      }
    }

    void variantiv_ext(gl::uint_t id, const  gl::int_t * addr) {
      if ( GLAD_GL_EXT_vertex_shader ) {
        glVariantivEXT(id, addr);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVariantivEXT' not available on this platform (extensions: GL_EXT_vertex_shader)");
      }
    }

    void variantsv_ext(gl::uint_t id, const  gl::short_t * addr) {
      if ( GLAD_GL_EXT_vertex_shader ) {
        glVariantsvEXT(id, addr);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVariantsvEXT' not available on this platform (extensions: GL_EXT_vertex_shader)");
      }
    }

    void variantubv_ext(gl::uint_t id, const  gl::ubyte_t * addr) {
      if ( GLAD_GL_EXT_vertex_shader ) {
        glVariantubvEXT(id, addr);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVariantubvEXT' not available on this platform (extensions: GL_EXT_vertex_shader)");
      }
    }

    void variantuiv_ext(gl::uint_t id, const  gl::uint_t * addr) {
      if ( GLAD_GL_EXT_vertex_shader ) {
        glVariantuivEXT(id, addr);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVariantuivEXT' not available on this platform (extensions: GL_EXT_vertex_shader)");
      }
    }

    void variantusv_ext(gl::uint_t id, const  gl::ushort_t * addr) {
      if ( GLAD_GL_EXT_vertex_shader ) {
        glVariantusvEXT(id, addr);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVariantusvEXT' not available on this platform (extensions: GL_EXT_vertex_shader)");
      }
    }

    void vertex_2b_oes(gl::byte_t x, gl::byte_t y) {
      if ( GLAD_GL_OES_byte_coordinates ) {
        glVertex2bOES(x, y);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertex2bOES' not available on this platform (extensions: GL_OES_byte_coordinates)");
      }
    }

    void vertex_2bv_oes(const  gl::byte_t * coords) {
      if ( GLAD_GL_OES_byte_coordinates ) {
        glVertex2bvOES(coords);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertex2bvOES' not available on this platform (extensions: GL_OES_byte_coordinates)");
      }
    }

    void vertex_2h_nv(gl::halfNV_t x, gl::halfNV_t y) {
      if ( GLAD_GL_NV_half_float ) {
        glVertex2hNV(x, y);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertex2hNV' not available on this platform (extensions: GL_NV_half_float)");
      }
    }

    void vertex_2hv_nv(const  gl::halfNV_t * v) {
      if ( GLAD_GL_NV_half_float ) {
        glVertex2hvNV(v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertex2hvNV' not available on this platform (extensions: GL_NV_half_float)");
      }
    }

    void vertex_2x_oes(gl::fixed_t x) {
      if ( GLAD_GL_OES_fixed_point ) {
        glVertex2xOES(x);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertex2xOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void vertex_2xv_oes(const  gl::fixed_t * coords) {
      if ( GLAD_GL_OES_fixed_point ) {
        glVertex2xvOES(coords);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertex2xvOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void vertex_3b_oes(gl::byte_t x, gl::byte_t y, gl::byte_t z) {
      if ( GLAD_GL_OES_byte_coordinates ) {
        glVertex3bOES(x, y, z);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertex3bOES' not available on this platform (extensions: GL_OES_byte_coordinates)");
      }
    }

    void vertex_3bv_oes(const  gl::byte_t * coords) {
      if ( GLAD_GL_OES_byte_coordinates ) {
        glVertex3bvOES(coords);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertex3bvOES' not available on this platform (extensions: GL_OES_byte_coordinates)");
      }
    }

    void vertex_3h_nv(gl::halfNV_t x, gl::halfNV_t y, gl::halfNV_t z) {
      if ( GLAD_GL_NV_half_float ) {
        glVertex3hNV(x, y, z);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertex3hNV' not available on this platform (extensions: GL_NV_half_float)");
      }
    }

    void vertex_3hv_nv(const  gl::halfNV_t * v) {
      if ( GLAD_GL_NV_half_float ) {
        glVertex3hvNV(v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertex3hvNV' not available on this platform (extensions: GL_NV_half_float)");
      }
    }

    void vertex_3x_oes(gl::fixed_t x, gl::fixed_t y) {
      if ( GLAD_GL_OES_fixed_point ) {
        glVertex3xOES(x, y);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertex3xOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void vertex_3xv_oes(const  gl::fixed_t * coords) {
      if ( GLAD_GL_OES_fixed_point ) {
        glVertex3xvOES(coords);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertex3xvOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void vertex_4b_oes(gl::byte_t x, gl::byte_t y, gl::byte_t z, gl::byte_t w) {
      if ( GLAD_GL_OES_byte_coordinates ) {
        glVertex4bOES(x, y, z, w);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertex4bOES' not available on this platform (extensions: GL_OES_byte_coordinates)");
      }
    }

    void vertex_4bv_oes(const  gl::byte_t * coords) {
      if ( GLAD_GL_OES_byte_coordinates ) {
        glVertex4bvOES(coords);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertex4bvOES' not available on this platform (extensions: GL_OES_byte_coordinates)");
      }
    }

    void vertex_4h_nv(gl::halfNV_t x, gl::halfNV_t y, gl::halfNV_t z, gl::halfNV_t w) {
      if ( GLAD_GL_NV_half_float ) {
        glVertex4hNV(x, y, z, w);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertex4hNV' not available on this platform (extensions: GL_NV_half_float)");
      }
    }

    void vertex_4hv_nv(const  gl::halfNV_t * v) {
      if ( GLAD_GL_NV_half_float ) {
        glVertex4hvNV(v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertex4hvNV' not available on this platform (extensions: GL_NV_half_float)");
      }
    }

    void vertex_4x_oes(gl::fixed_t x, gl::fixed_t y, gl::fixed_t z) {
      if ( GLAD_GL_OES_fixed_point ) {
        glVertex4xOES(x, y, z);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertex4xOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void vertex_4xv_oes(const  gl::fixed_t * coords) {
      if ( GLAD_GL_OES_fixed_point ) {
        glVertex4xvOES(coords);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertex4xvOES' not available on this platform (extensions: GL_OES_fixed_point)");
      }
    }

    void vertex_array_attrib_binding(gl::uint_t vaobj, gl::uint_t attribindex, gl::uint_t bindingindex) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glVertexArrayAttribBinding(vaobj, attribindex, bindingindex);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexArrayAttribBinding' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void vertex_array_attrib_format(gl::uint_t vaobj, gl::uint_t attribindex, gl::int_t size, gl::enum_t type, gl::boolean_t normalized, gl::uint_t relativeoffset) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glVertexArrayAttribFormat(vaobj, attribindex, size, type, normalized, relativeoffset);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexArrayAttribFormat' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void vertex_array_attrib_i_format(gl::uint_t vaobj, gl::uint_t attribindex, gl::int_t size, gl::enum_t type, gl::uint_t relativeoffset) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glVertexArrayAttribIFormat(vaobj, attribindex, size, type, relativeoffset);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexArrayAttribIFormat' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void vertex_array_attrib_l_format(gl::uint_t vaobj, gl::uint_t attribindex, gl::int_t size, gl::enum_t type, gl::uint_t relativeoffset) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glVertexArrayAttribLFormat(vaobj, attribindex, size, type, relativeoffset);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexArrayAttribLFormat' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void vertex_array_bind_vertex_buffer_ext(gl::uint_t vaobj, gl::uint_t bindingindex, gl::uint_t buffer, gl::intptr_t offset, gl::sizei_t stride) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glVertexArrayBindVertexBufferEXT(vaobj, bindingindex, buffer, offset, stride);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexArrayBindVertexBufferEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void vertex_array_binding_divisor(gl::uint_t vaobj, gl::uint_t bindingindex, gl::uint_t divisor) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glVertexArrayBindingDivisor(vaobj, bindingindex, divisor);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexArrayBindingDivisor' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void vertex_array_color_offset_ext(gl::uint_t vaobj, gl::uint_t buffer, gl::int_t size, color_pointer_type_t type, gl::sizei_t stride, gl::intptr_t offset) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glVertexArrayColorOffsetEXT(vaobj, buffer, size, static_cast<GLenum>(type), stride, offset);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexArrayColorOffsetEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void vertex_array_edge_flag_offset_ext(gl::uint_t vaobj, gl::uint_t buffer, gl::sizei_t stride, gl::intptr_t offset) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glVertexArrayEdgeFlagOffsetEXT(vaobj, buffer, stride, offset);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexArrayEdgeFlagOffsetEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void vertex_array_element_buffer(gl::uint_t vaobj, gl::uint_t buffer) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glVertexArrayElementBuffer(vaobj, buffer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexArrayElementBuffer' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void vertex_array_fog_coord_offset_ext(gl::uint_t vaobj, gl::uint_t buffer, fog_coordinate_pointer_type_t type, gl::sizei_t stride, gl::intptr_t offset) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glVertexArrayFogCoordOffsetEXT(vaobj, buffer, static_cast<GLenum>(type), stride, offset);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexArrayFogCoordOffsetEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void vertex_array_index_offset_ext(gl::uint_t vaobj, gl::uint_t buffer, index_pointer_type_t type, gl::sizei_t stride, gl::intptr_t offset) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glVertexArrayIndexOffsetEXT(vaobj, buffer, static_cast<GLenum>(type), stride, offset);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexArrayIndexOffsetEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void vertex_array_multi_tex_coord_offset_ext(gl::uint_t vaobj, gl::uint_t buffer, gl::enum_t texunit, gl::int_t size, tex_coord_pointer_type_t type, gl::sizei_t stride, gl::intptr_t offset) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glVertexArrayMultiTexCoordOffsetEXT(vaobj, buffer, texunit, size, static_cast<GLenum>(type), stride, offset);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexArrayMultiTexCoordOffsetEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void vertex_array_normal_offset_ext(gl::uint_t vaobj, gl::uint_t buffer, normal_pointer_type_t type, gl::sizei_t stride, gl::intptr_t offset) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glVertexArrayNormalOffsetEXT(vaobj, buffer, static_cast<GLenum>(type), stride, offset);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexArrayNormalOffsetEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void vertex_array_parameteri_apple(gl::enum_t pname, gl::int_t param) {
      if ( GLAD_GL_APPLE_vertex_array_range ) {
        glVertexArrayParameteriAPPLE(pname, param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexArrayParameteriAPPLE' not available on this platform (extensions: GL_APPLE_vertex_array_range)");
      }
    }

    void vertex_array_range_apple(gl::sizei_t length, void * pointer) {
      if ( GLAD_GL_APPLE_vertex_array_range ) {
        glVertexArrayRangeAPPLE(length, pointer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexArrayRangeAPPLE' not available on this platform (extensions: GL_APPLE_vertex_array_range)");
      }
    }

    void vertex_array_range_nv(gl::sizei_t length, const  void * pointer) {
      if ( GLAD_GL_NV_vertex_array_range ) {
        glVertexArrayRangeNV(length, pointer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexArrayRangeNV' not available on this platform (extensions: GL_NV_vertex_array_range)");
      }
    }

    void vertex_array_secondary_color_offset_ext(gl::uint_t vaobj, gl::uint_t buffer, gl::int_t size, color_pointer_type_t type, gl::sizei_t stride, gl::intptr_t offset) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glVertexArraySecondaryColorOffsetEXT(vaobj, buffer, size, static_cast<GLenum>(type), stride, offset);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexArraySecondaryColorOffsetEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void vertex_array_tex_coord_offset_ext(gl::uint_t vaobj, gl::uint_t buffer, gl::int_t size, tex_coord_pointer_type_t type, gl::sizei_t stride, gl::intptr_t offset) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glVertexArrayTexCoordOffsetEXT(vaobj, buffer, size, static_cast<GLenum>(type), stride, offset);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexArrayTexCoordOffsetEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void vertex_array_vertex_attrib_binding_ext(gl::uint_t vaobj, gl::uint_t attribindex, gl::uint_t bindingindex) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glVertexArrayVertexAttribBindingEXT(vaobj, attribindex, bindingindex);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexArrayVertexAttribBindingEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void vertex_array_vertex_attrib_divisor_ext(gl::uint_t vaobj, gl::uint_t index, gl::uint_t divisor) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glVertexArrayVertexAttribDivisorEXT(vaobj, index, divisor);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexArrayVertexAttribDivisorEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void vertex_array_vertex_attrib_format_ext(gl::uint_t vaobj, gl::uint_t attribindex, gl::int_t size, gl::enum_t type, gl::boolean_t normalized, gl::uint_t relativeoffset) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glVertexArrayVertexAttribFormatEXT(vaobj, attribindex, size, type, normalized, relativeoffset);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexArrayVertexAttribFormatEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void vertex_array_vertex_attrib_i_format_ext(gl::uint_t vaobj, gl::uint_t attribindex, gl::int_t size, gl::enum_t type, gl::uint_t relativeoffset) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glVertexArrayVertexAttribIFormatEXT(vaobj, attribindex, size, type, relativeoffset);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexArrayVertexAttribIFormatEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void vertex_array_vertex_attrib_i_offset_ext(gl::uint_t vaobj, gl::uint_t buffer, gl::uint_t index, gl::int_t size, gl::enum_t type, gl::sizei_t stride, gl::intptr_t offset) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glVertexArrayVertexAttribIOffsetEXT(vaobj, buffer, index, size, type, stride, offset);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexArrayVertexAttribIOffsetEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void vertex_array_vertex_attrib_l_format_ext(gl::uint_t vaobj, gl::uint_t attribindex, gl::int_t size, gl::enum_t type, gl::uint_t relativeoffset) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glVertexArrayVertexAttribLFormatEXT(vaobj, attribindex, size, type, relativeoffset);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexArrayVertexAttribLFormatEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void vertex_array_vertex_attrib_l_offset_ext(gl::uint_t vaobj, gl::uint_t buffer, gl::uint_t index, gl::int_t size, gl::enum_t type, gl::sizei_t stride, gl::intptr_t offset) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glVertexArrayVertexAttribLOffsetEXT(vaobj, buffer, index, size, type, stride, offset);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexArrayVertexAttribLOffsetEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void vertex_array_vertex_attrib_offset_ext(gl::uint_t vaobj, gl::uint_t buffer, gl::uint_t index, gl::int_t size, vertex_attrib_pointer_type_t type, gl::boolean_t normalized, gl::sizei_t stride, gl::intptr_t offset) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glVertexArrayVertexAttribOffsetEXT(vaobj, buffer, index, size, static_cast<GLenum>(type), normalized, stride, offset);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexArrayVertexAttribOffsetEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void vertex_array_vertex_binding_divisor_ext(gl::uint_t vaobj, gl::uint_t bindingindex, gl::uint_t divisor) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glVertexArrayVertexBindingDivisorEXT(vaobj, bindingindex, divisor);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexArrayVertexBindingDivisorEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void vertex_array_vertex_buffer(gl::uint_t vaobj, gl::uint_t bindingindex, gl::uint_t buffer, gl::intptr_t offset, gl::sizei_t stride) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glVertexArrayVertexBuffer(vaobj, bindingindex, buffer, offset, stride);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexArrayVertexBuffer' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void vertex_array_vertex_buffers(gl::uint_t vaobj, gl::uint_t first, gl::sizei_t count, const  gl::uint_t * buffers, const  gl::intptr_t * offsets, const  gl::sizei_t * strides) {
      if ( GLAD_GL_ARB_direct_state_access ) {
        glVertexArrayVertexBuffers(vaobj, first, count, buffers, offsets, strides);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexArrayVertexBuffers' not available on this platform (extensions: GL_ARB_direct_state_access)");
      }
    }

    void vertex_array_vertex_offset_ext(gl::uint_t vaobj, gl::uint_t buffer, gl::int_t size, vertex_pointer_type_t type, gl::sizei_t stride, gl::intptr_t offset) {
      if ( GLAD_GL_EXT_direct_state_access ) {
        glVertexArrayVertexOffsetEXT(vaobj, buffer, size, static_cast<GLenum>(type), stride, offset);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexArrayVertexOffsetEXT' not available on this platform (extensions: GL_EXT_direct_state_access)");
      }
    }

    void vertex_attrib_1d_arb(gl::uint_t index, gl::double_t x) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib1dARB(index, x);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib1dARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_1d_nv(gl::uint_t index, gl::double_t x) {
      if ( GLAD_GL_NV_vertex_program ) {
        glVertexAttrib1dNV(index, x);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib1dNV' not available on this platform (extensions: GL_NV_vertex_program)");
      }
    }

    void vertex_attrib_1dv_arb(gl::uint_t index, const  gl::double_t * v) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib1dvARB(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib1dvARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_1dv_nv(gl::uint_t index, const  gl::double_t * v) {
      if ( GLAD_GL_NV_vertex_program ) {
        glVertexAttrib1dvNV(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib1dvNV' not available on this platform (extensions: GL_NV_vertex_program)");
      }
    }

    void vertex_attrib_1f_arb(gl::uint_t index, gl::float_t x) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib1fARB(index, x);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib1fARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_1f_nv(gl::uint_t index, gl::float_t x) {
      if ( GLAD_GL_NV_vertex_program ) {
        glVertexAttrib1fNV(index, x);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib1fNV' not available on this platform (extensions: GL_NV_vertex_program)");
      }
    }

    void vertex_attrib_1fv_arb(gl::uint_t index, const  gl::float_t * v) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib1fvARB(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib1fvARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_1fv_nv(gl::uint_t index, const  gl::float_t * v) {
      if ( GLAD_GL_NV_vertex_program ) {
        glVertexAttrib1fvNV(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib1fvNV' not available on this platform (extensions: GL_NV_vertex_program)");
      }
    }

    void vertex_attrib_1h_nv(gl::uint_t index, gl::halfNV_t x) {
      if ( GLAD_GL_NV_half_float ) {
        glVertexAttrib1hNV(index, x);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib1hNV' not available on this platform (extensions: GL_NV_half_float)");
      }
    }

    void vertex_attrib_1hv_nv(gl::uint_t index, const  gl::halfNV_t * v) {
      if ( GLAD_GL_NV_half_float ) {
        glVertexAttrib1hvNV(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib1hvNV' not available on this platform (extensions: GL_NV_half_float)");
      }
    }

    void vertex_attrib_1s_arb(gl::uint_t index, gl::short_t x) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib1sARB(index, x);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib1sARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_1s_nv(gl::uint_t index, gl::short_t x) {
      if ( GLAD_GL_NV_vertex_program ) {
        glVertexAttrib1sNV(index, x);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib1sNV' not available on this platform (extensions: GL_NV_vertex_program)");
      }
    }

    void vertex_attrib_1sv_arb(gl::uint_t index, const  gl::short_t * v) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib1svARB(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib1svARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_1sv_nv(gl::uint_t index, const  gl::short_t * v) {
      if ( GLAD_GL_NV_vertex_program ) {
        glVertexAttrib1svNV(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib1svNV' not available on this platform (extensions: GL_NV_vertex_program)");
      }
    }

    void vertex_attrib_2d_arb(gl::uint_t index, gl::double_t x, gl::double_t y) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib2dARB(index, x, y);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib2dARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_2d_nv(gl::uint_t index, gl::double_t x, gl::double_t y) {
      if ( GLAD_GL_NV_vertex_program ) {
        glVertexAttrib2dNV(index, x, y);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib2dNV' not available on this platform (extensions: GL_NV_vertex_program)");
      }
    }

    void vertex_attrib_2dv_arb(gl::uint_t index, const  gl::double_t * v) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib2dvARB(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib2dvARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_2dv_nv(gl::uint_t index, const  gl::double_t * v) {
      if ( GLAD_GL_NV_vertex_program ) {
        glVertexAttrib2dvNV(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib2dvNV' not available on this platform (extensions: GL_NV_vertex_program)");
      }
    }

    void vertex_attrib_2f_arb(gl::uint_t index, gl::float_t x, gl::float_t y) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib2fARB(index, x, y);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib2fARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_2f_nv(gl::uint_t index, gl::float_t x, gl::float_t y) {
      if ( GLAD_GL_NV_vertex_program ) {
        glVertexAttrib2fNV(index, x, y);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib2fNV' not available on this platform (extensions: GL_NV_vertex_program)");
      }
    }

    void vertex_attrib_2fv_arb(gl::uint_t index, const  gl::float_t * v) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib2fvARB(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib2fvARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_2fv_nv(gl::uint_t index, const  gl::float_t * v) {
      if ( GLAD_GL_NV_vertex_program ) {
        glVertexAttrib2fvNV(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib2fvNV' not available on this platform (extensions: GL_NV_vertex_program)");
      }
    }

    void vertex_attrib_2h_nv(gl::uint_t index, gl::halfNV_t x, gl::halfNV_t y) {
      if ( GLAD_GL_NV_half_float ) {
        glVertexAttrib2hNV(index, x, y);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib2hNV' not available on this platform (extensions: GL_NV_half_float)");
      }
    }

    void vertex_attrib_2hv_nv(gl::uint_t index, const  gl::halfNV_t * v) {
      if ( GLAD_GL_NV_half_float ) {
        glVertexAttrib2hvNV(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib2hvNV' not available on this platform (extensions: GL_NV_half_float)");
      }
    }

    void vertex_attrib_2s_arb(gl::uint_t index, gl::short_t x, gl::short_t y) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib2sARB(index, x, y);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib2sARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_2s_nv(gl::uint_t index, gl::short_t x, gl::short_t y) {
      if ( GLAD_GL_NV_vertex_program ) {
        glVertexAttrib2sNV(index, x, y);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib2sNV' not available on this platform (extensions: GL_NV_vertex_program)");
      }
    }

    void vertex_attrib_2sv_arb(gl::uint_t index, const  gl::short_t * v) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib2svARB(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib2svARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_2sv_nv(gl::uint_t index, const  gl::short_t * v) {
      if ( GLAD_GL_NV_vertex_program ) {
        glVertexAttrib2svNV(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib2svNV' not available on this platform (extensions: GL_NV_vertex_program)");
      }
    }

    void vertex_attrib_3d_arb(gl::uint_t index, gl::double_t x, gl::double_t y, gl::double_t z) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib3dARB(index, x, y, z);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib3dARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_3d_nv(gl::uint_t index, gl::double_t x, gl::double_t y, gl::double_t z) {
      if ( GLAD_GL_NV_vertex_program ) {
        glVertexAttrib3dNV(index, x, y, z);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib3dNV' not available on this platform (extensions: GL_NV_vertex_program)");
      }
    }

    void vertex_attrib_3dv_arb(gl::uint_t index, const  gl::double_t * v) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib3dvARB(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib3dvARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_3dv_nv(gl::uint_t index, const  gl::double_t * v) {
      if ( GLAD_GL_NV_vertex_program ) {
        glVertexAttrib3dvNV(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib3dvNV' not available on this platform (extensions: GL_NV_vertex_program)");
      }
    }

    void vertex_attrib_3f_arb(gl::uint_t index, gl::float_t x, gl::float_t y, gl::float_t z) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib3fARB(index, x, y, z);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib3fARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_3f_nv(gl::uint_t index, gl::float_t x, gl::float_t y, gl::float_t z) {
      if ( GLAD_GL_NV_vertex_program ) {
        glVertexAttrib3fNV(index, x, y, z);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib3fNV' not available on this platform (extensions: GL_NV_vertex_program)");
      }
    }

    void vertex_attrib_3fv_arb(gl::uint_t index, const  gl::float_t * v) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib3fvARB(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib3fvARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_3fv_nv(gl::uint_t index, const  gl::float_t * v) {
      if ( GLAD_GL_NV_vertex_program ) {
        glVertexAttrib3fvNV(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib3fvNV' not available on this platform (extensions: GL_NV_vertex_program)");
      }
    }

    void vertex_attrib_3h_nv(gl::uint_t index, gl::halfNV_t x, gl::halfNV_t y, gl::halfNV_t z) {
      if ( GLAD_GL_NV_half_float ) {
        glVertexAttrib3hNV(index, x, y, z);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib3hNV' not available on this platform (extensions: GL_NV_half_float)");
      }
    }

    void vertex_attrib_3hv_nv(gl::uint_t index, const  gl::halfNV_t * v) {
      if ( GLAD_GL_NV_half_float ) {
        glVertexAttrib3hvNV(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib3hvNV' not available on this platform (extensions: GL_NV_half_float)");
      }
    }

    void vertex_attrib_3s_arb(gl::uint_t index, gl::short_t x, gl::short_t y, gl::short_t z) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib3sARB(index, x, y, z);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib3sARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_3s_nv(gl::uint_t index, gl::short_t x, gl::short_t y, gl::short_t z) {
      if ( GLAD_GL_NV_vertex_program ) {
        glVertexAttrib3sNV(index, x, y, z);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib3sNV' not available on this platform (extensions: GL_NV_vertex_program)");
      }
    }

    void vertex_attrib_3sv_arb(gl::uint_t index, const  gl::short_t * v) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib3svARB(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib3svARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_3sv_nv(gl::uint_t index, const  gl::short_t * v) {
      if ( GLAD_GL_NV_vertex_program ) {
        glVertexAttrib3svNV(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib3svNV' not available on this platform (extensions: GL_NV_vertex_program)");
      }
    }

    void vertex_attrib_4_nbv_arb(gl::uint_t index, const  gl::byte_t * v) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib4NbvARB(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib4NbvARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_4_niv_arb(gl::uint_t index, const  gl::int_t * v) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib4NivARB(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib4NivARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_4_nsv_arb(gl::uint_t index, const  gl::short_t * v) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib4NsvARB(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib4NsvARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_4_nub_arb(gl::uint_t index, gl::ubyte_t x, gl::ubyte_t y, gl::ubyte_t z, gl::ubyte_t w) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib4NubARB(index, x, y, z, w);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib4NubARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_4_nubv_arb(gl::uint_t index, const  gl::ubyte_t * v) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib4NubvARB(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib4NubvARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_4_nuiv_arb(gl::uint_t index, const  gl::uint_t * v) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib4NuivARB(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib4NuivARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_4_nusv_arb(gl::uint_t index, const  gl::ushort_t * v) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib4NusvARB(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib4NusvARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_4bv_arb(gl::uint_t index, const  gl::byte_t * v) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib4bvARB(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib4bvARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_4d_arb(gl::uint_t index, gl::double_t x, gl::double_t y, gl::double_t z, gl::double_t w) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib4dARB(index, x, y, z, w);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib4dARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_4d_nv(gl::uint_t index, gl::double_t x, gl::double_t y, gl::double_t z, gl::double_t w) {
      if ( GLAD_GL_NV_vertex_program ) {
        glVertexAttrib4dNV(index, x, y, z, w);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib4dNV' not available on this platform (extensions: GL_NV_vertex_program)");
      }
    }

    void vertex_attrib_4dv_arb(gl::uint_t index, const  gl::double_t * v) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib4dvARB(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib4dvARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_4dv_nv(gl::uint_t index, const  gl::double_t * v) {
      if ( GLAD_GL_NV_vertex_program ) {
        glVertexAttrib4dvNV(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib4dvNV' not available on this platform (extensions: GL_NV_vertex_program)");
      }
    }

    void vertex_attrib_4f_arb(gl::uint_t index, gl::float_t x, gl::float_t y, gl::float_t z, gl::float_t w) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib4fARB(index, x, y, z, w);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib4fARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_4f_nv(gl::uint_t index, gl::float_t x, gl::float_t y, gl::float_t z, gl::float_t w) {
      if ( GLAD_GL_NV_vertex_program ) {
        glVertexAttrib4fNV(index, x, y, z, w);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib4fNV' not available on this platform (extensions: GL_NV_vertex_program)");
      }
    }

    void vertex_attrib_4fv_arb(gl::uint_t index, const  gl::float_t * v) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib4fvARB(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib4fvARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_4fv_nv(gl::uint_t index, const  gl::float_t * v) {
      if ( GLAD_GL_NV_vertex_program ) {
        glVertexAttrib4fvNV(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib4fvNV' not available on this platform (extensions: GL_NV_vertex_program)");
      }
    }

    void vertex_attrib_4h_nv(gl::uint_t index, gl::halfNV_t x, gl::halfNV_t y, gl::halfNV_t z, gl::halfNV_t w) {
      if ( GLAD_GL_NV_half_float ) {
        glVertexAttrib4hNV(index, x, y, z, w);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib4hNV' not available on this platform (extensions: GL_NV_half_float)");
      }
    }

    void vertex_attrib_4hv_nv(gl::uint_t index, const  gl::halfNV_t * v) {
      if ( GLAD_GL_NV_half_float ) {
        glVertexAttrib4hvNV(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib4hvNV' not available on this platform (extensions: GL_NV_half_float)");
      }
    }

    void vertex_attrib_4iv_arb(gl::uint_t index, const  gl::int_t * v) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib4ivARB(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib4ivARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_4s_arb(gl::uint_t index, gl::short_t x, gl::short_t y, gl::short_t z, gl::short_t w) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib4sARB(index, x, y, z, w);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib4sARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_4s_nv(gl::uint_t index, gl::short_t x, gl::short_t y, gl::short_t z, gl::short_t w) {
      if ( GLAD_GL_NV_vertex_program ) {
        glVertexAttrib4sNV(index, x, y, z, w);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib4sNV' not available on this platform (extensions: GL_NV_vertex_program)");
      }
    }

    void vertex_attrib_4sv_arb(gl::uint_t index, const  gl::short_t * v) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib4svARB(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib4svARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_4sv_nv(gl::uint_t index, const  gl::short_t * v) {
      if ( GLAD_GL_NV_vertex_program ) {
        glVertexAttrib4svNV(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib4svNV' not available on this platform (extensions: GL_NV_vertex_program)");
      }
    }

    void vertex_attrib_4ub_nv(gl::uint_t index, gl::ubyte_t x, gl::ubyte_t y, gl::ubyte_t z, gl::ubyte_t w) {
      if ( GLAD_GL_NV_vertex_program ) {
        glVertexAttrib4ubNV(index, x, y, z, w);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib4ubNV' not available on this platform (extensions: GL_NV_vertex_program)");
      }
    }

    void vertex_attrib_4ubv_arb(gl::uint_t index, const  gl::ubyte_t * v) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib4ubvARB(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib4ubvARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_4ubv_nv(gl::uint_t index, const  gl::ubyte_t * v) {
      if ( GLAD_GL_NV_vertex_program ) {
        glVertexAttrib4ubvNV(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib4ubvNV' not available on this platform (extensions: GL_NV_vertex_program)");
      }
    }

    void vertex_attrib_4uiv_arb(gl::uint_t index, const  gl::uint_t * v) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib4uivARB(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib4uivARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_4usv_arb(gl::uint_t index, const  gl::ushort_t * v) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib4usvARB(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib4usvARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_array_object_ati(gl::uint_t index, gl::int_t size, vertex_attrib_pointer_type_t type, gl::boolean_t normalized, gl::sizei_t stride, gl::uint_t buffer, gl::uint_t offset) {
      if ( GLAD_GL_ATI_vertex_attrib_array_object ) {
        glVertexAttribArrayObjectATI(index, size, static_cast<GLenum>(type), normalized, stride, buffer, offset);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribArrayObjectATI' not available on this platform (extensions: GL_ATI_vertex_attrib_array_object)");
      }
    }

    void vertex_attrib_binding(gl::uint_t attribindex, gl::uint_t bindingindex) {
      if ( GLAD_GL_ARB_vertex_attrib_binding ) {
        glVertexAttribBinding(attribindex, bindingindex);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribBinding' not available on this platform (extensions: GL_ARB_vertex_attrib_binding)");
      }
    }

    void vertex_attrib_divisor_arb(gl::uint_t index, gl::uint_t divisor) {
      if ( GLAD_GL_ARB_instanced_arrays ) {
        glVertexAttribDivisorARB(index, divisor);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribDivisorARB' not available on this platform (extensions: GL_ARB_instanced_arrays)");
      }
    }

    void vertex_attrib_format(gl::uint_t attribindex, gl::int_t size, gl::enum_t type, gl::boolean_t normalized, gl::uint_t relativeoffset) {
      if ( GLAD_GL_ARB_vertex_attrib_binding ) {
        glVertexAttribFormat(attribindex, size, type, normalized, relativeoffset);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribFormat' not available on this platform (extensions: GL_ARB_vertex_attrib_binding)");
      }
    }

    void vertex_attrib_format_nv(gl::uint_t index, gl::int_t size, gl::enum_t type, gl::boolean_t normalized, gl::sizei_t stride) {
      if ( GLAD_GL_NV_vertex_buffer_unified_memory ) {
        glVertexAttribFormatNV(index, size, type, normalized, stride);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribFormatNV' not available on this platform (extensions: GL_NV_vertex_buffer_unified_memory)");
      }
    }

    void vertex_attrib_i1i_ext(gl::uint_t index, gl::int_t x) {
      if ( GLAD_GL_NV_vertex_program4 ) {
        glVertexAttribI1iEXT(index, x);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribI1iEXT' not available on this platform (extensions: GL_NV_vertex_program4)");
      }
    }

    void vertex_attrib_i1iv_ext(gl::uint_t index, const  gl::int_t * v) {
      if ( GLAD_GL_NV_vertex_program4 ) {
        glVertexAttribI1ivEXT(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribI1ivEXT' not available on this platform (extensions: GL_NV_vertex_program4)");
      }
    }

    void vertex_attrib_i1ui_ext(gl::uint_t index, gl::uint_t x) {
      if ( GLAD_GL_NV_vertex_program4 ) {
        glVertexAttribI1uiEXT(index, x);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribI1uiEXT' not available on this platform (extensions: GL_NV_vertex_program4)");
      }
    }

    void vertex_attrib_i1uiv_ext(gl::uint_t index, const  gl::uint_t * v) {
      if ( GLAD_GL_NV_vertex_program4 ) {
        glVertexAttribI1uivEXT(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribI1uivEXT' not available on this platform (extensions: GL_NV_vertex_program4)");
      }
    }

    void vertex_attrib_i2i_ext(gl::uint_t index, gl::int_t x, gl::int_t y) {
      if ( GLAD_GL_NV_vertex_program4 ) {
        glVertexAttribI2iEXT(index, x, y);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribI2iEXT' not available on this platform (extensions: GL_NV_vertex_program4)");
      }
    }

    void vertex_attrib_i2iv_ext(gl::uint_t index, const  gl::int_t * v) {
      if ( GLAD_GL_NV_vertex_program4 ) {
        glVertexAttribI2ivEXT(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribI2ivEXT' not available on this platform (extensions: GL_NV_vertex_program4)");
      }
    }

    void vertex_attrib_i2ui_ext(gl::uint_t index, gl::uint_t x, gl::uint_t y) {
      if ( GLAD_GL_NV_vertex_program4 ) {
        glVertexAttribI2uiEXT(index, x, y);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribI2uiEXT' not available on this platform (extensions: GL_NV_vertex_program4)");
      }
    }

    void vertex_attrib_i2uiv_ext(gl::uint_t index, const  gl::uint_t * v) {
      if ( GLAD_GL_NV_vertex_program4 ) {
        glVertexAttribI2uivEXT(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribI2uivEXT' not available on this platform (extensions: GL_NV_vertex_program4)");
      }
    }

    void vertex_attrib_i3i_ext(gl::uint_t index, gl::int_t x, gl::int_t y, gl::int_t z) {
      if ( GLAD_GL_NV_vertex_program4 ) {
        glVertexAttribI3iEXT(index, x, y, z);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribI3iEXT' not available on this platform (extensions: GL_NV_vertex_program4)");
      }
    }

    void vertex_attrib_i3iv_ext(gl::uint_t index, const  gl::int_t * v) {
      if ( GLAD_GL_NV_vertex_program4 ) {
        glVertexAttribI3ivEXT(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribI3ivEXT' not available on this platform (extensions: GL_NV_vertex_program4)");
      }
    }

    void vertex_attrib_i3ui_ext(gl::uint_t index, gl::uint_t x, gl::uint_t y, gl::uint_t z) {
      if ( GLAD_GL_NV_vertex_program4 ) {
        glVertexAttribI3uiEXT(index, x, y, z);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribI3uiEXT' not available on this platform (extensions: GL_NV_vertex_program4)");
      }
    }

    void vertex_attrib_i3uiv_ext(gl::uint_t index, const  gl::uint_t * v) {
      if ( GLAD_GL_NV_vertex_program4 ) {
        glVertexAttribI3uivEXT(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribI3uivEXT' not available on this platform (extensions: GL_NV_vertex_program4)");
      }
    }

    void vertex_attrib_i4bv_ext(gl::uint_t index, const  gl::byte_t * v) {
      if ( GLAD_GL_NV_vertex_program4 ) {
        glVertexAttribI4bvEXT(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribI4bvEXT' not available on this platform (extensions: GL_NV_vertex_program4)");
      }
    }

    void vertex_attrib_i4i_ext(gl::uint_t index, gl::int_t x, gl::int_t y, gl::int_t z, gl::int_t w) {
      if ( GLAD_GL_NV_vertex_program4 ) {
        glVertexAttribI4iEXT(index, x, y, z, w);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribI4iEXT' not available on this platform (extensions: GL_NV_vertex_program4)");
      }
    }

    void vertex_attrib_i4iv_ext(gl::uint_t index, const  gl::int_t * v) {
      if ( GLAD_GL_NV_vertex_program4 ) {
        glVertexAttribI4ivEXT(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribI4ivEXT' not available on this platform (extensions: GL_NV_vertex_program4)");
      }
    }

    void vertex_attrib_i4sv_ext(gl::uint_t index, const  gl::short_t * v) {
      if ( GLAD_GL_NV_vertex_program4 ) {
        glVertexAttribI4svEXT(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribI4svEXT' not available on this platform (extensions: GL_NV_vertex_program4)");
      }
    }

    void vertex_attrib_i4ubv_ext(gl::uint_t index, const  gl::ubyte_t * v) {
      if ( GLAD_GL_NV_vertex_program4 ) {
        glVertexAttribI4ubvEXT(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribI4ubvEXT' not available on this platform (extensions: GL_NV_vertex_program4)");
      }
    }

    void vertex_attrib_i4ui_ext(gl::uint_t index, gl::uint_t x, gl::uint_t y, gl::uint_t z, gl::uint_t w) {
      if ( GLAD_GL_NV_vertex_program4 ) {
        glVertexAttribI4uiEXT(index, x, y, z, w);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribI4uiEXT' not available on this platform (extensions: GL_NV_vertex_program4)");
      }
    }

    void vertex_attrib_i4uiv_ext(gl::uint_t index, const  gl::uint_t * v) {
      if ( GLAD_GL_NV_vertex_program4 ) {
        glVertexAttribI4uivEXT(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribI4uivEXT' not available on this platform (extensions: GL_NV_vertex_program4)");
      }
    }

    void vertex_attrib_i4usv_ext(gl::uint_t index, const  gl::ushort_t * v) {
      if ( GLAD_GL_NV_vertex_program4 ) {
        glVertexAttribI4usvEXT(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribI4usvEXT' not available on this platform (extensions: GL_NV_vertex_program4)");
      }
    }

    void vertex_attrib_i_format(gl::uint_t attribindex, gl::int_t size, gl::enum_t type, gl::uint_t relativeoffset) {
      if ( GLAD_GL_ARB_vertex_attrib_binding ) {
        glVertexAttribIFormat(attribindex, size, type, relativeoffset);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribIFormat' not available on this platform (extensions: GL_ARB_vertex_attrib_binding)");
      }
    }

    void vertex_attrib_i_format_nv(gl::uint_t index, gl::int_t size, gl::enum_t type, gl::sizei_t stride) {
      if ( GLAD_GL_NV_vertex_buffer_unified_memory ) {
        glVertexAttribIFormatNV(index, size, type, stride);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribIFormatNV' not available on this platform (extensions: GL_NV_vertex_buffer_unified_memory)");
      }
    }

    void vertex_attrib_i_pointer_ext(gl::uint_t index, gl::int_t size, gl::enum_t type, gl::sizei_t stride, const  void * pointer) {
      if ( GLAD_GL_NV_vertex_program4 ) {
        glVertexAttribIPointerEXT(index, size, type, stride, pointer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribIPointerEXT' not available on this platform (extensions: GL_NV_vertex_program4)");
      }
    }

    void vertex_attrib_l1d(gl::uint_t index, gl::double_t x) {
      if ( GLAD_GL_ARB_vertex_attrib_64bit ) {
        glVertexAttribL1d(index, x);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribL1d' not available on this platform (extensions: GL_ARB_vertex_attrib_64bit)");
      }
    }

    void vertex_attrib_l1d_ext(gl::uint_t index, gl::double_t x) {
      if ( GLAD_GL_EXT_vertex_attrib_64bit ) {
        glVertexAttribL1dEXT(index, x);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribL1dEXT' not available on this platform (extensions: GL_EXT_vertex_attrib_64bit)");
      }
    }

    void vertex_attrib_l1dv(gl::uint_t index, const  gl::double_t * v) {
      if ( GLAD_GL_ARB_vertex_attrib_64bit ) {
        glVertexAttribL1dv(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribL1dv' not available on this platform (extensions: GL_ARB_vertex_attrib_64bit)");
      }
    }

    void vertex_attrib_l1dv_ext(gl::uint_t index, const  gl::double_t * v) {
      if ( GLAD_GL_EXT_vertex_attrib_64bit ) {
        glVertexAttribL1dvEXT(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribL1dvEXT' not available on this platform (extensions: GL_EXT_vertex_attrib_64bit)");
      }
    }

    void vertex_attrib_l1i_64nv(gl::uint_t index, gl::int64EXT_t x) {
      if ( GLAD_GL_NV_vertex_attrib_integer_64bit ) {
        glVertexAttribL1i64NV(index, x);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribL1i64NV' not available on this platform (extensions: GL_NV_vertex_attrib_integer_64bit)");
      }
    }

    void vertex_attrib_l1i_64v_nv(gl::uint_t index, const  gl::int64EXT_t * v) {
      if ( GLAD_GL_NV_vertex_attrib_integer_64bit ) {
        glVertexAttribL1i64vNV(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribL1i64vNV' not available on this platform (extensions: GL_NV_vertex_attrib_integer_64bit)");
      }
    }

    void vertex_attrib_l1ui_64arb(gl::uint_t index, gl::uint64EXT_t x) {
      if ( GLAD_GL_ARB_bindless_texture ) {
        glVertexAttribL1ui64ARB(index, x);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribL1ui64ARB' not available on this platform (extensions: GL_ARB_bindless_texture)");
      }
    }

    void vertex_attrib_l1ui_64nv(gl::uint_t index, gl::uint64EXT_t x) {
      if ( GLAD_GL_NV_vertex_attrib_integer_64bit ) {
        glVertexAttribL1ui64NV(index, x);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribL1ui64NV' not available on this platform (extensions: GL_NV_vertex_attrib_integer_64bit)");
      }
    }

    void vertex_attrib_l1ui_64v_arb(gl::uint_t index, const  gl::uint64EXT_t * v) {
      if ( GLAD_GL_ARB_bindless_texture ) {
        glVertexAttribL1ui64vARB(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribL1ui64vARB' not available on this platform (extensions: GL_ARB_bindless_texture)");
      }
    }

    void vertex_attrib_l1ui_64v_nv(gl::uint_t index, const  gl::uint64EXT_t * v) {
      if ( GLAD_GL_NV_vertex_attrib_integer_64bit ) {
        glVertexAttribL1ui64vNV(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribL1ui64vNV' not available on this platform (extensions: GL_NV_vertex_attrib_integer_64bit)");
      }
    }

    void vertex_attrib_l2d(gl::uint_t index, gl::double_t x, gl::double_t y) {
      if ( GLAD_GL_ARB_vertex_attrib_64bit ) {
        glVertexAttribL2d(index, x, y);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribL2d' not available on this platform (extensions: GL_ARB_vertex_attrib_64bit)");
      }
    }

    void vertex_attrib_l2d_ext(gl::uint_t index, gl::double_t x, gl::double_t y) {
      if ( GLAD_GL_EXT_vertex_attrib_64bit ) {
        glVertexAttribL2dEXT(index, x, y);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribL2dEXT' not available on this platform (extensions: GL_EXT_vertex_attrib_64bit)");
      }
    }

    void vertex_attrib_l2dv(gl::uint_t index, const  gl::double_t * v) {
      if ( GLAD_GL_ARB_vertex_attrib_64bit ) {
        glVertexAttribL2dv(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribL2dv' not available on this platform (extensions: GL_ARB_vertex_attrib_64bit)");
      }
    }

    void vertex_attrib_l2dv_ext(gl::uint_t index, const  gl::double_t * v) {
      if ( GLAD_GL_EXT_vertex_attrib_64bit ) {
        glVertexAttribL2dvEXT(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribL2dvEXT' not available on this platform (extensions: GL_EXT_vertex_attrib_64bit)");
      }
    }

    void vertex_attrib_l2i_64nv(gl::uint_t index, gl::int64EXT_t x, gl::int64EXT_t y) {
      if ( GLAD_GL_NV_vertex_attrib_integer_64bit ) {
        glVertexAttribL2i64NV(index, x, y);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribL2i64NV' not available on this platform (extensions: GL_NV_vertex_attrib_integer_64bit)");
      }
    }

    void vertex_attrib_l2i_64v_nv(gl::uint_t index, const  gl::int64EXT_t * v) {
      if ( GLAD_GL_NV_vertex_attrib_integer_64bit ) {
        glVertexAttribL2i64vNV(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribL2i64vNV' not available on this platform (extensions: GL_NV_vertex_attrib_integer_64bit)");
      }
    }

    void vertex_attrib_l2ui_64nv(gl::uint_t index, gl::uint64EXT_t x, gl::uint64EXT_t y) {
      if ( GLAD_GL_NV_vertex_attrib_integer_64bit ) {
        glVertexAttribL2ui64NV(index, x, y);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribL2ui64NV' not available on this platform (extensions: GL_NV_vertex_attrib_integer_64bit)");
      }
    }

    void vertex_attrib_l2ui_64v_nv(gl::uint_t index, const  gl::uint64EXT_t * v) {
      if ( GLAD_GL_NV_vertex_attrib_integer_64bit ) {
        glVertexAttribL2ui64vNV(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribL2ui64vNV' not available on this platform (extensions: GL_NV_vertex_attrib_integer_64bit)");
      }
    }

    void vertex_attrib_l3d(gl::uint_t index, gl::double_t x, gl::double_t y, gl::double_t z) {
      if ( GLAD_GL_ARB_vertex_attrib_64bit ) {
        glVertexAttribL3d(index, x, y, z);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribL3d' not available on this platform (extensions: GL_ARB_vertex_attrib_64bit)");
      }
    }

    void vertex_attrib_l3d_ext(gl::uint_t index, gl::double_t x, gl::double_t y, gl::double_t z) {
      if ( GLAD_GL_EXT_vertex_attrib_64bit ) {
        glVertexAttribL3dEXT(index, x, y, z);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribL3dEXT' not available on this platform (extensions: GL_EXT_vertex_attrib_64bit)");
      }
    }

    void vertex_attrib_l3dv(gl::uint_t index, const  gl::double_t * v) {
      if ( GLAD_GL_ARB_vertex_attrib_64bit ) {
        glVertexAttribL3dv(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribL3dv' not available on this platform (extensions: GL_ARB_vertex_attrib_64bit)");
      }
    }

    void vertex_attrib_l3dv_ext(gl::uint_t index, const  gl::double_t * v) {
      if ( GLAD_GL_EXT_vertex_attrib_64bit ) {
        glVertexAttribL3dvEXT(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribL3dvEXT' not available on this platform (extensions: GL_EXT_vertex_attrib_64bit)");
      }
    }

    void vertex_attrib_l3i_64nv(gl::uint_t index, gl::int64EXT_t x, gl::int64EXT_t y, gl::int64EXT_t z) {
      if ( GLAD_GL_NV_vertex_attrib_integer_64bit ) {
        glVertexAttribL3i64NV(index, x, y, z);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribL3i64NV' not available on this platform (extensions: GL_NV_vertex_attrib_integer_64bit)");
      }
    }

    void vertex_attrib_l3i_64v_nv(gl::uint_t index, const  gl::int64EXT_t * v) {
      if ( GLAD_GL_NV_vertex_attrib_integer_64bit ) {
        glVertexAttribL3i64vNV(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribL3i64vNV' not available on this platform (extensions: GL_NV_vertex_attrib_integer_64bit)");
      }
    }

    void vertex_attrib_l3ui_64nv(gl::uint_t index, gl::uint64EXT_t x, gl::uint64EXT_t y, gl::uint64EXT_t z) {
      if ( GLAD_GL_NV_vertex_attrib_integer_64bit ) {
        glVertexAttribL3ui64NV(index, x, y, z);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribL3ui64NV' not available on this platform (extensions: GL_NV_vertex_attrib_integer_64bit)");
      }
    }

    void vertex_attrib_l3ui_64v_nv(gl::uint_t index, const  gl::uint64EXT_t * v) {
      if ( GLAD_GL_NV_vertex_attrib_integer_64bit ) {
        glVertexAttribL3ui64vNV(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribL3ui64vNV' not available on this platform (extensions: GL_NV_vertex_attrib_integer_64bit)");
      }
    }

    void vertex_attrib_l4d(gl::uint_t index, gl::double_t x, gl::double_t y, gl::double_t z, gl::double_t w) {
      if ( GLAD_GL_ARB_vertex_attrib_64bit ) {
        glVertexAttribL4d(index, x, y, z, w);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribL4d' not available on this platform (extensions: GL_ARB_vertex_attrib_64bit)");
      }
    }

    void vertex_attrib_l4d_ext(gl::uint_t index, gl::double_t x, gl::double_t y, gl::double_t z, gl::double_t w) {
      if ( GLAD_GL_EXT_vertex_attrib_64bit ) {
        glVertexAttribL4dEXT(index, x, y, z, w);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribL4dEXT' not available on this platform (extensions: GL_EXT_vertex_attrib_64bit)");
      }
    }

    void vertex_attrib_l4dv(gl::uint_t index, const  gl::double_t * v) {
      if ( GLAD_GL_ARB_vertex_attrib_64bit ) {
        glVertexAttribL4dv(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribL4dv' not available on this platform (extensions: GL_ARB_vertex_attrib_64bit)");
      }
    }

    void vertex_attrib_l4dv_ext(gl::uint_t index, const  gl::double_t * v) {
      if ( GLAD_GL_EXT_vertex_attrib_64bit ) {
        glVertexAttribL4dvEXT(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribL4dvEXT' not available on this platform (extensions: GL_EXT_vertex_attrib_64bit)");
      }
    }

    void vertex_attrib_l4i_64nv(gl::uint_t index, gl::int64EXT_t x, gl::int64EXT_t y, gl::int64EXT_t z, gl::int64EXT_t w) {
      if ( GLAD_GL_NV_vertex_attrib_integer_64bit ) {
        glVertexAttribL4i64NV(index, x, y, z, w);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribL4i64NV' not available on this platform (extensions: GL_NV_vertex_attrib_integer_64bit)");
      }
    }

    void vertex_attrib_l4i_64v_nv(gl::uint_t index, const  gl::int64EXT_t * v) {
      if ( GLAD_GL_NV_vertex_attrib_integer_64bit ) {
        glVertexAttribL4i64vNV(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribL4i64vNV' not available on this platform (extensions: GL_NV_vertex_attrib_integer_64bit)");
      }
    }

    void vertex_attrib_l4ui_64nv(gl::uint_t index, gl::uint64EXT_t x, gl::uint64EXT_t y, gl::uint64EXT_t z, gl::uint64EXT_t w) {
      if ( GLAD_GL_NV_vertex_attrib_integer_64bit ) {
        glVertexAttribL4ui64NV(index, x, y, z, w);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribL4ui64NV' not available on this platform (extensions: GL_NV_vertex_attrib_integer_64bit)");
      }
    }

    void vertex_attrib_l4ui_64v_nv(gl::uint_t index, const  gl::uint64EXT_t * v) {
      if ( GLAD_GL_NV_vertex_attrib_integer_64bit ) {
        glVertexAttribL4ui64vNV(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribL4ui64vNV' not available on this platform (extensions: GL_NV_vertex_attrib_integer_64bit)");
      }
    }

    void vertex_attrib_l_format(gl::uint_t attribindex, gl::int_t size, gl::enum_t type, gl::uint_t relativeoffset) {
      if ( GLAD_GL_ARB_vertex_attrib_binding ) {
        glVertexAttribLFormat(attribindex, size, type, relativeoffset);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribLFormat' not available on this platform (extensions: GL_ARB_vertex_attrib_binding)");
      }
    }

    void vertex_attrib_l_format_nv(gl::uint_t index, gl::int_t size, gl::enum_t type, gl::sizei_t stride) {
      if ( GLAD_GL_NV_vertex_attrib_integer_64bit ) {
        glVertexAttribLFormatNV(index, size, type, stride);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribLFormatNV' not available on this platform (extensions: GL_NV_vertex_attrib_integer_64bit)");
      }
    }

    void vertex_attrib_l_pointer(gl::uint_t index, gl::int_t size, gl::enum_t type, gl::sizei_t stride, const  void * pointer) {
      if ( GLAD_GL_ARB_vertex_attrib_64bit ) {
        glVertexAttribLPointer(index, size, type, stride, pointer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribLPointer' not available on this platform (extensions: GL_ARB_vertex_attrib_64bit)");
      }
    }

    void vertex_attrib_l_pointer_ext(gl::uint_t index, gl::int_t size, gl::enum_t type, gl::sizei_t stride, const  void * pointer) {
      if ( GLAD_GL_EXT_vertex_attrib_64bit ) {
        glVertexAttribLPointerEXT(index, size, type, stride, pointer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribLPointerEXT' not available on this platform (extensions: GL_EXT_vertex_attrib_64bit)");
      }
    }

    void vertex_attrib_p1ui(gl::uint_t index, gl::enum_t type, gl::boolean_t normalized, gl::uint_t value) {
      if ( GLAD_GL_ARB_vertex_type_2_10_10_10_rev ) {
        glVertexAttribP1ui(index, type, normalized, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribP1ui' not available on this platform (extensions: GL_ARB_vertex_type_2_10_10_10_rev)");
      }
    }

    void vertex_attrib_p1uiv(gl::uint_t index, gl::enum_t type, gl::boolean_t normalized, const  gl::uint_t * value) {
      if ( GLAD_GL_ARB_vertex_type_2_10_10_10_rev ) {
        glVertexAttribP1uiv(index, type, normalized, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribP1uiv' not available on this platform (extensions: GL_ARB_vertex_type_2_10_10_10_rev)");
      }
    }

    void vertex_attrib_p2ui(gl::uint_t index, gl::enum_t type, gl::boolean_t normalized, gl::uint_t value) {
      if ( GLAD_GL_ARB_vertex_type_2_10_10_10_rev ) {
        glVertexAttribP2ui(index, type, normalized, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribP2ui' not available on this platform (extensions: GL_ARB_vertex_type_2_10_10_10_rev)");
      }
    }

    void vertex_attrib_p2uiv(gl::uint_t index, gl::enum_t type, gl::boolean_t normalized, const  gl::uint_t * value) {
      if ( GLAD_GL_ARB_vertex_type_2_10_10_10_rev ) {
        glVertexAttribP2uiv(index, type, normalized, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribP2uiv' not available on this platform (extensions: GL_ARB_vertex_type_2_10_10_10_rev)");
      }
    }

    void vertex_attrib_p3ui(gl::uint_t index, gl::enum_t type, gl::boolean_t normalized, gl::uint_t value) {
      if ( GLAD_GL_ARB_vertex_type_2_10_10_10_rev ) {
        glVertexAttribP3ui(index, type, normalized, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribP3ui' not available on this platform (extensions: GL_ARB_vertex_type_2_10_10_10_rev)");
      }
    }

    void vertex_attrib_p3uiv(gl::uint_t index, gl::enum_t type, gl::boolean_t normalized, const  gl::uint_t * value) {
      if ( GLAD_GL_ARB_vertex_type_2_10_10_10_rev ) {
        glVertexAttribP3uiv(index, type, normalized, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribP3uiv' not available on this platform (extensions: GL_ARB_vertex_type_2_10_10_10_rev)");
      }
    }

    void vertex_attrib_p4ui(gl::uint_t index, gl::enum_t type, gl::boolean_t normalized, gl::uint_t value) {
      if ( GLAD_GL_ARB_vertex_type_2_10_10_10_rev ) {
        glVertexAttribP4ui(index, type, normalized, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribP4ui' not available on this platform (extensions: GL_ARB_vertex_type_2_10_10_10_rev)");
      }
    }

    void vertex_attrib_p4uiv(gl::uint_t index, gl::enum_t type, gl::boolean_t normalized, const  gl::uint_t * value) {
      if ( GLAD_GL_ARB_vertex_type_2_10_10_10_rev ) {
        glVertexAttribP4uiv(index, type, normalized, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribP4uiv' not available on this platform (extensions: GL_ARB_vertex_type_2_10_10_10_rev)");
      }
    }

    void vertex_attrib_parameteri_amd(gl::uint_t index, gl::enum_t pname, gl::int_t param) {
      if ( GLAD_GL_AMD_interleaved_elements ) {
        glVertexAttribParameteriAMD(index, pname, param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribParameteriAMD' not available on this platform (extensions: GL_AMD_interleaved_elements)");
      }
    }

    void vertex_attrib_pointer_arb(gl::uint_t index, gl::int_t size, vertex_attrib_pointer_type_t type, gl::boolean_t normalized, gl::sizei_t stride, const  void * pointer) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttribPointerARB(index, size, static_cast<GLenum>(type), normalized, stride, pointer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribPointerARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_pointer_nv(gl::uint_t index, gl::int_t fsize, vertex_attrib_pointer_type_t type, gl::sizei_t stride, const  void * pointer) {
      if ( GLAD_GL_NV_vertex_program ) {
        glVertexAttribPointerNV(index, fsize, static_cast<GLenum>(type), stride, pointer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribPointerNV' not available on this platform (extensions: GL_NV_vertex_program)");
      }
    }

    void vertex_attribs_1dv_nv(gl::uint_t index, gl::sizei_t count, const  gl::double_t * v) {
      if ( GLAD_GL_NV_vertex_program ) {
        glVertexAttribs1dvNV(index, count, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribs1dvNV' not available on this platform (extensions: GL_NV_vertex_program)");
      }
    }

    void vertex_attribs_1fv_nv(gl::uint_t index, gl::sizei_t count, const  gl::float_t * v) {
      if ( GLAD_GL_NV_vertex_program ) {
        glVertexAttribs1fvNV(index, count, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribs1fvNV' not available on this platform (extensions: GL_NV_vertex_program)");
      }
    }

    void vertex_attribs_1hv_nv(gl::uint_t index, gl::sizei_t n, const  gl::halfNV_t * v) {
      if ( GLAD_GL_NV_half_float ) {
        glVertexAttribs1hvNV(index, n, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribs1hvNV' not available on this platform (extensions: GL_NV_half_float)");
      }
    }

    void vertex_attribs_1sv_nv(gl::uint_t index, gl::sizei_t count, const  gl::short_t * v) {
      if ( GLAD_GL_NV_vertex_program ) {
        glVertexAttribs1svNV(index, count, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribs1svNV' not available on this platform (extensions: GL_NV_vertex_program)");
      }
    }

    void vertex_attribs_2dv_nv(gl::uint_t index, gl::sizei_t count, const  gl::double_t * v) {
      if ( GLAD_GL_NV_vertex_program ) {
        glVertexAttribs2dvNV(index, count, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribs2dvNV' not available on this platform (extensions: GL_NV_vertex_program)");
      }
    }

    void vertex_attribs_2fv_nv(gl::uint_t index, gl::sizei_t count, const  gl::float_t * v) {
      if ( GLAD_GL_NV_vertex_program ) {
        glVertexAttribs2fvNV(index, count, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribs2fvNV' not available on this platform (extensions: GL_NV_vertex_program)");
      }
    }

    void vertex_attribs_2hv_nv(gl::uint_t index, gl::sizei_t n, const  gl::halfNV_t * v) {
      if ( GLAD_GL_NV_half_float ) {
        glVertexAttribs2hvNV(index, n, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribs2hvNV' not available on this platform (extensions: GL_NV_half_float)");
      }
    }

    void vertex_attribs_2sv_nv(gl::uint_t index, gl::sizei_t count, const  gl::short_t * v) {
      if ( GLAD_GL_NV_vertex_program ) {
        glVertexAttribs2svNV(index, count, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribs2svNV' not available on this platform (extensions: GL_NV_vertex_program)");
      }
    }

    void vertex_attribs_3dv_nv(gl::uint_t index, gl::sizei_t count, const  gl::double_t * v) {
      if ( GLAD_GL_NV_vertex_program ) {
        glVertexAttribs3dvNV(index, count, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribs3dvNV' not available on this platform (extensions: GL_NV_vertex_program)");
      }
    }

    void vertex_attribs_3fv_nv(gl::uint_t index, gl::sizei_t count, const  gl::float_t * v) {
      if ( GLAD_GL_NV_vertex_program ) {
        glVertexAttribs3fvNV(index, count, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribs3fvNV' not available on this platform (extensions: GL_NV_vertex_program)");
      }
    }

    void vertex_attribs_3hv_nv(gl::uint_t index, gl::sizei_t n, const  gl::halfNV_t * v) {
      if ( GLAD_GL_NV_half_float ) {
        glVertexAttribs3hvNV(index, n, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribs3hvNV' not available on this platform (extensions: GL_NV_half_float)");
      }
    }

    void vertex_attribs_3sv_nv(gl::uint_t index, gl::sizei_t count, const  gl::short_t * v) {
      if ( GLAD_GL_NV_vertex_program ) {
        glVertexAttribs3svNV(index, count, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribs3svNV' not available on this platform (extensions: GL_NV_vertex_program)");
      }
    }

    void vertex_attribs_4dv_nv(gl::uint_t index, gl::sizei_t count, const  gl::double_t * v) {
      if ( GLAD_GL_NV_vertex_program ) {
        glVertexAttribs4dvNV(index, count, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribs4dvNV' not available on this platform (extensions: GL_NV_vertex_program)");
      }
    }

    void vertex_attribs_4fv_nv(gl::uint_t index, gl::sizei_t count, const  gl::float_t * v) {
      if ( GLAD_GL_NV_vertex_program ) {
        glVertexAttribs4fvNV(index, count, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribs4fvNV' not available on this platform (extensions: GL_NV_vertex_program)");
      }
    }

    void vertex_attribs_4hv_nv(gl::uint_t index, gl::sizei_t n, const  gl::halfNV_t * v) {
      if ( GLAD_GL_NV_half_float ) {
        glVertexAttribs4hvNV(index, n, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribs4hvNV' not available on this platform (extensions: GL_NV_half_float)");
      }
    }

    void vertex_attribs_4sv_nv(gl::uint_t index, gl::sizei_t count, const  gl::short_t * v) {
      if ( GLAD_GL_NV_vertex_program ) {
        glVertexAttribs4svNV(index, count, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribs4svNV' not available on this platform (extensions: GL_NV_vertex_program)");
      }
    }

    void vertex_attribs_4ubv_nv(gl::uint_t index, gl::sizei_t count, const  gl::ubyte_t * v) {
      if ( GLAD_GL_NV_vertex_program ) {
        glVertexAttribs4ubvNV(index, count, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribs4ubvNV' not available on this platform (extensions: GL_NV_vertex_program)");
      }
    }

    void vertex_binding_divisor(gl::uint_t bindingindex, gl::uint_t divisor) {
      if ( GLAD_GL_ARB_vertex_attrib_binding ) {
        glVertexBindingDivisor(bindingindex, divisor);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexBindingDivisor' not available on this platform (extensions: GL_ARB_vertex_attrib_binding)");
      }
    }

    void vertex_blend_arb(gl::int_t count) {
      if ( GLAD_GL_ARB_vertex_blend ) {
        glVertexBlendARB(count);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexBlendARB' not available on this platform (extensions: GL_ARB_vertex_blend)");
      }
    }

    void vertex_blend_envf_ati(gl::enum_t pname, gl::float_t param) {
      if ( GLAD_GL_ATI_vertex_streams ) {
        glVertexBlendEnvfATI(pname, param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexBlendEnvfATI' not available on this platform (extensions: GL_ATI_vertex_streams)");
      }
    }

    void vertex_blend_envi_ati(gl::enum_t pname, gl::int_t param) {
      if ( GLAD_GL_ATI_vertex_streams ) {
        glVertexBlendEnviATI(pname, param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexBlendEnviATI' not available on this platform (extensions: GL_ATI_vertex_streams)");
      }
    }

    void vertex_format_nv(gl::int_t size, gl::enum_t type, gl::sizei_t stride) {
      if ( GLAD_GL_NV_vertex_buffer_unified_memory ) {
        glVertexFormatNV(size, type, stride);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexFormatNV' not available on this platform (extensions: GL_NV_vertex_buffer_unified_memory)");
      }
    }

    void vertex_p2ui(gl::enum_t type, gl::uint_t value) {
      if ( GLAD_GL_ARB_vertex_type_2_10_10_10_rev ) {
        glVertexP2ui(type, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexP2ui' not available on this platform (extensions: GL_ARB_vertex_type_2_10_10_10_rev)");
      }
    }

    void vertex_p2uiv(gl::enum_t type, const  gl::uint_t * value) {
      if ( GLAD_GL_ARB_vertex_type_2_10_10_10_rev ) {
        glVertexP2uiv(type, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexP2uiv' not available on this platform (extensions: GL_ARB_vertex_type_2_10_10_10_rev)");
      }
    }

    void vertex_p3ui(gl::enum_t type, gl::uint_t value) {
      if ( GLAD_GL_ARB_vertex_type_2_10_10_10_rev ) {
        glVertexP3ui(type, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexP3ui' not available on this platform (extensions: GL_ARB_vertex_type_2_10_10_10_rev)");
      }
    }

    void vertex_p3uiv(gl::enum_t type, const  gl::uint_t * value) {
      if ( GLAD_GL_ARB_vertex_type_2_10_10_10_rev ) {
        glVertexP3uiv(type, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexP3uiv' not available on this platform (extensions: GL_ARB_vertex_type_2_10_10_10_rev)");
      }
    }

    void vertex_p4ui(gl::enum_t type, gl::uint_t value) {
      if ( GLAD_GL_ARB_vertex_type_2_10_10_10_rev ) {
        glVertexP4ui(type, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexP4ui' not available on this platform (extensions: GL_ARB_vertex_type_2_10_10_10_rev)");
      }
    }

    void vertex_p4uiv(gl::enum_t type, const  gl::uint_t * value) {
      if ( GLAD_GL_ARB_vertex_type_2_10_10_10_rev ) {
        glVertexP4uiv(type, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexP4uiv' not available on this platform (extensions: GL_ARB_vertex_type_2_10_10_10_rev)");
      }
    }

    void vertex_pointer_ext(gl::int_t size, vertex_pointer_type_t type, gl::sizei_t stride, gl::sizei_t count, const  void * pointer) {
      if ( GLAD_GL_EXT_vertex_array ) {
        glVertexPointerEXT(size, static_cast<GLenum>(type), stride, count, pointer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexPointerEXT' not available on this platform (extensions: GL_EXT_vertex_array)");
      }
    }

    void vertex_pointer_list_ibm(gl::int_t size, vertex_pointer_type_t type, gl::int_t stride, const  void ** pointer, gl::int_t ptrstride) {
      if ( GLAD_GL_IBM_vertex_array_lists ) {
        glVertexPointerListIBM(size, static_cast<GLenum>(type), stride, pointer, ptrstride);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexPointerListIBM' not available on this platform (extensions: GL_IBM_vertex_array_lists)");
      }
    }

    void vertex_pointerv_intel(gl::int_t size, vertex_pointer_type_t type, const  void ** pointer) {
      if ( GLAD_GL_INTEL_parallel_arrays ) {
        glVertexPointervINTEL(size, static_cast<GLenum>(type), pointer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexPointervINTEL' not available on this platform (extensions: GL_INTEL_parallel_arrays)");
      }
    }

    void vertex_stream_1d_ati(gl::enum_t stream, gl::double_t x) {
      if ( GLAD_GL_ATI_vertex_streams ) {
        glVertexStream1dATI(stream, x);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexStream1dATI' not available on this platform (extensions: GL_ATI_vertex_streams)");
      }
    }

    void vertex_stream_1dv_ati(gl::enum_t stream, const  gl::double_t * coords) {
      if ( GLAD_GL_ATI_vertex_streams ) {
        glVertexStream1dvATI(stream, coords);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexStream1dvATI' not available on this platform (extensions: GL_ATI_vertex_streams)");
      }
    }

    void vertex_stream_1f_ati(gl::enum_t stream, gl::float_t x) {
      if ( GLAD_GL_ATI_vertex_streams ) {
        glVertexStream1fATI(stream, x);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexStream1fATI' not available on this platform (extensions: GL_ATI_vertex_streams)");
      }
    }

    void vertex_stream_1fv_ati(gl::enum_t stream, const  gl::float_t * coords) {
      if ( GLAD_GL_ATI_vertex_streams ) {
        glVertexStream1fvATI(stream, coords);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexStream1fvATI' not available on this platform (extensions: GL_ATI_vertex_streams)");
      }
    }

    void vertex_stream_1i_ati(gl::enum_t stream, gl::int_t x) {
      if ( GLAD_GL_ATI_vertex_streams ) {
        glVertexStream1iATI(stream, x);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexStream1iATI' not available on this platform (extensions: GL_ATI_vertex_streams)");
      }
    }

    void vertex_stream_1iv_ati(gl::enum_t stream, const  gl::int_t * coords) {
      if ( GLAD_GL_ATI_vertex_streams ) {
        glVertexStream1ivATI(stream, coords);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexStream1ivATI' not available on this platform (extensions: GL_ATI_vertex_streams)");
      }
    }

    void vertex_stream_1s_ati(gl::enum_t stream, gl::short_t x) {
      if ( GLAD_GL_ATI_vertex_streams ) {
        glVertexStream1sATI(stream, x);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexStream1sATI' not available on this platform (extensions: GL_ATI_vertex_streams)");
      }
    }

    void vertex_stream_1sv_ati(gl::enum_t stream, const  gl::short_t * coords) {
      if ( GLAD_GL_ATI_vertex_streams ) {
        glVertexStream1svATI(stream, coords);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexStream1svATI' not available on this platform (extensions: GL_ATI_vertex_streams)");
      }
    }

    void vertex_stream_2d_ati(gl::enum_t stream, gl::double_t x, gl::double_t y) {
      if ( GLAD_GL_ATI_vertex_streams ) {
        glVertexStream2dATI(stream, x, y);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexStream2dATI' not available on this platform (extensions: GL_ATI_vertex_streams)");
      }
    }

    void vertex_stream_2dv_ati(gl::enum_t stream, const  gl::double_t * coords) {
      if ( GLAD_GL_ATI_vertex_streams ) {
        glVertexStream2dvATI(stream, coords);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexStream2dvATI' not available on this platform (extensions: GL_ATI_vertex_streams)");
      }
    }

    void vertex_stream_2f_ati(gl::enum_t stream, gl::float_t x, gl::float_t y) {
      if ( GLAD_GL_ATI_vertex_streams ) {
        glVertexStream2fATI(stream, x, y);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexStream2fATI' not available on this platform (extensions: GL_ATI_vertex_streams)");
      }
    }

    void vertex_stream_2fv_ati(gl::enum_t stream, const  gl::float_t * coords) {
      if ( GLAD_GL_ATI_vertex_streams ) {
        glVertexStream2fvATI(stream, coords);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexStream2fvATI' not available on this platform (extensions: GL_ATI_vertex_streams)");
      }
    }

    void vertex_stream_2i_ati(gl::enum_t stream, gl::int_t x, gl::int_t y) {
      if ( GLAD_GL_ATI_vertex_streams ) {
        glVertexStream2iATI(stream, x, y);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexStream2iATI' not available on this platform (extensions: GL_ATI_vertex_streams)");
      }
    }

    void vertex_stream_2iv_ati(gl::enum_t stream, const  gl::int_t * coords) {
      if ( GLAD_GL_ATI_vertex_streams ) {
        glVertexStream2ivATI(stream, coords);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexStream2ivATI' not available on this platform (extensions: GL_ATI_vertex_streams)");
      }
    }

    void vertex_stream_2s_ati(gl::enum_t stream, gl::short_t x, gl::short_t y) {
      if ( GLAD_GL_ATI_vertex_streams ) {
        glVertexStream2sATI(stream, x, y);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexStream2sATI' not available on this platform (extensions: GL_ATI_vertex_streams)");
      }
    }

    void vertex_stream_2sv_ati(gl::enum_t stream, const  gl::short_t * coords) {
      if ( GLAD_GL_ATI_vertex_streams ) {
        glVertexStream2svATI(stream, coords);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexStream2svATI' not available on this platform (extensions: GL_ATI_vertex_streams)");
      }
    }

    void vertex_stream_3d_ati(gl::enum_t stream, gl::double_t x, gl::double_t y, gl::double_t z) {
      if ( GLAD_GL_ATI_vertex_streams ) {
        glVertexStream3dATI(stream, x, y, z);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexStream3dATI' not available on this platform (extensions: GL_ATI_vertex_streams)");
      }
    }

    void vertex_stream_3dv_ati(gl::enum_t stream, const  gl::double_t * coords) {
      if ( GLAD_GL_ATI_vertex_streams ) {
        glVertexStream3dvATI(stream, coords);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexStream3dvATI' not available on this platform (extensions: GL_ATI_vertex_streams)");
      }
    }

    void vertex_stream_3f_ati(gl::enum_t stream, gl::float_t x, gl::float_t y, gl::float_t z) {
      if ( GLAD_GL_ATI_vertex_streams ) {
        glVertexStream3fATI(stream, x, y, z);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexStream3fATI' not available on this platform (extensions: GL_ATI_vertex_streams)");
      }
    }

    void vertex_stream_3fv_ati(gl::enum_t stream, const  gl::float_t * coords) {
      if ( GLAD_GL_ATI_vertex_streams ) {
        glVertexStream3fvATI(stream, coords);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexStream3fvATI' not available on this platform (extensions: GL_ATI_vertex_streams)");
      }
    }

    void vertex_stream_3i_ati(gl::enum_t stream, gl::int_t x, gl::int_t y, gl::int_t z) {
      if ( GLAD_GL_ATI_vertex_streams ) {
        glVertexStream3iATI(stream, x, y, z);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexStream3iATI' not available on this platform (extensions: GL_ATI_vertex_streams)");
      }
    }

    void vertex_stream_3iv_ati(gl::enum_t stream, const  gl::int_t * coords) {
      if ( GLAD_GL_ATI_vertex_streams ) {
        glVertexStream3ivATI(stream, coords);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexStream3ivATI' not available on this platform (extensions: GL_ATI_vertex_streams)");
      }
    }

    void vertex_stream_3s_ati(gl::enum_t stream, gl::short_t x, gl::short_t y, gl::short_t z) {
      if ( GLAD_GL_ATI_vertex_streams ) {
        glVertexStream3sATI(stream, x, y, z);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexStream3sATI' not available on this platform (extensions: GL_ATI_vertex_streams)");
      }
    }

    void vertex_stream_3sv_ati(gl::enum_t stream, const  gl::short_t * coords) {
      if ( GLAD_GL_ATI_vertex_streams ) {
        glVertexStream3svATI(stream, coords);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexStream3svATI' not available on this platform (extensions: GL_ATI_vertex_streams)");
      }
    }

    void vertex_stream_4d_ati(gl::enum_t stream, gl::double_t x, gl::double_t y, gl::double_t z, gl::double_t w) {
      if ( GLAD_GL_ATI_vertex_streams ) {
        glVertexStream4dATI(stream, x, y, z, w);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexStream4dATI' not available on this platform (extensions: GL_ATI_vertex_streams)");
      }
    }

    void vertex_stream_4dv_ati(gl::enum_t stream, const  gl::double_t * coords) {
      if ( GLAD_GL_ATI_vertex_streams ) {
        glVertexStream4dvATI(stream, coords);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexStream4dvATI' not available on this platform (extensions: GL_ATI_vertex_streams)");
      }
    }

    void vertex_stream_4f_ati(gl::enum_t stream, gl::float_t x, gl::float_t y, gl::float_t z, gl::float_t w) {
      if ( GLAD_GL_ATI_vertex_streams ) {
        glVertexStream4fATI(stream, x, y, z, w);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexStream4fATI' not available on this platform (extensions: GL_ATI_vertex_streams)");
      }
    }

    void vertex_stream_4fv_ati(gl::enum_t stream, const  gl::float_t * coords) {
      if ( GLAD_GL_ATI_vertex_streams ) {
        glVertexStream4fvATI(stream, coords);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexStream4fvATI' not available on this platform (extensions: GL_ATI_vertex_streams)");
      }
    }

    void vertex_stream_4i_ati(gl::enum_t stream, gl::int_t x, gl::int_t y, gl::int_t z, gl::int_t w) {
      if ( GLAD_GL_ATI_vertex_streams ) {
        glVertexStream4iATI(stream, x, y, z, w);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexStream4iATI' not available on this platform (extensions: GL_ATI_vertex_streams)");
      }
    }

    void vertex_stream_4iv_ati(gl::enum_t stream, const  gl::int_t * coords) {
      if ( GLAD_GL_ATI_vertex_streams ) {
        glVertexStream4ivATI(stream, coords);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexStream4ivATI' not available on this platform (extensions: GL_ATI_vertex_streams)");
      }
    }

    void vertex_stream_4s_ati(gl::enum_t stream, gl::short_t x, gl::short_t y, gl::short_t z, gl::short_t w) {
      if ( GLAD_GL_ATI_vertex_streams ) {
        glVertexStream4sATI(stream, x, y, z, w);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexStream4sATI' not available on this platform (extensions: GL_ATI_vertex_streams)");
      }
    }

    void vertex_stream_4sv_ati(gl::enum_t stream, const  gl::short_t * coords) {
      if ( GLAD_GL_ATI_vertex_streams ) {
        glVertexStream4svATI(stream, coords);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexStream4svATI' not available on this platform (extensions: GL_ATI_vertex_streams)");
      }
    }

    void vertex_weight_pointer_ext(gl::int_t size, gl::enum_t type, gl::sizei_t stride, const  void * pointer) {
      if ( GLAD_GL_EXT_vertex_weighting ) {
        glVertexWeightPointerEXT(size, type, stride, pointer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexWeightPointerEXT' not available on this platform (extensions: GL_EXT_vertex_weighting)");
      }
    }

    void vertex_weightf_ext(gl::float_t weight) {
      if ( GLAD_GL_EXT_vertex_weighting ) {
        glVertexWeightfEXT(weight);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexWeightfEXT' not available on this platform (extensions: GL_EXT_vertex_weighting)");
      }
    }

    void vertex_weightfv_ext(const  gl::float_t * weight) {
      if ( GLAD_GL_EXT_vertex_weighting ) {
        glVertexWeightfvEXT(weight);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexWeightfvEXT' not available on this platform (extensions: GL_EXT_vertex_weighting)");
      }
    }

    void vertex_weighth_nv(gl::halfNV_t weight) {
      if ( GLAD_GL_NV_half_float ) {
        glVertexWeighthNV(weight);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexWeighthNV' not available on this platform (extensions: GL_NV_half_float)");
      }
    }

    void vertex_weighthv_nv(const  gl::halfNV_t * weight) {
      if ( GLAD_GL_NV_half_float ) {
        glVertexWeighthvNV(weight);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexWeighthvNV' not available on this platform (extensions: GL_NV_half_float)");
      }
    }

    gl::enum_t video_capture_nv(gl::uint_t video_capture_slot, gl::uint_t * sequence_num, gl::uint64EXT_t * capture_time) {
      if ( GLAD_GL_NV_video_capture ) {
        return glVideoCaptureNV(video_capture_slot, sequence_num, capture_time);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVideoCaptureNV' not available on this platform (extensions: GL_NV_video_capture)");
      }
    }

    void video_capture_stream_parameterdv_nv(gl::uint_t video_capture_slot, gl::uint_t stream, gl::enum_t pname, const  gl::double_t * params) {
      if ( GLAD_GL_NV_video_capture ) {
        glVideoCaptureStreamParameterdvNV(video_capture_slot, stream, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVideoCaptureStreamParameterdvNV' not available on this platform (extensions: GL_NV_video_capture)");
      }
    }

    void video_capture_stream_parameterfv_nv(gl::uint_t video_capture_slot, gl::uint_t stream, gl::enum_t pname, const  gl::float_t * params) {
      if ( GLAD_GL_NV_video_capture ) {
        glVideoCaptureStreamParameterfvNV(video_capture_slot, stream, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVideoCaptureStreamParameterfvNV' not available on this platform (extensions: GL_NV_video_capture)");
      }
    }

    void video_capture_stream_parameteriv_nv(gl::uint_t video_capture_slot, gl::uint_t stream, gl::enum_t pname, const  gl::int_t * params) {
      if ( GLAD_GL_NV_video_capture ) {
        glVideoCaptureStreamParameterivNV(video_capture_slot, stream, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVideoCaptureStreamParameterivNV' not available on this platform (extensions: GL_NV_video_capture)");
      }
    }

    void viewport_arrayv(gl::uint_t first, gl::sizei_t count, const  gl::float_t * v) {
      if ( GLAD_GL_ARB_viewport_array ) {
        glViewportArrayv(first, count, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glViewportArrayv' not available on this platform (extensions: GL_ARB_viewport_array)");
      }
    }

    void viewport_indexedf(gl::uint_t index, gl::float_t x, gl::float_t y, gl::float_t w, gl::float_t h) {
      if ( GLAD_GL_ARB_viewport_array ) {
        glViewportIndexedf(index, x, y, w, h);
      }
      else {
        throw std::runtime_error("OpenGL command 'glViewportIndexedf' not available on this platform (extensions: GL_ARB_viewport_array)");
      }
    }

    void viewport_indexedfv(gl::uint_t index, const  gl::float_t * v) {
      if ( GLAD_GL_ARB_viewport_array ) {
        glViewportIndexedfv(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glViewportIndexedfv' not available on this platform (extensions: GL_ARB_viewport_array)");
      }
    }

    void wait_sync(gl::sync_t sync, gl::bitfield_t flags, gl::uint64_t timeout) {
      if ( GLAD_GL_ARB_sync ) {
        glWaitSync(sync, flags, timeout);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWaitSync' not available on this platform (extensions: GL_ARB_sync)");
      }
    }

    void weight_paths_nv(gl::uint_t resultPath, gl::sizei_t numPaths, const  gl::uint_t * paths, const  gl::float_t * weights) {
      if ( GLAD_GL_NV_path_rendering ) {
        glWeightPathsNV(resultPath, numPaths, paths, weights);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWeightPathsNV' not available on this platform (extensions: GL_NV_path_rendering)");
      }
    }

    void weight_pointer_arb(gl::int_t size, gl::enum_t type, gl::sizei_t stride, const  void * pointer) {
      if ( GLAD_GL_ARB_vertex_blend ) {
        glWeightPointerARB(size, type, stride, pointer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWeightPointerARB' not available on this platform (extensions: GL_ARB_vertex_blend)");
      }
    }

    void weightbv_arb(gl::int_t size, const  gl::byte_t * weights) {
      if ( GLAD_GL_ARB_vertex_blend ) {
        glWeightbvARB(size, weights);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWeightbvARB' not available on this platform (extensions: GL_ARB_vertex_blend)");
      }
    }

    void weightdv_arb(gl::int_t size, const  gl::double_t * weights) {
      if ( GLAD_GL_ARB_vertex_blend ) {
        glWeightdvARB(size, weights);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWeightdvARB' not available on this platform (extensions: GL_ARB_vertex_blend)");
      }
    }

    void weightfv_arb(gl::int_t size, const  gl::float_t * weights) {
      if ( GLAD_GL_ARB_vertex_blend ) {
        glWeightfvARB(size, weights);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWeightfvARB' not available on this platform (extensions: GL_ARB_vertex_blend)");
      }
    }

    void weightiv_arb(gl::int_t size, const  gl::int_t * weights) {
      if ( GLAD_GL_ARB_vertex_blend ) {
        glWeightivARB(size, weights);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWeightivARB' not available on this platform (extensions: GL_ARB_vertex_blend)");
      }
    }

    void weightsv_arb(gl::int_t size, const  gl::short_t * weights) {
      if ( GLAD_GL_ARB_vertex_blend ) {
        glWeightsvARB(size, weights);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWeightsvARB' not available on this platform (extensions: GL_ARB_vertex_blend)");
      }
    }

    void weightubv_arb(gl::int_t size, const  gl::ubyte_t * weights) {
      if ( GLAD_GL_ARB_vertex_blend ) {
        glWeightubvARB(size, weights);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWeightubvARB' not available on this platform (extensions: GL_ARB_vertex_blend)");
      }
    }

    void weightuiv_arb(gl::int_t size, const  gl::uint_t * weights) {
      if ( GLAD_GL_ARB_vertex_blend ) {
        glWeightuivARB(size, weights);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWeightuivARB' not available on this platform (extensions: GL_ARB_vertex_blend)");
      }
    }

    void weightusv_arb(gl::int_t size, const  gl::ushort_t * weights) {
      if ( GLAD_GL_ARB_vertex_blend ) {
        glWeightusvARB(size, weights);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWeightusvARB' not available on this platform (extensions: GL_ARB_vertex_blend)");
      }
    }

    void window_pos_2d_arb(gl::double_t x, gl::double_t y) {
      if ( GLAD_GL_ARB_window_pos ) {
        glWindowPos2dARB(x, y);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWindowPos2dARB' not available on this platform (extensions: GL_ARB_window_pos)");
      }
    }

    void window_pos_2d_mesa(gl::double_t x, gl::double_t y) {
      if ( GLAD_GL_MESA_window_pos ) {
        glWindowPos2dMESA(x, y);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWindowPos2dMESA' not available on this platform (extensions: GL_MESA_window_pos)");
      }
    }

    void window_pos_2dv_arb(const  gl::double_t * v) {
      if ( GLAD_GL_ARB_window_pos ) {
        glWindowPos2dvARB(v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWindowPos2dvARB' not available on this platform (extensions: GL_ARB_window_pos)");
      }
    }

    void window_pos_2dv_mesa(const  gl::double_t * v) {
      if ( GLAD_GL_MESA_window_pos ) {
        glWindowPos2dvMESA(v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWindowPos2dvMESA' not available on this platform (extensions: GL_MESA_window_pos)");
      }
    }

    void window_pos_2f_arb(gl::float_t x, gl::float_t y) {
      if ( GLAD_GL_ARB_window_pos ) {
        glWindowPos2fARB(x, y);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWindowPos2fARB' not available on this platform (extensions: GL_ARB_window_pos)");
      }
    }

    void window_pos_2f_mesa(gl::float_t x, gl::float_t y) {
      if ( GLAD_GL_MESA_window_pos ) {
        glWindowPos2fMESA(x, y);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWindowPos2fMESA' not available on this platform (extensions: GL_MESA_window_pos)");
      }
    }

    void window_pos_2fv_arb(const  gl::float_t * v) {
      if ( GLAD_GL_ARB_window_pos ) {
        glWindowPos2fvARB(v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWindowPos2fvARB' not available on this platform (extensions: GL_ARB_window_pos)");
      }
    }

    void window_pos_2fv_mesa(const  gl::float_t * v) {
      if ( GLAD_GL_MESA_window_pos ) {
        glWindowPos2fvMESA(v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWindowPos2fvMESA' not available on this platform (extensions: GL_MESA_window_pos)");
      }
    }

    void window_pos_2i_arb(gl::int_t x, gl::int_t y) {
      if ( GLAD_GL_ARB_window_pos ) {
        glWindowPos2iARB(x, y);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWindowPos2iARB' not available on this platform (extensions: GL_ARB_window_pos)");
      }
    }

    void window_pos_2i_mesa(gl::int_t x, gl::int_t y) {
      if ( GLAD_GL_MESA_window_pos ) {
        glWindowPos2iMESA(x, y);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWindowPos2iMESA' not available on this platform (extensions: GL_MESA_window_pos)");
      }
    }

    void window_pos_2iv_arb(const  gl::int_t * v) {
      if ( GLAD_GL_ARB_window_pos ) {
        glWindowPos2ivARB(v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWindowPos2ivARB' not available on this platform (extensions: GL_ARB_window_pos)");
      }
    }

    void window_pos_2iv_mesa(const  gl::int_t * v) {
      if ( GLAD_GL_MESA_window_pos ) {
        glWindowPos2ivMESA(v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWindowPos2ivMESA' not available on this platform (extensions: GL_MESA_window_pos)");
      }
    }

    void window_pos_2s_arb(gl::short_t x, gl::short_t y) {
      if ( GLAD_GL_ARB_window_pos ) {
        glWindowPos2sARB(x, y);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWindowPos2sARB' not available on this platform (extensions: GL_ARB_window_pos)");
      }
    }

    void window_pos_2s_mesa(gl::short_t x, gl::short_t y) {
      if ( GLAD_GL_MESA_window_pos ) {
        glWindowPos2sMESA(x, y);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWindowPos2sMESA' not available on this platform (extensions: GL_MESA_window_pos)");
      }
    }

    void window_pos_2sv_arb(const  gl::short_t * v) {
      if ( GLAD_GL_ARB_window_pos ) {
        glWindowPos2svARB(v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWindowPos2svARB' not available on this platform (extensions: GL_ARB_window_pos)");
      }
    }

    void window_pos_2sv_mesa(const  gl::short_t * v) {
      if ( GLAD_GL_MESA_window_pos ) {
        glWindowPos2svMESA(v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWindowPos2svMESA' not available on this platform (extensions: GL_MESA_window_pos)");
      }
    }

    void window_pos_3d_arb(gl::double_t x, gl::double_t y, gl::double_t z) {
      if ( GLAD_GL_ARB_window_pos ) {
        glWindowPos3dARB(x, y, z);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWindowPos3dARB' not available on this platform (extensions: GL_ARB_window_pos)");
      }
    }

    void window_pos_3d_mesa(gl::double_t x, gl::double_t y, gl::double_t z) {
      if ( GLAD_GL_MESA_window_pos ) {
        glWindowPos3dMESA(x, y, z);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWindowPos3dMESA' not available on this platform (extensions: GL_MESA_window_pos)");
      }
    }

    void window_pos_3dv_arb(const  gl::double_t * v) {
      if ( GLAD_GL_ARB_window_pos ) {
        glWindowPos3dvARB(v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWindowPos3dvARB' not available on this platform (extensions: GL_ARB_window_pos)");
      }
    }

    void window_pos_3dv_mesa(const  gl::double_t * v) {
      if ( GLAD_GL_MESA_window_pos ) {
        glWindowPos3dvMESA(v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWindowPos3dvMESA' not available on this platform (extensions: GL_MESA_window_pos)");
      }
    }

    void window_pos_3f_arb(gl::float_t x, gl::float_t y, gl::float_t z) {
      if ( GLAD_GL_ARB_window_pos ) {
        glWindowPos3fARB(x, y, z);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWindowPos3fARB' not available on this platform (extensions: GL_ARB_window_pos)");
      }
    }

    void window_pos_3f_mesa(gl::float_t x, gl::float_t y, gl::float_t z) {
      if ( GLAD_GL_MESA_window_pos ) {
        glWindowPos3fMESA(x, y, z);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWindowPos3fMESA' not available on this platform (extensions: GL_MESA_window_pos)");
      }
    }

    void window_pos_3fv_arb(const  gl::float_t * v) {
      if ( GLAD_GL_ARB_window_pos ) {
        glWindowPos3fvARB(v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWindowPos3fvARB' not available on this platform (extensions: GL_ARB_window_pos)");
      }
    }

    void window_pos_3fv_mesa(const  gl::float_t * v) {
      if ( GLAD_GL_MESA_window_pos ) {
        glWindowPos3fvMESA(v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWindowPos3fvMESA' not available on this platform (extensions: GL_MESA_window_pos)");
      }
    }

    void window_pos_3i_arb(gl::int_t x, gl::int_t y, gl::int_t z) {
      if ( GLAD_GL_ARB_window_pos ) {
        glWindowPos3iARB(x, y, z);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWindowPos3iARB' not available on this platform (extensions: GL_ARB_window_pos)");
      }
    }

    void window_pos_3i_mesa(gl::int_t x, gl::int_t y, gl::int_t z) {
      if ( GLAD_GL_MESA_window_pos ) {
        glWindowPos3iMESA(x, y, z);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWindowPos3iMESA' not available on this platform (extensions: GL_MESA_window_pos)");
      }
    }

    void window_pos_3iv_arb(const  gl::int_t * v) {
      if ( GLAD_GL_ARB_window_pos ) {
        glWindowPos3ivARB(v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWindowPos3ivARB' not available on this platform (extensions: GL_ARB_window_pos)");
      }
    }

    void window_pos_3iv_mesa(const  gl::int_t * v) {
      if ( GLAD_GL_MESA_window_pos ) {
        glWindowPos3ivMESA(v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWindowPos3ivMESA' not available on this platform (extensions: GL_MESA_window_pos)");
      }
    }

    void window_pos_3s_arb(gl::short_t x, gl::short_t y, gl::short_t z) {
      if ( GLAD_GL_ARB_window_pos ) {
        glWindowPos3sARB(x, y, z);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWindowPos3sARB' not available on this platform (extensions: GL_ARB_window_pos)");
      }
    }

    void window_pos_3s_mesa(gl::short_t x, gl::short_t y, gl::short_t z) {
      if ( GLAD_GL_MESA_window_pos ) {
        glWindowPos3sMESA(x, y, z);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWindowPos3sMESA' not available on this platform (extensions: GL_MESA_window_pos)");
      }
    }

    void window_pos_3sv_arb(const  gl::short_t * v) {
      if ( GLAD_GL_ARB_window_pos ) {
        glWindowPos3svARB(v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWindowPos3svARB' not available on this platform (extensions: GL_ARB_window_pos)");
      }
    }

    void window_pos_3sv_mesa(const  gl::short_t * v) {
      if ( GLAD_GL_MESA_window_pos ) {
        glWindowPos3svMESA(v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWindowPos3svMESA' not available on this platform (extensions: GL_MESA_window_pos)");
      }
    }

    void window_pos_4d_mesa(gl::double_t x, gl::double_t y, gl::double_t z, gl::double_t w) {
      if ( GLAD_GL_MESA_window_pos ) {
        glWindowPos4dMESA(x, y, z, w);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWindowPos4dMESA' not available on this platform (extensions: GL_MESA_window_pos)");
      }
    }

    void window_pos_4dv_mesa(const  gl::double_t * v) {
      if ( GLAD_GL_MESA_window_pos ) {
        glWindowPos4dvMESA(v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWindowPos4dvMESA' not available on this platform (extensions: GL_MESA_window_pos)");
      }
    }

    void window_pos_4f_mesa(gl::float_t x, gl::float_t y, gl::float_t z, gl::float_t w) {
      if ( GLAD_GL_MESA_window_pos ) {
        glWindowPos4fMESA(x, y, z, w);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWindowPos4fMESA' not available on this platform (extensions: GL_MESA_window_pos)");
      }
    }

    void window_pos_4fv_mesa(const  gl::float_t * v) {
      if ( GLAD_GL_MESA_window_pos ) {
        glWindowPos4fvMESA(v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWindowPos4fvMESA' not available on this platform (extensions: GL_MESA_window_pos)");
      }
    }

    void window_pos_4i_mesa(gl::int_t x, gl::int_t y, gl::int_t z, gl::int_t w) {
      if ( GLAD_GL_MESA_window_pos ) {
        glWindowPos4iMESA(x, y, z, w);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWindowPos4iMESA' not available on this platform (extensions: GL_MESA_window_pos)");
      }
    }

    void window_pos_4iv_mesa(const  gl::int_t * v) {
      if ( GLAD_GL_MESA_window_pos ) {
        glWindowPos4ivMESA(v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWindowPos4ivMESA' not available on this platform (extensions: GL_MESA_window_pos)");
      }
    }

    void window_pos_4s_mesa(gl::short_t x, gl::short_t y, gl::short_t z, gl::short_t w) {
      if ( GLAD_GL_MESA_window_pos ) {
        glWindowPos4sMESA(x, y, z, w);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWindowPos4sMESA' not available on this platform (extensions: GL_MESA_window_pos)");
      }
    }

    void window_pos_4sv_mesa(const  gl::short_t * v) {
      if ( GLAD_GL_MESA_window_pos ) {
        glWindowPos4svMESA(v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWindowPos4svMESA' not available on this platform (extensions: GL_MESA_window_pos)");
      }
    }

    void write_mask_ext(gl::uint_t res, gl::uint_t in, gl::enum_t outX, gl::enum_t outY, gl::enum_t outZ, gl::enum_t outW) {
      if ( GLAD_GL_EXT_vertex_shader ) {
        glWriteMaskEXT(res, in, outX, outY, outZ, outW);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWriteMaskEXT' not available on this platform (extensions: GL_EXT_vertex_shader)");
      }
    }

}
