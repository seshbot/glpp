/**
 * This file was autogenerated by glgen (https://github.com/seshbot/glgen) on 2015-06-11
 * Command line: src/gen.py assets/gl.xml -p assets/gl-patch.xml -o ../glpp/ --includesubdir include/glpp --sourcesubdir src --namespace gl2:osx --force --cpp --gl2only --extensionsimportfile assets/extensions_osx.txt --extensionsoutputfilename extensions
 */

#include <glad/glad.h>
#include <stdexcept>
#include <glpp/gl2/osx/extensions.h>


namespace gl2 {
namespace osx {

   /**
    * command aliases
    */
  
    void draw_element_array(primitive_type_t mode, gl::int_t first, gl::sizei_t count) {
      if ( GLAD_GL_APPLE_element_array ) {
        glDrawElementArrayAPPLE(static_cast<GLenum>(mode), first, count);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDrawElementArrayAPPLE' not available on this platform (extensions: GL_APPLE_element_array)");
      }
    }

    void draw_range_element_array(primitive_type_t mode, gl::uint_t start, gl::uint_t end, gl::int_t first, gl::sizei_t count) {
      if ( GLAD_GL_APPLE_element_array ) {
        glDrawRangeElementArrayAPPLE(static_cast<GLenum>(mode), start, end, first, count);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDrawRangeElementArrayAPPLE' not available on this platform (extensions: GL_APPLE_element_array)");
      }
    }

    void element_pointer(gl::enum_t type, const  void * pointer) {
      if ( GLAD_GL_APPLE_element_array ) {
        glElementPointerAPPLE(type, pointer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glElementPointerAPPLE' not available on this platform (extensions: GL_APPLE_element_array)");
      }
    }

    void multi_draw_element_array(primitive_type_t mode, const  gl::int_t * first, const  gl::sizei_t * count, gl::sizei_t primcount) {
      if ( GLAD_GL_APPLE_element_array ) {
        glMultiDrawElementArrayAPPLE(static_cast<GLenum>(mode), first, count, primcount);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiDrawElementArrayAPPLE' not available on this platform (extensions: GL_APPLE_element_array)");
      }
    }

    void multi_draw_range_element_array(primitive_type_t mode, gl::uint_t start, gl::uint_t end, const  gl::int_t * first, const  gl::sizei_t * count, gl::sizei_t primcount) {
      if ( GLAD_GL_APPLE_element_array ) {
        glMultiDrawRangeElementArrayAPPLE(static_cast<GLenum>(mode), start, end, first, count, primcount);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiDrawRangeElementArrayAPPLE' not available on this platform (extensions: GL_APPLE_element_array)");
      }
    }

    void delete_fences(gl::sizei_t n, const  gl::uint_t * fences) {
      if ( GLAD_GL_APPLE_fence ) {
        glDeleteFencesAPPLE(n, fences);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDeleteFencesAPPLE' not available on this platform (extensions: GL_APPLE_fence)");
      }
    }

    void finish_fence(gl::uint_t fence) {
      if ( GLAD_GL_APPLE_fence ) {
        glFinishFenceAPPLE(fence);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFinishFenceAPPLE' not available on this platform (extensions: GL_APPLE_fence)");
      }
    }

    void finish_object(gl::enum_t object, gl::int_t name) {
      if ( GLAD_GL_APPLE_fence ) {
        glFinishObjectAPPLE(object, name);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFinishObjectAPPLE' not available on this platform (extensions: GL_APPLE_fence)");
      }
    }

    void gen_fences(gl::sizei_t n, gl::uint_t * fences) {
      if ( GLAD_GL_APPLE_fence ) {
        glGenFencesAPPLE(n, fences);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGenFencesAPPLE' not available on this platform (extensions: GL_APPLE_fence)");
      }
    }

    gl::boolean_t is_fence(gl::uint_t fence) {
      if ( GLAD_GL_APPLE_fence ) {
        return glIsFenceAPPLE(fence);
      }
      else {
        throw std::runtime_error("OpenGL command 'glIsFenceAPPLE' not available on this platform (extensions: GL_APPLE_fence)");
      }
    }

    void set_fence(gl::uint_t fence) {
      if ( GLAD_GL_APPLE_fence ) {
        glSetFenceAPPLE(fence);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSetFenceAPPLE' not available on this platform (extensions: GL_APPLE_fence)");
      }
    }

    gl::boolean_t test_fence(gl::uint_t fence) {
      if ( GLAD_GL_APPLE_fence ) {
        return glTestFenceAPPLE(fence);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTestFenceAPPLE' not available on this platform (extensions: GL_APPLE_fence)");
      }
    }

    gl::boolean_t test_object(gl::enum_t object, gl::uint_t name) {
      if ( GLAD_GL_APPLE_fence ) {
        return glTestObjectAPPLE(object, name);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTestObjectAPPLE' not available on this platform (extensions: GL_APPLE_fence)");
      }
    }

    void buffer_parameteri(gl::enum_t target, gl::enum_t pname, gl::int_t param) {
      if ( GLAD_GL_APPLE_flush_buffer_range ) {
        glBufferParameteriAPPLE(target, pname, param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBufferParameteriAPPLE' not available on this platform (extensions: GL_APPLE_flush_buffer_range)");
      }
    }

    void flush_mapped_buffer_range(buffer_target_arb_t target, gl::intptr_t offset, gl::sizeiptr_t size) {
      if ( GLAD_GL_APPLE_flush_buffer_range ) {
        glFlushMappedBufferRangeAPPLE(static_cast<GLenum>(target), offset, size);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFlushMappedBufferRangeAPPLE' not available on this platform (extensions: GL_APPLE_flush_buffer_range)");
      }
    }

    gl::enum_t object_purgeable(gl::enum_t objectType, gl::uint_t name, gl::enum_t option) {
      if ( GLAD_GL_APPLE_object_purgeable ) {
        return glObjectPurgeableAPPLE(objectType, name, option);
      }
      else {
        throw std::runtime_error("OpenGL command 'glObjectPurgeableAPPLE' not available on this platform (extensions: GL_APPLE_object_purgeable)");
      }
    }

    gl::enum_t object_unpurgeable(gl::enum_t objectType, gl::uint_t name, gl::enum_t option) {
      if ( GLAD_GL_APPLE_object_purgeable ) {
        return glObjectUnpurgeableAPPLE(objectType, name, option);
      }
      else {
        throw std::runtime_error("OpenGL command 'glObjectUnpurgeableAPPLE' not available on this platform (extensions: GL_APPLE_object_purgeable)");
      }
    }

    void get_tex_parameter_pointerv(gl::enum_t target, gl::enum_t pname, void ** params) {
      if ( GLAD_GL_APPLE_texture_range ) {
        glGetTexParameterPointervAPPLE(target, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetTexParameterPointervAPPLE' not available on this platform (extensions: GL_APPLE_texture_range)");
      }
    }

    void texture_range(gl::enum_t target, gl::sizei_t length, const  void * pointer) {
      if ( GLAD_GL_APPLE_texture_range ) {
        glTextureRangeAPPLE(target, length, pointer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTextureRangeAPPLE' not available on this platform (extensions: GL_APPLE_texture_range)");
      }
    }

    void bind_vertex_array(gl::uint_t array) {
      if ( GLAD_GL_APPLE_vertex_array_object ) {
        glBindVertexArrayAPPLE(array);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBindVertexArrayAPPLE' not available on this platform (extensions: GL_APPLE_vertex_array_object)");
      }
    }

    void delete_vertex_arrays(gl::sizei_t n, const  gl::uint_t * arrays) {
      if ( GLAD_GL_APPLE_vertex_array_object ) {
        glDeleteVertexArraysAPPLE(n, arrays);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDeleteVertexArraysAPPLE' not available on this platform (extensions: GL_APPLE_vertex_array_object)");
      }
    }

    void gen_vertex_arrays(gl::sizei_t n, gl::uint_t * arrays) {
      if ( GLAD_GL_APPLE_vertex_array_object ) {
        glGenVertexArraysAPPLE(n, arrays);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGenVertexArraysAPPLE' not available on this platform (extensions: GL_APPLE_vertex_array_object)");
      }
    }

    gl::boolean_t is_vertex_array(gl::uint_t array) {
      if ( GLAD_GL_APPLE_vertex_array_object ) {
        return glIsVertexArrayAPPLE(array);
      }
      else {
        throw std::runtime_error("OpenGL command 'glIsVertexArrayAPPLE' not available on this platform (extensions: GL_APPLE_vertex_array_object)");
      }
    }

    void flush_vertex_array_range(gl::sizei_t length, void * pointer) {
      if ( GLAD_GL_APPLE_vertex_array_range ) {
        glFlushVertexArrayRangeAPPLE(length, pointer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFlushVertexArrayRangeAPPLE' not available on this platform (extensions: GL_APPLE_vertex_array_range)");
      }
    }

    void vertex_array_parameteri(gl::enum_t pname, gl::int_t param) {
      if ( GLAD_GL_APPLE_vertex_array_range ) {
        glVertexArrayParameteriAPPLE(pname, param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexArrayParameteriAPPLE' not available on this platform (extensions: GL_APPLE_vertex_array_range)");
      }
    }

    void vertex_array_range(gl::sizei_t length, void * pointer) {
      if ( GLAD_GL_APPLE_vertex_array_range ) {
        glVertexArrayRangeAPPLE(length, pointer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexArrayRangeAPPLE' not available on this platform (extensions: GL_APPLE_vertex_array_range)");
      }
    }

    void disable_vertex_attrib(gl::uint_t index, gl::enum_t pname) {
      if ( GLAD_GL_APPLE_vertex_program_evaluators ) {
        glDisableVertexAttribAPPLE(index, pname);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDisableVertexAttribAPPLE' not available on this platform (extensions: GL_APPLE_vertex_program_evaluators)");
      }
    }

    void enable_vertex_attrib(gl::uint_t index, gl::enum_t pname) {
      if ( GLAD_GL_APPLE_vertex_program_evaluators ) {
        glEnableVertexAttribAPPLE(index, pname);
      }
      else {
        throw std::runtime_error("OpenGL command 'glEnableVertexAttribAPPLE' not available on this platform (extensions: GL_APPLE_vertex_program_evaluators)");
      }
    }

    gl::boolean_t is_vertex_attrib_enabled(gl::uint_t index, gl::enum_t pname) {
      if ( GLAD_GL_APPLE_vertex_program_evaluators ) {
        return glIsVertexAttribEnabledAPPLE(index, pname);
      }
      else {
        throw std::runtime_error("OpenGL command 'glIsVertexAttribEnabledAPPLE' not available on this platform (extensions: GL_APPLE_vertex_program_evaluators)");
      }
    }

    void map_vertex_attrib_1d(gl::uint_t index, gl::uint_t size, gl::double_t u1, gl::double_t u2, gl::int_t stride, gl::int_t order, const  gl::double_t * points) {
      if ( GLAD_GL_APPLE_vertex_program_evaluators ) {
        glMapVertexAttrib1dAPPLE(index, size, u1, u2, stride, order, points);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMapVertexAttrib1dAPPLE' not available on this platform (extensions: GL_APPLE_vertex_program_evaluators)");
      }
    }

    void map_vertex_attrib_1f(gl::uint_t index, gl::uint_t size, gl::float_t u1, gl::float_t u2, gl::int_t stride, gl::int_t order, const  gl::float_t * points) {
      if ( GLAD_GL_APPLE_vertex_program_evaluators ) {
        glMapVertexAttrib1fAPPLE(index, size, u1, u2, stride, order, points);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMapVertexAttrib1fAPPLE' not available on this platform (extensions: GL_APPLE_vertex_program_evaluators)");
      }
    }

    void map_vertex_attrib_2d(gl::uint_t index, gl::uint_t size, gl::double_t u1, gl::double_t u2, gl::int_t ustride, gl::int_t uorder, gl::double_t v1, gl::double_t v2, gl::int_t vstride, gl::int_t vorder, const  gl::double_t * points) {
      if ( GLAD_GL_APPLE_vertex_program_evaluators ) {
        glMapVertexAttrib2dAPPLE(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMapVertexAttrib2dAPPLE' not available on this platform (extensions: GL_APPLE_vertex_program_evaluators)");
      }
    }

    void map_vertex_attrib_2f(gl::uint_t index, gl::uint_t size, gl::float_t u1, gl::float_t u2, gl::int_t ustride, gl::int_t uorder, gl::float_t v1, gl::float_t v2, gl::int_t vstride, gl::int_t vorder, const  gl::float_t * points) {
      if ( GLAD_GL_APPLE_vertex_program_evaluators ) {
        glMapVertexAttrib2fAPPLE(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMapVertexAttrib2fAPPLE' not available on this platform (extensions: GL_APPLE_vertex_program_evaluators)");
      }
    }

    void clamp_color(gl::enum_t target, gl::enum_t clamp) {
      if ( GLAD_GL_ARB_color_buffer_float ) {
        glClampColorARB(target, clamp);
      }
      else {
        throw std::runtime_error("OpenGL command 'glClampColorARB' not available on this platform (extensions: GL_ARB_color_buffer_float)");
      }
    }

    void draw_buffers(gl::sizei_t n, const  gl::enum_t * bufs) {
      if ( GLAD_GL_ARB_draw_buffers ) {
        glDrawBuffersARB(n, bufs);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDrawBuffersARB' not available on this platform (extensions: GL_ARB_draw_buffers)");
      }
    }

    void draw_arrays_instanced(primitive_type_t mode, gl::int_t first, gl::sizei_t count, gl::sizei_t primcount) {
      if ( GLAD_GL_ARB_draw_instanced ) {
        glDrawArraysInstancedARB(static_cast<GLenum>(mode), first, count, primcount);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDrawArraysInstancedARB' not available on this platform (extensions: GL_ARB_draw_instanced)");
      }
    }

    void draw_elements_instanced(primitive_type_t mode, gl::sizei_t count, draw_elements_type_t type, const  void * indices, gl::sizei_t primcount) {
      if ( GLAD_GL_ARB_draw_instanced ) {
        glDrawElementsInstancedARB(static_cast<GLenum>(mode), count, static_cast<GLenum>(type), indices, primcount);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDrawElementsInstancedARB' not available on this platform (extensions: GL_ARB_draw_instanced)");
      }
    }

    void bind_program(gl::enum_t target, gl::uint_t program) {
      if ( GLAD_GL_ARB_fragment_program || GLAD_GL_ARB_vertex_program ) {
        glBindProgramARB(target, program);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBindProgramARB' not available on this platform (extensions: GL_ARB_fragment_program, GL_ARB_vertex_program)");
      }
    }

    void delete_programs(gl::sizei_t n, const  gl::uint_t * programs) {
      if ( GLAD_GL_ARB_fragment_program || GLAD_GL_ARB_vertex_program ) {
        glDeleteProgramsARB(n, programs);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDeleteProgramsARB' not available on this platform (extensions: GL_ARB_fragment_program, GL_ARB_vertex_program)");
      }
    }

    void gen_programs(gl::sizei_t n, gl::uint_t * programs) {
      if ( GLAD_GL_ARB_fragment_program || GLAD_GL_ARB_vertex_program ) {
        glGenProgramsARB(n, programs);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGenProgramsARB' not available on this platform (extensions: GL_ARB_fragment_program, GL_ARB_vertex_program)");
      }
    }

    void get_program_env_parameterdv(gl::enum_t target, gl::uint_t index, gl::double_t * params) {
      if ( GLAD_GL_ARB_fragment_program || GLAD_GL_ARB_vertex_program ) {
        glGetProgramEnvParameterdvARB(target, index, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetProgramEnvParameterdvARB' not available on this platform (extensions: GL_ARB_fragment_program, GL_ARB_vertex_program)");
      }
    }

    void get_program_env_parameterfv(gl::enum_t target, gl::uint_t index, gl::float_t * params) {
      if ( GLAD_GL_ARB_fragment_program || GLAD_GL_ARB_vertex_program ) {
        glGetProgramEnvParameterfvARB(target, index, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetProgramEnvParameterfvARB' not available on this platform (extensions: GL_ARB_fragment_program, GL_ARB_vertex_program)");
      }
    }

    void get_program_local_parameterdv(gl::enum_t target, gl::uint_t index, gl::double_t * params) {
      if ( GLAD_GL_ARB_fragment_program || GLAD_GL_ARB_vertex_program ) {
        glGetProgramLocalParameterdvARB(target, index, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetProgramLocalParameterdvARB' not available on this platform (extensions: GL_ARB_fragment_program, GL_ARB_vertex_program)");
      }
    }

    void get_program_local_parameterfv(gl::enum_t target, gl::uint_t index, gl::float_t * params) {
      if ( GLAD_GL_ARB_fragment_program || GLAD_GL_ARB_vertex_program ) {
        glGetProgramLocalParameterfvARB(target, index, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetProgramLocalParameterfvARB' not available on this platform (extensions: GL_ARB_fragment_program, GL_ARB_vertex_program)");
      }
    }

    void get_program_string(gl::enum_t target, gl::enum_t pname, void * string) {
      if ( GLAD_GL_ARB_fragment_program || GLAD_GL_ARB_vertex_program ) {
        glGetProgramStringARB(target, pname, string);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetProgramStringARB' not available on this platform (extensions: GL_ARB_fragment_program, GL_ARB_vertex_program)");
      }
    }

    void get_programiv(gl::enum_t target, get_programiv_p_name_t pname, gl::int_t * params) {
      if ( GLAD_GL_ARB_fragment_program || GLAD_GL_ARB_vertex_program ) {
        glGetProgramivARB(target, static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetProgramivARB' not available on this platform (extensions: GL_ARB_fragment_program, GL_ARB_vertex_program)");
      }
    }

    gl::boolean_t is_program(gl::uint_t program) {
      if ( GLAD_GL_ARB_fragment_program || GLAD_GL_ARB_vertex_program ) {
        return glIsProgramARB(program);
      }
      else {
        throw std::runtime_error("OpenGL command 'glIsProgramARB' not available on this platform (extensions: GL_ARB_fragment_program, GL_ARB_vertex_program)");
      }
    }

    void program_env_parameter_4d(gl::enum_t target, gl::uint_t index, gl::double_t x, gl::double_t y, gl::double_t z, gl::double_t w) {
      if ( GLAD_GL_ARB_fragment_program || GLAD_GL_ARB_vertex_program ) {
        glProgramEnvParameter4dARB(target, index, x, y, z, w);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramEnvParameter4dARB' not available on this platform (extensions: GL_ARB_fragment_program, GL_ARB_vertex_program)");
      }
    }

    void program_env_parameter_4dv(gl::enum_t target, gl::uint_t index, const  gl::double_t * params) {
      if ( GLAD_GL_ARB_fragment_program || GLAD_GL_ARB_vertex_program ) {
        glProgramEnvParameter4dvARB(target, index, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramEnvParameter4dvARB' not available on this platform (extensions: GL_ARB_fragment_program, GL_ARB_vertex_program)");
      }
    }

    void program_env_parameter_4f(gl::enum_t target, gl::uint_t index, gl::float_t x, gl::float_t y, gl::float_t z, gl::float_t w) {
      if ( GLAD_GL_ARB_fragment_program || GLAD_GL_ARB_vertex_program ) {
        glProgramEnvParameter4fARB(target, index, x, y, z, w);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramEnvParameter4fARB' not available on this platform (extensions: GL_ARB_fragment_program, GL_ARB_vertex_program)");
      }
    }

    void program_env_parameter_4fv(gl::enum_t target, gl::uint_t index, const  gl::float_t * params) {
      if ( GLAD_GL_ARB_fragment_program || GLAD_GL_ARB_vertex_program ) {
        glProgramEnvParameter4fvARB(target, index, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramEnvParameter4fvARB' not available on this platform (extensions: GL_ARB_fragment_program, GL_ARB_vertex_program)");
      }
    }

    void program_local_parameter_4d(gl::enum_t target, gl::uint_t index, gl::double_t x, gl::double_t y, gl::double_t z, gl::double_t w) {
      if ( GLAD_GL_ARB_fragment_program || GLAD_GL_ARB_vertex_program ) {
        glProgramLocalParameter4dARB(target, index, x, y, z, w);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramLocalParameter4dARB' not available on this platform (extensions: GL_ARB_fragment_program, GL_ARB_vertex_program)");
      }
    }

    void program_local_parameter_4dv(gl::enum_t target, gl::uint_t index, const  gl::double_t * params) {
      if ( GLAD_GL_ARB_fragment_program || GLAD_GL_ARB_vertex_program ) {
        glProgramLocalParameter4dvARB(target, index, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramLocalParameter4dvARB' not available on this platform (extensions: GL_ARB_fragment_program, GL_ARB_vertex_program)");
      }
    }

    void program_local_parameter_4f(gl::enum_t target, gl::uint_t index, gl::float_t x, gl::float_t y, gl::float_t z, gl::float_t w) {
      if ( GLAD_GL_ARB_fragment_program || GLAD_GL_ARB_vertex_program ) {
        glProgramLocalParameter4fARB(target, index, x, y, z, w);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramLocalParameter4fARB' not available on this platform (extensions: GL_ARB_fragment_program, GL_ARB_vertex_program)");
      }
    }

    void program_local_parameter_4fv(gl::enum_t target, gl::uint_t index, const  gl::float_t * params) {
      if ( GLAD_GL_ARB_fragment_program || GLAD_GL_ARB_vertex_program ) {
        glProgramLocalParameter4fvARB(target, index, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramLocalParameter4fvARB' not available on this platform (extensions: GL_ARB_fragment_program, GL_ARB_vertex_program)");
      }
    }

    void program_string(gl::enum_t target, gl::enum_t format, gl::sizei_t len, const  void * string) {
      if ( GLAD_GL_ARB_fragment_program || GLAD_GL_ARB_vertex_program ) {
        glProgramStringARB(target, format, len, string);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramStringARB' not available on this platform (extensions: GL_ARB_fragment_program, GL_ARB_vertex_program)");
      }
    }

    void vertex_attrib_divisor(gl::uint_t index, gl::uint_t divisor) {
      if ( GLAD_GL_ARB_instanced_arrays ) {
        glVertexAttribDivisorARB(index, divisor);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribDivisorARB' not available on this platform (extensions: GL_ARB_instanced_arrays)");
      }
    }

    void sample_coverage(gl::float_t value, gl::boolean_t invert) {
      if ( GLAD_GL_ARB_multisample ) {
        glSampleCoverageARB(value, invert);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSampleCoverageARB' not available on this platform (extensions: GL_ARB_multisample)");
      }
    }

    void active_texture(texture_unit_t texture) {
      if ( GLAD_GL_ARB_multitexture ) {
        glActiveTextureARB(static_cast<GLenum>(texture));
      }
      else {
        throw std::runtime_error("OpenGL command 'glActiveTextureARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void client_active_texture(texture_unit_t texture) {
      if ( GLAD_GL_ARB_multitexture ) {
        glClientActiveTextureARB(static_cast<GLenum>(texture));
      }
      else {
        throw std::runtime_error("OpenGL command 'glClientActiveTextureARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_1d(texture_unit_t target, gl::double_t s) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord1dARB(static_cast<GLenum>(target), s);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord1dARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_1dv(texture_unit_t target, const  gl::double_t * v) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord1dvARB(static_cast<GLenum>(target), v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord1dvARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_1f(texture_unit_t target, gl::float_t s) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord1fARB(static_cast<GLenum>(target), s);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord1fARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_1fv(texture_unit_t target, const  gl::float_t * v) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord1fvARB(static_cast<GLenum>(target), v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord1fvARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_1i(texture_unit_t target, gl::int_t s) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord1iARB(static_cast<GLenum>(target), s);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord1iARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_1iv(texture_unit_t target, const  gl::int_t * v) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord1ivARB(static_cast<GLenum>(target), v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord1ivARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_1s(texture_unit_t target, gl::short_t s) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord1sARB(static_cast<GLenum>(target), s);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord1sARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_1sv(texture_unit_t target, const  gl::short_t * v) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord1svARB(static_cast<GLenum>(target), v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord1svARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_2d(texture_unit_t target, gl::double_t s, gl::double_t t) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord2dARB(static_cast<GLenum>(target), s, t);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord2dARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_2dv(texture_unit_t target, const  gl::double_t * v) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord2dvARB(static_cast<GLenum>(target), v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord2dvARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_2f(texture_unit_t target, gl::float_t s, gl::float_t t) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord2fARB(static_cast<GLenum>(target), s, t);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord2fARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_2fv(texture_unit_t target, const  gl::float_t * v) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord2fvARB(static_cast<GLenum>(target), v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord2fvARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_2i(texture_unit_t target, gl::int_t s, gl::int_t t) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord2iARB(static_cast<GLenum>(target), s, t);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord2iARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_2iv(texture_unit_t target, const  gl::int_t * v) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord2ivARB(static_cast<GLenum>(target), v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord2ivARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_2s(texture_unit_t target, gl::short_t s, gl::short_t t) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord2sARB(static_cast<GLenum>(target), s, t);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord2sARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_2sv(texture_unit_t target, const  gl::short_t * v) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord2svARB(static_cast<GLenum>(target), v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord2svARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_3d(texture_unit_t target, gl::double_t s, gl::double_t t, gl::double_t r) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord3dARB(static_cast<GLenum>(target), s, t, r);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord3dARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_3dv(texture_unit_t target, const  gl::double_t * v) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord3dvARB(static_cast<GLenum>(target), v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord3dvARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_3f(texture_unit_t target, gl::float_t s, gl::float_t t, gl::float_t r) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord3fARB(static_cast<GLenum>(target), s, t, r);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord3fARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_3fv(texture_unit_t target, const  gl::float_t * v) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord3fvARB(static_cast<GLenum>(target), v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord3fvARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_3i(texture_unit_t target, gl::int_t s, gl::int_t t, gl::int_t r) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord3iARB(static_cast<GLenum>(target), s, t, r);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord3iARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_3iv(texture_unit_t target, const  gl::int_t * v) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord3ivARB(static_cast<GLenum>(target), v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord3ivARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_3s(texture_unit_t target, gl::short_t s, gl::short_t t, gl::short_t r) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord3sARB(static_cast<GLenum>(target), s, t, r);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord3sARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_3sv(texture_unit_t target, const  gl::short_t * v) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord3svARB(static_cast<GLenum>(target), v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord3svARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_4d(texture_unit_t target, gl::double_t s, gl::double_t t, gl::double_t r, gl::double_t q) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord4dARB(static_cast<GLenum>(target), s, t, r, q);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord4dARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_4dv(texture_unit_t target, const  gl::double_t * v) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord4dvARB(static_cast<GLenum>(target), v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord4dvARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_4f(texture_unit_t target, gl::float_t s, gl::float_t t, gl::float_t r, gl::float_t q) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord4fARB(static_cast<GLenum>(target), s, t, r, q);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord4fARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_4fv(texture_unit_t target, const  gl::float_t * v) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord4fvARB(static_cast<GLenum>(target), v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord4fvARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_4i(texture_unit_t target, gl::int_t s, gl::int_t t, gl::int_t r, gl::int_t q) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord4iARB(static_cast<GLenum>(target), s, t, r, q);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord4iARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_4iv(texture_unit_t target, const  gl::int_t * v) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord4ivARB(static_cast<GLenum>(target), v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord4ivARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_4s(texture_unit_t target, gl::short_t s, gl::short_t t, gl::short_t r, gl::short_t q) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord4sARB(static_cast<GLenum>(target), s, t, r, q);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord4sARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_4sv(texture_unit_t target, const  gl::short_t * v) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord4svARB(static_cast<GLenum>(target), v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord4svARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void begin_query(gl::enum_t target, gl::uint_t id) {
      if ( GLAD_GL_ARB_occlusion_query ) {
        glBeginQueryARB(target, id);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBeginQueryARB' not available on this platform (extensions: GL_ARB_occlusion_query)");
      }
    }

    void delete_queries(gl::sizei_t n, const  gl::uint_t * ids) {
      if ( GLAD_GL_ARB_occlusion_query ) {
        glDeleteQueriesARB(n, ids);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDeleteQueriesARB' not available on this platform (extensions: GL_ARB_occlusion_query)");
      }
    }

    void end_query(gl::enum_t target) {
      if ( GLAD_GL_ARB_occlusion_query ) {
        glEndQueryARB(target);
      }
      else {
        throw std::runtime_error("OpenGL command 'glEndQueryARB' not available on this platform (extensions: GL_ARB_occlusion_query)");
      }
    }

    void gen_queries(gl::sizei_t n, gl::uint_t * ids) {
      if ( GLAD_GL_ARB_occlusion_query ) {
        glGenQueriesARB(n, ids);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGenQueriesARB' not available on this platform (extensions: GL_ARB_occlusion_query)");
      }
    }

    void get_query_objectiv(gl::uint_t id, gl::enum_t pname, gl::int_t * params) {
      if ( GLAD_GL_ARB_occlusion_query ) {
        glGetQueryObjectivARB(id, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetQueryObjectivARB' not available on this platform (extensions: GL_ARB_occlusion_query)");
      }
    }

    void get_query_objectuiv(gl::uint_t id, gl::enum_t pname, gl::uint_t * params) {
      if ( GLAD_GL_ARB_occlusion_query ) {
        glGetQueryObjectuivARB(id, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetQueryObjectuivARB' not available on this platform (extensions: GL_ARB_occlusion_query)");
      }
    }

    void get_queryiv(gl::enum_t target, gl::enum_t pname, gl::int_t * params) {
      if ( GLAD_GL_ARB_occlusion_query ) {
        glGetQueryivARB(target, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetQueryivARB' not available on this platform (extensions: GL_ARB_occlusion_query)");
      }
    }

    gl::boolean_t is_query(gl::uint_t id) {
      if ( GLAD_GL_ARB_occlusion_query ) {
        return glIsQueryARB(id);
      }
      else {
        throw std::runtime_error("OpenGL command 'glIsQueryARB' not available on this platform (extensions: GL_ARB_occlusion_query)");
      }
    }

    void point_parameterf(gl::enum_t pname, gl::float_t param) {
      if ( GLAD_GL_ARB_point_parameters ) {
        glPointParameterfARB(pname, param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPointParameterfARB' not available on this platform (extensions: GL_ARB_point_parameters)");
      }
    }

    void point_parameterfv(gl::enum_t pname, const  gl::float_t * params) {
      if ( GLAD_GL_ARB_point_parameters ) {
        glPointParameterfvARB(pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPointParameterfvARB' not available on this platform (extensions: GL_ARB_point_parameters)");
      }
    }

    void attach_object(gl::handleARB_t containerObj, gl::handleARB_t obj) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glAttachObjectARB(containerObj, obj);
      }
      else {
        throw std::runtime_error("OpenGL command 'glAttachObjectARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void compile_shader(gl::handleARB_t shaderObj) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glCompileShaderARB(shaderObj);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCompileShaderARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    gl::handleARB_t create_program_object() {
      if ( GLAD_GL_ARB_shader_objects ) {
        return glCreateProgramObjectARB();
      }
      else {
        throw std::runtime_error("OpenGL command 'glCreateProgramObjectARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    gl::handleARB_t create_shader_object(gl::enum_t shaderType) {
      if ( GLAD_GL_ARB_shader_objects ) {
        return glCreateShaderObjectARB(shaderType);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCreateShaderObjectARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void delete_object(gl::handleARB_t obj) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glDeleteObjectARB(obj);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDeleteObjectARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void detach_object(gl::handleARB_t containerObj, gl::handleARB_t attachedObj) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glDetachObjectARB(containerObj, attachedObj);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDetachObjectARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void get_active_uniform(gl::handleARB_t programObj, gl::uint_t index, gl::sizei_t maxLength, gl::sizei_t * length, gl::int_t * size, uniform_type_t * type, gl::charARB_t * name) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glGetActiveUniformARB(programObj, index, maxLength, length, size, reinterpret_cast<GLenum *>(type), name);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetActiveUniformARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void get_attached_objects(gl::handleARB_t containerObj, gl::sizei_t maxCount, gl::sizei_t * count, gl::handleARB_t * obj) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glGetAttachedObjectsARB(containerObj, maxCount, count, obj);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetAttachedObjectsARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    gl::handleARB_t get_handle(gl::enum_t pname) {
      if ( GLAD_GL_ARB_shader_objects ) {
        return glGetHandleARB(pname);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetHandleARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void get_info_log(gl::handleARB_t obj, gl::sizei_t maxLength, gl::sizei_t * length, gl::charARB_t * infoLog) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glGetInfoLogARB(obj, maxLength, length, infoLog);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetInfoLogARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void get_object_parameterfv(gl::handleARB_t obj, gl::enum_t pname, gl::float_t * params) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glGetObjectParameterfvARB(obj, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetObjectParameterfvARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void get_object_parameteriv(gl::handleARB_t obj, gl::enum_t pname, gl::int_t * params) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glGetObjectParameterivARB(obj, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetObjectParameterivARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void get_shader_source(gl::handleARB_t obj, gl::sizei_t maxLength, gl::sizei_t * length, gl::charARB_t * source) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glGetShaderSourceARB(obj, maxLength, length, source);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetShaderSourceARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    gl::int_t get_uniform_location(gl::handleARB_t programObj, const  gl::charARB_t * name) {
      if ( GLAD_GL_ARB_shader_objects ) {
        return glGetUniformLocationARB(programObj, name);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetUniformLocationARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void get_uniformfv(gl::handleARB_t programObj, gl::int_t location, gl::float_t * params) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glGetUniformfvARB(programObj, location, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetUniformfvARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void get_uniformiv(gl::handleARB_t programObj, gl::int_t location, gl::int_t * params) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glGetUniformivARB(programObj, location, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetUniformivARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void link_program(gl::handleARB_t programObj) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glLinkProgramARB(programObj);
      }
      else {
        throw std::runtime_error("OpenGL command 'glLinkProgramARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void shader_source(gl::handleARB_t shaderObj, gl::sizei_t count, const  gl::charARB_t ** string, const  gl::int_t * length) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glShaderSourceARB(shaderObj, count, string, length);
      }
      else {
        throw std::runtime_error("OpenGL command 'glShaderSourceARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void uniform_1f(gl::int_t location, gl::float_t v0) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glUniform1fARB(location, v0);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform1fARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void uniform_1fv(gl::int_t location, gl::sizei_t count, const  gl::float_t * value) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glUniform1fvARB(location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform1fvARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void uniform_1i(gl::int_t location, gl::int_t v0) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glUniform1iARB(location, v0);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform1iARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void uniform_1iv(gl::int_t location, gl::sizei_t count, const  gl::int_t * value) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glUniform1ivARB(location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform1ivARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void uniform_2f(gl::int_t location, gl::float_t v0, gl::float_t v1) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glUniform2fARB(location, v0, v1);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform2fARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void uniform_2fv(gl::int_t location, gl::sizei_t count, const  gl::float_t * value) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glUniform2fvARB(location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform2fvARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void uniform_2i(gl::int_t location, gl::int_t v0, gl::int_t v1) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glUniform2iARB(location, v0, v1);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform2iARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void uniform_2iv(gl::int_t location, gl::sizei_t count, const  gl::int_t * value) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glUniform2ivARB(location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform2ivARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void uniform_3f(gl::int_t location, gl::float_t v0, gl::float_t v1, gl::float_t v2) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glUniform3fARB(location, v0, v1, v2);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform3fARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void uniform_3fv(gl::int_t location, gl::sizei_t count, const  gl::float_t * value) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glUniform3fvARB(location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform3fvARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void uniform_3i(gl::int_t location, gl::int_t v0, gl::int_t v1, gl::int_t v2) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glUniform3iARB(location, v0, v1, v2);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform3iARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void uniform_3iv(gl::int_t location, gl::sizei_t count, const  gl::int_t * value) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glUniform3ivARB(location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform3ivARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void uniform_4f(gl::int_t location, gl::float_t v0, gl::float_t v1, gl::float_t v2, gl::float_t v3) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glUniform4fARB(location, v0, v1, v2, v3);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform4fARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void uniform_4fv(gl::int_t location, gl::sizei_t count, const  gl::float_t * value) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glUniform4fvARB(location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform4fvARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void uniform_4i(gl::int_t location, gl::int_t v0, gl::int_t v1, gl::int_t v2, gl::int_t v3) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glUniform4iARB(location, v0, v1, v2, v3);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform4iARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void uniform_4iv(gl::int_t location, gl::sizei_t count, const  gl::int_t * value) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glUniform4ivARB(location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform4ivARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void uniform_matrix_2fv(gl::int_t location, gl::sizei_t count, gl::boolean_t transpose, const  gl::float_t * value) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glUniformMatrix2fvARB(location, count, transpose, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniformMatrix2fvARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void uniform_matrix_3fv(gl::int_t location, gl::sizei_t count, gl::boolean_t transpose, const  gl::float_t * value) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glUniformMatrix3fvARB(location, count, transpose, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniformMatrix3fvARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void uniform_matrix_4fv(gl::int_t location, gl::sizei_t count, gl::boolean_t transpose, const  gl::float_t * value) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glUniformMatrix4fvARB(location, count, transpose, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniformMatrix4fvARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void use_program_object(gl::handleARB_t programObj) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glUseProgramObjectARB(programObj);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUseProgramObjectARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void validate_program(gl::handleARB_t programObj) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glValidateProgramARB(programObj);
      }
      else {
        throw std::runtime_error("OpenGL command 'glValidateProgramARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void compressed_tex_image_1d(texture_target_t target, gl::int_t level, gl::enum_t internalformat, gl::sizei_t width, gl::int_t border, gl::sizei_t imageSize, const  void * data) {
      if ( GLAD_GL_ARB_texture_compression ) {
        glCompressedTexImage1DARB(static_cast<GLenum>(target), level, internalformat, width, border, imageSize, data);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCompressedTexImage1DARB' not available on this platform (extensions: GL_ARB_texture_compression)");
      }
    }

    void compressed_tex_image_2d(texture_target_t target, gl::int_t level, gl::enum_t internalformat, gl::sizei_t width, gl::sizei_t height, gl::int_t border, gl::sizei_t imageSize, const  void * data) {
      if ( GLAD_GL_ARB_texture_compression ) {
        glCompressedTexImage2DARB(static_cast<GLenum>(target), level, internalformat, width, height, border, imageSize, data);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCompressedTexImage2DARB' not available on this platform (extensions: GL_ARB_texture_compression)");
      }
    }

    void compressed_tex_image_3d(texture_target_t target, gl::int_t level, gl::enum_t internalformat, gl::sizei_t width, gl::sizei_t height, gl::sizei_t depth, gl::int_t border, gl::sizei_t imageSize, const  void * data) {
      if ( GLAD_GL_ARB_texture_compression ) {
        glCompressedTexImage3DARB(static_cast<GLenum>(target), level, internalformat, width, height, depth, border, imageSize, data);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCompressedTexImage3DARB' not available on this platform (extensions: GL_ARB_texture_compression)");
      }
    }

    void compressed_tex_sub_image_1d(texture_target_t target, gl::int_t level, gl::int_t xoffset, gl::sizei_t width, pixel_format_t format, gl::sizei_t imageSize, const  void * data) {
      if ( GLAD_GL_ARB_texture_compression ) {
        glCompressedTexSubImage1DARB(static_cast<GLenum>(target), level, xoffset, width, static_cast<GLenum>(format), imageSize, data);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCompressedTexSubImage1DARB' not available on this platform (extensions: GL_ARB_texture_compression)");
      }
    }

    void compressed_tex_sub_image_2d(texture_target_t target, gl::int_t level, gl::int_t xoffset, gl::int_t yoffset, gl::sizei_t width, gl::sizei_t height, pixel_format_t format, gl::sizei_t imageSize, const  void * data) {
      if ( GLAD_GL_ARB_texture_compression ) {
        glCompressedTexSubImage2DARB(static_cast<GLenum>(target), level, xoffset, yoffset, width, height, static_cast<GLenum>(format), imageSize, data);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCompressedTexSubImage2DARB' not available on this platform (extensions: GL_ARB_texture_compression)");
      }
    }

    void compressed_tex_sub_image_3d(texture_target_t target, gl::int_t level, gl::int_t xoffset, gl::int_t yoffset, gl::int_t zoffset, gl::sizei_t width, gl::sizei_t height, gl::sizei_t depth, pixel_format_t format, gl::sizei_t imageSize, const  void * data) {
      if ( GLAD_GL_ARB_texture_compression ) {
        glCompressedTexSubImage3DARB(static_cast<GLenum>(target), level, xoffset, yoffset, zoffset, width, height, depth, static_cast<GLenum>(format), imageSize, data);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCompressedTexSubImage3DARB' not available on this platform (extensions: GL_ARB_texture_compression)");
      }
    }

    void get_compressed_tex_image(texture_target_t target, gl::int_t level, void * img) {
      if ( GLAD_GL_ARB_texture_compression ) {
        glGetCompressedTexImageARB(static_cast<GLenum>(target), level, img);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetCompressedTexImageARB' not available on this platform (extensions: GL_ARB_texture_compression)");
      }
    }

    void load_transpose_matrixd(const  gl::double_t * m) {
      if ( GLAD_GL_ARB_transpose_matrix ) {
        glLoadTransposeMatrixdARB(m);
      }
      else {
        throw std::runtime_error("OpenGL command 'glLoadTransposeMatrixdARB' not available on this platform (extensions: GL_ARB_transpose_matrix)");
      }
    }

    void load_transpose_matrixf(const  gl::float_t * m) {
      if ( GLAD_GL_ARB_transpose_matrix ) {
        glLoadTransposeMatrixfARB(m);
      }
      else {
        throw std::runtime_error("OpenGL command 'glLoadTransposeMatrixfARB' not available on this platform (extensions: GL_ARB_transpose_matrix)");
      }
    }

    void mult_transpose_matrixd(const  gl::double_t * m) {
      if ( GLAD_GL_ARB_transpose_matrix ) {
        glMultTransposeMatrixdARB(m);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultTransposeMatrixdARB' not available on this platform (extensions: GL_ARB_transpose_matrix)");
      }
    }

    void mult_transpose_matrixf(const  gl::float_t * m) {
      if ( GLAD_GL_ARB_transpose_matrix ) {
        glMultTransposeMatrixfARB(m);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultTransposeMatrixfARB' not available on this platform (extensions: GL_ARB_transpose_matrix)");
      }
    }

    void vertex_blend(gl::int_t count) {
      if ( GLAD_GL_ARB_vertex_blend ) {
        glVertexBlendARB(count);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexBlendARB' not available on this platform (extensions: GL_ARB_vertex_blend)");
      }
    }

    void weight_pointer(gl::int_t size, gl::enum_t type, gl::sizei_t stride, const  void * pointer) {
      if ( GLAD_GL_ARB_vertex_blend ) {
        glWeightPointerARB(size, type, stride, pointer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWeightPointerARB' not available on this platform (extensions: GL_ARB_vertex_blend)");
      }
    }

    void weightbv(gl::int_t size, const  gl::byte_t * weights) {
      if ( GLAD_GL_ARB_vertex_blend ) {
        glWeightbvARB(size, weights);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWeightbvARB' not available on this platform (extensions: GL_ARB_vertex_blend)");
      }
    }

    void weightdv(gl::int_t size, const  gl::double_t * weights) {
      if ( GLAD_GL_ARB_vertex_blend ) {
        glWeightdvARB(size, weights);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWeightdvARB' not available on this platform (extensions: GL_ARB_vertex_blend)");
      }
    }

    void weightfv(gl::int_t size, const  gl::float_t * weights) {
      if ( GLAD_GL_ARB_vertex_blend ) {
        glWeightfvARB(size, weights);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWeightfvARB' not available on this platform (extensions: GL_ARB_vertex_blend)");
      }
    }

    void weightiv(gl::int_t size, const  gl::int_t * weights) {
      if ( GLAD_GL_ARB_vertex_blend ) {
        glWeightivARB(size, weights);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWeightivARB' not available on this platform (extensions: GL_ARB_vertex_blend)");
      }
    }

    void weightsv(gl::int_t size, const  gl::short_t * weights) {
      if ( GLAD_GL_ARB_vertex_blend ) {
        glWeightsvARB(size, weights);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWeightsvARB' not available on this platform (extensions: GL_ARB_vertex_blend)");
      }
    }

    void weightubv(gl::int_t size, const  gl::ubyte_t * weights) {
      if ( GLAD_GL_ARB_vertex_blend ) {
        glWeightubvARB(size, weights);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWeightubvARB' not available on this platform (extensions: GL_ARB_vertex_blend)");
      }
    }

    void weightuiv(gl::int_t size, const  gl::uint_t * weights) {
      if ( GLAD_GL_ARB_vertex_blend ) {
        glWeightuivARB(size, weights);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWeightuivARB' not available on this platform (extensions: GL_ARB_vertex_blend)");
      }
    }

    void weightusv(gl::int_t size, const  gl::ushort_t * weights) {
      if ( GLAD_GL_ARB_vertex_blend ) {
        glWeightusvARB(size, weights);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWeightusvARB' not available on this platform (extensions: GL_ARB_vertex_blend)");
      }
    }

    void bind_buffer(buffer_target_arb_t target, gl::uint_t buffer) {
      if ( GLAD_GL_ARB_vertex_buffer_object ) {
        glBindBufferARB(static_cast<GLenum>(target), buffer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBindBufferARB' not available on this platform (extensions: GL_ARB_vertex_buffer_object)");
      }
    }

    void buffer_data(buffer_target_arb_t target, gl::sizeiptrARB_t size, const  void * data, buffer_usage_arb_t usage) {
      if ( GLAD_GL_ARB_vertex_buffer_object ) {
        glBufferDataARB(static_cast<GLenum>(target), size, data, static_cast<GLenum>(usage));
      }
      else {
        throw std::runtime_error("OpenGL command 'glBufferDataARB' not available on this platform (extensions: GL_ARB_vertex_buffer_object)");
      }
    }

    void buffer_sub_data(buffer_target_arb_t target, gl::intptrARB_t offset, gl::sizeiptrARB_t size, const  void * data) {
      if ( GLAD_GL_ARB_vertex_buffer_object ) {
        glBufferSubDataARB(static_cast<GLenum>(target), offset, size, data);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBufferSubDataARB' not available on this platform (extensions: GL_ARB_vertex_buffer_object)");
      }
    }

    void delete_buffers(gl::sizei_t n, const  gl::uint_t * buffers) {
      if ( GLAD_GL_ARB_vertex_buffer_object ) {
        glDeleteBuffersARB(n, buffers);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDeleteBuffersARB' not available on this platform (extensions: GL_ARB_vertex_buffer_object)");
      }
    }

    void gen_buffers(gl::sizei_t n, gl::uint_t * buffers) {
      if ( GLAD_GL_ARB_vertex_buffer_object ) {
        glGenBuffersARB(n, buffers);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGenBuffersARB' not available on this platform (extensions: GL_ARB_vertex_buffer_object)");
      }
    }

    void get_buffer_parameteriv(buffer_target_arb_t target, buffer_p_name_arb_t pname, gl::int_t * params) {
      if ( GLAD_GL_ARB_vertex_buffer_object ) {
        glGetBufferParameterivARB(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetBufferParameterivARB' not available on this platform (extensions: GL_ARB_vertex_buffer_object)");
      }
    }

    void get_buffer_pointerv(buffer_target_arb_t target, gl::enum_t pname, void ** params) {
      if ( GLAD_GL_ARB_vertex_buffer_object ) {
        glGetBufferPointervARB(static_cast<GLenum>(target), pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetBufferPointervARB' not available on this platform (extensions: GL_ARB_vertex_buffer_object)");
      }
    }

    void get_buffer_sub_data(buffer_target_arb_t target, gl::intptrARB_t offset, gl::sizeiptrARB_t size, void * data) {
      if ( GLAD_GL_ARB_vertex_buffer_object ) {
        glGetBufferSubDataARB(static_cast<GLenum>(target), offset, size, data);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetBufferSubDataARB' not available on this platform (extensions: GL_ARB_vertex_buffer_object)");
      }
    }

    gl::boolean_t is_buffer(gl::uint_t buffer) {
      if ( GLAD_GL_ARB_vertex_buffer_object ) {
        return glIsBufferARB(buffer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glIsBufferARB' not available on this platform (extensions: GL_ARB_vertex_buffer_object)");
      }
    }

    void * map_buffer(buffer_target_arb_t target, gl::enum_t access) {
      if ( GLAD_GL_ARB_vertex_buffer_object ) {
        return glMapBufferARB(static_cast<GLenum>(target), access);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMapBufferARB' not available on this platform (extensions: GL_ARB_vertex_buffer_object)");
      }
    }

    gl::boolean_t unmap_buffer(buffer_target_arb_t target) {
      if ( GLAD_GL_ARB_vertex_buffer_object ) {
        return glUnmapBufferARB(static_cast<GLenum>(target));
      }
      else {
        throw std::runtime_error("OpenGL command 'glUnmapBufferARB' not available on this platform (extensions: GL_ARB_vertex_buffer_object)");
      }
    }

    void disable_vertex_attrib_array(gl::uint_t index) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glDisableVertexAttribArrayARB(index);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDisableVertexAttribArrayARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void enable_vertex_attrib_array(gl::uint_t index) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glEnableVertexAttribArrayARB(index);
      }
      else {
        throw std::runtime_error("OpenGL command 'glEnableVertexAttribArrayARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void get_vertex_attrib_pointerv(gl::uint_t index, vertex_attrib_pointer_property_arb_t pname, void ** pointer) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glGetVertexAttribPointervARB(index, static_cast<GLenum>(pname), pointer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetVertexAttribPointervARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void get_vertex_attribdv(gl::uint_t index, vertex_attrib_property_arb_t pname, gl::double_t * params) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glGetVertexAttribdvARB(index, static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetVertexAttribdvARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void get_vertex_attribfv(gl::uint_t index, vertex_attrib_property_arb_t pname, gl::float_t * params) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glGetVertexAttribfvARB(index, static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetVertexAttribfvARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void get_vertex_attribiv(gl::uint_t index, vertex_attrib_property_arb_t pname, gl::int_t * params) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glGetVertexAttribivARB(index, static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetVertexAttribivARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_1d(gl::uint_t index, gl::double_t x) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib1dARB(index, x);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib1dARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_1dv(gl::uint_t index, const  gl::double_t * v) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib1dvARB(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib1dvARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_1f(gl::uint_t index, gl::float_t x) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib1fARB(index, x);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib1fARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_1fv(gl::uint_t index, const  gl::float_t * v) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib1fvARB(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib1fvARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_1s(gl::uint_t index, gl::short_t x) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib1sARB(index, x);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib1sARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_1sv(gl::uint_t index, const  gl::short_t * v) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib1svARB(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib1svARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_2d(gl::uint_t index, gl::double_t x, gl::double_t y) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib2dARB(index, x, y);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib2dARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_2dv(gl::uint_t index, const  gl::double_t * v) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib2dvARB(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib2dvARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_2f(gl::uint_t index, gl::float_t x, gl::float_t y) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib2fARB(index, x, y);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib2fARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_2fv(gl::uint_t index, const  gl::float_t * v) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib2fvARB(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib2fvARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_2s(gl::uint_t index, gl::short_t x, gl::short_t y) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib2sARB(index, x, y);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib2sARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_2sv(gl::uint_t index, const  gl::short_t * v) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib2svARB(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib2svARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_3d(gl::uint_t index, gl::double_t x, gl::double_t y, gl::double_t z) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib3dARB(index, x, y, z);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib3dARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_3dv(gl::uint_t index, const  gl::double_t * v) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib3dvARB(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib3dvARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_3f(gl::uint_t index, gl::float_t x, gl::float_t y, gl::float_t z) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib3fARB(index, x, y, z);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib3fARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_3fv(gl::uint_t index, const  gl::float_t * v) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib3fvARB(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib3fvARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_3s(gl::uint_t index, gl::short_t x, gl::short_t y, gl::short_t z) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib3sARB(index, x, y, z);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib3sARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_3sv(gl::uint_t index, const  gl::short_t * v) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib3svARB(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib3svARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_4_nbv(gl::uint_t index, const  gl::byte_t * v) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib4NbvARB(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib4NbvARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_4_niv(gl::uint_t index, const  gl::int_t * v) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib4NivARB(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib4NivARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_4_nsv(gl::uint_t index, const  gl::short_t * v) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib4NsvARB(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib4NsvARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_4_nub(gl::uint_t index, gl::ubyte_t x, gl::ubyte_t y, gl::ubyte_t z, gl::ubyte_t w) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib4NubARB(index, x, y, z, w);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib4NubARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_4_nubv(gl::uint_t index, const  gl::ubyte_t * v) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib4NubvARB(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib4NubvARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_4_nuiv(gl::uint_t index, const  gl::uint_t * v) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib4NuivARB(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib4NuivARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_4_nusv(gl::uint_t index, const  gl::ushort_t * v) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib4NusvARB(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib4NusvARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_4bv(gl::uint_t index, const  gl::byte_t * v) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib4bvARB(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib4bvARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_4d(gl::uint_t index, gl::double_t x, gl::double_t y, gl::double_t z, gl::double_t w) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib4dARB(index, x, y, z, w);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib4dARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_4dv(gl::uint_t index, const  gl::double_t * v) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib4dvARB(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib4dvARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_4f(gl::uint_t index, gl::float_t x, gl::float_t y, gl::float_t z, gl::float_t w) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib4fARB(index, x, y, z, w);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib4fARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_4fv(gl::uint_t index, const  gl::float_t * v) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib4fvARB(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib4fvARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_4iv(gl::uint_t index, const  gl::int_t * v) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib4ivARB(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib4ivARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_4s(gl::uint_t index, gl::short_t x, gl::short_t y, gl::short_t z, gl::short_t w) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib4sARB(index, x, y, z, w);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib4sARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_4sv(gl::uint_t index, const  gl::short_t * v) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib4svARB(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib4svARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_4ubv(gl::uint_t index, const  gl::ubyte_t * v) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib4ubvARB(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib4ubvARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_4uiv(gl::uint_t index, const  gl::uint_t * v) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib4uivARB(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib4uivARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_4usv(gl::uint_t index, const  gl::ushort_t * v) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib4usvARB(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib4usvARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_pointer(gl::uint_t index, gl::int_t size, vertex_attrib_pointer_type_t type, gl::boolean_t normalized, gl::sizei_t stride, const  void * pointer) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttribPointerARB(index, size, static_cast<GLenum>(type), normalized, stride, pointer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribPointerARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void bind_attrib_location(gl::handleARB_t programObj, gl::uint_t index, const  gl::charARB_t * name) {
      if ( GLAD_GL_ARB_vertex_shader ) {
        glBindAttribLocationARB(programObj, index, name);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBindAttribLocationARB' not available on this platform (extensions: GL_ARB_vertex_shader)");
      }
    }

    void get_active_attrib(gl::handleARB_t programObj, gl::uint_t index, gl::sizei_t maxLength, gl::sizei_t * length, gl::int_t * size, attrib_type_t * type, gl::charARB_t * name) {
      if ( GLAD_GL_ARB_vertex_shader ) {
        glGetActiveAttribARB(programObj, index, maxLength, length, size, reinterpret_cast<GLenum *>(type), name);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetActiveAttribARB' not available on this platform (extensions: GL_ARB_vertex_shader)");
      }
    }

    gl::int_t get_attrib_location(gl::handleARB_t programObj, const  gl::charARB_t * name) {
      if ( GLAD_GL_ARB_vertex_shader ) {
        return glGetAttribLocationARB(programObj, name);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetAttribLocationARB' not available on this platform (extensions: GL_ARB_vertex_shader)");
      }
    }

    void window_pos_2d(gl::double_t x, gl::double_t y) {
      if ( GLAD_GL_ARB_window_pos ) {
        glWindowPos2dARB(x, y);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWindowPos2dARB' not available on this platform (extensions: GL_ARB_window_pos)");
      }
    }

    void window_pos_2dv(const  gl::double_t * v) {
      if ( GLAD_GL_ARB_window_pos ) {
        glWindowPos2dvARB(v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWindowPos2dvARB' not available on this platform (extensions: GL_ARB_window_pos)");
      }
    }

    void window_pos_2f(gl::float_t x, gl::float_t y) {
      if ( GLAD_GL_ARB_window_pos ) {
        glWindowPos2fARB(x, y);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWindowPos2fARB' not available on this platform (extensions: GL_ARB_window_pos)");
      }
    }

    void window_pos_2fv(const  gl::float_t * v) {
      if ( GLAD_GL_ARB_window_pos ) {
        glWindowPos2fvARB(v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWindowPos2fvARB' not available on this platform (extensions: GL_ARB_window_pos)");
      }
    }

    void window_pos_2i(gl::int_t x, gl::int_t y) {
      if ( GLAD_GL_ARB_window_pos ) {
        glWindowPos2iARB(x, y);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWindowPos2iARB' not available on this platform (extensions: GL_ARB_window_pos)");
      }
    }

    void window_pos_2iv(const  gl::int_t * v) {
      if ( GLAD_GL_ARB_window_pos ) {
        glWindowPos2ivARB(v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWindowPos2ivARB' not available on this platform (extensions: GL_ARB_window_pos)");
      }
    }

    void window_pos_2s(gl::short_t x, gl::short_t y) {
      if ( GLAD_GL_ARB_window_pos ) {
        glWindowPos2sARB(x, y);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWindowPos2sARB' not available on this platform (extensions: GL_ARB_window_pos)");
      }
    }

    void window_pos_2sv(const  gl::short_t * v) {
      if ( GLAD_GL_ARB_window_pos ) {
        glWindowPos2svARB(v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWindowPos2svARB' not available on this platform (extensions: GL_ARB_window_pos)");
      }
    }

    void window_pos_3d(gl::double_t x, gl::double_t y, gl::double_t z) {
      if ( GLAD_GL_ARB_window_pos ) {
        glWindowPos3dARB(x, y, z);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWindowPos3dARB' not available on this platform (extensions: GL_ARB_window_pos)");
      }
    }

    void window_pos_3dv(const  gl::double_t * v) {
      if ( GLAD_GL_ARB_window_pos ) {
        glWindowPos3dvARB(v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWindowPos3dvARB' not available on this platform (extensions: GL_ARB_window_pos)");
      }
    }

    void window_pos_3f(gl::float_t x, gl::float_t y, gl::float_t z) {
      if ( GLAD_GL_ARB_window_pos ) {
        glWindowPos3fARB(x, y, z);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWindowPos3fARB' not available on this platform (extensions: GL_ARB_window_pos)");
      }
    }

    void window_pos_3fv(const  gl::float_t * v) {
      if ( GLAD_GL_ARB_window_pos ) {
        glWindowPos3fvARB(v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWindowPos3fvARB' not available on this platform (extensions: GL_ARB_window_pos)");
      }
    }

    void window_pos_3i(gl::int_t x, gl::int_t y, gl::int_t z) {
      if ( GLAD_GL_ARB_window_pos ) {
        glWindowPos3iARB(x, y, z);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWindowPos3iARB' not available on this platform (extensions: GL_ARB_window_pos)");
      }
    }

    void window_pos_3iv(const  gl::int_t * v) {
      if ( GLAD_GL_ARB_window_pos ) {
        glWindowPos3ivARB(v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWindowPos3ivARB' not available on this platform (extensions: GL_ARB_window_pos)");
      }
    }

    void window_pos_3s(gl::short_t x, gl::short_t y, gl::short_t z) {
      if ( GLAD_GL_ARB_window_pos ) {
        glWindowPos3sARB(x, y, z);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWindowPos3sARB' not available on this platform (extensions: GL_ARB_window_pos)");
      }
    }

    void window_pos_3sv(const  gl::short_t * v) {
      if ( GLAD_GL_ARB_window_pos ) {
        glWindowPos3svARB(v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWindowPos3svARB' not available on this platform (extensions: GL_ARB_window_pos)");
      }
    }

    gl::int_t get_uniform_buffer_size(gl::uint_t program, gl::int_t location) {
      if ( GLAD_GL_EXT_bindable_uniform ) {
        return glGetUniformBufferSizeEXT(program, location);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetUniformBufferSizeEXT' not available on this platform (extensions: GL_EXT_bindable_uniform)");
      }
    }

    gl::intptr_t get_uniform_offset(gl::uint_t program, gl::int_t location) {
      if ( GLAD_GL_EXT_bindable_uniform ) {
        return glGetUniformOffsetEXT(program, location);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetUniformOffsetEXT' not available on this platform (extensions: GL_EXT_bindable_uniform)");
      }
    }

    void uniform_buffer(gl::uint_t program, gl::int_t location, gl::uint_t buffer) {
      if ( GLAD_GL_EXT_bindable_uniform ) {
        glUniformBufferEXT(program, location, buffer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniformBufferEXT' not available on this platform (extensions: GL_EXT_bindable_uniform)");
      }
    }

    void blend_color(gl::float_t red, gl::float_t green, gl::float_t blue, gl::float_t alpha) {
      if ( GLAD_GL_EXT_blend_color ) {
        glBlendColorEXT(red, green, blue, alpha);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBlendColorEXT' not available on this platform (extensions: GL_EXT_blend_color)");
      }
    }

    void blend_equation_separate(blend_equation_mode_ext_t modeRGB, blend_equation_mode_ext_t modeAlpha) {
      if ( GLAD_GL_EXT_blend_equation_separate ) {
        glBlendEquationSeparateEXT(static_cast<GLenum>(modeRGB), static_cast<GLenum>(modeAlpha));
      }
      else {
        throw std::runtime_error("OpenGL command 'glBlendEquationSeparateEXT' not available on this platform (extensions: GL_EXT_blend_equation_separate)");
      }
    }

    void blend_func_separate(blend_func_separate_parameter_ext_t sfactorRGB, blend_func_separate_parameter_ext_t dfactorRGB, blend_func_separate_parameter_ext_t sfactorAlpha, blend_func_separate_parameter_ext_t dfactorAlpha) {
      if ( GLAD_GL_EXT_blend_func_separate ) {
        glBlendFuncSeparateEXT(static_cast<GLenum>(sfactorRGB), static_cast<GLenum>(dfactorRGB), static_cast<GLenum>(sfactorAlpha), static_cast<GLenum>(dfactorAlpha));
      }
      else {
        throw std::runtime_error("OpenGL command 'glBlendFuncSeparateEXT' not available on this platform (extensions: GL_EXT_blend_func_separate)");
      }
    }

    void blend_equation(blend_equation_mode_ext_t mode) {
      if ( GLAD_GL_EXT_blend_minmax ) {
        glBlendEquationEXT(static_cast<GLenum>(mode));
      }
      else {
        throw std::runtime_error("OpenGL command 'glBlendEquationEXT' not available on this platform (extensions: GL_EXT_blend_minmax)");
      }
    }

    void get_object_label(gl::enum_t type, gl::uint_t object, gl::sizei_t bufSize, gl::sizei_t * length, gl::char_t * label) {
      if ( GLAD_GL_EXT_debug_label ) {
        glGetObjectLabelEXT(type, object, bufSize, length, label);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetObjectLabelEXT' not available on this platform (extensions: GL_EXT_debug_label)");
      }
    }

    void label_object(gl::enum_t type, gl::uint_t object, gl::sizei_t length, const  gl::char_t * label) {
      if ( GLAD_GL_EXT_debug_label ) {
        glLabelObjectEXT(type, object, length, label);
      }
      else {
        throw std::runtime_error("OpenGL command 'glLabelObjectEXT' not available on this platform (extensions: GL_EXT_debug_label)");
      }
    }

    void insert_event_marker(gl::sizei_t length, const  gl::char_t * marker) {
      if ( GLAD_GL_EXT_debug_marker ) {
        glInsertEventMarkerEXT(length, marker);
      }
      else {
        throw std::runtime_error("OpenGL command 'glInsertEventMarkerEXT' not available on this platform (extensions: GL_EXT_debug_marker)");
      }
    }

    void pop_group_marker() {
      if ( GLAD_GL_EXT_debug_marker ) {
        glPopGroupMarkerEXT();
      }
      else {
        throw std::runtime_error("OpenGL command 'glPopGroupMarkerEXT' not available on this platform (extensions: GL_EXT_debug_marker)");
      }
    }

    void push_group_marker(gl::sizei_t length, const  gl::char_t * marker) {
      if ( GLAD_GL_EXT_debug_marker ) {
        glPushGroupMarkerEXT(length, marker);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPushGroupMarkerEXT' not available on this platform (extensions: GL_EXT_debug_marker)");
      }
    }

    void disable_indexed(gl::enum_t target, gl::uint_t index) {
      if ( GLAD_GL_EXT_direct_state_access || GLAD_GL_EXT_draw_buffers2 ) {
        glDisableIndexedEXT(target, index);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDisableIndexedEXT' not available on this platform (extensions: GL_EXT_direct_state_access, GL_EXT_draw_buffers2)");
      }
    }

    void enable_indexed(gl::enum_t target, gl::uint_t index) {
      if ( GLAD_GL_EXT_direct_state_access || GLAD_GL_EXT_draw_buffers2 ) {
        glEnableIndexedEXT(target, index);
      }
      else {
        throw std::runtime_error("OpenGL command 'glEnableIndexedEXT' not available on this platform (extensions: GL_EXT_direct_state_access, GL_EXT_draw_buffers2)");
      }
    }

    void get_boolean_indexedv(gl::enum_t target, gl::uint_t index, gl::boolean_t * data) {
      if ( GLAD_GL_EXT_direct_state_access || GLAD_GL_EXT_draw_buffers2 ) {
        glGetBooleanIndexedvEXT(target, index, data);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetBooleanIndexedvEXT' not available on this platform (extensions: GL_EXT_direct_state_access, GL_EXT_draw_buffers2)");
      }
    }

    void get_integer_indexedv(gl::enum_t target, gl::uint_t index, gl::int_t * data) {
      if ( GLAD_GL_EXT_direct_state_access || GLAD_GL_EXT_draw_buffers2 ) {
        glGetIntegerIndexedvEXT(target, index, data);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetIntegerIndexedvEXT' not available on this platform (extensions: GL_EXT_direct_state_access, GL_EXT_draw_buffers2)");
      }
    }

    gl::boolean_t is_enabled_indexed(gl::enum_t target, gl::uint_t index) {
      if ( GLAD_GL_EXT_direct_state_access || GLAD_GL_EXT_draw_buffers2 ) {
        return glIsEnabledIndexedEXT(target, index);
      }
      else {
        throw std::runtime_error("OpenGL command 'glIsEnabledIndexedEXT' not available on this platform (extensions: GL_EXT_direct_state_access, GL_EXT_draw_buffers2)");
      }
    }

    void get_query_objecti_64v(gl::uint_t id, gl::enum_t pname, gl::int64_t * params) {
      if ( GLAD_GL_EXT_timer_query ) {
        glGetQueryObjecti64vEXT(id, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetQueryObjecti64vEXT' not available on this platform (extensions: GL_EXT_timer_query)");
      }
    }

    void get_query_objectui_64v(gl::uint_t id, gl::enum_t pname, gl::uint64_t * params) {
      if ( GLAD_GL_EXT_timer_query ) {
        glGetQueryObjectui64vEXT(id, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetQueryObjectui64vEXT' not available on this platform (extensions: GL_EXT_timer_query)");
      }
    }

    void color_mask_indexed(gl::uint_t index, gl::boolean_t r, gl::boolean_t g, gl::boolean_t b, gl::boolean_t a) {
      if ( GLAD_GL_EXT_draw_buffers2 ) {
        glColorMaskIndexedEXT(index, r, g, b, a);
      }
      else {
        throw std::runtime_error("OpenGL command 'glColorMaskIndexedEXT' not available on this platform (extensions: GL_EXT_draw_buffers2)");
      }
    }

    void draw_range_elements(primitive_type_t mode, gl::uint_t start, gl::uint_t end, gl::sizei_t count, draw_elements_type_t type, const  void * indices) {
      if ( GLAD_GL_EXT_draw_range_elements ) {
        glDrawRangeElementsEXT(static_cast<GLenum>(mode), start, end, count, static_cast<GLenum>(type), indices);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDrawRangeElementsEXT' not available on this platform (extensions: GL_EXT_draw_range_elements)");
      }
    }

    void fog_coord_pointer(fog_pointer_type_ext_t type, gl::sizei_t stride, const  void * pointer) {
      if ( GLAD_GL_EXT_fog_coord ) {
        glFogCoordPointerEXT(static_cast<GLenum>(type), stride, pointer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFogCoordPointerEXT' not available on this platform (extensions: GL_EXT_fog_coord)");
      }
    }

    void fog_coordd(gl::double_t coord) {
      if ( GLAD_GL_EXT_fog_coord ) {
        glFogCoorddEXT(coord);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFogCoorddEXT' not available on this platform (extensions: GL_EXT_fog_coord)");
      }
    }

    void fog_coorddv(const  gl::double_t * coord) {
      if ( GLAD_GL_EXT_fog_coord ) {
        glFogCoorddvEXT(coord);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFogCoorddvEXT' not available on this platform (extensions: GL_EXT_fog_coord)");
      }
    }

    void fog_coordf(gl::float_t coord) {
      if ( GLAD_GL_EXT_fog_coord ) {
        glFogCoordfEXT(coord);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFogCoordfEXT' not available on this platform (extensions: GL_EXT_fog_coord)");
      }
    }

    void fog_coordfv(const  gl::float_t * coord) {
      if ( GLAD_GL_EXT_fog_coord ) {
        glFogCoordfvEXT(coord);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFogCoordfvEXT' not available on this platform (extensions: GL_EXT_fog_coord)");
      }
    }

    void blit_framebuffer(gl::int_t srcX0, gl::int_t srcY0, gl::int_t srcX1, gl::int_t srcY1, gl::int_t dstX0, gl::int_t dstY0, gl::int_t dstX1, gl::int_t dstY1, gl::bitmask<clear_buffer_flags_t> mask, gl::enum_t filter) {
      if ( GLAD_GL_EXT_framebuffer_blit ) {
        glBlitFramebufferEXT(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, static_cast<GLbitfield>(mask.value), filter);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBlitFramebufferEXT' not available on this platform (extensions: GL_EXT_framebuffer_blit)");
      }
    }

    void renderbuffer_storage_multisample(renderbuffer_target_t target, gl::sizei_t samples, internal_format_t internalformat, gl::sizei_t width, gl::sizei_t height) {
      if ( GLAD_GL_EXT_framebuffer_multisample ) {
        glRenderbufferStorageMultisampleEXT(static_cast<GLenum>(target), samples, static_cast<GLenum>(internalformat), width, height);
      }
      else {
        throw std::runtime_error("OpenGL command 'glRenderbufferStorageMultisampleEXT' not available on this platform (extensions: GL_EXT_framebuffer_multisample)");
      }
    }

    void bind_framebuffer(framebuffer_target_t target, gl::uint_t framebuffer) {
      if ( GLAD_GL_EXT_framebuffer_object ) {
        glBindFramebufferEXT(static_cast<GLenum>(target), framebuffer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBindFramebufferEXT' not available on this platform (extensions: GL_EXT_framebuffer_object)");
      }
    }

    void bind_renderbuffer(renderbuffer_target_t target, gl::uint_t renderbuffer) {
      if ( GLAD_GL_EXT_framebuffer_object ) {
        glBindRenderbufferEXT(static_cast<GLenum>(target), renderbuffer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBindRenderbufferEXT' not available on this platform (extensions: GL_EXT_framebuffer_object)");
      }
    }

    gl::enum_t check_framebuffer_status(framebuffer_target_t target) {
      if ( GLAD_GL_EXT_framebuffer_object ) {
        return glCheckFramebufferStatusEXT(static_cast<GLenum>(target));
      }
      else {
        throw std::runtime_error("OpenGL command 'glCheckFramebufferStatusEXT' not available on this platform (extensions: GL_EXT_framebuffer_object)");
      }
    }

    void delete_framebuffers(gl::sizei_t n, const  gl::uint_t * framebuffers) {
      if ( GLAD_GL_EXT_framebuffer_object ) {
        glDeleteFramebuffersEXT(n, framebuffers);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDeleteFramebuffersEXT' not available on this platform (extensions: GL_EXT_framebuffer_object)");
      }
    }

    void delete_renderbuffers(gl::sizei_t n, const  gl::uint_t * renderbuffers) {
      if ( GLAD_GL_EXT_framebuffer_object ) {
        glDeleteRenderbuffersEXT(n, renderbuffers);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDeleteRenderbuffersEXT' not available on this platform (extensions: GL_EXT_framebuffer_object)");
      }
    }

    void framebuffer_renderbuffer(framebuffer_target_t target, framebuffer_attachment_t attachment, renderbuffer_target_t renderbuffertarget, gl::uint_t renderbuffer) {
      if ( GLAD_GL_EXT_framebuffer_object ) {
        glFramebufferRenderbufferEXT(static_cast<GLenum>(target), static_cast<GLenum>(attachment), static_cast<GLenum>(renderbuffertarget), renderbuffer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFramebufferRenderbufferEXT' not available on this platform (extensions: GL_EXT_framebuffer_object)");
      }
    }

    void framebuffer_texture_1d(framebuffer_target_t target, framebuffer_attachment_t attachment, gl::enum_t textarget, gl::uint_t texture, gl::int_t level) {
      if ( GLAD_GL_EXT_framebuffer_object ) {
        glFramebufferTexture1DEXT(static_cast<GLenum>(target), static_cast<GLenum>(attachment), textarget, texture, level);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFramebufferTexture1DEXT' not available on this platform (extensions: GL_EXT_framebuffer_object)");
      }
    }

    void framebuffer_texture_2d(framebuffer_target_t target, framebuffer_attachment_t attachment, framebuffer_texture_target_t textarget, gl::uint_t texture, gl::int_t level) {
      if ( GLAD_GL_EXT_framebuffer_object ) {
        glFramebufferTexture2DEXT(static_cast<GLenum>(target), static_cast<GLenum>(attachment), static_cast<GLenum>(textarget), texture, level);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFramebufferTexture2DEXT' not available on this platform (extensions: GL_EXT_framebuffer_object)");
      }
    }

    void framebuffer_texture_3d(framebuffer_target_t target, framebuffer_attachment_t attachment, gl::enum_t textarget, gl::uint_t texture, gl::int_t level, gl::int_t zoffset) {
      if ( GLAD_GL_EXT_framebuffer_object ) {
        glFramebufferTexture3DEXT(static_cast<GLenum>(target), static_cast<GLenum>(attachment), textarget, texture, level, zoffset);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFramebufferTexture3DEXT' not available on this platform (extensions: GL_EXT_framebuffer_object)");
      }
    }

    void gen_framebuffers(gl::sizei_t n, gl::uint_t * framebuffers) {
      if ( GLAD_GL_EXT_framebuffer_object ) {
        glGenFramebuffersEXT(n, framebuffers);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGenFramebuffersEXT' not available on this platform (extensions: GL_EXT_framebuffer_object)");
      }
    }

    void gen_renderbuffers(gl::sizei_t n, gl::uint_t * renderbuffers) {
      if ( GLAD_GL_EXT_framebuffer_object ) {
        glGenRenderbuffersEXT(n, renderbuffers);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGenRenderbuffersEXT' not available on this platform (extensions: GL_EXT_framebuffer_object)");
      }
    }

    void generate_mipmap(mipmap_target_t target) {
      if ( GLAD_GL_EXT_framebuffer_object ) {
        glGenerateMipmapEXT(static_cast<GLenum>(target));
      }
      else {
        throw std::runtime_error("OpenGL command 'glGenerateMipmapEXT' not available on this platform (extensions: GL_EXT_framebuffer_object)");
      }
    }

    void get_framebuffer_attachment_parameteriv(framebuffer_target_t target, framebuffer_attachment_t attachment, gl::enum_t pname, gl::int_t * params) {
      if ( GLAD_GL_EXT_framebuffer_object ) {
        glGetFramebufferAttachmentParameterivEXT(static_cast<GLenum>(target), static_cast<GLenum>(attachment), pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetFramebufferAttachmentParameterivEXT' not available on this platform (extensions: GL_EXT_framebuffer_object)");
      }
    }

    void get_renderbuffer_parameteriv(renderbuffer_target_t target, gl::enum_t pname, gl::int_t * params) {
      if ( GLAD_GL_EXT_framebuffer_object ) {
        glGetRenderbufferParameterivEXT(static_cast<GLenum>(target), pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetRenderbufferParameterivEXT' not available on this platform (extensions: GL_EXT_framebuffer_object)");
      }
    }

    gl::boolean_t is_framebuffer(gl::uint_t framebuffer) {
      if ( GLAD_GL_EXT_framebuffer_object ) {
        return glIsFramebufferEXT(framebuffer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glIsFramebufferEXT' not available on this platform (extensions: GL_EXT_framebuffer_object)");
      }
    }

    gl::boolean_t is_renderbuffer(gl::uint_t renderbuffer) {
      if ( GLAD_GL_EXT_framebuffer_object ) {
        return glIsRenderbufferEXT(renderbuffer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glIsRenderbufferEXT' not available on this platform (extensions: GL_EXT_framebuffer_object)");
      }
    }

    void renderbuffer_storage(renderbuffer_target_t target, internal_format_t internalformat, gl::sizei_t width, gl::sizei_t height) {
      if ( GLAD_GL_EXT_framebuffer_object ) {
        glRenderbufferStorageEXT(static_cast<GLenum>(target), static_cast<GLenum>(internalformat), width, height);
      }
      else {
        throw std::runtime_error("OpenGL command 'glRenderbufferStorageEXT' not available on this platform (extensions: GL_EXT_framebuffer_object)");
      }
    }

    void program_parameteri(gl::uint_t program, gl::enum_t pname, gl::int_t value) {
      if ( GLAD_GL_EXT_geometry_shader4 ) {
        glProgramParameteriEXT(program, pname, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramParameteriEXT' not available on this platform (extensions: GL_EXT_geometry_shader4)");
      }
    }

    void program_env_parameters_4fv(gl::enum_t target, gl::uint_t index, gl::sizei_t count, const  gl::float_t * params) {
      if ( GLAD_GL_EXT_gpu_program_parameters ) {
        glProgramEnvParameters4fvEXT(target, index, count, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramEnvParameters4fvEXT' not available on this platform (extensions: GL_EXT_gpu_program_parameters)");
      }
    }

    void program_local_parameters_4fv(gl::enum_t target, gl::uint_t index, gl::sizei_t count, const  gl::float_t * params) {
      if ( GLAD_GL_EXT_gpu_program_parameters ) {
        glProgramLocalParameters4fvEXT(target, index, count, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramLocalParameters4fvEXT' not available on this platform (extensions: GL_EXT_gpu_program_parameters)");
      }
    }

    void bind_frag_data_location(gl::uint_t program, gl::uint_t color, const  gl::char_t * name) {
      if ( GLAD_GL_EXT_gpu_shader4 ) {
        glBindFragDataLocationEXT(program, color, name);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBindFragDataLocationEXT' not available on this platform (extensions: GL_EXT_gpu_shader4)");
      }
    }

    gl::int_t get_frag_data_location(gl::uint_t program, const  gl::char_t * name) {
      if ( GLAD_GL_EXT_gpu_shader4 ) {
        return glGetFragDataLocationEXT(program, name);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetFragDataLocationEXT' not available on this platform (extensions: GL_EXT_gpu_shader4)");
      }
    }

    void get_uniformuiv(gl::uint_t program, gl::int_t location, gl::uint_t * params) {
      if ( GLAD_GL_EXT_gpu_shader4 ) {
        glGetUniformuivEXT(program, location, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetUniformuivEXT' not available on this platform (extensions: GL_EXT_gpu_shader4)");
      }
    }

    void uniform_1ui(gl::int_t location, gl::uint_t v0) {
      if ( GLAD_GL_EXT_gpu_shader4 ) {
        glUniform1uiEXT(location, v0);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform1uiEXT' not available on this platform (extensions: GL_EXT_gpu_shader4)");
      }
    }

    void uniform_1uiv(gl::int_t location, gl::sizei_t count, const  gl::uint_t * value) {
      if ( GLAD_GL_EXT_gpu_shader4 ) {
        glUniform1uivEXT(location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform1uivEXT' not available on this platform (extensions: GL_EXT_gpu_shader4)");
      }
    }

    void uniform_2ui(gl::int_t location, gl::uint_t v0, gl::uint_t v1) {
      if ( GLAD_GL_EXT_gpu_shader4 ) {
        glUniform2uiEXT(location, v0, v1);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform2uiEXT' not available on this platform (extensions: GL_EXT_gpu_shader4)");
      }
    }

    void uniform_2uiv(gl::int_t location, gl::sizei_t count, const  gl::uint_t * value) {
      if ( GLAD_GL_EXT_gpu_shader4 ) {
        glUniform2uivEXT(location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform2uivEXT' not available on this platform (extensions: GL_EXT_gpu_shader4)");
      }
    }

    void uniform_3ui(gl::int_t location, gl::uint_t v0, gl::uint_t v1, gl::uint_t v2) {
      if ( GLAD_GL_EXT_gpu_shader4 ) {
        glUniform3uiEXT(location, v0, v1, v2);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform3uiEXT' not available on this platform (extensions: GL_EXT_gpu_shader4)");
      }
    }

    void uniform_3uiv(gl::int_t location, gl::sizei_t count, const  gl::uint_t * value) {
      if ( GLAD_GL_EXT_gpu_shader4 ) {
        glUniform3uivEXT(location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform3uivEXT' not available on this platform (extensions: GL_EXT_gpu_shader4)");
      }
    }

    void uniform_4ui(gl::int_t location, gl::uint_t v0, gl::uint_t v1, gl::uint_t v2, gl::uint_t v3) {
      if ( GLAD_GL_EXT_gpu_shader4 ) {
        glUniform4uiEXT(location, v0, v1, v2, v3);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform4uiEXT' not available on this platform (extensions: GL_EXT_gpu_shader4)");
      }
    }

    void uniform_4uiv(gl::int_t location, gl::sizei_t count, const  gl::uint_t * value) {
      if ( GLAD_GL_EXT_gpu_shader4 ) {
        glUniform4uivEXT(location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform4uivEXT' not available on this platform (extensions: GL_EXT_gpu_shader4)");
      }
    }

    void multi_draw_arrays(primitive_type_t mode, const  gl::int_t * first, const  gl::sizei_t * count, gl::sizei_t primcount) {
      if ( GLAD_GL_EXT_multi_draw_arrays ) {
        glMultiDrawArraysEXT(static_cast<GLenum>(mode), first, count, primcount);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiDrawArraysEXT' not available on this platform (extensions: GL_EXT_multi_draw_arrays)");
      }
    }

    void multi_draw_elements(primitive_type_t mode, const  gl::sizei_t * count, draw_elements_type_t type, const  void * * indices, gl::sizei_t primcount) {
      if ( GLAD_GL_EXT_multi_draw_arrays ) {
        glMultiDrawElementsEXT(static_cast<GLenum>(mode), count, static_cast<GLenum>(type), indices, primcount);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiDrawElementsEXT' not available on this platform (extensions: GL_EXT_multi_draw_arrays)");
      }
    }

    void provoking_vertex(gl::enum_t mode) {
      if ( GLAD_GL_EXT_provoking_vertex ) {
        glProvokingVertexEXT(mode);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProvokingVertexEXT' not available on this platform (extensions: GL_EXT_provoking_vertex)");
      }
    }

    void secondary_color_3b(gl::byte_t red, gl::byte_t green, gl::byte_t blue) {
      if ( GLAD_GL_EXT_secondary_color ) {
        glSecondaryColor3bEXT(red, green, blue);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSecondaryColor3bEXT' not available on this platform (extensions: GL_EXT_secondary_color)");
      }
    }

    void secondary_color_3bv(const  gl::byte_t * v) {
      if ( GLAD_GL_EXT_secondary_color ) {
        glSecondaryColor3bvEXT(v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSecondaryColor3bvEXT' not available on this platform (extensions: GL_EXT_secondary_color)");
      }
    }

    void secondary_color_3d(gl::double_t red, gl::double_t green, gl::double_t blue) {
      if ( GLAD_GL_EXT_secondary_color ) {
        glSecondaryColor3dEXT(red, green, blue);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSecondaryColor3dEXT' not available on this platform (extensions: GL_EXT_secondary_color)");
      }
    }

    void secondary_color_3dv(const  gl::double_t * v) {
      if ( GLAD_GL_EXT_secondary_color ) {
        glSecondaryColor3dvEXT(v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSecondaryColor3dvEXT' not available on this platform (extensions: GL_EXT_secondary_color)");
      }
    }

    void secondary_color_3f(gl::float_t red, gl::float_t green, gl::float_t blue) {
      if ( GLAD_GL_EXT_secondary_color ) {
        glSecondaryColor3fEXT(red, green, blue);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSecondaryColor3fEXT' not available on this platform (extensions: GL_EXT_secondary_color)");
      }
    }

    void secondary_color_3fv(const  gl::float_t * v) {
      if ( GLAD_GL_EXT_secondary_color ) {
        glSecondaryColor3fvEXT(v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSecondaryColor3fvEXT' not available on this platform (extensions: GL_EXT_secondary_color)");
      }
    }

    void secondary_color_3i(gl::int_t red, gl::int_t green, gl::int_t blue) {
      if ( GLAD_GL_EXT_secondary_color ) {
        glSecondaryColor3iEXT(red, green, blue);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSecondaryColor3iEXT' not available on this platform (extensions: GL_EXT_secondary_color)");
      }
    }

    void secondary_color_3iv(const  gl::int_t * v) {
      if ( GLAD_GL_EXT_secondary_color ) {
        glSecondaryColor3ivEXT(v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSecondaryColor3ivEXT' not available on this platform (extensions: GL_EXT_secondary_color)");
      }
    }

    void secondary_color_3s(gl::short_t red, gl::short_t green, gl::short_t blue) {
      if ( GLAD_GL_EXT_secondary_color ) {
        glSecondaryColor3sEXT(red, green, blue);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSecondaryColor3sEXT' not available on this platform (extensions: GL_EXT_secondary_color)");
      }
    }

    void secondary_color_3sv(const  gl::short_t * v) {
      if ( GLAD_GL_EXT_secondary_color ) {
        glSecondaryColor3svEXT(v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSecondaryColor3svEXT' not available on this platform (extensions: GL_EXT_secondary_color)");
      }
    }

    void secondary_color_3ub(gl::ubyte_t red, gl::ubyte_t green, gl::ubyte_t blue) {
      if ( GLAD_GL_EXT_secondary_color ) {
        glSecondaryColor3ubEXT(red, green, blue);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSecondaryColor3ubEXT' not available on this platform (extensions: GL_EXT_secondary_color)");
      }
    }

    void secondary_color_3ubv(const  gl::ubyte_t * v) {
      if ( GLAD_GL_EXT_secondary_color ) {
        glSecondaryColor3ubvEXT(v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSecondaryColor3ubvEXT' not available on this platform (extensions: GL_EXT_secondary_color)");
      }
    }

    void secondary_color_3ui(gl::uint_t red, gl::uint_t green, gl::uint_t blue) {
      if ( GLAD_GL_EXT_secondary_color ) {
        glSecondaryColor3uiEXT(red, green, blue);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSecondaryColor3uiEXT' not available on this platform (extensions: GL_EXT_secondary_color)");
      }
    }

    void secondary_color_3uiv(const  gl::uint_t * v) {
      if ( GLAD_GL_EXT_secondary_color ) {
        glSecondaryColor3uivEXT(v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSecondaryColor3uivEXT' not available on this platform (extensions: GL_EXT_secondary_color)");
      }
    }

    void secondary_color_3us(gl::ushort_t red, gl::ushort_t green, gl::ushort_t blue) {
      if ( GLAD_GL_EXT_secondary_color ) {
        glSecondaryColor3usEXT(red, green, blue);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSecondaryColor3usEXT' not available on this platform (extensions: GL_EXT_secondary_color)");
      }
    }

    void secondary_color_3usv(const  gl::ushort_t * v) {
      if ( GLAD_GL_EXT_secondary_color ) {
        glSecondaryColor3usvEXT(v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSecondaryColor3usvEXT' not available on this platform (extensions: GL_EXT_secondary_color)");
      }
    }

    void secondary_color_pointer(gl::int_t size, color_pointer_type_t type, gl::sizei_t stride, const  void * pointer) {
      if ( GLAD_GL_EXT_secondary_color ) {
        glSecondaryColorPointerEXT(size, static_cast<GLenum>(type), stride, pointer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSecondaryColorPointerEXT' not available on this platform (extensions: GL_EXT_secondary_color)");
      }
    }

    void active_stencil_face(stencil_face_direction_t face) {
      if ( GLAD_GL_EXT_stencil_two_side ) {
        glActiveStencilFaceEXT(static_cast<GLenum>(face));
      }
      else {
        throw std::runtime_error("OpenGL command 'glActiveStencilFaceEXT' not available on this platform (extensions: GL_EXT_stencil_two_side)");
      }
    }

    void framebuffer_texture_layer(framebuffer_target_t target, framebuffer_attachment_t attachment, gl::uint_t texture, gl::int_t level, gl::int_t layer) {
      if ( GLAD_GL_EXT_texture_array || GLAD_GL_NV_geometry_program4 ) {
        glFramebufferTextureLayerEXT(static_cast<GLenum>(target), static_cast<GLenum>(attachment), texture, level, layer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFramebufferTextureLayerEXT' not available on this platform (extensions: GL_EXT_texture_array, GL_NV_geometry_program4)");
      }
    }

    void get_tex_parameter_iiv(texture_target_t target, get_texture_parameter_t pname, gl::int_t * params) {
      if ( GLAD_GL_EXT_texture_integer ) {
        glGetTexParameterIivEXT(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetTexParameterIivEXT' not available on this platform (extensions: GL_EXT_texture_integer)");
      }
    }

    void get_tex_parameter_iuiv(texture_target_t target, get_texture_parameter_t pname, gl::uint_t * params) {
      if ( GLAD_GL_EXT_texture_integer ) {
        glGetTexParameterIuivEXT(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetTexParameterIuivEXT' not available on this platform (extensions: GL_EXT_texture_integer)");
      }
    }

    void tex_parameter_iiv(texture_target_t target, texture_parameter_name_t pname, const  gl::int_t * params) {
      if ( GLAD_GL_EXT_texture_integer ) {
        glTexParameterIivEXT(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexParameterIivEXT' not available on this platform (extensions: GL_EXT_texture_integer)");
      }
    }

    void tex_parameter_iuiv(texture_target_t target, texture_parameter_name_t pname, const  gl::uint_t * params) {
      if ( GLAD_GL_EXT_texture_integer ) {
        glTexParameterIuivEXT(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexParameterIuivEXT' not available on this platform (extensions: GL_EXT_texture_integer)");
      }
    }

    void clear_color_ii(gl::int_t red, gl::int_t green, gl::int_t blue, gl::int_t alpha) {
      if ( GLAD_GL_EXT_texture_integer ) {
        glClearColorIiEXT(red, green, blue, alpha);
      }
      else {
        throw std::runtime_error("OpenGL command 'glClearColorIiEXT' not available on this platform (extensions: GL_EXT_texture_integer)");
      }
    }

    void clear_color_iui(gl::uint_t red, gl::uint_t green, gl::uint_t blue, gl::uint_t alpha) {
      if ( GLAD_GL_EXT_texture_integer ) {
        glClearColorIuiEXT(red, green, blue, alpha);
      }
      else {
        throw std::runtime_error("OpenGL command 'glClearColorIuiEXT' not available on this platform (extensions: GL_EXT_texture_integer)");
      }
    }

    void begin_transform_feedback(gl::enum_t primitiveMode) {
      if ( GLAD_GL_EXT_transform_feedback ) {
        glBeginTransformFeedbackEXT(primitiveMode);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBeginTransformFeedbackEXT' not available on this platform (extensions: GL_EXT_transform_feedback)");
      }
    }

    void bind_buffer_base(gl::enum_t target, gl::uint_t index, gl::uint_t buffer) {
      if ( GLAD_GL_EXT_transform_feedback ) {
        glBindBufferBaseEXT(target, index, buffer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBindBufferBaseEXT' not available on this platform (extensions: GL_EXT_transform_feedback)");
      }
    }

    void bind_buffer_offset(gl::enum_t target, gl::uint_t index, gl::uint_t buffer, gl::intptr_t offset) {
      if ( GLAD_GL_EXT_transform_feedback ) {
        glBindBufferOffsetEXT(target, index, buffer, offset);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBindBufferOffsetEXT' not available on this platform (extensions: GL_EXT_transform_feedback)");
      }
    }

    void bind_buffer_range(gl::enum_t target, gl::uint_t index, gl::uint_t buffer, gl::intptr_t offset, gl::sizeiptr_t size) {
      if ( GLAD_GL_EXT_transform_feedback ) {
        glBindBufferRangeEXT(target, index, buffer, offset, size);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBindBufferRangeEXT' not available on this platform (extensions: GL_EXT_transform_feedback)");
      }
    }

    void end_transform_feedback() {
      if ( GLAD_GL_EXT_transform_feedback ) {
        glEndTransformFeedbackEXT();
      }
      else {
        throw std::runtime_error("OpenGL command 'glEndTransformFeedbackEXT' not available on this platform (extensions: GL_EXT_transform_feedback)");
      }
    }

    void get_transform_feedback_varying(gl::uint_t program, gl::uint_t index, gl::sizei_t bufSize, gl::sizei_t * length, gl::sizei_t * size, gl::enum_t * type, gl::char_t * name) {
      if ( GLAD_GL_EXT_transform_feedback ) {
        glGetTransformFeedbackVaryingEXT(program, index, bufSize, length, size, type, name);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetTransformFeedbackVaryingEXT' not available on this platform (extensions: GL_EXT_transform_feedback)");
      }
    }

    void transform_feedback_varyings(gl::uint_t program, gl::sizei_t count, const  gl::char_t ** varyings, gl::enum_t bufferMode) {
      if ( GLAD_GL_EXT_transform_feedback ) {
        glTransformFeedbackVaryingsEXT(program, count, varyings, bufferMode);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTransformFeedbackVaryingsEXT' not available on this platform (extensions: GL_EXT_transform_feedback)");
      }
    }

    void begin_conditional_render(gl::uint_t id, gl::enum_t mode) {
      if ( GLAD_GL_NV_conditional_render ) {
        glBeginConditionalRenderNV(id, mode);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBeginConditionalRenderNV' not available on this platform (extensions: GL_NV_conditional_render)");
      }
    }

    void end_conditional_render() {
      if ( GLAD_GL_NV_conditional_render ) {
        glEndConditionalRenderNV();
      }
      else {
        throw std::runtime_error("OpenGL command 'glEndConditionalRenderNV' not available on this platform (extensions: GL_NV_conditional_render)");
      }
    }

    void texture_barrier() {
      if ( GLAD_GL_NV_texture_barrier ) {
        glTextureBarrierNV();
      }
      else {
        throw std::runtime_error("OpenGL command 'glTextureBarrierNV' not available on this platform (extensions: GL_NV_texture_barrier)");
      }
    }


   /**
    * non-aliased commands
    */
  
    void draw_element_array_apple(primitive_type_t mode, gl::int_t first, gl::sizei_t count) {
      if ( GLAD_GL_APPLE_element_array ) {
        glDrawElementArrayAPPLE(static_cast<GLenum>(mode), first, count);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDrawElementArrayAPPLE' not available on this platform (extensions: GL_APPLE_element_array)");
      }
    }

    void draw_range_element_array_apple(primitive_type_t mode, gl::uint_t start, gl::uint_t end, gl::int_t first, gl::sizei_t count) {
      if ( GLAD_GL_APPLE_element_array ) {
        glDrawRangeElementArrayAPPLE(static_cast<GLenum>(mode), start, end, first, count);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDrawRangeElementArrayAPPLE' not available on this platform (extensions: GL_APPLE_element_array)");
      }
    }

    void element_pointer_apple(gl::enum_t type, const  void * pointer) {
      if ( GLAD_GL_APPLE_element_array ) {
        glElementPointerAPPLE(type, pointer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glElementPointerAPPLE' not available on this platform (extensions: GL_APPLE_element_array)");
      }
    }

    void multi_draw_element_array_apple(primitive_type_t mode, const  gl::int_t * first, const  gl::sizei_t * count, gl::sizei_t primcount) {
      if ( GLAD_GL_APPLE_element_array ) {
        glMultiDrawElementArrayAPPLE(static_cast<GLenum>(mode), first, count, primcount);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiDrawElementArrayAPPLE' not available on this platform (extensions: GL_APPLE_element_array)");
      }
    }

    void multi_draw_range_element_array_apple(primitive_type_t mode, gl::uint_t start, gl::uint_t end, const  gl::int_t * first, const  gl::sizei_t * count, gl::sizei_t primcount) {
      if ( GLAD_GL_APPLE_element_array ) {
        glMultiDrawRangeElementArrayAPPLE(static_cast<GLenum>(mode), start, end, first, count, primcount);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiDrawRangeElementArrayAPPLE' not available on this platform (extensions: GL_APPLE_element_array)");
      }
    }

    void delete_fences_apple(gl::sizei_t n, const  gl::uint_t * fences) {
      if ( GLAD_GL_APPLE_fence ) {
        glDeleteFencesAPPLE(n, fences);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDeleteFencesAPPLE' not available on this platform (extensions: GL_APPLE_fence)");
      }
    }

    void finish_fence_apple(gl::uint_t fence) {
      if ( GLAD_GL_APPLE_fence ) {
        glFinishFenceAPPLE(fence);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFinishFenceAPPLE' not available on this platform (extensions: GL_APPLE_fence)");
      }
    }

    void finish_object_apple(gl::enum_t object, gl::int_t name) {
      if ( GLAD_GL_APPLE_fence ) {
        glFinishObjectAPPLE(object, name);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFinishObjectAPPLE' not available on this platform (extensions: GL_APPLE_fence)");
      }
    }

    void gen_fences_apple(gl::sizei_t n, gl::uint_t * fences) {
      if ( GLAD_GL_APPLE_fence ) {
        glGenFencesAPPLE(n, fences);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGenFencesAPPLE' not available on this platform (extensions: GL_APPLE_fence)");
      }
    }

    gl::boolean_t is_fence_apple(gl::uint_t fence) {
      if ( GLAD_GL_APPLE_fence ) {
        return glIsFenceAPPLE(fence);
      }
      else {
        throw std::runtime_error("OpenGL command 'glIsFenceAPPLE' not available on this platform (extensions: GL_APPLE_fence)");
      }
    }

    void set_fence_apple(gl::uint_t fence) {
      if ( GLAD_GL_APPLE_fence ) {
        glSetFenceAPPLE(fence);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSetFenceAPPLE' not available on this platform (extensions: GL_APPLE_fence)");
      }
    }

    gl::boolean_t test_fence_apple(gl::uint_t fence) {
      if ( GLAD_GL_APPLE_fence ) {
        return glTestFenceAPPLE(fence);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTestFenceAPPLE' not available on this platform (extensions: GL_APPLE_fence)");
      }
    }

    gl::boolean_t test_object_apple(gl::enum_t object, gl::uint_t name) {
      if ( GLAD_GL_APPLE_fence ) {
        return glTestObjectAPPLE(object, name);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTestObjectAPPLE' not available on this platform (extensions: GL_APPLE_fence)");
      }
    }

    void buffer_parameteri_apple(gl::enum_t target, gl::enum_t pname, gl::int_t param) {
      if ( GLAD_GL_APPLE_flush_buffer_range ) {
        glBufferParameteriAPPLE(target, pname, param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBufferParameteriAPPLE' not available on this platform (extensions: GL_APPLE_flush_buffer_range)");
      }
    }

    void flush_mapped_buffer_range_apple(buffer_target_arb_t target, gl::intptr_t offset, gl::sizeiptr_t size) {
      if ( GLAD_GL_APPLE_flush_buffer_range ) {
        glFlushMappedBufferRangeAPPLE(static_cast<GLenum>(target), offset, size);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFlushMappedBufferRangeAPPLE' not available on this platform (extensions: GL_APPLE_flush_buffer_range)");
      }
    }

    void get_object_parameteriv_apple(gl::enum_t objectType, gl::uint_t name, gl::enum_t pname, gl::int_t * params) {
      if ( GLAD_GL_APPLE_object_purgeable ) {
        glGetObjectParameterivAPPLE(objectType, name, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetObjectParameterivAPPLE' not available on this platform (extensions: GL_APPLE_object_purgeable)");
      }
    }

    gl::enum_t object_purgeable_apple(gl::enum_t objectType, gl::uint_t name, gl::enum_t option) {
      if ( GLAD_GL_APPLE_object_purgeable ) {
        return glObjectPurgeableAPPLE(objectType, name, option);
      }
      else {
        throw std::runtime_error("OpenGL command 'glObjectPurgeableAPPLE' not available on this platform (extensions: GL_APPLE_object_purgeable)");
      }
    }

    gl::enum_t object_unpurgeable_apple(gl::enum_t objectType, gl::uint_t name, gl::enum_t option) {
      if ( GLAD_GL_APPLE_object_purgeable ) {
        return glObjectUnpurgeableAPPLE(objectType, name, option);
      }
      else {
        throw std::runtime_error("OpenGL command 'glObjectUnpurgeableAPPLE' not available on this platform (extensions: GL_APPLE_object_purgeable)");
      }
    }

    void get_tex_parameter_pointerv_apple(gl::enum_t target, gl::enum_t pname, void ** params) {
      if ( GLAD_GL_APPLE_texture_range ) {
        glGetTexParameterPointervAPPLE(target, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetTexParameterPointervAPPLE' not available on this platform (extensions: GL_APPLE_texture_range)");
      }
    }

    void texture_range_apple(gl::enum_t target, gl::sizei_t length, const  void * pointer) {
      if ( GLAD_GL_APPLE_texture_range ) {
        glTextureRangeAPPLE(target, length, pointer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTextureRangeAPPLE' not available on this platform (extensions: GL_APPLE_texture_range)");
      }
    }

    void bind_vertex_array_apple(gl::uint_t array) {
      if ( GLAD_GL_APPLE_vertex_array_object ) {
        glBindVertexArrayAPPLE(array);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBindVertexArrayAPPLE' not available on this platform (extensions: GL_APPLE_vertex_array_object)");
      }
    }

    void delete_vertex_arrays_apple(gl::sizei_t n, const  gl::uint_t * arrays) {
      if ( GLAD_GL_APPLE_vertex_array_object ) {
        glDeleteVertexArraysAPPLE(n, arrays);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDeleteVertexArraysAPPLE' not available on this platform (extensions: GL_APPLE_vertex_array_object)");
      }
    }

    void gen_vertex_arrays_apple(gl::sizei_t n, gl::uint_t * arrays) {
      if ( GLAD_GL_APPLE_vertex_array_object ) {
        glGenVertexArraysAPPLE(n, arrays);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGenVertexArraysAPPLE' not available on this platform (extensions: GL_APPLE_vertex_array_object)");
      }
    }

    gl::boolean_t is_vertex_array_apple(gl::uint_t array) {
      if ( GLAD_GL_APPLE_vertex_array_object ) {
        return glIsVertexArrayAPPLE(array);
      }
      else {
        throw std::runtime_error("OpenGL command 'glIsVertexArrayAPPLE' not available on this platform (extensions: GL_APPLE_vertex_array_object)");
      }
    }

    void flush_vertex_array_range_apple(gl::sizei_t length, void * pointer) {
      if ( GLAD_GL_APPLE_vertex_array_range ) {
        glFlushVertexArrayRangeAPPLE(length, pointer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFlushVertexArrayRangeAPPLE' not available on this platform (extensions: GL_APPLE_vertex_array_range)");
      }
    }

    void vertex_array_parameteri_apple(gl::enum_t pname, gl::int_t param) {
      if ( GLAD_GL_APPLE_vertex_array_range ) {
        glVertexArrayParameteriAPPLE(pname, param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexArrayParameteriAPPLE' not available on this platform (extensions: GL_APPLE_vertex_array_range)");
      }
    }

    void vertex_array_range_apple(gl::sizei_t length, void * pointer) {
      if ( GLAD_GL_APPLE_vertex_array_range ) {
        glVertexArrayRangeAPPLE(length, pointer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexArrayRangeAPPLE' not available on this platform (extensions: GL_APPLE_vertex_array_range)");
      }
    }

    void disable_vertex_attrib_apple(gl::uint_t index, gl::enum_t pname) {
      if ( GLAD_GL_APPLE_vertex_program_evaluators ) {
        glDisableVertexAttribAPPLE(index, pname);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDisableVertexAttribAPPLE' not available on this platform (extensions: GL_APPLE_vertex_program_evaluators)");
      }
    }

    void enable_vertex_attrib_apple(gl::uint_t index, gl::enum_t pname) {
      if ( GLAD_GL_APPLE_vertex_program_evaluators ) {
        glEnableVertexAttribAPPLE(index, pname);
      }
      else {
        throw std::runtime_error("OpenGL command 'glEnableVertexAttribAPPLE' not available on this platform (extensions: GL_APPLE_vertex_program_evaluators)");
      }
    }

    gl::boolean_t is_vertex_attrib_enabled_apple(gl::uint_t index, gl::enum_t pname) {
      if ( GLAD_GL_APPLE_vertex_program_evaluators ) {
        return glIsVertexAttribEnabledAPPLE(index, pname);
      }
      else {
        throw std::runtime_error("OpenGL command 'glIsVertexAttribEnabledAPPLE' not available on this platform (extensions: GL_APPLE_vertex_program_evaluators)");
      }
    }

    void map_vertex_attrib_1d_apple(gl::uint_t index, gl::uint_t size, gl::double_t u1, gl::double_t u2, gl::int_t stride, gl::int_t order, const  gl::double_t * points) {
      if ( GLAD_GL_APPLE_vertex_program_evaluators ) {
        glMapVertexAttrib1dAPPLE(index, size, u1, u2, stride, order, points);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMapVertexAttrib1dAPPLE' not available on this platform (extensions: GL_APPLE_vertex_program_evaluators)");
      }
    }

    void map_vertex_attrib_1f_apple(gl::uint_t index, gl::uint_t size, gl::float_t u1, gl::float_t u2, gl::int_t stride, gl::int_t order, const  gl::float_t * points) {
      if ( GLAD_GL_APPLE_vertex_program_evaluators ) {
        glMapVertexAttrib1fAPPLE(index, size, u1, u2, stride, order, points);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMapVertexAttrib1fAPPLE' not available on this platform (extensions: GL_APPLE_vertex_program_evaluators)");
      }
    }

    void map_vertex_attrib_2d_apple(gl::uint_t index, gl::uint_t size, gl::double_t u1, gl::double_t u2, gl::int_t ustride, gl::int_t uorder, gl::double_t v1, gl::double_t v2, gl::int_t vstride, gl::int_t vorder, const  gl::double_t * points) {
      if ( GLAD_GL_APPLE_vertex_program_evaluators ) {
        glMapVertexAttrib2dAPPLE(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMapVertexAttrib2dAPPLE' not available on this platform (extensions: GL_APPLE_vertex_program_evaluators)");
      }
    }

    void map_vertex_attrib_2f_apple(gl::uint_t index, gl::uint_t size, gl::float_t u1, gl::float_t u2, gl::int_t ustride, gl::int_t uorder, gl::float_t v1, gl::float_t v2, gl::int_t vstride, gl::int_t vorder, const  gl::float_t * points) {
      if ( GLAD_GL_APPLE_vertex_program_evaluators ) {
        glMapVertexAttrib2fAPPLE(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMapVertexAttrib2fAPPLE' not available on this platform (extensions: GL_APPLE_vertex_program_evaluators)");
      }
    }

    void clamp_color_arb(gl::enum_t target, gl::enum_t clamp) {
      if ( GLAD_GL_ARB_color_buffer_float ) {
        glClampColorARB(target, clamp);
      }
      else {
        throw std::runtime_error("OpenGL command 'glClampColorARB' not available on this platform (extensions: GL_ARB_color_buffer_float)");
      }
    }

    void draw_buffers_arb(gl::sizei_t n, const  gl::enum_t * bufs) {
      if ( GLAD_GL_ARB_draw_buffers ) {
        glDrawBuffersARB(n, bufs);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDrawBuffersARB' not available on this platform (extensions: GL_ARB_draw_buffers)");
      }
    }

    void draw_elements_base_vertex(primitive_type_t mode, gl::sizei_t count, draw_elements_type_t type, const  void * indices, gl::int_t basevertex) {
      if ( GLAD_GL_ARB_draw_elements_base_vertex ) {
        glDrawElementsBaseVertex(static_cast<GLenum>(mode), count, static_cast<GLenum>(type), indices, basevertex);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDrawElementsBaseVertex' not available on this platform (extensions: GL_ARB_draw_elements_base_vertex)");
      }
    }

    void draw_elements_instanced_base_vertex(primitive_type_t mode, gl::sizei_t count, draw_elements_type_t type, const  void * indices, gl::sizei_t instancecount, gl::int_t basevertex) {
      if ( GLAD_GL_ARB_draw_elements_base_vertex ) {
        glDrawElementsInstancedBaseVertex(static_cast<GLenum>(mode), count, static_cast<GLenum>(type), indices, instancecount, basevertex);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDrawElementsInstancedBaseVertex' not available on this platform (extensions: GL_ARB_draw_elements_base_vertex)");
      }
    }

    void draw_range_elements_base_vertex(primitive_type_t mode, gl::uint_t start, gl::uint_t end, gl::sizei_t count, draw_elements_type_t type, const  void * indices, gl::int_t basevertex) {
      if ( GLAD_GL_ARB_draw_elements_base_vertex ) {
        glDrawRangeElementsBaseVertex(static_cast<GLenum>(mode), start, end, count, static_cast<GLenum>(type), indices, basevertex);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDrawRangeElementsBaseVertex' not available on this platform (extensions: GL_ARB_draw_elements_base_vertex)");
      }
    }

    void multi_draw_elements_base_vertex(gl::enum_t mode, const  gl::sizei_t * count, draw_elements_type_t type, const  void ** indices, gl::sizei_t drawcount, const  gl::int_t * basevertex) {
      if ( GLAD_GL_ARB_draw_elements_base_vertex ) {
        glMultiDrawElementsBaseVertex(mode, count, static_cast<GLenum>(type), indices, drawcount, basevertex);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiDrawElementsBaseVertex' not available on this platform (extensions: GL_ARB_draw_elements_base_vertex)");
      }
    }

    void draw_arrays_instanced_arb(primitive_type_t mode, gl::int_t first, gl::sizei_t count, gl::sizei_t primcount) {
      if ( GLAD_GL_ARB_draw_instanced ) {
        glDrawArraysInstancedARB(static_cast<GLenum>(mode), first, count, primcount);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDrawArraysInstancedARB' not available on this platform (extensions: GL_ARB_draw_instanced)");
      }
    }

    void draw_elements_instanced_arb(primitive_type_t mode, gl::sizei_t count, draw_elements_type_t type, const  void * indices, gl::sizei_t primcount) {
      if ( GLAD_GL_ARB_draw_instanced ) {
        glDrawElementsInstancedARB(static_cast<GLenum>(mode), count, static_cast<GLenum>(type), indices, primcount);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDrawElementsInstancedARB' not available on this platform (extensions: GL_ARB_draw_instanced)");
      }
    }

    void bind_program_arb(gl::enum_t target, gl::uint_t program) {
      if ( GLAD_GL_ARB_fragment_program || GLAD_GL_ARB_vertex_program ) {
        glBindProgramARB(target, program);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBindProgramARB' not available on this platform (extensions: GL_ARB_fragment_program, GL_ARB_vertex_program)");
      }
    }

    void delete_programs_arb(gl::sizei_t n, const  gl::uint_t * programs) {
      if ( GLAD_GL_ARB_fragment_program || GLAD_GL_ARB_vertex_program ) {
        glDeleteProgramsARB(n, programs);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDeleteProgramsARB' not available on this platform (extensions: GL_ARB_fragment_program, GL_ARB_vertex_program)");
      }
    }

    void gen_programs_arb(gl::sizei_t n, gl::uint_t * programs) {
      if ( GLAD_GL_ARB_fragment_program || GLAD_GL_ARB_vertex_program ) {
        glGenProgramsARB(n, programs);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGenProgramsARB' not available on this platform (extensions: GL_ARB_fragment_program, GL_ARB_vertex_program)");
      }
    }

    void get_program_env_parameterdv_arb(gl::enum_t target, gl::uint_t index, gl::double_t * params) {
      if ( GLAD_GL_ARB_fragment_program || GLAD_GL_ARB_vertex_program ) {
        glGetProgramEnvParameterdvARB(target, index, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetProgramEnvParameterdvARB' not available on this platform (extensions: GL_ARB_fragment_program, GL_ARB_vertex_program)");
      }
    }

    void get_program_env_parameterfv_arb(gl::enum_t target, gl::uint_t index, gl::float_t * params) {
      if ( GLAD_GL_ARB_fragment_program || GLAD_GL_ARB_vertex_program ) {
        glGetProgramEnvParameterfvARB(target, index, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetProgramEnvParameterfvARB' not available on this platform (extensions: GL_ARB_fragment_program, GL_ARB_vertex_program)");
      }
    }

    void get_program_local_parameterdv_arb(gl::enum_t target, gl::uint_t index, gl::double_t * params) {
      if ( GLAD_GL_ARB_fragment_program || GLAD_GL_ARB_vertex_program ) {
        glGetProgramLocalParameterdvARB(target, index, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetProgramLocalParameterdvARB' not available on this platform (extensions: GL_ARB_fragment_program, GL_ARB_vertex_program)");
      }
    }

    void get_program_local_parameterfv_arb(gl::enum_t target, gl::uint_t index, gl::float_t * params) {
      if ( GLAD_GL_ARB_fragment_program || GLAD_GL_ARB_vertex_program ) {
        glGetProgramLocalParameterfvARB(target, index, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetProgramLocalParameterfvARB' not available on this platform (extensions: GL_ARB_fragment_program, GL_ARB_vertex_program)");
      }
    }

    void get_program_string_arb(gl::enum_t target, gl::enum_t pname, void * string) {
      if ( GLAD_GL_ARB_fragment_program || GLAD_GL_ARB_vertex_program ) {
        glGetProgramStringARB(target, pname, string);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetProgramStringARB' not available on this platform (extensions: GL_ARB_fragment_program, GL_ARB_vertex_program)");
      }
    }

    void get_programiv_arb(gl::enum_t target, get_programiv_p_name_t pname, gl::int_t * params) {
      if ( GLAD_GL_ARB_fragment_program || GLAD_GL_ARB_vertex_program ) {
        glGetProgramivARB(target, static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetProgramivARB' not available on this platform (extensions: GL_ARB_fragment_program, GL_ARB_vertex_program)");
      }
    }

    gl::boolean_t is_program_arb(gl::uint_t program) {
      if ( GLAD_GL_ARB_fragment_program || GLAD_GL_ARB_vertex_program ) {
        return glIsProgramARB(program);
      }
      else {
        throw std::runtime_error("OpenGL command 'glIsProgramARB' not available on this platform (extensions: GL_ARB_fragment_program, GL_ARB_vertex_program)");
      }
    }

    void program_env_parameter_4d_arb(gl::enum_t target, gl::uint_t index, gl::double_t x, gl::double_t y, gl::double_t z, gl::double_t w) {
      if ( GLAD_GL_ARB_fragment_program || GLAD_GL_ARB_vertex_program ) {
        glProgramEnvParameter4dARB(target, index, x, y, z, w);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramEnvParameter4dARB' not available on this platform (extensions: GL_ARB_fragment_program, GL_ARB_vertex_program)");
      }
    }

    void program_env_parameter_4dv_arb(gl::enum_t target, gl::uint_t index, const  gl::double_t * params) {
      if ( GLAD_GL_ARB_fragment_program || GLAD_GL_ARB_vertex_program ) {
        glProgramEnvParameter4dvARB(target, index, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramEnvParameter4dvARB' not available on this platform (extensions: GL_ARB_fragment_program, GL_ARB_vertex_program)");
      }
    }

    void program_env_parameter_4f_arb(gl::enum_t target, gl::uint_t index, gl::float_t x, gl::float_t y, gl::float_t z, gl::float_t w) {
      if ( GLAD_GL_ARB_fragment_program || GLAD_GL_ARB_vertex_program ) {
        glProgramEnvParameter4fARB(target, index, x, y, z, w);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramEnvParameter4fARB' not available on this platform (extensions: GL_ARB_fragment_program, GL_ARB_vertex_program)");
      }
    }

    void program_env_parameter_4fv_arb(gl::enum_t target, gl::uint_t index, const  gl::float_t * params) {
      if ( GLAD_GL_ARB_fragment_program || GLAD_GL_ARB_vertex_program ) {
        glProgramEnvParameter4fvARB(target, index, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramEnvParameter4fvARB' not available on this platform (extensions: GL_ARB_fragment_program, GL_ARB_vertex_program)");
      }
    }

    void program_local_parameter_4d_arb(gl::enum_t target, gl::uint_t index, gl::double_t x, gl::double_t y, gl::double_t z, gl::double_t w) {
      if ( GLAD_GL_ARB_fragment_program || GLAD_GL_ARB_vertex_program ) {
        glProgramLocalParameter4dARB(target, index, x, y, z, w);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramLocalParameter4dARB' not available on this platform (extensions: GL_ARB_fragment_program, GL_ARB_vertex_program)");
      }
    }

    void program_local_parameter_4dv_arb(gl::enum_t target, gl::uint_t index, const  gl::double_t * params) {
      if ( GLAD_GL_ARB_fragment_program || GLAD_GL_ARB_vertex_program ) {
        glProgramLocalParameter4dvARB(target, index, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramLocalParameter4dvARB' not available on this platform (extensions: GL_ARB_fragment_program, GL_ARB_vertex_program)");
      }
    }

    void program_local_parameter_4f_arb(gl::enum_t target, gl::uint_t index, gl::float_t x, gl::float_t y, gl::float_t z, gl::float_t w) {
      if ( GLAD_GL_ARB_fragment_program || GLAD_GL_ARB_vertex_program ) {
        glProgramLocalParameter4fARB(target, index, x, y, z, w);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramLocalParameter4fARB' not available on this platform (extensions: GL_ARB_fragment_program, GL_ARB_vertex_program)");
      }
    }

    void program_local_parameter_4fv_arb(gl::enum_t target, gl::uint_t index, const  gl::float_t * params) {
      if ( GLAD_GL_ARB_fragment_program || GLAD_GL_ARB_vertex_program ) {
        glProgramLocalParameter4fvARB(target, index, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramLocalParameter4fvARB' not available on this platform (extensions: GL_ARB_fragment_program, GL_ARB_vertex_program)");
      }
    }

    void program_string_arb(gl::enum_t target, gl::enum_t format, gl::sizei_t len, const  void * string) {
      if ( GLAD_GL_ARB_fragment_program || GLAD_GL_ARB_vertex_program ) {
        glProgramStringARB(target, format, len, string);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramStringARB' not available on this platform (extensions: GL_ARB_fragment_program, GL_ARB_vertex_program)");
      }
    }

    void bind_framebuffer(framebuffer_target_t target, gl::uint_t framebuffer) {
      if ( GLAD_GL_ARB_framebuffer_object ) {
        glBindFramebuffer(static_cast<GLenum>(target), framebuffer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBindFramebuffer' not available on this platform (extensions: GL_ARB_framebuffer_object)");
      }
    }

    void bind_renderbuffer(renderbuffer_target_t target, gl::uint_t renderbuffer) {
      if ( GLAD_GL_ARB_framebuffer_object ) {
        glBindRenderbuffer(static_cast<GLenum>(target), renderbuffer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBindRenderbuffer' not available on this platform (extensions: GL_ARB_framebuffer_object)");
      }
    }

    void blit_framebuffer(gl::int_t srcX0, gl::int_t srcY0, gl::int_t srcX1, gl::int_t srcY1, gl::int_t dstX0, gl::int_t dstY0, gl::int_t dstX1, gl::int_t dstY1, gl::bitmask<clear_buffer_flags_t> mask, gl::enum_t filter) {
      if ( GLAD_GL_ARB_framebuffer_object ) {
        glBlitFramebuffer(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, static_cast<GLbitfield>(mask.value), filter);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBlitFramebuffer' not available on this platform (extensions: GL_ARB_framebuffer_object)");
      }
    }

    framebuffer_status_t check_framebuffer_status(framebuffer_target_t target) {
      if ( GLAD_GL_ARB_framebuffer_object ) {
        return static_cast<framebuffer_status_t>(glCheckFramebufferStatus(static_cast<GLenum>(target)));
      }
      else {
        throw std::runtime_error("OpenGL command 'glCheckFramebufferStatus' not available on this platform (extensions: GL_ARB_framebuffer_object)");
      }
    }

    void delete_framebuffers(gl::sizei_t n, const  gl::uint_t * framebuffers) {
      if ( GLAD_GL_ARB_framebuffer_object ) {
        glDeleteFramebuffers(n, framebuffers);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDeleteFramebuffers' not available on this platform (extensions: GL_ARB_framebuffer_object)");
      }
    }

    void delete_renderbuffers(gl::sizei_t n, const  gl::uint_t * renderbuffers) {
      if ( GLAD_GL_ARB_framebuffer_object ) {
        glDeleteRenderbuffers(n, renderbuffers);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDeleteRenderbuffers' not available on this platform (extensions: GL_ARB_framebuffer_object)");
      }
    }

    void framebuffer_renderbuffer(framebuffer_target_t target, framebuffer_attachment_t attachment, renderbuffer_target_t renderbuffertarget, gl::uint_t renderbuffer) {
      if ( GLAD_GL_ARB_framebuffer_object ) {
        glFramebufferRenderbuffer(static_cast<GLenum>(target), static_cast<GLenum>(attachment), static_cast<GLenum>(renderbuffertarget), renderbuffer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFramebufferRenderbuffer' not available on this platform (extensions: GL_ARB_framebuffer_object)");
      }
    }

    void framebuffer_texture_1d(framebuffer_target_t target, framebuffer_attachment_t attachment, gl::enum_t textarget, gl::uint_t texture, gl::int_t level) {
      if ( GLAD_GL_ARB_framebuffer_object ) {
        glFramebufferTexture1D(static_cast<GLenum>(target), static_cast<GLenum>(attachment), textarget, texture, level);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFramebufferTexture1D' not available on this platform (extensions: GL_ARB_framebuffer_object)");
      }
    }

    void framebuffer_texture_2d(framebuffer_target_t target, framebuffer_attachment_t attachment, framebuffer_texture_target_t textarget, gl::uint_t texture, gl::int_t level) {
      if ( GLAD_GL_ARB_framebuffer_object ) {
        glFramebufferTexture2D(static_cast<GLenum>(target), static_cast<GLenum>(attachment), static_cast<GLenum>(textarget), texture, level);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFramebufferTexture2D' not available on this platform (extensions: GL_ARB_framebuffer_object)");
      }
    }

    void framebuffer_texture_3d(framebuffer_target_t target, framebuffer_attachment_t attachment, gl::enum_t textarget, gl::uint_t texture, gl::int_t level, gl::int_t zoffset) {
      if ( GLAD_GL_ARB_framebuffer_object ) {
        glFramebufferTexture3D(static_cast<GLenum>(target), static_cast<GLenum>(attachment), textarget, texture, level, zoffset);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFramebufferTexture3D' not available on this platform (extensions: GL_ARB_framebuffer_object)");
      }
    }

    void framebuffer_texture_layer(framebuffer_target_t target, framebuffer_attachment_t attachment, gl::uint_t texture, gl::int_t level, gl::int_t layer) {
      if ( GLAD_GL_ARB_framebuffer_object ) {
        glFramebufferTextureLayer(static_cast<GLenum>(target), static_cast<GLenum>(attachment), texture, level, layer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFramebufferTextureLayer' not available on this platform (extensions: GL_ARB_framebuffer_object)");
      }
    }

    void gen_framebuffers(gl::sizei_t n, gl::uint_t * framebuffers) {
      if ( GLAD_GL_ARB_framebuffer_object ) {
        glGenFramebuffers(n, framebuffers);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGenFramebuffers' not available on this platform (extensions: GL_ARB_framebuffer_object)");
      }
    }

    void gen_renderbuffers(gl::sizei_t n, gl::uint_t * renderbuffers) {
      if ( GLAD_GL_ARB_framebuffer_object ) {
        glGenRenderbuffers(n, renderbuffers);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGenRenderbuffers' not available on this platform (extensions: GL_ARB_framebuffer_object)");
      }
    }

    void generate_mipmap(mipmap_target_t target) {
      if ( GLAD_GL_ARB_framebuffer_object ) {
        glGenerateMipmap(static_cast<GLenum>(target));
      }
      else {
        throw std::runtime_error("OpenGL command 'glGenerateMipmap' not available on this platform (extensions: GL_ARB_framebuffer_object)");
      }
    }

    void get_framebuffer_attachment_parameteriv(framebuffer_target_t target, framebuffer_attachment_t attachment, gl::enum_t pname, gl::int_t * params) {
      if ( GLAD_GL_ARB_framebuffer_object ) {
        glGetFramebufferAttachmentParameteriv(static_cast<GLenum>(target), static_cast<GLenum>(attachment), pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetFramebufferAttachmentParameteriv' not available on this platform (extensions: GL_ARB_framebuffer_object)");
      }
    }

    void get_renderbuffer_parameteriv(renderbuffer_target_t target, gl::enum_t pname, gl::int_t * params) {
      if ( GLAD_GL_ARB_framebuffer_object ) {
        glGetRenderbufferParameteriv(static_cast<GLenum>(target), pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetRenderbufferParameteriv' not available on this platform (extensions: GL_ARB_framebuffer_object)");
      }
    }

    gl::boolean_t is_framebuffer(gl::uint_t framebuffer) {
      if ( GLAD_GL_ARB_framebuffer_object ) {
        return glIsFramebuffer(framebuffer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glIsFramebuffer' not available on this platform (extensions: GL_ARB_framebuffer_object)");
      }
    }

    gl::boolean_t is_renderbuffer(gl::uint_t renderbuffer) {
      if ( GLAD_GL_ARB_framebuffer_object ) {
        return glIsRenderbuffer(renderbuffer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glIsRenderbuffer' not available on this platform (extensions: GL_ARB_framebuffer_object)");
      }
    }

    void renderbuffer_storage(renderbuffer_target_t target, internal_format_t internalformat, gl::sizei_t width, gl::sizei_t height) {
      if ( GLAD_GL_ARB_framebuffer_object ) {
        glRenderbufferStorage(static_cast<GLenum>(target), static_cast<GLenum>(internalformat), width, height);
      }
      else {
        throw std::runtime_error("OpenGL command 'glRenderbufferStorage' not available on this platform (extensions: GL_ARB_framebuffer_object)");
      }
    }

    void renderbuffer_storage_multisample(renderbuffer_target_t target, gl::sizei_t samples, internal_format_t internalformat, gl::sizei_t width, gl::sizei_t height) {
      if ( GLAD_GL_ARB_framebuffer_object ) {
        glRenderbufferStorageMultisample(static_cast<GLenum>(target), samples, static_cast<GLenum>(internalformat), width, height);
      }
      else {
        throw std::runtime_error("OpenGL command 'glRenderbufferStorageMultisample' not available on this platform (extensions: GL_ARB_framebuffer_object)");
      }
    }

    void blend_color(gl::float_t red, gl::float_t green, gl::float_t blue, gl::float_t alpha) {
      if ( GLAD_GL_ARB_imaging ) {
        glBlendColor(red, green, blue, alpha);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBlendColor' not available on this platform (extensions: GL_ARB_imaging)");
      }
    }

    void blend_equation(blend_equation_mode_t mode) {
      if ( GLAD_GL_ARB_imaging ) {
        glBlendEquation(static_cast<GLenum>(mode));
      }
      else {
        throw std::runtime_error("OpenGL command 'glBlendEquation' not available on this platform (extensions: GL_ARB_imaging)");
      }
    }

    void color_sub_table(gl::enum_t target, gl::sizei_t start, gl::sizei_t count, pixel_format_t format, pixel_type_t type, const  void * data) {
      if ( GLAD_GL_ARB_imaging ) {
        glColorSubTable(target, start, count, static_cast<GLenum>(format), static_cast<GLenum>(type), data);
      }
      else {
        throw std::runtime_error("OpenGL command 'glColorSubTable' not available on this platform (extensions: GL_ARB_imaging)");
      }
    }

    void color_table(gl::enum_t target, gl::enum_t internalformat, gl::sizei_t width, pixel_format_t format, pixel_type_t type, const  void * table) {
      if ( GLAD_GL_ARB_imaging ) {
        glColorTable(target, internalformat, width, static_cast<GLenum>(format), static_cast<GLenum>(type), table);
      }
      else {
        throw std::runtime_error("OpenGL command 'glColorTable' not available on this platform (extensions: GL_ARB_imaging)");
      }
    }

    void color_table_parameterfv(gl::enum_t target, gl::enum_t pname, const  gl::float_t * params) {
      if ( GLAD_GL_ARB_imaging ) {
        glColorTableParameterfv(target, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glColorTableParameterfv' not available on this platform (extensions: GL_ARB_imaging)");
      }
    }

    void color_table_parameteriv(gl::enum_t target, gl::enum_t pname, const  gl::int_t * params) {
      if ( GLAD_GL_ARB_imaging ) {
        glColorTableParameteriv(target, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glColorTableParameteriv' not available on this platform (extensions: GL_ARB_imaging)");
      }
    }

    void convolution_filter_1d(gl::enum_t target, gl::enum_t internalformat, gl::sizei_t width, pixel_format_t format, pixel_type_t type, const  void * image) {
      if ( GLAD_GL_ARB_imaging ) {
        glConvolutionFilter1D(target, internalformat, width, static_cast<GLenum>(format), static_cast<GLenum>(type), image);
      }
      else {
        throw std::runtime_error("OpenGL command 'glConvolutionFilter1D' not available on this platform (extensions: GL_ARB_imaging)");
      }
    }

    void convolution_filter_2d(gl::enum_t target, gl::enum_t internalformat, gl::sizei_t width, gl::sizei_t height, pixel_format_t format, pixel_type_t type, const  void * image) {
      if ( GLAD_GL_ARB_imaging ) {
        glConvolutionFilter2D(target, internalformat, width, height, static_cast<GLenum>(format), static_cast<GLenum>(type), image);
      }
      else {
        throw std::runtime_error("OpenGL command 'glConvolutionFilter2D' not available on this platform (extensions: GL_ARB_imaging)");
      }
    }

    void convolution_parameterf(gl::enum_t target, gl::enum_t pname, gl::float_t params) {
      if ( GLAD_GL_ARB_imaging ) {
        glConvolutionParameterf(target, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glConvolutionParameterf' not available on this platform (extensions: GL_ARB_imaging)");
      }
    }

    void convolution_parameterfv(gl::enum_t target, gl::enum_t pname, const  gl::float_t * params) {
      if ( GLAD_GL_ARB_imaging ) {
        glConvolutionParameterfv(target, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glConvolutionParameterfv' not available on this platform (extensions: GL_ARB_imaging)");
      }
    }

    void convolution_parameteri(gl::enum_t target, gl::enum_t pname, gl::int_t params) {
      if ( GLAD_GL_ARB_imaging ) {
        glConvolutionParameteri(target, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glConvolutionParameteri' not available on this platform (extensions: GL_ARB_imaging)");
      }
    }

    void convolution_parameteriv(gl::enum_t target, gl::enum_t pname, const  gl::int_t * params) {
      if ( GLAD_GL_ARB_imaging ) {
        glConvolutionParameteriv(target, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glConvolutionParameteriv' not available on this platform (extensions: GL_ARB_imaging)");
      }
    }

    void copy_color_sub_table(gl::enum_t target, gl::sizei_t start, gl::int_t x, gl::int_t y, gl::sizei_t width) {
      if ( GLAD_GL_ARB_imaging ) {
        glCopyColorSubTable(target, start, x, y, width);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCopyColorSubTable' not available on this platform (extensions: GL_ARB_imaging)");
      }
    }

    void copy_color_table(gl::enum_t target, gl::enum_t internalformat, gl::int_t x, gl::int_t y, gl::sizei_t width) {
      if ( GLAD_GL_ARB_imaging ) {
        glCopyColorTable(target, internalformat, x, y, width);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCopyColorTable' not available on this platform (extensions: GL_ARB_imaging)");
      }
    }

    void copy_convolution_filter_1d(gl::enum_t target, gl::enum_t internalformat, gl::int_t x, gl::int_t y, gl::sizei_t width) {
      if ( GLAD_GL_ARB_imaging ) {
        glCopyConvolutionFilter1D(target, internalformat, x, y, width);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCopyConvolutionFilter1D' not available on this platform (extensions: GL_ARB_imaging)");
      }
    }

    void copy_convolution_filter_2d(gl::enum_t target, gl::enum_t internalformat, gl::int_t x, gl::int_t y, gl::sizei_t width, gl::sizei_t height) {
      if ( GLAD_GL_ARB_imaging ) {
        glCopyConvolutionFilter2D(target, internalformat, x, y, width, height);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCopyConvolutionFilter2D' not available on this platform (extensions: GL_ARB_imaging)");
      }
    }

    void get_color_table(gl::enum_t target, pixel_format_t format, pixel_type_t type, void * table) {
      if ( GLAD_GL_ARB_imaging ) {
        glGetColorTable(target, static_cast<GLenum>(format), static_cast<GLenum>(type), table);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetColorTable' not available on this platform (extensions: GL_ARB_imaging)");
      }
    }

    void get_color_table_parameterfv(gl::enum_t target, gl::enum_t pname, gl::float_t * params) {
      if ( GLAD_GL_ARB_imaging ) {
        glGetColorTableParameterfv(target, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetColorTableParameterfv' not available on this platform (extensions: GL_ARB_imaging)");
      }
    }

    void get_color_table_parameteriv(gl::enum_t target, gl::enum_t pname, gl::int_t * params) {
      if ( GLAD_GL_ARB_imaging ) {
        glGetColorTableParameteriv(target, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetColorTableParameteriv' not available on this platform (extensions: GL_ARB_imaging)");
      }
    }

    void get_convolution_filter(gl::enum_t target, pixel_format_t format, pixel_type_t type, void * image) {
      if ( GLAD_GL_ARB_imaging ) {
        glGetConvolutionFilter(target, static_cast<GLenum>(format), static_cast<GLenum>(type), image);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetConvolutionFilter' not available on this platform (extensions: GL_ARB_imaging)");
      }
    }

    void get_convolution_parameterfv(gl::enum_t target, gl::enum_t pname, gl::float_t * params) {
      if ( GLAD_GL_ARB_imaging ) {
        glGetConvolutionParameterfv(target, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetConvolutionParameterfv' not available on this platform (extensions: GL_ARB_imaging)");
      }
    }

    void get_convolution_parameteriv(gl::enum_t target, gl::enum_t pname, gl::int_t * params) {
      if ( GLAD_GL_ARB_imaging ) {
        glGetConvolutionParameteriv(target, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetConvolutionParameteriv' not available on this platform (extensions: GL_ARB_imaging)");
      }
    }

    void get_histogram(gl::enum_t target, gl::boolean_t reset, pixel_format_t format, pixel_type_t type, void * values) {
      if ( GLAD_GL_ARB_imaging ) {
        glGetHistogram(target, reset, static_cast<GLenum>(format), static_cast<GLenum>(type), values);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetHistogram' not available on this platform (extensions: GL_ARB_imaging)");
      }
    }

    void get_histogram_parameterfv(gl::enum_t target, gl::enum_t pname, gl::float_t * params) {
      if ( GLAD_GL_ARB_imaging ) {
        glGetHistogramParameterfv(target, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetHistogramParameterfv' not available on this platform (extensions: GL_ARB_imaging)");
      }
    }

    void get_histogram_parameteriv(gl::enum_t target, gl::enum_t pname, gl::int_t * params) {
      if ( GLAD_GL_ARB_imaging ) {
        glGetHistogramParameteriv(target, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetHistogramParameteriv' not available on this platform (extensions: GL_ARB_imaging)");
      }
    }

    void get_minmax(gl::enum_t target, gl::boolean_t reset, pixel_format_t format, pixel_type_t type, void * values) {
      if ( GLAD_GL_ARB_imaging ) {
        glGetMinmax(target, reset, static_cast<GLenum>(format), static_cast<GLenum>(type), values);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetMinmax' not available on this platform (extensions: GL_ARB_imaging)");
      }
    }

    void get_minmax_parameterfv(gl::enum_t target, gl::enum_t pname, gl::float_t * params) {
      if ( GLAD_GL_ARB_imaging ) {
        glGetMinmaxParameterfv(target, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetMinmaxParameterfv' not available on this platform (extensions: GL_ARB_imaging)");
      }
    }

    void get_minmax_parameteriv(gl::enum_t target, gl::enum_t pname, gl::int_t * params) {
      if ( GLAD_GL_ARB_imaging ) {
        glGetMinmaxParameteriv(target, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetMinmaxParameteriv' not available on this platform (extensions: GL_ARB_imaging)");
      }
    }

    void get_separable_filter(gl::enum_t target, pixel_format_t format, pixel_type_t type, void * row, void * column, void * span) {
      if ( GLAD_GL_ARB_imaging ) {
        glGetSeparableFilter(target, static_cast<GLenum>(format), static_cast<GLenum>(type), row, column, span);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetSeparableFilter' not available on this platform (extensions: GL_ARB_imaging)");
      }
    }

    void histogram(gl::enum_t target, gl::sizei_t width, gl::enum_t internalformat, gl::boolean_t sink) {
      if ( GLAD_GL_ARB_imaging ) {
        glHistogram(target, width, internalformat, sink);
      }
      else {
        throw std::runtime_error("OpenGL command 'glHistogram' not available on this platform (extensions: GL_ARB_imaging)");
      }
    }

    void minmax(gl::enum_t target, gl::enum_t internalformat, gl::boolean_t sink) {
      if ( GLAD_GL_ARB_imaging ) {
        glMinmax(target, internalformat, sink);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMinmax' not available on this platform (extensions: GL_ARB_imaging)");
      }
    }

    void reset_histogram(gl::enum_t target) {
      if ( GLAD_GL_ARB_imaging ) {
        glResetHistogram(target);
      }
      else {
        throw std::runtime_error("OpenGL command 'glResetHistogram' not available on this platform (extensions: GL_ARB_imaging)");
      }
    }

    void reset_minmax(gl::enum_t target) {
      if ( GLAD_GL_ARB_imaging ) {
        glResetMinmax(target);
      }
      else {
        throw std::runtime_error("OpenGL command 'glResetMinmax' not available on this platform (extensions: GL_ARB_imaging)");
      }
    }

    void separable_filter_2d(gl::enum_t target, gl::enum_t internalformat, gl::sizei_t width, gl::sizei_t height, pixel_format_t format, pixel_type_t type, const  void * row, const  void * column) {
      if ( GLAD_GL_ARB_imaging ) {
        glSeparableFilter2D(target, internalformat, width, height, static_cast<GLenum>(format), static_cast<GLenum>(type), row, column);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSeparableFilter2D' not available on this platform (extensions: GL_ARB_imaging)");
      }
    }

    void vertex_attrib_divisor_arb(gl::uint_t index, gl::uint_t divisor) {
      if ( GLAD_GL_ARB_instanced_arrays ) {
        glVertexAttribDivisorARB(index, divisor);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribDivisorARB' not available on this platform (extensions: GL_ARB_instanced_arrays)");
      }
    }

    void sample_coverage_arb(gl::float_t value, gl::boolean_t invert) {
      if ( GLAD_GL_ARB_multisample ) {
        glSampleCoverageARB(value, invert);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSampleCoverageARB' not available on this platform (extensions: GL_ARB_multisample)");
      }
    }

    void active_texture_arb(texture_unit_t texture) {
      if ( GLAD_GL_ARB_multitexture ) {
        glActiveTextureARB(static_cast<GLenum>(texture));
      }
      else {
        throw std::runtime_error("OpenGL command 'glActiveTextureARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void client_active_texture_arb(texture_unit_t texture) {
      if ( GLAD_GL_ARB_multitexture ) {
        glClientActiveTextureARB(static_cast<GLenum>(texture));
      }
      else {
        throw std::runtime_error("OpenGL command 'glClientActiveTextureARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_1d_arb(texture_unit_t target, gl::double_t s) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord1dARB(static_cast<GLenum>(target), s);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord1dARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_1dv_arb(texture_unit_t target, const  gl::double_t * v) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord1dvARB(static_cast<GLenum>(target), v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord1dvARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_1f_arb(texture_unit_t target, gl::float_t s) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord1fARB(static_cast<GLenum>(target), s);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord1fARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_1fv_arb(texture_unit_t target, const  gl::float_t * v) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord1fvARB(static_cast<GLenum>(target), v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord1fvARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_1i_arb(texture_unit_t target, gl::int_t s) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord1iARB(static_cast<GLenum>(target), s);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord1iARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_1iv_arb(texture_unit_t target, const  gl::int_t * v) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord1ivARB(static_cast<GLenum>(target), v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord1ivARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_1s_arb(texture_unit_t target, gl::short_t s) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord1sARB(static_cast<GLenum>(target), s);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord1sARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_1sv_arb(texture_unit_t target, const  gl::short_t * v) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord1svARB(static_cast<GLenum>(target), v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord1svARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_2d_arb(texture_unit_t target, gl::double_t s, gl::double_t t) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord2dARB(static_cast<GLenum>(target), s, t);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord2dARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_2dv_arb(texture_unit_t target, const  gl::double_t * v) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord2dvARB(static_cast<GLenum>(target), v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord2dvARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_2f_arb(texture_unit_t target, gl::float_t s, gl::float_t t) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord2fARB(static_cast<GLenum>(target), s, t);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord2fARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_2fv_arb(texture_unit_t target, const  gl::float_t * v) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord2fvARB(static_cast<GLenum>(target), v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord2fvARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_2i_arb(texture_unit_t target, gl::int_t s, gl::int_t t) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord2iARB(static_cast<GLenum>(target), s, t);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord2iARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_2iv_arb(texture_unit_t target, const  gl::int_t * v) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord2ivARB(static_cast<GLenum>(target), v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord2ivARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_2s_arb(texture_unit_t target, gl::short_t s, gl::short_t t) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord2sARB(static_cast<GLenum>(target), s, t);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord2sARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_2sv_arb(texture_unit_t target, const  gl::short_t * v) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord2svARB(static_cast<GLenum>(target), v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord2svARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_3d_arb(texture_unit_t target, gl::double_t s, gl::double_t t, gl::double_t r) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord3dARB(static_cast<GLenum>(target), s, t, r);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord3dARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_3dv_arb(texture_unit_t target, const  gl::double_t * v) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord3dvARB(static_cast<GLenum>(target), v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord3dvARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_3f_arb(texture_unit_t target, gl::float_t s, gl::float_t t, gl::float_t r) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord3fARB(static_cast<GLenum>(target), s, t, r);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord3fARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_3fv_arb(texture_unit_t target, const  gl::float_t * v) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord3fvARB(static_cast<GLenum>(target), v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord3fvARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_3i_arb(texture_unit_t target, gl::int_t s, gl::int_t t, gl::int_t r) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord3iARB(static_cast<GLenum>(target), s, t, r);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord3iARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_3iv_arb(texture_unit_t target, const  gl::int_t * v) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord3ivARB(static_cast<GLenum>(target), v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord3ivARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_3s_arb(texture_unit_t target, gl::short_t s, gl::short_t t, gl::short_t r) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord3sARB(static_cast<GLenum>(target), s, t, r);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord3sARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_3sv_arb(texture_unit_t target, const  gl::short_t * v) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord3svARB(static_cast<GLenum>(target), v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord3svARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_4d_arb(texture_unit_t target, gl::double_t s, gl::double_t t, gl::double_t r, gl::double_t q) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord4dARB(static_cast<GLenum>(target), s, t, r, q);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord4dARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_4dv_arb(texture_unit_t target, const  gl::double_t * v) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord4dvARB(static_cast<GLenum>(target), v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord4dvARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_4f_arb(texture_unit_t target, gl::float_t s, gl::float_t t, gl::float_t r, gl::float_t q) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord4fARB(static_cast<GLenum>(target), s, t, r, q);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord4fARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_4fv_arb(texture_unit_t target, const  gl::float_t * v) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord4fvARB(static_cast<GLenum>(target), v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord4fvARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_4i_arb(texture_unit_t target, gl::int_t s, gl::int_t t, gl::int_t r, gl::int_t q) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord4iARB(static_cast<GLenum>(target), s, t, r, q);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord4iARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_4iv_arb(texture_unit_t target, const  gl::int_t * v) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord4ivARB(static_cast<GLenum>(target), v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord4ivARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_4s_arb(texture_unit_t target, gl::short_t s, gl::short_t t, gl::short_t r, gl::short_t q) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord4sARB(static_cast<GLenum>(target), s, t, r, q);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord4sARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void multi_tex_coord_4sv_arb(texture_unit_t target, const  gl::short_t * v) {
      if ( GLAD_GL_ARB_multitexture ) {
        glMultiTexCoord4svARB(static_cast<GLenum>(target), v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiTexCoord4svARB' not available on this platform (extensions: GL_ARB_multitexture)");
      }
    }

    void begin_query_arb(gl::enum_t target, gl::uint_t id) {
      if ( GLAD_GL_ARB_occlusion_query ) {
        glBeginQueryARB(target, id);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBeginQueryARB' not available on this platform (extensions: GL_ARB_occlusion_query)");
      }
    }

    void delete_queries_arb(gl::sizei_t n, const  gl::uint_t * ids) {
      if ( GLAD_GL_ARB_occlusion_query ) {
        glDeleteQueriesARB(n, ids);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDeleteQueriesARB' not available on this platform (extensions: GL_ARB_occlusion_query)");
      }
    }

    void end_query_arb(gl::enum_t target) {
      if ( GLAD_GL_ARB_occlusion_query ) {
        glEndQueryARB(target);
      }
      else {
        throw std::runtime_error("OpenGL command 'glEndQueryARB' not available on this platform (extensions: GL_ARB_occlusion_query)");
      }
    }

    void gen_queries_arb(gl::sizei_t n, gl::uint_t * ids) {
      if ( GLAD_GL_ARB_occlusion_query ) {
        glGenQueriesARB(n, ids);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGenQueriesARB' not available on this platform (extensions: GL_ARB_occlusion_query)");
      }
    }

    void get_query_objectiv_arb(gl::uint_t id, gl::enum_t pname, gl::int_t * params) {
      if ( GLAD_GL_ARB_occlusion_query ) {
        glGetQueryObjectivARB(id, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetQueryObjectivARB' not available on this platform (extensions: GL_ARB_occlusion_query)");
      }
    }

    void get_query_objectuiv_arb(gl::uint_t id, gl::enum_t pname, gl::uint_t * params) {
      if ( GLAD_GL_ARB_occlusion_query ) {
        glGetQueryObjectuivARB(id, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetQueryObjectuivARB' not available on this platform (extensions: GL_ARB_occlusion_query)");
      }
    }

    void get_queryiv_arb(gl::enum_t target, gl::enum_t pname, gl::int_t * params) {
      if ( GLAD_GL_ARB_occlusion_query ) {
        glGetQueryivARB(target, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetQueryivARB' not available on this platform (extensions: GL_ARB_occlusion_query)");
      }
    }

    gl::boolean_t is_query_arb(gl::uint_t id) {
      if ( GLAD_GL_ARB_occlusion_query ) {
        return glIsQueryARB(id);
      }
      else {
        throw std::runtime_error("OpenGL command 'glIsQueryARB' not available on this platform (extensions: GL_ARB_occlusion_query)");
      }
    }

    void point_parameterf_arb(gl::enum_t pname, gl::float_t param) {
      if ( GLAD_GL_ARB_point_parameters ) {
        glPointParameterfARB(pname, param);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPointParameterfARB' not available on this platform (extensions: GL_ARB_point_parameters)");
      }
    }

    void point_parameterfv_arb(gl::enum_t pname, const  gl::float_t * params) {
      if ( GLAD_GL_ARB_point_parameters ) {
        glPointParameterfvARB(pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPointParameterfvARB' not available on this platform (extensions: GL_ARB_point_parameters)");
      }
    }

    void provoking_vertex(gl::enum_t mode) {
      if ( GLAD_GL_ARB_provoking_vertex ) {
        glProvokingVertex(mode);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProvokingVertex' not available on this platform (extensions: GL_ARB_provoking_vertex)");
      }
    }

    void attach_object_arb(gl::handleARB_t containerObj, gl::handleARB_t obj) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glAttachObjectARB(containerObj, obj);
      }
      else {
        throw std::runtime_error("OpenGL command 'glAttachObjectARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void compile_shader_arb(gl::handleARB_t shaderObj) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glCompileShaderARB(shaderObj);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCompileShaderARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    gl::handleARB_t create_program_object_arb() {
      if ( GLAD_GL_ARB_shader_objects ) {
        return glCreateProgramObjectARB();
      }
      else {
        throw std::runtime_error("OpenGL command 'glCreateProgramObjectARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    gl::handleARB_t create_shader_object_arb(gl::enum_t shaderType) {
      if ( GLAD_GL_ARB_shader_objects ) {
        return glCreateShaderObjectARB(shaderType);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCreateShaderObjectARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void delete_object_arb(gl::handleARB_t obj) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glDeleteObjectARB(obj);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDeleteObjectARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void detach_object_arb(gl::handleARB_t containerObj, gl::handleARB_t attachedObj) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glDetachObjectARB(containerObj, attachedObj);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDetachObjectARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void get_active_uniform_arb(gl::handleARB_t programObj, gl::uint_t index, gl::sizei_t maxLength, gl::sizei_t * length, gl::int_t * size, uniform_type_t * type, gl::charARB_t * name) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glGetActiveUniformARB(programObj, index, maxLength, length, size, reinterpret_cast<GLenum *>(type), name);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetActiveUniformARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void get_attached_objects_arb(gl::handleARB_t containerObj, gl::sizei_t maxCount, gl::sizei_t * count, gl::handleARB_t * obj) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glGetAttachedObjectsARB(containerObj, maxCount, count, obj);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetAttachedObjectsARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    gl::handleARB_t get_handle_arb(gl::enum_t pname) {
      if ( GLAD_GL_ARB_shader_objects ) {
        return glGetHandleARB(pname);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetHandleARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void get_info_log_arb(gl::handleARB_t obj, gl::sizei_t maxLength, gl::sizei_t * length, gl::charARB_t * infoLog) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glGetInfoLogARB(obj, maxLength, length, infoLog);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetInfoLogARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void get_object_parameterfv_arb(gl::handleARB_t obj, gl::enum_t pname, gl::float_t * params) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glGetObjectParameterfvARB(obj, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetObjectParameterfvARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void get_object_parameteriv_arb(gl::handleARB_t obj, gl::enum_t pname, gl::int_t * params) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glGetObjectParameterivARB(obj, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetObjectParameterivARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void get_shader_source_arb(gl::handleARB_t obj, gl::sizei_t maxLength, gl::sizei_t * length, gl::charARB_t * source) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glGetShaderSourceARB(obj, maxLength, length, source);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetShaderSourceARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    gl::int_t get_uniform_location_arb(gl::handleARB_t programObj, const  gl::charARB_t * name) {
      if ( GLAD_GL_ARB_shader_objects ) {
        return glGetUniformLocationARB(programObj, name);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetUniformLocationARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void get_uniformfv_arb(gl::handleARB_t programObj, gl::int_t location, gl::float_t * params) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glGetUniformfvARB(programObj, location, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetUniformfvARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void get_uniformiv_arb(gl::handleARB_t programObj, gl::int_t location, gl::int_t * params) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glGetUniformivARB(programObj, location, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetUniformivARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void link_program_arb(gl::handleARB_t programObj) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glLinkProgramARB(programObj);
      }
      else {
        throw std::runtime_error("OpenGL command 'glLinkProgramARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void shader_source_arb(gl::handleARB_t shaderObj, gl::sizei_t count, const  gl::charARB_t ** string, const  gl::int_t * length) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glShaderSourceARB(shaderObj, count, string, length);
      }
      else {
        throw std::runtime_error("OpenGL command 'glShaderSourceARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void uniform_1f_arb(gl::int_t location, gl::float_t v0) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glUniform1fARB(location, v0);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform1fARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void uniform_1fv_arb(gl::int_t location, gl::sizei_t count, const  gl::float_t * value) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glUniform1fvARB(location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform1fvARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void uniform_1i_arb(gl::int_t location, gl::int_t v0) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glUniform1iARB(location, v0);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform1iARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void uniform_1iv_arb(gl::int_t location, gl::sizei_t count, const  gl::int_t * value) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glUniform1ivARB(location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform1ivARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void uniform_2f_arb(gl::int_t location, gl::float_t v0, gl::float_t v1) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glUniform2fARB(location, v0, v1);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform2fARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void uniform_2fv_arb(gl::int_t location, gl::sizei_t count, const  gl::float_t * value) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glUniform2fvARB(location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform2fvARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void uniform_2i_arb(gl::int_t location, gl::int_t v0, gl::int_t v1) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glUniform2iARB(location, v0, v1);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform2iARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void uniform_2iv_arb(gl::int_t location, gl::sizei_t count, const  gl::int_t * value) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glUniform2ivARB(location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform2ivARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void uniform_3f_arb(gl::int_t location, gl::float_t v0, gl::float_t v1, gl::float_t v2) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glUniform3fARB(location, v0, v1, v2);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform3fARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void uniform_3fv_arb(gl::int_t location, gl::sizei_t count, const  gl::float_t * value) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glUniform3fvARB(location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform3fvARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void uniform_3i_arb(gl::int_t location, gl::int_t v0, gl::int_t v1, gl::int_t v2) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glUniform3iARB(location, v0, v1, v2);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform3iARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void uniform_3iv_arb(gl::int_t location, gl::sizei_t count, const  gl::int_t * value) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glUniform3ivARB(location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform3ivARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void uniform_4f_arb(gl::int_t location, gl::float_t v0, gl::float_t v1, gl::float_t v2, gl::float_t v3) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glUniform4fARB(location, v0, v1, v2, v3);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform4fARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void uniform_4fv_arb(gl::int_t location, gl::sizei_t count, const  gl::float_t * value) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glUniform4fvARB(location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform4fvARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void uniform_4i_arb(gl::int_t location, gl::int_t v0, gl::int_t v1, gl::int_t v2, gl::int_t v3) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glUniform4iARB(location, v0, v1, v2, v3);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform4iARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void uniform_4iv_arb(gl::int_t location, gl::sizei_t count, const  gl::int_t * value) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glUniform4ivARB(location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform4ivARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void uniform_matrix_2fv_arb(gl::int_t location, gl::sizei_t count, gl::boolean_t transpose, const  gl::float_t * value) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glUniformMatrix2fvARB(location, count, transpose, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniformMatrix2fvARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void uniform_matrix_3fv_arb(gl::int_t location, gl::sizei_t count, gl::boolean_t transpose, const  gl::float_t * value) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glUniformMatrix3fvARB(location, count, transpose, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniformMatrix3fvARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void uniform_matrix_4fv_arb(gl::int_t location, gl::sizei_t count, gl::boolean_t transpose, const  gl::float_t * value) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glUniformMatrix4fvARB(location, count, transpose, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniformMatrix4fvARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void use_program_object_arb(gl::handleARB_t programObj) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glUseProgramObjectARB(programObj);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUseProgramObjectARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    void validate_program_arb(gl::handleARB_t programObj) {
      if ( GLAD_GL_ARB_shader_objects ) {
        glValidateProgramARB(programObj);
      }
      else {
        throw std::runtime_error("OpenGL command 'glValidateProgramARB' not available on this platform (extensions: GL_ARB_shader_objects)");
      }
    }

    gl::enum_t client_wait_sync(gl::sync_t sync, gl::bitfield_t flags, gl::uint64_t timeout) {
      if ( GLAD_GL_ARB_sync ) {
        return glClientWaitSync(sync, flags, timeout);
      }
      else {
        throw std::runtime_error("OpenGL command 'glClientWaitSync' not available on this platform (extensions: GL_ARB_sync)");
      }
    }

    void delete_sync(gl::sync_t sync) {
      if ( GLAD_GL_ARB_sync ) {
        glDeleteSync(sync);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDeleteSync' not available on this platform (extensions: GL_ARB_sync)");
      }
    }

    gl::sync_t fence_sync(gl::enum_t condition, gl::bitfield_t flags) {
      if ( GLAD_GL_ARB_sync ) {
        return glFenceSync(condition, flags);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFenceSync' not available on this platform (extensions: GL_ARB_sync)");
      }
    }

    void get_integer_64v(gl::enum_t pname, gl::int64_t * data) {
      if ( GLAD_GL_ARB_sync ) {
        glGetInteger64v(pname, data);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetInteger64v' not available on this platform (extensions: GL_ARB_sync)");
      }
    }

    void get_synciv(gl::sync_t sync, gl::enum_t pname, gl::sizei_t bufSize, gl::sizei_t * length, gl::int_t * values) {
      if ( GLAD_GL_ARB_sync ) {
        glGetSynciv(sync, pname, bufSize, length, values);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetSynciv' not available on this platform (extensions: GL_ARB_sync)");
      }
    }

    gl::boolean_t is_sync(gl::sync_t sync) {
      if ( GLAD_GL_ARB_sync ) {
        return glIsSync(sync);
      }
      else {
        throw std::runtime_error("OpenGL command 'glIsSync' not available on this platform (extensions: GL_ARB_sync)");
      }
    }

    void wait_sync(gl::sync_t sync, gl::bitfield_t flags, gl::uint64_t timeout) {
      if ( GLAD_GL_ARB_sync ) {
        glWaitSync(sync, flags, timeout);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWaitSync' not available on this platform (extensions: GL_ARB_sync)");
      }
    }

    void compressed_tex_image_1darb(texture_target_t target, gl::int_t level, gl::enum_t internalformat, gl::sizei_t width, gl::int_t border, gl::sizei_t imageSize, const  void * data) {
      if ( GLAD_GL_ARB_texture_compression ) {
        glCompressedTexImage1DARB(static_cast<GLenum>(target), level, internalformat, width, border, imageSize, data);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCompressedTexImage1DARB' not available on this platform (extensions: GL_ARB_texture_compression)");
      }
    }

    void compressed_tex_image_2darb(texture_target_t target, gl::int_t level, gl::enum_t internalformat, gl::sizei_t width, gl::sizei_t height, gl::int_t border, gl::sizei_t imageSize, const  void * data) {
      if ( GLAD_GL_ARB_texture_compression ) {
        glCompressedTexImage2DARB(static_cast<GLenum>(target), level, internalformat, width, height, border, imageSize, data);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCompressedTexImage2DARB' not available on this platform (extensions: GL_ARB_texture_compression)");
      }
    }

    void compressed_tex_image_3darb(texture_target_t target, gl::int_t level, gl::enum_t internalformat, gl::sizei_t width, gl::sizei_t height, gl::sizei_t depth, gl::int_t border, gl::sizei_t imageSize, const  void * data) {
      if ( GLAD_GL_ARB_texture_compression ) {
        glCompressedTexImage3DARB(static_cast<GLenum>(target), level, internalformat, width, height, depth, border, imageSize, data);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCompressedTexImage3DARB' not available on this platform (extensions: GL_ARB_texture_compression)");
      }
    }

    void compressed_tex_sub_image_1darb(texture_target_t target, gl::int_t level, gl::int_t xoffset, gl::sizei_t width, pixel_format_t format, gl::sizei_t imageSize, const  void * data) {
      if ( GLAD_GL_ARB_texture_compression ) {
        glCompressedTexSubImage1DARB(static_cast<GLenum>(target), level, xoffset, width, static_cast<GLenum>(format), imageSize, data);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCompressedTexSubImage1DARB' not available on this platform (extensions: GL_ARB_texture_compression)");
      }
    }

    void compressed_tex_sub_image_2darb(texture_target_t target, gl::int_t level, gl::int_t xoffset, gl::int_t yoffset, gl::sizei_t width, gl::sizei_t height, pixel_format_t format, gl::sizei_t imageSize, const  void * data) {
      if ( GLAD_GL_ARB_texture_compression ) {
        glCompressedTexSubImage2DARB(static_cast<GLenum>(target), level, xoffset, yoffset, width, height, static_cast<GLenum>(format), imageSize, data);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCompressedTexSubImage2DARB' not available on this platform (extensions: GL_ARB_texture_compression)");
      }
    }

    void compressed_tex_sub_image_3darb(texture_target_t target, gl::int_t level, gl::int_t xoffset, gl::int_t yoffset, gl::int_t zoffset, gl::sizei_t width, gl::sizei_t height, gl::sizei_t depth, pixel_format_t format, gl::sizei_t imageSize, const  void * data) {
      if ( GLAD_GL_ARB_texture_compression ) {
        glCompressedTexSubImage3DARB(static_cast<GLenum>(target), level, xoffset, yoffset, zoffset, width, height, depth, static_cast<GLenum>(format), imageSize, data);
      }
      else {
        throw std::runtime_error("OpenGL command 'glCompressedTexSubImage3DARB' not available on this platform (extensions: GL_ARB_texture_compression)");
      }
    }

    void get_compressed_tex_image_arb(texture_target_t target, gl::int_t level, void * img) {
      if ( GLAD_GL_ARB_texture_compression ) {
        glGetCompressedTexImageARB(static_cast<GLenum>(target), level, img);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetCompressedTexImageARB' not available on this platform (extensions: GL_ARB_texture_compression)");
      }
    }

    void load_transpose_matrixd_arb(const  gl::double_t * m) {
      if ( GLAD_GL_ARB_transpose_matrix ) {
        glLoadTransposeMatrixdARB(m);
      }
      else {
        throw std::runtime_error("OpenGL command 'glLoadTransposeMatrixdARB' not available on this platform (extensions: GL_ARB_transpose_matrix)");
      }
    }

    void load_transpose_matrixf_arb(const  gl::float_t * m) {
      if ( GLAD_GL_ARB_transpose_matrix ) {
        glLoadTransposeMatrixfARB(m);
      }
      else {
        throw std::runtime_error("OpenGL command 'glLoadTransposeMatrixfARB' not available on this platform (extensions: GL_ARB_transpose_matrix)");
      }
    }

    void mult_transpose_matrixd_arb(const  gl::double_t * m) {
      if ( GLAD_GL_ARB_transpose_matrix ) {
        glMultTransposeMatrixdARB(m);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultTransposeMatrixdARB' not available on this platform (extensions: GL_ARB_transpose_matrix)");
      }
    }

    void mult_transpose_matrixf_arb(const  gl::float_t * m) {
      if ( GLAD_GL_ARB_transpose_matrix ) {
        glMultTransposeMatrixfARB(m);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultTransposeMatrixfARB' not available on this platform (extensions: GL_ARB_transpose_matrix)");
      }
    }

    void vertex_blend_arb(gl::int_t count) {
      if ( GLAD_GL_ARB_vertex_blend ) {
        glVertexBlendARB(count);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexBlendARB' not available on this platform (extensions: GL_ARB_vertex_blend)");
      }
    }

    void weight_pointer_arb(gl::int_t size, gl::enum_t type, gl::sizei_t stride, const  void * pointer) {
      if ( GLAD_GL_ARB_vertex_blend ) {
        glWeightPointerARB(size, type, stride, pointer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWeightPointerARB' not available on this platform (extensions: GL_ARB_vertex_blend)");
      }
    }

    void weightbv_arb(gl::int_t size, const  gl::byte_t * weights) {
      if ( GLAD_GL_ARB_vertex_blend ) {
        glWeightbvARB(size, weights);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWeightbvARB' not available on this platform (extensions: GL_ARB_vertex_blend)");
      }
    }

    void weightdv_arb(gl::int_t size, const  gl::double_t * weights) {
      if ( GLAD_GL_ARB_vertex_blend ) {
        glWeightdvARB(size, weights);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWeightdvARB' not available on this platform (extensions: GL_ARB_vertex_blend)");
      }
    }

    void weightfv_arb(gl::int_t size, const  gl::float_t * weights) {
      if ( GLAD_GL_ARB_vertex_blend ) {
        glWeightfvARB(size, weights);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWeightfvARB' not available on this platform (extensions: GL_ARB_vertex_blend)");
      }
    }

    void weightiv_arb(gl::int_t size, const  gl::int_t * weights) {
      if ( GLAD_GL_ARB_vertex_blend ) {
        glWeightivARB(size, weights);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWeightivARB' not available on this platform (extensions: GL_ARB_vertex_blend)");
      }
    }

    void weightsv_arb(gl::int_t size, const  gl::short_t * weights) {
      if ( GLAD_GL_ARB_vertex_blend ) {
        glWeightsvARB(size, weights);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWeightsvARB' not available on this platform (extensions: GL_ARB_vertex_blend)");
      }
    }

    void weightubv_arb(gl::int_t size, const  gl::ubyte_t * weights) {
      if ( GLAD_GL_ARB_vertex_blend ) {
        glWeightubvARB(size, weights);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWeightubvARB' not available on this platform (extensions: GL_ARB_vertex_blend)");
      }
    }

    void weightuiv_arb(gl::int_t size, const  gl::uint_t * weights) {
      if ( GLAD_GL_ARB_vertex_blend ) {
        glWeightuivARB(size, weights);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWeightuivARB' not available on this platform (extensions: GL_ARB_vertex_blend)");
      }
    }

    void weightusv_arb(gl::int_t size, const  gl::ushort_t * weights) {
      if ( GLAD_GL_ARB_vertex_blend ) {
        glWeightusvARB(size, weights);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWeightusvARB' not available on this platform (extensions: GL_ARB_vertex_blend)");
      }
    }

    void bind_buffer_arb(buffer_target_arb_t target, gl::uint_t buffer) {
      if ( GLAD_GL_ARB_vertex_buffer_object ) {
        glBindBufferARB(static_cast<GLenum>(target), buffer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBindBufferARB' not available on this platform (extensions: GL_ARB_vertex_buffer_object)");
      }
    }

    void buffer_data_arb(buffer_target_arb_t target, gl::sizeiptrARB_t size, const  void * data, buffer_usage_arb_t usage) {
      if ( GLAD_GL_ARB_vertex_buffer_object ) {
        glBufferDataARB(static_cast<GLenum>(target), size, data, static_cast<GLenum>(usage));
      }
      else {
        throw std::runtime_error("OpenGL command 'glBufferDataARB' not available on this platform (extensions: GL_ARB_vertex_buffer_object)");
      }
    }

    void buffer_sub_data_arb(buffer_target_arb_t target, gl::intptrARB_t offset, gl::sizeiptrARB_t size, const  void * data) {
      if ( GLAD_GL_ARB_vertex_buffer_object ) {
        glBufferSubDataARB(static_cast<GLenum>(target), offset, size, data);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBufferSubDataARB' not available on this platform (extensions: GL_ARB_vertex_buffer_object)");
      }
    }

    void delete_buffers_arb(gl::sizei_t n, const  gl::uint_t * buffers) {
      if ( GLAD_GL_ARB_vertex_buffer_object ) {
        glDeleteBuffersARB(n, buffers);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDeleteBuffersARB' not available on this platform (extensions: GL_ARB_vertex_buffer_object)");
      }
    }

    void gen_buffers_arb(gl::sizei_t n, gl::uint_t * buffers) {
      if ( GLAD_GL_ARB_vertex_buffer_object ) {
        glGenBuffersARB(n, buffers);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGenBuffersARB' not available on this platform (extensions: GL_ARB_vertex_buffer_object)");
      }
    }

    void get_buffer_parameteriv_arb(buffer_target_arb_t target, buffer_p_name_arb_t pname, gl::int_t * params) {
      if ( GLAD_GL_ARB_vertex_buffer_object ) {
        glGetBufferParameterivARB(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetBufferParameterivARB' not available on this platform (extensions: GL_ARB_vertex_buffer_object)");
      }
    }

    void get_buffer_pointerv_arb(buffer_target_arb_t target, gl::enum_t pname, void ** params) {
      if ( GLAD_GL_ARB_vertex_buffer_object ) {
        glGetBufferPointervARB(static_cast<GLenum>(target), pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetBufferPointervARB' not available on this platform (extensions: GL_ARB_vertex_buffer_object)");
      }
    }

    void get_buffer_sub_data_arb(buffer_target_arb_t target, gl::intptrARB_t offset, gl::sizeiptrARB_t size, void * data) {
      if ( GLAD_GL_ARB_vertex_buffer_object ) {
        glGetBufferSubDataARB(static_cast<GLenum>(target), offset, size, data);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetBufferSubDataARB' not available on this platform (extensions: GL_ARB_vertex_buffer_object)");
      }
    }

    gl::boolean_t is_buffer_arb(gl::uint_t buffer) {
      if ( GLAD_GL_ARB_vertex_buffer_object ) {
        return glIsBufferARB(buffer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glIsBufferARB' not available on this platform (extensions: GL_ARB_vertex_buffer_object)");
      }
    }

    void * map_buffer_arb(buffer_target_arb_t target, gl::enum_t access) {
      if ( GLAD_GL_ARB_vertex_buffer_object ) {
        return glMapBufferARB(static_cast<GLenum>(target), access);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMapBufferARB' not available on this platform (extensions: GL_ARB_vertex_buffer_object)");
      }
    }

    gl::boolean_t unmap_buffer_arb(buffer_target_arb_t target) {
      if ( GLAD_GL_ARB_vertex_buffer_object ) {
        return glUnmapBufferARB(static_cast<GLenum>(target));
      }
      else {
        throw std::runtime_error("OpenGL command 'glUnmapBufferARB' not available on this platform (extensions: GL_ARB_vertex_buffer_object)");
      }
    }

    void disable_vertex_attrib_array_arb(gl::uint_t index) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glDisableVertexAttribArrayARB(index);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDisableVertexAttribArrayARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void enable_vertex_attrib_array_arb(gl::uint_t index) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glEnableVertexAttribArrayARB(index);
      }
      else {
        throw std::runtime_error("OpenGL command 'glEnableVertexAttribArrayARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void get_vertex_attrib_pointerv_arb(gl::uint_t index, vertex_attrib_pointer_property_arb_t pname, void ** pointer) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glGetVertexAttribPointervARB(index, static_cast<GLenum>(pname), pointer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetVertexAttribPointervARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void get_vertex_attribdv_arb(gl::uint_t index, vertex_attrib_property_arb_t pname, gl::double_t * params) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glGetVertexAttribdvARB(index, static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetVertexAttribdvARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void get_vertex_attribfv_arb(gl::uint_t index, vertex_attrib_property_arb_t pname, gl::float_t * params) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glGetVertexAttribfvARB(index, static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetVertexAttribfvARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void get_vertex_attribiv_arb(gl::uint_t index, vertex_attrib_property_arb_t pname, gl::int_t * params) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glGetVertexAttribivARB(index, static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetVertexAttribivARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_1d_arb(gl::uint_t index, gl::double_t x) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib1dARB(index, x);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib1dARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_1dv_arb(gl::uint_t index, const  gl::double_t * v) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib1dvARB(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib1dvARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_1f_arb(gl::uint_t index, gl::float_t x) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib1fARB(index, x);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib1fARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_1fv_arb(gl::uint_t index, const  gl::float_t * v) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib1fvARB(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib1fvARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_1s_arb(gl::uint_t index, gl::short_t x) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib1sARB(index, x);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib1sARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_1sv_arb(gl::uint_t index, const  gl::short_t * v) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib1svARB(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib1svARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_2d_arb(gl::uint_t index, gl::double_t x, gl::double_t y) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib2dARB(index, x, y);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib2dARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_2dv_arb(gl::uint_t index, const  gl::double_t * v) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib2dvARB(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib2dvARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_2f_arb(gl::uint_t index, gl::float_t x, gl::float_t y) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib2fARB(index, x, y);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib2fARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_2fv_arb(gl::uint_t index, const  gl::float_t * v) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib2fvARB(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib2fvARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_2s_arb(gl::uint_t index, gl::short_t x, gl::short_t y) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib2sARB(index, x, y);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib2sARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_2sv_arb(gl::uint_t index, const  gl::short_t * v) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib2svARB(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib2svARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_3d_arb(gl::uint_t index, gl::double_t x, gl::double_t y, gl::double_t z) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib3dARB(index, x, y, z);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib3dARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_3dv_arb(gl::uint_t index, const  gl::double_t * v) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib3dvARB(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib3dvARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_3f_arb(gl::uint_t index, gl::float_t x, gl::float_t y, gl::float_t z) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib3fARB(index, x, y, z);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib3fARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_3fv_arb(gl::uint_t index, const  gl::float_t * v) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib3fvARB(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib3fvARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_3s_arb(gl::uint_t index, gl::short_t x, gl::short_t y, gl::short_t z) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib3sARB(index, x, y, z);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib3sARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_3sv_arb(gl::uint_t index, const  gl::short_t * v) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib3svARB(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib3svARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_4_nbv_arb(gl::uint_t index, const  gl::byte_t * v) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib4NbvARB(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib4NbvARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_4_niv_arb(gl::uint_t index, const  gl::int_t * v) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib4NivARB(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib4NivARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_4_nsv_arb(gl::uint_t index, const  gl::short_t * v) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib4NsvARB(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib4NsvARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_4_nub_arb(gl::uint_t index, gl::ubyte_t x, gl::ubyte_t y, gl::ubyte_t z, gl::ubyte_t w) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib4NubARB(index, x, y, z, w);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib4NubARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_4_nubv_arb(gl::uint_t index, const  gl::ubyte_t * v) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib4NubvARB(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib4NubvARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_4_nuiv_arb(gl::uint_t index, const  gl::uint_t * v) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib4NuivARB(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib4NuivARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_4_nusv_arb(gl::uint_t index, const  gl::ushort_t * v) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib4NusvARB(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib4NusvARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_4bv_arb(gl::uint_t index, const  gl::byte_t * v) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib4bvARB(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib4bvARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_4d_arb(gl::uint_t index, gl::double_t x, gl::double_t y, gl::double_t z, gl::double_t w) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib4dARB(index, x, y, z, w);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib4dARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_4dv_arb(gl::uint_t index, const  gl::double_t * v) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib4dvARB(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib4dvARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_4f_arb(gl::uint_t index, gl::float_t x, gl::float_t y, gl::float_t z, gl::float_t w) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib4fARB(index, x, y, z, w);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib4fARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_4fv_arb(gl::uint_t index, const  gl::float_t * v) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib4fvARB(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib4fvARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_4iv_arb(gl::uint_t index, const  gl::int_t * v) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib4ivARB(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib4ivARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_4s_arb(gl::uint_t index, gl::short_t x, gl::short_t y, gl::short_t z, gl::short_t w) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib4sARB(index, x, y, z, w);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib4sARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_4sv_arb(gl::uint_t index, const  gl::short_t * v) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib4svARB(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib4svARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_4ubv_arb(gl::uint_t index, const  gl::ubyte_t * v) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib4ubvARB(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib4ubvARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_4uiv_arb(gl::uint_t index, const  gl::uint_t * v) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib4uivARB(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib4uivARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_4usv_arb(gl::uint_t index, const  gl::ushort_t * v) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttrib4usvARB(index, v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttrib4usvARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void vertex_attrib_pointer_arb(gl::uint_t index, gl::int_t size, vertex_attrib_pointer_type_t type, gl::boolean_t normalized, gl::sizei_t stride, const  void * pointer) {
      if ( GLAD_GL_ARB_vertex_program || GLAD_GL_ARB_vertex_shader ) {
        glVertexAttribPointerARB(index, size, static_cast<GLenum>(type), normalized, stride, pointer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glVertexAttribPointerARB' not available on this platform (extensions: GL_ARB_vertex_program, GL_ARB_vertex_shader)");
      }
    }

    void bind_attrib_location_arb(gl::handleARB_t programObj, gl::uint_t index, const  gl::charARB_t * name) {
      if ( GLAD_GL_ARB_vertex_shader ) {
        glBindAttribLocationARB(programObj, index, name);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBindAttribLocationARB' not available on this platform (extensions: GL_ARB_vertex_shader)");
      }
    }

    void get_active_attrib_arb(gl::handleARB_t programObj, gl::uint_t index, gl::sizei_t maxLength, gl::sizei_t * length, gl::int_t * size, attrib_type_t * type, gl::charARB_t * name) {
      if ( GLAD_GL_ARB_vertex_shader ) {
        glGetActiveAttribARB(programObj, index, maxLength, length, size, reinterpret_cast<GLenum *>(type), name);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetActiveAttribARB' not available on this platform (extensions: GL_ARB_vertex_shader)");
      }
    }

    gl::int_t get_attrib_location_arb(gl::handleARB_t programObj, const  gl::charARB_t * name) {
      if ( GLAD_GL_ARB_vertex_shader ) {
        return glGetAttribLocationARB(programObj, name);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetAttribLocationARB' not available on this platform (extensions: GL_ARB_vertex_shader)");
      }
    }

    void window_pos_2d_arb(gl::double_t x, gl::double_t y) {
      if ( GLAD_GL_ARB_window_pos ) {
        glWindowPos2dARB(x, y);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWindowPos2dARB' not available on this platform (extensions: GL_ARB_window_pos)");
      }
    }

    void window_pos_2dv_arb(const  gl::double_t * v) {
      if ( GLAD_GL_ARB_window_pos ) {
        glWindowPos2dvARB(v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWindowPos2dvARB' not available on this platform (extensions: GL_ARB_window_pos)");
      }
    }

    void window_pos_2f_arb(gl::float_t x, gl::float_t y) {
      if ( GLAD_GL_ARB_window_pos ) {
        glWindowPos2fARB(x, y);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWindowPos2fARB' not available on this platform (extensions: GL_ARB_window_pos)");
      }
    }

    void window_pos_2fv_arb(const  gl::float_t * v) {
      if ( GLAD_GL_ARB_window_pos ) {
        glWindowPos2fvARB(v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWindowPos2fvARB' not available on this platform (extensions: GL_ARB_window_pos)");
      }
    }

    void window_pos_2i_arb(gl::int_t x, gl::int_t y) {
      if ( GLAD_GL_ARB_window_pos ) {
        glWindowPos2iARB(x, y);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWindowPos2iARB' not available on this platform (extensions: GL_ARB_window_pos)");
      }
    }

    void window_pos_2iv_arb(const  gl::int_t * v) {
      if ( GLAD_GL_ARB_window_pos ) {
        glWindowPos2ivARB(v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWindowPos2ivARB' not available on this platform (extensions: GL_ARB_window_pos)");
      }
    }

    void window_pos_2s_arb(gl::short_t x, gl::short_t y) {
      if ( GLAD_GL_ARB_window_pos ) {
        glWindowPos2sARB(x, y);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWindowPos2sARB' not available on this platform (extensions: GL_ARB_window_pos)");
      }
    }

    void window_pos_2sv_arb(const  gl::short_t * v) {
      if ( GLAD_GL_ARB_window_pos ) {
        glWindowPos2svARB(v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWindowPos2svARB' not available on this platform (extensions: GL_ARB_window_pos)");
      }
    }

    void window_pos_3d_arb(gl::double_t x, gl::double_t y, gl::double_t z) {
      if ( GLAD_GL_ARB_window_pos ) {
        glWindowPos3dARB(x, y, z);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWindowPos3dARB' not available on this platform (extensions: GL_ARB_window_pos)");
      }
    }

    void window_pos_3dv_arb(const  gl::double_t * v) {
      if ( GLAD_GL_ARB_window_pos ) {
        glWindowPos3dvARB(v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWindowPos3dvARB' not available on this platform (extensions: GL_ARB_window_pos)");
      }
    }

    void window_pos_3f_arb(gl::float_t x, gl::float_t y, gl::float_t z) {
      if ( GLAD_GL_ARB_window_pos ) {
        glWindowPos3fARB(x, y, z);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWindowPos3fARB' not available on this platform (extensions: GL_ARB_window_pos)");
      }
    }

    void window_pos_3fv_arb(const  gl::float_t * v) {
      if ( GLAD_GL_ARB_window_pos ) {
        glWindowPos3fvARB(v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWindowPos3fvARB' not available on this platform (extensions: GL_ARB_window_pos)");
      }
    }

    void window_pos_3i_arb(gl::int_t x, gl::int_t y, gl::int_t z) {
      if ( GLAD_GL_ARB_window_pos ) {
        glWindowPos3iARB(x, y, z);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWindowPos3iARB' not available on this platform (extensions: GL_ARB_window_pos)");
      }
    }

    void window_pos_3iv_arb(const  gl::int_t * v) {
      if ( GLAD_GL_ARB_window_pos ) {
        glWindowPos3ivARB(v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWindowPos3ivARB' not available on this platform (extensions: GL_ARB_window_pos)");
      }
    }

    void window_pos_3s_arb(gl::short_t x, gl::short_t y, gl::short_t z) {
      if ( GLAD_GL_ARB_window_pos ) {
        glWindowPos3sARB(x, y, z);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWindowPos3sARB' not available on this platform (extensions: GL_ARB_window_pos)");
      }
    }

    void window_pos_3sv_arb(const  gl::short_t * v) {
      if ( GLAD_GL_ARB_window_pos ) {
        glWindowPos3svARB(v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glWindowPos3svARB' not available on this platform (extensions: GL_ARB_window_pos)");
      }
    }

    void stencil_func_separate_ati(stencil_function_t frontfunc, stencil_function_t backfunc, gl::int_t ref, gl::uint_t mask) {
      if ( GLAD_GL_ATI_separate_stencil ) {
        glStencilFuncSeparateATI(static_cast<GLenum>(frontfunc), static_cast<GLenum>(backfunc), ref, mask);
      }
      else {
        throw std::runtime_error("OpenGL command 'glStencilFuncSeparateATI' not available on this platform (extensions: GL_ATI_separate_stencil)");
      }
    }

    void stencil_op_separate_ati(stencil_face_direction_t face, stencil_op_t sfail, stencil_op_t dpfail, stencil_op_t dppass) {
      if ( GLAD_GL_ATI_separate_stencil ) {
        glStencilOpSeparateATI(static_cast<GLenum>(face), static_cast<GLenum>(sfail), static_cast<GLenum>(dpfail), static_cast<GLenum>(dppass));
      }
      else {
        throw std::runtime_error("OpenGL command 'glStencilOpSeparateATI' not available on this platform (extensions: GL_ATI_separate_stencil)");
      }
    }

    gl::int_t get_uniform_buffer_size_ext(gl::uint_t program, gl::int_t location) {
      if ( GLAD_GL_EXT_bindable_uniform ) {
        return glGetUniformBufferSizeEXT(program, location);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetUniformBufferSizeEXT' not available on this platform (extensions: GL_EXT_bindable_uniform)");
      }
    }

    gl::intptr_t get_uniform_offset_ext(gl::uint_t program, gl::int_t location) {
      if ( GLAD_GL_EXT_bindable_uniform ) {
        return glGetUniformOffsetEXT(program, location);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetUniformOffsetEXT' not available on this platform (extensions: GL_EXT_bindable_uniform)");
      }
    }

    void uniform_buffer_ext(gl::uint_t program, gl::int_t location, gl::uint_t buffer) {
      if ( GLAD_GL_EXT_bindable_uniform ) {
        glUniformBufferEXT(program, location, buffer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniformBufferEXT' not available on this platform (extensions: GL_EXT_bindable_uniform)");
      }
    }

    void blend_color_ext(gl::float_t red, gl::float_t green, gl::float_t blue, gl::float_t alpha) {
      if ( GLAD_GL_EXT_blend_color ) {
        glBlendColorEXT(red, green, blue, alpha);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBlendColorEXT' not available on this platform (extensions: GL_EXT_blend_color)");
      }
    }

    void blend_equation_separate_ext(blend_equation_mode_ext_t modeRGB, blend_equation_mode_ext_t modeAlpha) {
      if ( GLAD_GL_EXT_blend_equation_separate ) {
        glBlendEquationSeparateEXT(static_cast<GLenum>(modeRGB), static_cast<GLenum>(modeAlpha));
      }
      else {
        throw std::runtime_error("OpenGL command 'glBlendEquationSeparateEXT' not available on this platform (extensions: GL_EXT_blend_equation_separate)");
      }
    }

    void blend_func_separate_ext(blend_func_separate_parameter_ext_t sfactorRGB, blend_func_separate_parameter_ext_t dfactorRGB, blend_func_separate_parameter_ext_t sfactorAlpha, blend_func_separate_parameter_ext_t dfactorAlpha) {
      if ( GLAD_GL_EXT_blend_func_separate ) {
        glBlendFuncSeparateEXT(static_cast<GLenum>(sfactorRGB), static_cast<GLenum>(dfactorRGB), static_cast<GLenum>(sfactorAlpha), static_cast<GLenum>(dfactorAlpha));
      }
      else {
        throw std::runtime_error("OpenGL command 'glBlendFuncSeparateEXT' not available on this platform (extensions: GL_EXT_blend_func_separate)");
      }
    }

    void blend_equation_ext(blend_equation_mode_ext_t mode) {
      if ( GLAD_GL_EXT_blend_minmax ) {
        glBlendEquationEXT(static_cast<GLenum>(mode));
      }
      else {
        throw std::runtime_error("OpenGL command 'glBlendEquationEXT' not available on this platform (extensions: GL_EXT_blend_minmax)");
      }
    }

    void get_object_label_ext(gl::enum_t type, gl::uint_t object, gl::sizei_t bufSize, gl::sizei_t * length, gl::char_t * label) {
      if ( GLAD_GL_EXT_debug_label ) {
        glGetObjectLabelEXT(type, object, bufSize, length, label);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetObjectLabelEXT' not available on this platform (extensions: GL_EXT_debug_label)");
      }
    }

    void label_object_ext(gl::enum_t type, gl::uint_t object, gl::sizei_t length, const  gl::char_t * label) {
      if ( GLAD_GL_EXT_debug_label ) {
        glLabelObjectEXT(type, object, length, label);
      }
      else {
        throw std::runtime_error("OpenGL command 'glLabelObjectEXT' not available on this platform (extensions: GL_EXT_debug_label)");
      }
    }

    void insert_event_marker_ext(gl::sizei_t length, const  gl::char_t * marker) {
      if ( GLAD_GL_EXT_debug_marker ) {
        glInsertEventMarkerEXT(length, marker);
      }
      else {
        throw std::runtime_error("OpenGL command 'glInsertEventMarkerEXT' not available on this platform (extensions: GL_EXT_debug_marker)");
      }
    }

    void pop_group_marker_ext() {
      if ( GLAD_GL_EXT_debug_marker ) {
        glPopGroupMarkerEXT();
      }
      else {
        throw std::runtime_error("OpenGL command 'glPopGroupMarkerEXT' not available on this platform (extensions: GL_EXT_debug_marker)");
      }
    }

    void push_group_marker_ext(gl::sizei_t length, const  gl::char_t * marker) {
      if ( GLAD_GL_EXT_debug_marker ) {
        glPushGroupMarkerEXT(length, marker);
      }
      else {
        throw std::runtime_error("OpenGL command 'glPushGroupMarkerEXT' not available on this platform (extensions: GL_EXT_debug_marker)");
      }
    }

    void disable_indexed_ext(gl::enum_t target, gl::uint_t index) {
      if ( GLAD_GL_EXT_direct_state_access || GLAD_GL_EXT_draw_buffers2 ) {
        glDisableIndexedEXT(target, index);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDisableIndexedEXT' not available on this platform (extensions: GL_EXT_direct_state_access, GL_EXT_draw_buffers2)");
      }
    }

    void enable_indexed_ext(gl::enum_t target, gl::uint_t index) {
      if ( GLAD_GL_EXT_direct_state_access || GLAD_GL_EXT_draw_buffers2 ) {
        glEnableIndexedEXT(target, index);
      }
      else {
        throw std::runtime_error("OpenGL command 'glEnableIndexedEXT' not available on this platform (extensions: GL_EXT_direct_state_access, GL_EXT_draw_buffers2)");
      }
    }

    void get_boolean_indexedv_ext(gl::enum_t target, gl::uint_t index, gl::boolean_t * data) {
      if ( GLAD_GL_EXT_direct_state_access || GLAD_GL_EXT_draw_buffers2 ) {
        glGetBooleanIndexedvEXT(target, index, data);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetBooleanIndexedvEXT' not available on this platform (extensions: GL_EXT_direct_state_access, GL_EXT_draw_buffers2)");
      }
    }

    void get_integer_indexedv_ext(gl::enum_t target, gl::uint_t index, gl::int_t * data) {
      if ( GLAD_GL_EXT_direct_state_access || GLAD_GL_EXT_draw_buffers2 ) {
        glGetIntegerIndexedvEXT(target, index, data);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetIntegerIndexedvEXT' not available on this platform (extensions: GL_EXT_direct_state_access, GL_EXT_draw_buffers2)");
      }
    }

    gl::boolean_t is_enabled_indexed_ext(gl::enum_t target, gl::uint_t index) {
      if ( GLAD_GL_EXT_direct_state_access || GLAD_GL_EXT_draw_buffers2 ) {
        return glIsEnabledIndexedEXT(target, index);
      }
      else {
        throw std::runtime_error("OpenGL command 'glIsEnabledIndexedEXT' not available on this platform (extensions: GL_EXT_direct_state_access, GL_EXT_draw_buffers2)");
      }
    }

    void get_query_objecti_64v_ext(gl::uint_t id, gl::enum_t pname, gl::int64_t * params) {
      if ( GLAD_GL_EXT_timer_query ) {
        glGetQueryObjecti64vEXT(id, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetQueryObjecti64vEXT' not available on this platform (extensions: GL_EXT_timer_query)");
      }
    }

    void get_query_objectui_64v_ext(gl::uint_t id, gl::enum_t pname, gl::uint64_t * params) {
      if ( GLAD_GL_EXT_timer_query ) {
        glGetQueryObjectui64vEXT(id, pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetQueryObjectui64vEXT' not available on this platform (extensions: GL_EXT_timer_query)");
      }
    }

    void color_mask_indexed_ext(gl::uint_t index, gl::boolean_t r, gl::boolean_t g, gl::boolean_t b, gl::boolean_t a) {
      if ( GLAD_GL_EXT_draw_buffers2 ) {
        glColorMaskIndexedEXT(index, r, g, b, a);
      }
      else {
        throw std::runtime_error("OpenGL command 'glColorMaskIndexedEXT' not available on this platform (extensions: GL_EXT_draw_buffers2)");
      }
    }

    void draw_range_elements_ext(primitive_type_t mode, gl::uint_t start, gl::uint_t end, gl::sizei_t count, draw_elements_type_t type, const  void * indices) {
      if ( GLAD_GL_EXT_draw_range_elements ) {
        glDrawRangeElementsEXT(static_cast<GLenum>(mode), start, end, count, static_cast<GLenum>(type), indices);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDrawRangeElementsEXT' not available on this platform (extensions: GL_EXT_draw_range_elements)");
      }
    }

    void fog_coord_pointer_ext(fog_pointer_type_ext_t type, gl::sizei_t stride, const  void * pointer) {
      if ( GLAD_GL_EXT_fog_coord ) {
        glFogCoordPointerEXT(static_cast<GLenum>(type), stride, pointer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFogCoordPointerEXT' not available on this platform (extensions: GL_EXT_fog_coord)");
      }
    }

    void fog_coordd_ext(gl::double_t coord) {
      if ( GLAD_GL_EXT_fog_coord ) {
        glFogCoorddEXT(coord);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFogCoorddEXT' not available on this platform (extensions: GL_EXT_fog_coord)");
      }
    }

    void fog_coorddv_ext(const  gl::double_t * coord) {
      if ( GLAD_GL_EXT_fog_coord ) {
        glFogCoorddvEXT(coord);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFogCoorddvEXT' not available on this platform (extensions: GL_EXT_fog_coord)");
      }
    }

    void fog_coordf_ext(gl::float_t coord) {
      if ( GLAD_GL_EXT_fog_coord ) {
        glFogCoordfEXT(coord);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFogCoordfEXT' not available on this platform (extensions: GL_EXT_fog_coord)");
      }
    }

    void fog_coordfv_ext(const  gl::float_t * coord) {
      if ( GLAD_GL_EXT_fog_coord ) {
        glFogCoordfvEXT(coord);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFogCoordfvEXT' not available on this platform (extensions: GL_EXT_fog_coord)");
      }
    }

    void blit_framebuffer_ext(gl::int_t srcX0, gl::int_t srcY0, gl::int_t srcX1, gl::int_t srcY1, gl::int_t dstX0, gl::int_t dstY0, gl::int_t dstX1, gl::int_t dstY1, gl::bitmask<clear_buffer_flags_t> mask, gl::enum_t filter) {
      if ( GLAD_GL_EXT_framebuffer_blit ) {
        glBlitFramebufferEXT(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, static_cast<GLbitfield>(mask.value), filter);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBlitFramebufferEXT' not available on this platform (extensions: GL_EXT_framebuffer_blit)");
      }
    }

    void renderbuffer_storage_multisample_ext(renderbuffer_target_t target, gl::sizei_t samples, internal_format_t internalformat, gl::sizei_t width, gl::sizei_t height) {
      if ( GLAD_GL_EXT_framebuffer_multisample ) {
        glRenderbufferStorageMultisampleEXT(static_cast<GLenum>(target), samples, static_cast<GLenum>(internalformat), width, height);
      }
      else {
        throw std::runtime_error("OpenGL command 'glRenderbufferStorageMultisampleEXT' not available on this platform (extensions: GL_EXT_framebuffer_multisample)");
      }
    }

    void bind_framebuffer_ext(framebuffer_target_t target, gl::uint_t framebuffer) {
      if ( GLAD_GL_EXT_framebuffer_object ) {
        glBindFramebufferEXT(static_cast<GLenum>(target), framebuffer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBindFramebufferEXT' not available on this platform (extensions: GL_EXT_framebuffer_object)");
      }
    }

    void bind_renderbuffer_ext(renderbuffer_target_t target, gl::uint_t renderbuffer) {
      if ( GLAD_GL_EXT_framebuffer_object ) {
        glBindRenderbufferEXT(static_cast<GLenum>(target), renderbuffer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBindRenderbufferEXT' not available on this platform (extensions: GL_EXT_framebuffer_object)");
      }
    }

    gl::enum_t check_framebuffer_status_ext(framebuffer_target_t target) {
      if ( GLAD_GL_EXT_framebuffer_object ) {
        return glCheckFramebufferStatusEXT(static_cast<GLenum>(target));
      }
      else {
        throw std::runtime_error("OpenGL command 'glCheckFramebufferStatusEXT' not available on this platform (extensions: GL_EXT_framebuffer_object)");
      }
    }

    void delete_framebuffers_ext(gl::sizei_t n, const  gl::uint_t * framebuffers) {
      if ( GLAD_GL_EXT_framebuffer_object ) {
        glDeleteFramebuffersEXT(n, framebuffers);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDeleteFramebuffersEXT' not available on this platform (extensions: GL_EXT_framebuffer_object)");
      }
    }

    void delete_renderbuffers_ext(gl::sizei_t n, const  gl::uint_t * renderbuffers) {
      if ( GLAD_GL_EXT_framebuffer_object ) {
        glDeleteRenderbuffersEXT(n, renderbuffers);
      }
      else {
        throw std::runtime_error("OpenGL command 'glDeleteRenderbuffersEXT' not available on this platform (extensions: GL_EXT_framebuffer_object)");
      }
    }

    void framebuffer_renderbuffer_ext(framebuffer_target_t target, framebuffer_attachment_t attachment, renderbuffer_target_t renderbuffertarget, gl::uint_t renderbuffer) {
      if ( GLAD_GL_EXT_framebuffer_object ) {
        glFramebufferRenderbufferEXT(static_cast<GLenum>(target), static_cast<GLenum>(attachment), static_cast<GLenum>(renderbuffertarget), renderbuffer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFramebufferRenderbufferEXT' not available on this platform (extensions: GL_EXT_framebuffer_object)");
      }
    }

    void framebuffer_texture_1dext(framebuffer_target_t target, framebuffer_attachment_t attachment, gl::enum_t textarget, gl::uint_t texture, gl::int_t level) {
      if ( GLAD_GL_EXT_framebuffer_object ) {
        glFramebufferTexture1DEXT(static_cast<GLenum>(target), static_cast<GLenum>(attachment), textarget, texture, level);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFramebufferTexture1DEXT' not available on this platform (extensions: GL_EXT_framebuffer_object)");
      }
    }

    void framebuffer_texture_2dext(framebuffer_target_t target, framebuffer_attachment_t attachment, framebuffer_texture_target_t textarget, gl::uint_t texture, gl::int_t level) {
      if ( GLAD_GL_EXT_framebuffer_object ) {
        glFramebufferTexture2DEXT(static_cast<GLenum>(target), static_cast<GLenum>(attachment), static_cast<GLenum>(textarget), texture, level);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFramebufferTexture2DEXT' not available on this platform (extensions: GL_EXT_framebuffer_object)");
      }
    }

    void framebuffer_texture_3dext(framebuffer_target_t target, framebuffer_attachment_t attachment, gl::enum_t textarget, gl::uint_t texture, gl::int_t level, gl::int_t zoffset) {
      if ( GLAD_GL_EXT_framebuffer_object ) {
        glFramebufferTexture3DEXT(static_cast<GLenum>(target), static_cast<GLenum>(attachment), textarget, texture, level, zoffset);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFramebufferTexture3DEXT' not available on this platform (extensions: GL_EXT_framebuffer_object)");
      }
    }

    void gen_framebuffers_ext(gl::sizei_t n, gl::uint_t * framebuffers) {
      if ( GLAD_GL_EXT_framebuffer_object ) {
        glGenFramebuffersEXT(n, framebuffers);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGenFramebuffersEXT' not available on this platform (extensions: GL_EXT_framebuffer_object)");
      }
    }

    void gen_renderbuffers_ext(gl::sizei_t n, gl::uint_t * renderbuffers) {
      if ( GLAD_GL_EXT_framebuffer_object ) {
        glGenRenderbuffersEXT(n, renderbuffers);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGenRenderbuffersEXT' not available on this platform (extensions: GL_EXT_framebuffer_object)");
      }
    }

    void generate_mipmap_ext(mipmap_target_t target) {
      if ( GLAD_GL_EXT_framebuffer_object ) {
        glGenerateMipmapEXT(static_cast<GLenum>(target));
      }
      else {
        throw std::runtime_error("OpenGL command 'glGenerateMipmapEXT' not available on this platform (extensions: GL_EXT_framebuffer_object)");
      }
    }

    void get_framebuffer_attachment_parameteriv_ext(framebuffer_target_t target, framebuffer_attachment_t attachment, gl::enum_t pname, gl::int_t * params) {
      if ( GLAD_GL_EXT_framebuffer_object ) {
        glGetFramebufferAttachmentParameterivEXT(static_cast<GLenum>(target), static_cast<GLenum>(attachment), pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetFramebufferAttachmentParameterivEXT' not available on this platform (extensions: GL_EXT_framebuffer_object)");
      }
    }

    void get_renderbuffer_parameteriv_ext(renderbuffer_target_t target, gl::enum_t pname, gl::int_t * params) {
      if ( GLAD_GL_EXT_framebuffer_object ) {
        glGetRenderbufferParameterivEXT(static_cast<GLenum>(target), pname, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetRenderbufferParameterivEXT' not available on this platform (extensions: GL_EXT_framebuffer_object)");
      }
    }

    gl::boolean_t is_framebuffer_ext(gl::uint_t framebuffer) {
      if ( GLAD_GL_EXT_framebuffer_object ) {
        return glIsFramebufferEXT(framebuffer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glIsFramebufferEXT' not available on this platform (extensions: GL_EXT_framebuffer_object)");
      }
    }

    gl::boolean_t is_renderbuffer_ext(gl::uint_t renderbuffer) {
      if ( GLAD_GL_EXT_framebuffer_object ) {
        return glIsRenderbufferEXT(renderbuffer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glIsRenderbufferEXT' not available on this platform (extensions: GL_EXT_framebuffer_object)");
      }
    }

    void renderbuffer_storage_ext(renderbuffer_target_t target, internal_format_t internalformat, gl::sizei_t width, gl::sizei_t height) {
      if ( GLAD_GL_EXT_framebuffer_object ) {
        glRenderbufferStorageEXT(static_cast<GLenum>(target), static_cast<GLenum>(internalformat), width, height);
      }
      else {
        throw std::runtime_error("OpenGL command 'glRenderbufferStorageEXT' not available on this platform (extensions: GL_EXT_framebuffer_object)");
      }
    }

    void program_parameteri_ext(gl::uint_t program, gl::enum_t pname, gl::int_t value) {
      if ( GLAD_GL_EXT_geometry_shader4 ) {
        glProgramParameteriEXT(program, pname, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramParameteriEXT' not available on this platform (extensions: GL_EXT_geometry_shader4)");
      }
    }

    void program_env_parameters_4fv_ext(gl::enum_t target, gl::uint_t index, gl::sizei_t count, const  gl::float_t * params) {
      if ( GLAD_GL_EXT_gpu_program_parameters ) {
        glProgramEnvParameters4fvEXT(target, index, count, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramEnvParameters4fvEXT' not available on this platform (extensions: GL_EXT_gpu_program_parameters)");
      }
    }

    void program_local_parameters_4fv_ext(gl::enum_t target, gl::uint_t index, gl::sizei_t count, const  gl::float_t * params) {
      if ( GLAD_GL_EXT_gpu_program_parameters ) {
        glProgramLocalParameters4fvEXT(target, index, count, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProgramLocalParameters4fvEXT' not available on this platform (extensions: GL_EXT_gpu_program_parameters)");
      }
    }

    void bind_frag_data_location_ext(gl::uint_t program, gl::uint_t color, const  gl::char_t * name) {
      if ( GLAD_GL_EXT_gpu_shader4 ) {
        glBindFragDataLocationEXT(program, color, name);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBindFragDataLocationEXT' not available on this platform (extensions: GL_EXT_gpu_shader4)");
      }
    }

    gl::int_t get_frag_data_location_ext(gl::uint_t program, const  gl::char_t * name) {
      if ( GLAD_GL_EXT_gpu_shader4 ) {
        return glGetFragDataLocationEXT(program, name);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetFragDataLocationEXT' not available on this platform (extensions: GL_EXT_gpu_shader4)");
      }
    }

    void get_uniformuiv_ext(gl::uint_t program, gl::int_t location, gl::uint_t * params) {
      if ( GLAD_GL_EXT_gpu_shader4 ) {
        glGetUniformuivEXT(program, location, params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetUniformuivEXT' not available on this platform (extensions: GL_EXT_gpu_shader4)");
      }
    }

    void uniform_1ui_ext(gl::int_t location, gl::uint_t v0) {
      if ( GLAD_GL_EXT_gpu_shader4 ) {
        glUniform1uiEXT(location, v0);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform1uiEXT' not available on this platform (extensions: GL_EXT_gpu_shader4)");
      }
    }

    void uniform_1uiv_ext(gl::int_t location, gl::sizei_t count, const  gl::uint_t * value) {
      if ( GLAD_GL_EXT_gpu_shader4 ) {
        glUniform1uivEXT(location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform1uivEXT' not available on this platform (extensions: GL_EXT_gpu_shader4)");
      }
    }

    void uniform_2ui_ext(gl::int_t location, gl::uint_t v0, gl::uint_t v1) {
      if ( GLAD_GL_EXT_gpu_shader4 ) {
        glUniform2uiEXT(location, v0, v1);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform2uiEXT' not available on this platform (extensions: GL_EXT_gpu_shader4)");
      }
    }

    void uniform_2uiv_ext(gl::int_t location, gl::sizei_t count, const  gl::uint_t * value) {
      if ( GLAD_GL_EXT_gpu_shader4 ) {
        glUniform2uivEXT(location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform2uivEXT' not available on this platform (extensions: GL_EXT_gpu_shader4)");
      }
    }

    void uniform_3ui_ext(gl::int_t location, gl::uint_t v0, gl::uint_t v1, gl::uint_t v2) {
      if ( GLAD_GL_EXT_gpu_shader4 ) {
        glUniform3uiEXT(location, v0, v1, v2);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform3uiEXT' not available on this platform (extensions: GL_EXT_gpu_shader4)");
      }
    }

    void uniform_3uiv_ext(gl::int_t location, gl::sizei_t count, const  gl::uint_t * value) {
      if ( GLAD_GL_EXT_gpu_shader4 ) {
        glUniform3uivEXT(location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform3uivEXT' not available on this platform (extensions: GL_EXT_gpu_shader4)");
      }
    }

    void uniform_4ui_ext(gl::int_t location, gl::uint_t v0, gl::uint_t v1, gl::uint_t v2, gl::uint_t v3) {
      if ( GLAD_GL_EXT_gpu_shader4 ) {
        glUniform4uiEXT(location, v0, v1, v2, v3);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform4uiEXT' not available on this platform (extensions: GL_EXT_gpu_shader4)");
      }
    }

    void uniform_4uiv_ext(gl::int_t location, gl::sizei_t count, const  gl::uint_t * value) {
      if ( GLAD_GL_EXT_gpu_shader4 ) {
        glUniform4uivEXT(location, count, value);
      }
      else {
        throw std::runtime_error("OpenGL command 'glUniform4uivEXT' not available on this platform (extensions: GL_EXT_gpu_shader4)");
      }
    }

    void multi_draw_arrays_ext(primitive_type_t mode, const  gl::int_t * first, const  gl::sizei_t * count, gl::sizei_t primcount) {
      if ( GLAD_GL_EXT_multi_draw_arrays ) {
        glMultiDrawArraysEXT(static_cast<GLenum>(mode), first, count, primcount);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiDrawArraysEXT' not available on this platform (extensions: GL_EXT_multi_draw_arrays)");
      }
    }

    void multi_draw_elements_ext(primitive_type_t mode, const  gl::sizei_t * count, draw_elements_type_t type, const  void * * indices, gl::sizei_t primcount) {
      if ( GLAD_GL_EXT_multi_draw_arrays ) {
        glMultiDrawElementsEXT(static_cast<GLenum>(mode), count, static_cast<GLenum>(type), indices, primcount);
      }
      else {
        throw std::runtime_error("OpenGL command 'glMultiDrawElementsEXT' not available on this platform (extensions: GL_EXT_multi_draw_arrays)");
      }
    }

    void provoking_vertex_ext(gl::enum_t mode) {
      if ( GLAD_GL_EXT_provoking_vertex ) {
        glProvokingVertexEXT(mode);
      }
      else {
        throw std::runtime_error("OpenGL command 'glProvokingVertexEXT' not available on this platform (extensions: GL_EXT_provoking_vertex)");
      }
    }

    void secondary_color_3b_ext(gl::byte_t red, gl::byte_t green, gl::byte_t blue) {
      if ( GLAD_GL_EXT_secondary_color ) {
        glSecondaryColor3bEXT(red, green, blue);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSecondaryColor3bEXT' not available on this platform (extensions: GL_EXT_secondary_color)");
      }
    }

    void secondary_color_3bv_ext(const  gl::byte_t * v) {
      if ( GLAD_GL_EXT_secondary_color ) {
        glSecondaryColor3bvEXT(v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSecondaryColor3bvEXT' not available on this platform (extensions: GL_EXT_secondary_color)");
      }
    }

    void secondary_color_3d_ext(gl::double_t red, gl::double_t green, gl::double_t blue) {
      if ( GLAD_GL_EXT_secondary_color ) {
        glSecondaryColor3dEXT(red, green, blue);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSecondaryColor3dEXT' not available on this platform (extensions: GL_EXT_secondary_color)");
      }
    }

    void secondary_color_3dv_ext(const  gl::double_t * v) {
      if ( GLAD_GL_EXT_secondary_color ) {
        glSecondaryColor3dvEXT(v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSecondaryColor3dvEXT' not available on this platform (extensions: GL_EXT_secondary_color)");
      }
    }

    void secondary_color_3f_ext(gl::float_t red, gl::float_t green, gl::float_t blue) {
      if ( GLAD_GL_EXT_secondary_color ) {
        glSecondaryColor3fEXT(red, green, blue);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSecondaryColor3fEXT' not available on this platform (extensions: GL_EXT_secondary_color)");
      }
    }

    void secondary_color_3fv_ext(const  gl::float_t * v) {
      if ( GLAD_GL_EXT_secondary_color ) {
        glSecondaryColor3fvEXT(v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSecondaryColor3fvEXT' not available on this platform (extensions: GL_EXT_secondary_color)");
      }
    }

    void secondary_color_3i_ext(gl::int_t red, gl::int_t green, gl::int_t blue) {
      if ( GLAD_GL_EXT_secondary_color ) {
        glSecondaryColor3iEXT(red, green, blue);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSecondaryColor3iEXT' not available on this platform (extensions: GL_EXT_secondary_color)");
      }
    }

    void secondary_color_3iv_ext(const  gl::int_t * v) {
      if ( GLAD_GL_EXT_secondary_color ) {
        glSecondaryColor3ivEXT(v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSecondaryColor3ivEXT' not available on this platform (extensions: GL_EXT_secondary_color)");
      }
    }

    void secondary_color_3s_ext(gl::short_t red, gl::short_t green, gl::short_t blue) {
      if ( GLAD_GL_EXT_secondary_color ) {
        glSecondaryColor3sEXT(red, green, blue);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSecondaryColor3sEXT' not available on this platform (extensions: GL_EXT_secondary_color)");
      }
    }

    void secondary_color_3sv_ext(const  gl::short_t * v) {
      if ( GLAD_GL_EXT_secondary_color ) {
        glSecondaryColor3svEXT(v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSecondaryColor3svEXT' not available on this platform (extensions: GL_EXT_secondary_color)");
      }
    }

    void secondary_color_3ub_ext(gl::ubyte_t red, gl::ubyte_t green, gl::ubyte_t blue) {
      if ( GLAD_GL_EXT_secondary_color ) {
        glSecondaryColor3ubEXT(red, green, blue);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSecondaryColor3ubEXT' not available on this platform (extensions: GL_EXT_secondary_color)");
      }
    }

    void secondary_color_3ubv_ext(const  gl::ubyte_t * v) {
      if ( GLAD_GL_EXT_secondary_color ) {
        glSecondaryColor3ubvEXT(v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSecondaryColor3ubvEXT' not available on this platform (extensions: GL_EXT_secondary_color)");
      }
    }

    void secondary_color_3ui_ext(gl::uint_t red, gl::uint_t green, gl::uint_t blue) {
      if ( GLAD_GL_EXT_secondary_color ) {
        glSecondaryColor3uiEXT(red, green, blue);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSecondaryColor3uiEXT' not available on this platform (extensions: GL_EXT_secondary_color)");
      }
    }

    void secondary_color_3uiv_ext(const  gl::uint_t * v) {
      if ( GLAD_GL_EXT_secondary_color ) {
        glSecondaryColor3uivEXT(v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSecondaryColor3uivEXT' not available on this platform (extensions: GL_EXT_secondary_color)");
      }
    }

    void secondary_color_3us_ext(gl::ushort_t red, gl::ushort_t green, gl::ushort_t blue) {
      if ( GLAD_GL_EXT_secondary_color ) {
        glSecondaryColor3usEXT(red, green, blue);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSecondaryColor3usEXT' not available on this platform (extensions: GL_EXT_secondary_color)");
      }
    }

    void secondary_color_3usv_ext(const  gl::ushort_t * v) {
      if ( GLAD_GL_EXT_secondary_color ) {
        glSecondaryColor3usvEXT(v);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSecondaryColor3usvEXT' not available on this platform (extensions: GL_EXT_secondary_color)");
      }
    }

    void secondary_color_pointer_ext(gl::int_t size, color_pointer_type_t type, gl::sizei_t stride, const  void * pointer) {
      if ( GLAD_GL_EXT_secondary_color ) {
        glSecondaryColorPointerEXT(size, static_cast<GLenum>(type), stride, pointer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glSecondaryColorPointerEXT' not available on this platform (extensions: GL_EXT_secondary_color)");
      }
    }

    void active_stencil_face_ext(stencil_face_direction_t face) {
      if ( GLAD_GL_EXT_stencil_two_side ) {
        glActiveStencilFaceEXT(static_cast<GLenum>(face));
      }
      else {
        throw std::runtime_error("OpenGL command 'glActiveStencilFaceEXT' not available on this platform (extensions: GL_EXT_stencil_two_side)");
      }
    }

    void framebuffer_texture_layer_ext(framebuffer_target_t target, framebuffer_attachment_t attachment, gl::uint_t texture, gl::int_t level, gl::int_t layer) {
      if ( GLAD_GL_EXT_texture_array || GLAD_GL_NV_geometry_program4 ) {
        glFramebufferTextureLayerEXT(static_cast<GLenum>(target), static_cast<GLenum>(attachment), texture, level, layer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glFramebufferTextureLayerEXT' not available on this platform (extensions: GL_EXT_texture_array, GL_NV_geometry_program4)");
      }
    }

    void get_tex_parameter_iiv_ext(texture_target_t target, get_texture_parameter_t pname, gl::int_t * params) {
      if ( GLAD_GL_EXT_texture_integer ) {
        glGetTexParameterIivEXT(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetTexParameterIivEXT' not available on this platform (extensions: GL_EXT_texture_integer)");
      }
    }

    void get_tex_parameter_iuiv_ext(texture_target_t target, get_texture_parameter_t pname, gl::uint_t * params) {
      if ( GLAD_GL_EXT_texture_integer ) {
        glGetTexParameterIuivEXT(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetTexParameterIuivEXT' not available on this platform (extensions: GL_EXT_texture_integer)");
      }
    }

    void tex_parameter_iiv_ext(texture_target_t target, texture_parameter_name_t pname, const  gl::int_t * params) {
      if ( GLAD_GL_EXT_texture_integer ) {
        glTexParameterIivEXT(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexParameterIivEXT' not available on this platform (extensions: GL_EXT_texture_integer)");
      }
    }

    void tex_parameter_iuiv_ext(texture_target_t target, texture_parameter_name_t pname, const  gl::uint_t * params) {
      if ( GLAD_GL_EXT_texture_integer ) {
        glTexParameterIuivEXT(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTexParameterIuivEXT' not available on this platform (extensions: GL_EXT_texture_integer)");
      }
    }

    void clear_color_ii_ext(gl::int_t red, gl::int_t green, gl::int_t blue, gl::int_t alpha) {
      if ( GLAD_GL_EXT_texture_integer ) {
        glClearColorIiEXT(red, green, blue, alpha);
      }
      else {
        throw std::runtime_error("OpenGL command 'glClearColorIiEXT' not available on this platform (extensions: GL_EXT_texture_integer)");
      }
    }

    void clear_color_iui_ext(gl::uint_t red, gl::uint_t green, gl::uint_t blue, gl::uint_t alpha) {
      if ( GLAD_GL_EXT_texture_integer ) {
        glClearColorIuiEXT(red, green, blue, alpha);
      }
      else {
        throw std::runtime_error("OpenGL command 'glClearColorIuiEXT' not available on this platform (extensions: GL_EXT_texture_integer)");
      }
    }

    void begin_transform_feedback_ext(gl::enum_t primitiveMode) {
      if ( GLAD_GL_EXT_transform_feedback ) {
        glBeginTransformFeedbackEXT(primitiveMode);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBeginTransformFeedbackEXT' not available on this platform (extensions: GL_EXT_transform_feedback)");
      }
    }

    void bind_buffer_base_ext(gl::enum_t target, gl::uint_t index, gl::uint_t buffer) {
      if ( GLAD_GL_EXT_transform_feedback ) {
        glBindBufferBaseEXT(target, index, buffer);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBindBufferBaseEXT' not available on this platform (extensions: GL_EXT_transform_feedback)");
      }
    }

    void bind_buffer_offset_ext(gl::enum_t target, gl::uint_t index, gl::uint_t buffer, gl::intptr_t offset) {
      if ( GLAD_GL_EXT_transform_feedback ) {
        glBindBufferOffsetEXT(target, index, buffer, offset);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBindBufferOffsetEXT' not available on this platform (extensions: GL_EXT_transform_feedback)");
      }
    }

    void bind_buffer_range_ext(gl::enum_t target, gl::uint_t index, gl::uint_t buffer, gl::intptr_t offset, gl::sizeiptr_t size) {
      if ( GLAD_GL_EXT_transform_feedback ) {
        glBindBufferRangeEXT(target, index, buffer, offset, size);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBindBufferRangeEXT' not available on this platform (extensions: GL_EXT_transform_feedback)");
      }
    }

    void end_transform_feedback_ext() {
      if ( GLAD_GL_EXT_transform_feedback ) {
        glEndTransformFeedbackEXT();
      }
      else {
        throw std::runtime_error("OpenGL command 'glEndTransformFeedbackEXT' not available on this platform (extensions: GL_EXT_transform_feedback)");
      }
    }

    void get_transform_feedback_varying_ext(gl::uint_t program, gl::uint_t index, gl::sizei_t bufSize, gl::sizei_t * length, gl::sizei_t * size, gl::enum_t * type, gl::char_t * name) {
      if ( GLAD_GL_EXT_transform_feedback ) {
        glGetTransformFeedbackVaryingEXT(program, index, bufSize, length, size, type, name);
      }
      else {
        throw std::runtime_error("OpenGL command 'glGetTransformFeedbackVaryingEXT' not available on this platform (extensions: GL_EXT_transform_feedback)");
      }
    }

    void transform_feedback_varyings_ext(gl::uint_t program, gl::sizei_t count, const  gl::char_t ** varyings, gl::enum_t bufferMode) {
      if ( GLAD_GL_EXT_transform_feedback ) {
        glTransformFeedbackVaryingsEXT(program, count, varyings, bufferMode);
      }
      else {
        throw std::runtime_error("OpenGL command 'glTransformFeedbackVaryingsEXT' not available on this platform (extensions: GL_EXT_transform_feedback)");
      }
    }

    void begin_conditional_render_nv(gl::uint_t id, gl::enum_t mode) {
      if ( GLAD_GL_NV_conditional_render ) {
        glBeginConditionalRenderNV(id, mode);
      }
      else {
        throw std::runtime_error("OpenGL command 'glBeginConditionalRenderNV' not available on this platform (extensions: GL_NV_conditional_render)");
      }
    }

    void end_conditional_render_nv() {
      if ( GLAD_GL_NV_conditional_render ) {
        glEndConditionalRenderNV();
      }
      else {
        throw std::runtime_error("OpenGL command 'glEndConditionalRenderNV' not available on this platform (extensions: GL_NV_conditional_render)");
      }
    }

    void texture_barrier_nv() {
      if ( GLAD_GL_NV_texture_barrier ) {
        glTextureBarrierNV();
      }
      else {
        throw std::runtime_error("OpenGL command 'glTextureBarrierNV' not available on this platform (extensions: GL_NV_texture_barrier)");
      }
    }

} // namespace osx
} // namespace gl2
